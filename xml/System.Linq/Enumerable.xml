<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d784f7085ee5c91b69f527975ecebf8715b7afc6" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52231339" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module Enumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type Enumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一組 <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) 方法，用於查詢實作 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的物件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此類別中的方法提供查詢資料來源實作的標準查詢運算子實作<xref:System.Collections.Generic.IEnumerable%601>。 標準查詢運算子會遵循的一般用途方法[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]模式，並讓您透過任何表示周遊、 篩選和投射作業。以.NET 為基礎的程式設計語言。  
  
 此類別中方法大多會定義為延伸的延伸模組方法<xref:System.Collections.Generic.IEnumerable%601>。 這表示它們可以實作任何物件上呼叫和執行個體方法一樣<xref:System.Collections.Generic.IEnumerable%601>。  
  
 傳回值序列的查詢中所使用的方法並不會耗用目標資料，直到列舉查詢物件。 這稱為 「 延後執行 」。 傳回單一值的查詢中所使用的方法執行，而且會立即耗用目標資料。  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">標準查詢運算子概觀</related>
    <related type="Article" href="https://msdn.microsoft.com/library/175ce3ff-9bbf-4e64-8421-faeb81a0bb51">擴充方法 (C# 程式設計手冊)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b8020aae-374d-46a9-bcb7-8cc2390b93b6">擴充方法 (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IEnumerable(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">所要彙總 (Aggregate) 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="func">要在每個項目上叫用 (Invoke) 的累加函式。</param>
        <summary>將累加函式套用到序列上。</summary>
        <returns>最終累積值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>方法輕鬆地透過一連串的值執行計算。 這個方法的運作方式是呼叫`func`每個項目中的一次`source`除了第一個。 每次`func`呼叫時，<xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>中的順序，並彙總的值傳遞的項目 (做為第一個引數`func`)。 第一個項目`source`做為初始的彙總值。 結果`func`會取代先前的彙的總值。 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> 傳回的最終結果`func`。  
  
 這個多載<xref:System.Linq.Enumerable.Aggregate%2A>方法不適合所有情況下，因為它使用的第一個元素`source`做為初始彙總的值。 如果傳回的值應該包含的項目，您應選擇另一個多載`source`符合特定條件。 比方說，這個多載不可靠，如果您想要計算總和的中的偶數`source`。 結果會是第一個項目是奇數，而不是甚至如果不正確。  
  
 若要簡化常見的彙總作業，標準查詢運算子也包含一般用途計數方法<xref:System.Linq.Enumerable.Count%2A>，還有四個數值彙總方法，也就是<xref:System.Linq.Enumerable.Min%2A>， <xref:System.Linq.Enumerable.Max%2A>， <xref:System.Linq.Enumerable.Sum%2A>，和<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何藉由使用反轉的字串中的文字順序<xref:System.Linq.Enumerable.Aggregate%2A>。  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="func" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.Enumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TAccumulate">累積值的類型。</typeparam>
        <param name="source">所要彙總 (Aggregate) 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="seed">初始累積值。</param>
        <param name="func">要在每個項目上叫用 (Invoke) 的累加函式。</param>
        <summary>將累加函式套用到序列上。 使用指定的初始值做為初始累加值。</summary>
        <returns>最終累積值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>方法輕鬆地透過一連串的值執行計算。 這個方法的運作方式是呼叫`func`每個項目中的一次`source`。 每次`func`呼叫時，<xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>中的順序，並彙總的值傳遞的項目 (做為第一個引數`func`)。 值`seed`參數做為初始的彙總值。 結果`func`會取代先前的彙的總值。 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> 傳回的最終結果`func`。  
  
 若要簡化常見的彙總作業，標準查詢運算子也包含一般用途計數方法<xref:System.Linq.Enumerable.Count%2A>，還有四個數值彙總方法，也就是<xref:System.Linq.Enumerable.Min%2A>， <xref:System.Linq.Enumerable.Max%2A>， <xref:System.Linq.Enumerable.Sum%2A>，和<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Aggregate%2A>套用的累加函式，並使用種子值。  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="func" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TAccumulate">累積值的類型。</typeparam>
        <typeparam name="TResult">結果值的類型。</typeparam>
        <param name="source">所要彙總 (Aggregate) 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="seed">初始累積值。</param>
        <param name="func">要在每個項目上叫用 (Invoke) 的累加函式。</param>
        <param name="resultSelector">用來將最終累加值轉換成結果值的函式。</param>
        <summary>將累加函式套用到序列上。 使用指定的值做為初始累加值，並使用指定的函式來選取結果值。</summary>
        <returns>轉換後的最終累加值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>方法輕鬆地透過一連串的值執行計算。 這個方法的運作方式是呼叫`func`每個項目中的一次`source`。 每次`func`呼叫時，<xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>中的順序，並彙總的值傳遞的項目 (做為第一個引數`func`)。 值`seed`參數做為初始的彙總值。 結果`func`會取代先前的彙的總值。 最終結果`func`傳遞給`resultSelector`若要取得的最終結果<xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>。  
  
 若要簡化常見的彙總作業，標準查詢運算子也包含一般用途計數方法<xref:System.Linq.Enumerable.Count%2A>，還有四個數值彙總方法，也就是<xref:System.Linq.Enumerable.Min%2A>， <xref:System.Linq.Enumerable.Max%2A>， <xref:System.Linq.Enumerable.Sum%2A>，和<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Aggregate%2A>来套用的累加函式和結果選取器。  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="func" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含要套用述詞 (Predicate) 的項目。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>判斷序列的所有項目是否全都符合條件。</summary>
        <returns>如果來源序列的每個項目都通過以指定之述詞 (Predicate) 進行的測試，或序列是空的，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法不會傳回集合的所有項目。 相反地，它會判斷集合中的所有項目是否全都符合條件。  
  
 列舉`source`可以判斷結果為已停止。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into All()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.All%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.All%2A>來判斷序列中的所有項目是否全都符合條件。 變數`allStartWithB`為 true 以"B"開頭的所有的寵物名稱則`pets`陣列是空的。  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 布林值，<xref:System.Linq.Enumerable.All%2A>方法傳回的述詞通常會用於`where`子句 (`Where`子句在 Visual Basic 中的) 或直接呼叫<xref:System.Linq.Enumerable.Where%2A>方法。 下列範例示範這個用法`All`方法。  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷序列的任何項目是否符合條件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要檢查是否為空白的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>判斷序列是否包含任何項目。</summary>
        <returns>如果來源序列包含任何項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法不會傳回集合中的任何一個項目。 相反地，它會判斷集合是否包含任何項目。  
  
 列舉`source`可以判斷結果為已停止。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Any()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Any%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Any%2A>來判斷序列是否包含任何項目。  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 布林值，<xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法傳回的述詞通常會用於`where`子句 (`Where`子句在 Visual Basic 中的) 或直接呼叫<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法。 下列範例示範這個用法`Any`方法。  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">其項目要套用述詞的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>判斷序列的任何項目是否符合條件。</summary>
        <returns>如果來源序列中的任何項目通過以指定之述詞進行的測試，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法不會傳回集合中的任何一個項目。 相反地，它會判斷集合中的任何項目是否全都符合條件。  
  
 列舉`source`可以判斷結果為已停止。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Any()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Any%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Any%2A>來判斷序列中的任何項目是否符合條件。  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Append(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">一連串的值。</param>
        <param name="element">要附加在 <paramref name="source" /> 後面的值。</param>
        <summary>將值附加在序列結尾。</summary>
        <returns>以 <paramref name="element" /> 結尾的新序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法不會修改集合的元素。 相反地，它會建立集合的複本與新的項目。
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Append%2A>來將值附加至序列的結尾。  
  
 [!code-csharp[System.Linq.Enumerable#201](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#201)]
 [!code-vb[System.Linq.Enumerable#201](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#201)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">型別為 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的序列。</param>
        <summary>傳回 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 類型的輸入。</summary>
        <returns>型別為 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的輸入序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法沒有任何作用以外的其他變更的編譯階段型別`source`從型別可實作<xref:System.Collections.Generic.IEnumerable%601>到<xref:System.Collections.Generic.IEnumerable%601>本身。  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 可用於查詢實作時的順序實作之間做選擇<xref:System.Collections.Generic.IEnumerable%601>，但也有一組不同的可用公用的查詢方法。 例如，指定泛型類別`Table`可實<xref:System.Collections.Generic.IEnumerable%601>和具有它自己的方法，例如`Where`， `Select`，和`SelectMany`，呼叫`Where`會叫用公用`Where`方法`Table`. A`Table`型別，表示資料庫資料表可能會有`Where`接受述詞的引數之運算式樹狀架構，並將樹狀結構轉換成 SQL 中，遠端執行的方法。 如果遠端執行不符預期，例如因為述詞會叫用的本機方法，<xref:System.Linq.Enumerable.AsEnumerable%2A>方法可用來隱藏自訂方法，並改為提供的標準查詢運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>隱藏的類型的自訂`Where`時想要使用的標準查詢運算子實作的方法。  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>計算數值序列的平均值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算平均值的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Decimal" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>來計算的值序列的平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算平均值的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Double" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果項目的總和太大而無法表示為<xref:System.Double>，這個方法會傳回無限大的正數或負數。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算平均值的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Int32" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>來計算平均值。  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算平均值的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Int64" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算其平均值的可為 Null 之 <see cref="T:System.Decimal" /> 值的序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Decimal" /> 值序列的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算其平均值的可為 Null 之 <see cref="T:System.Double" /> 值的序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Double" /> 值序列的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果項目的總和太大而無法表示為<xref:System.Double>，這個方法會傳回無限大的正數或負數。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算其平均值的可為 Null 之 <see cref="T:System.Int32" /> 值的序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Int32" /> 值序列的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算其平均值的可為 Null 之 <see cref="T:System.Int64" /> 值的序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Int64" /> 值序列的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>來計算平均值。  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算其平均值的可為 Null 之 <see cref="T:System.Single" /> 值的序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Single" /> 值序列的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算平均值的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Single" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Decimal" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Double" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Int32" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>來計算平均值。  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源之項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Int64" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Decimal" /> 值的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Double" /> 值的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Int32" /> 值的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">序列中項目的總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Int64" /> 值的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Single" /> 值的平均值。</summary>
        <returns>值序列的平均值，或者，如果來源序列是空的或只包含 <see langword="null" /> 值，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要計算平均值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Single" /> 值序列的平均值。</summary>
        <returns>值序列的平均。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Average()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Average%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>來計算平均值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Cast(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">要將 <paramref name="source" /> 之項目轉換成的型別。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.IEnumerable" />，其中包含要轉換成類型 <c>TResult</c> 的項目。</param>
        <summary>將 <see cref="T:System.Collections.IEnumerable" /> 的項目轉換成指定的型別。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含已轉型成指定之型別的每個來源序列項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>方法可讓標準查詢運算子來叫用非泛型集合上提供必要的型別資訊。 例如，<xref:System.Collections.ArrayList>不會實作<xref:System.Collections.Generic.IEnumerable%601>，但藉由呼叫<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>上<xref:System.Collections.ArrayList>物件時，標準查詢運算子可以再用來查詢的序列。  
  
 如果項目無法轉換為類型`TResult`，此方法會擲回<xref:System.InvalidCastException>。

 來源序列，這個方法的<xref:System.Collections.IEnumerable>，表示項目都有編譯時間靜態類型的`object`。 這個方法所執行的唯一類型轉換為參考轉換和 unboxing 轉換。 集合中的項目執行階段型別必須符合目標類型，或實值型別，如果項目執行階段類型必須是目標類型的 boxing 轉換的結果。 其他的轉換類型，例如不同的數值型別，不允許。 
 
 若要取得只可以轉換成輸入的項目才`TResult`，使用<xref:System.Linq.Enumerable.OfType%2A>方法，而非<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>。  
  
 在查詢運算式中，明確指定型別的的反覆運算變數會轉譯成的引動過程<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>。 此範例顯示具有明確類型的範圍變數的語法。  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  

使用`select`子句的查詢來執行其他的轉換類型，例如隱含數值轉換。 下列範例會使用這兩者`Cast`方法和`select`陳述式，以將一連串的 boxed 整數轉換成一連串的雙精度浮點數。

```csharp
IEnumerable sequence = Enumerable.Range(0, 10);
var doubles = from int item in sequence
                select (double)item;
``` 

```vb
Dim sequence As IEnumerable = Enumerable.Range(0, 10)
Dim doubles = From item As Integer In sequence
                Select CType(item, Double)
```

## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>若要啟用的標準查詢運算子在<xref:System.Collections.ArrayList>。  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">無法將序列中的項目轉換為型別 <paramref name="TResult" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">from 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Concat(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">要串連的第一個序列。</param>
        <param name="second">要串連到第一個序列的序列。</param>
        <summary>串連兩個序列。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含兩個輸入序列的串連項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法不同於<xref:System.Linq.Enumerable.Union%2A>方法因為<xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法會傳回輸入序列中的所有原始的項目。 <xref:System.Linq.Enumerable.Union%2A>方法會傳回唯一的項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>來串連兩個序列。  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 串連兩個序列的替代方式是建構一個集合，例如陣列的序列，然後套用<xref:System.Linq.Enumerable.SelectMany%2A>方法，將身分識別選取器函式傳遞給它。 下列範例示範這個用法<xref:System.Linq.Enumerable.SelectMany%2A>。  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷序列是否包含指定的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要在其中尋找值的序列。</param>
        <param name="value">要在序列中尋找的值。</param>
        <summary>使用預設的相等比較子 (Comparer) 來判斷序列是否包含指定的項目。</summary>
        <returns>如果來源序列包含具有指定值的項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型`source`會實作<xref:System.Collections.Generic.ICollection%601>，則`Contains`中實作的方法會叫用來取得結果。 否則，這個方法會判斷是否`source`包含指定的項目。  
  
 只要找到相符的項目，列舉型別就會終止。  
  
 項目時，會比較指定的值上，使用預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>來判斷陣列是否包含特定項目。  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要在其中尋找值的序列。</param>
        <param name="value">要在序列中尋找的值。</param>
        <param name="comparer">用來比較值的相等比較子。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 來判斷序列是否包含指定的項目。</summary>
        <returns>如果來源序列包含具有指定值的項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只要找到相符的項目，列舉型別就會終止。  
  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較項目指定的值。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.Contains%2A>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用一連串`Product`中的物件<xref:System.Linq.Enumerable.Contains%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列中的項目數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; -&gt; int" Usage="System.Linq.Enumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">包含要計算之項目的序列。</param>
        <summary>傳回序列中的項目數。</summary>
        <returns>輸入序列中的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型`source`實作<xref:System.Collections.Generic.ICollection%601>，該實作用來取得項目的計數。 否則，這個方法會判斷計數。  
  
 使用<xref:System.Linq.Enumerable.LongCount%2A>方法時您所預期，而且想要允許的結果必須小於或等於<xref:System.Int32.MaxValue>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Count()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>來計算陣列中的項目。  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> 中的項目數目大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.Enumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">包含要測試及計算之項目的序列。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回數字，代表指定之序列中符合條件的項目數目。</summary>
        <returns>數字，代表序列中符合述詞函式之條件的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型`source`實作<xref:System.Collections.Generic.ICollection%601>，該實作用來取得項目的計數。 否則，這個方法會判斷計數。  
  
 您應該使用<xref:System.Linq.Enumerable.LongCount%2A>方法時您所預期，而且想要允許的結果必須小於或等於<xref:System.Int32.MaxValue>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Count()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>計算陣列中滿足條件的項目。  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> 中的項目數目大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的項目；如果序列是空的，則傳回預設值單一集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">序列，若此序列空白，便傳回預設值。</param>
        <summary>傳回指定之序列的項目；如果序列是空的，則傳回單一集合中型別參數的預設值。</summary>
        <returns>如果 <paramref name="TSource" /> 為空白，則為包含 <paramref name="source" /> 型別之預設值的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 物件，否則為 <paramref name="source" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 參考和可為 null 類型的預設值是`null`。  
  
 這個方法可以用來產生左外部聯結，當它結合<xref:System.Linq.Enumerable.GroupJoin%2A>) 方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>提供預設值，如果來源序列是空的。  
  
 此範例使用非空白序列。  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 此範例會使用空的序列。  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">聯結</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource), defaultValue As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">序列，若此序列空白，便傳回指定的值。</param>
        <param name="defaultValue">在序列空白時所要傳回的值。</param>
        <summary>傳回指定之序列的項目；如果序列是空的，則傳回單一集合中型別參數的預設值。</summary>
        <returns>如果 <paramref name="defaultValue" /> 是空的，則為包含 <paramref name="source" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，否則為 <paramref name="source" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 這個方法可以用來產生左外部聯結，當它結合<xref:System.Linq.Enumerable.GroupJoin%2A>) 方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>方法並指定預設值。 第一個序列不是空的第二個序列是空的。  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">聯結</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從序列傳回獨特的項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 結果序列沒有排序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要移除重複項目的序列。</param>
        <summary>使用預設的相等比較子來比較值，以便從序列傳回獨特的項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含來源序列中的獨特項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法會傳回未排序的序列，其中包含任何重複的值。 它會使用預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Distinct`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Distinct%2A>。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值的類型可實作<xref:System.IEquatable%601>泛型介面。 若要比較的自訂資料類型，您需要實作這個介面，並提供您自己<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>類型的方法。  
  
 如需使用的範例<xref:System.Collections.Generic.IEqualityComparer%601>若要定義自訂比較子，請參閱<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>從整數的序列傳回獨特的項目。  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 如果您想要從某種自訂資料類型的物件序列傳回獨特的項目，您必須實作<xref:System.IEquatable%601>類別中的泛型介面。 下列程式碼範例示範如何實作這個介面中的自訂資料類型，並提供<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>方法。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 您實作這個介面之後，您可以使用一連串`Product`中的物件<xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/86f42614-0d8f-4ffc-b888-ce8a37a8d36a">Distinct 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要移除重複項目的序列。</param>
        <param name="comparer">用來比較值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 來比較值，以便從序列傳回獨特的項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含來源序列中的獨特項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>方法會傳回未排序的序列，其中包含任何重複的值。 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.Distinct%2A>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用一連串`Product`中的物件<xref:System.Linq.Enumerable.Distinct%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="index">要擷取的項目之以零為起始索引。</param>
        <summary>傳回位於序列中指定索引處的項目。</summary>
        <returns>位於來源序列中指定位置的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型`source`實作<xref:System.Collections.Generic.IList%601>，該實作用來取得指定索引處的項目。 否則，這個方法會取得指定的項目。  
  
 此方法擲回例外狀況，如果`index`超出範圍。 若要改為傳回的預設值，指定的索引超出範圍時，請使用<xref:System.Linq.Enumerable.ElementAtOrDefault%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ElementAt%2A>傳回特定位置的項目。  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於 0 或大於或等於 <paramref name="source" /> 中的項目數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="index">要擷取的項目之以零為起始索引。</param>
        <summary>傳回位於序列中指定索引處的元素；如果索引超出範圍，則傳回預設值。</summary>
        <returns>如果索引位於來源序列的界限之外，則為 <see langword="default" />(<paramref name="TSource" />)，否則為位於來源序列中指定索引處的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類型`source`實作<xref:System.Collections.Generic.IList%601>，該實作用來取得指定索引處的項目。 否則，這個方法會取得指定的項目。  
  
 參考和可為 null 類型的預設值是`null`。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>。 此範例使用陣列界限之外的索引。  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">型別，用來指派給傳回之泛型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的型別參數。</typeparam>
        <summary>傳回具有指定之型別引數的空白 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>其型別引數為 <paramref name="TResult" /> 的空白 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Empty%60%601>方法會快取類型的空的序列`TResult`。 它會傳回的物件列舉時，它會產生任何項目。  
  
 在某些情況下，這個方法很適合用於將空的時序傳遞至使用者定義的方法會採用<xref:System.Collections.Generic.IEnumerable%601>。 它也可用來產生方法的相關項目，例如<xref:System.Linq.Enumerable.Union%2A>。 請參閱 < 範例 > 一節的使用範例<xref:System.Linq.Enumerable.Empty%60%601>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Empty%60%601>來產生空白<xref:System.Collections.Generic.IEnumerable%601>。  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 下列程式碼範例示範可能的應用程式的<xref:System.Linq.Enumerable.Empty%60%601>方法。 <xref:System.Linq.Enumerable.Aggregate%2A>方法會套用至集合的字串陣列。 集合中每個陣列的元素加入產生<xref:System.Collections.Generic.IEnumerable%601>只有該陣列包含四個或多個項目。 <xref:System.Linq.Enumerable.Empty%2A> 用來產生的種子值<xref:System.Linq.Enumerable.Aggregate%2A>因為如果在集合中的沒有任何陣列具有四個或多個項目，會傳回空的序列。  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>產生兩個序列的差異。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目若未同時存在 <paramref name="second" /> 中，便會傳回這些項目。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，若其項目同時出現在第一個序列中，便會從傳回的序列中移除這些項目。</param>
        <summary>使用預設相等比較子來比較值，以便產生兩個序列的差異。</summary>
        <returns>序列，其中包含兩個序列之項目的差異。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 兩個集合的集合差異被定義為不會出現在第二個集合中第一個集合的成員。  
  
> [!NOTE]
>  這個方法會傳回中的項目`first`，並不會顯示在`second`。 它也不會傳回中的項目`second`，並不會顯示在`first`。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值的類型可實作<xref:System.Collections.Generic.IEqualityComparer%601>泛型介面。 若要比較的自訂資料類型，您需要實作這個介面，並提供您自己<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>類型的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法來比較兩個序列的數字，並傳回項目只會出現在第一個序列。  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 如果您想要比較之物件的某些自訂資料類型的序列，您必須實作<xref:System.Collections.Generic.IEqualityComparer%601>helperclass 中的泛型介面。 下列程式碼範例示範如何實作這個介面中的自訂資料類型，並提供<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>方法。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 您實作這個介面之後，您可以使用的序列`ProductA`中的物件<xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目若未同時存在 <paramref name="second" /> 中，便會傳回這些項目。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，若其項目同時出現在第一個序列中，便會從傳回的序列中移除這些項目。</param>
        <param name="comparer">用來比較值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 來比較值，以便產生兩個序列的差異。</summary>
        <returns>序列，其中包含兩個序列之項目的差異。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.Except%2A>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用連串`Product`中的物件<xref:System.Linq.Enumerable.Except%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的第一個項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回第一個項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的第一個項目。</summary>
        <returns>指定之序列中的第一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法時擲回例外狀況`source`包含任何項目。 若要改為傳回預設值，當來源序列是空的使用<xref:System.Linq.Enumerable.FirstOrDefault%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>傳回陣列的第一個元素。  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">來源序列為空。</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回序列中符合指定條件的第一個元素。</summary>
        <returns>序列中通過指定之述詞函式所做測試的第一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法擲回例外狀況，如果沒有相符的項目位於`source`。 若要找到任何相符的項目時，請改為傳回預設值，請使用<xref:System.Linq.Enumerable.FirstOrDefault%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>傳回陣列，符合條件的第一個元素。  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">沒有任何項目符合 <paramref name="predicate" /> 的條件。  
  
-或- 
來源序列為空。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的第一個項目；如果找不到任何項目，則傳回預設值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回第一個項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的第一個元素；如果序列中沒有包含任何元素，則傳回預設值。</summary>
        <returns>如果 <paramref name="TSource" /> 是空的，則為 <see langword="default" />(<paramref name="source" />)，否則為 <paramref name="source" /> 中的第一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
 <xref:System.Linq.Enumerable.FirstOrDefault%2A>方法不會提供方法來指定預設值。 如果您想要指定預設值以外`default(TSource)`，使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>範例 > 一節中所述的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>上的空陣列。  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 有時值`default(TSource)`不是您想要使用如果集合不包含任何元素的預設值。 除了檢查不必要的預設值的結果，並將它如有必要變更，您可以使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>方法，以指定您想要使用這個集合是空的預設值。 然後，呼叫<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>取得第一個項目。 下列程式碼範例會使用這兩種技術以取得預設值為 1，如果數字月份的集合是空的。 整數，預設值為 0，這未對應至任何月份，因為預設值必須被指定為 1。 查詢完成執行後不必要的預設值會檢查第一個結果變數。 第二個結果變數使用取得的<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>指定預設值為 1。  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回序列中符合條件的第一個元素；如果找不到這類元素，則傳回預設值。</summary>
        <returns>如果 <paramref name="TSource" /> 是空的，或是沒有任何項目通過 <paramref name="source" /> 所指定的測試，則為 <see langword="default" />(<paramref name="predicate" />)，否則為 <paramref name="source" /> 中通過 <paramref name="predicate" /> 指定之測試的第一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>傳遞述詞中。 在第二個方法呼叫中，沒有任何項目中符合條件的陣列。  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>群組序列的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <summary>依據指定的索引鍵選擇器函式來群組序列的項目。</summary>
        <returns>C# 中的 <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> 或 Visual Basic 中的 <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c>，其中每個 <see cref="T:System.Linq.IGrouping`2" /> 物件包含一序列的物件序和一個索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
> [!NOTE]
>  如需範例的`GroupBy`，請參閱下列主題。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>方法傳回的集合<xref:System.Linq.IGrouping%602>物件，一個用於每個發現的相異索引鍵。 <xref:System.Linq.IGrouping%602>是<xref:System.Collections.Generic.IEnumerable%601>也具有其項目相關聯的索引鍵。  
  
 <xref:System.Linq.IGrouping%602>物件產生根據順序中的項目順序`source`產生第一個索引鍵，每個<xref:System.Linq.IGrouping%602>。 在群組中的項目中出現的順序產生`source`。  
  
 預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。 如需詳細資訊和使用方式範例，請參閱 < [group 子句](~/docs/csharp/language-reference/keywords/group-clause.md)並[By 子句群組](~/docs/visual-basic/language-reference/queries/group-by-clause.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並使用指定的比較子來比較索引鍵。</summary>
        <returns>C# 中的 <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> 或 Visual Basic 中的 <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c>，其中每個 <see cref="T:System.Linq.IGrouping`2" /> 物件包含一個物件集合和一個索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
> [!NOTE]
>  如需範例的`GroupBy`，請參閱下列主題。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>方法傳回的集合<xref:System.Linq.IGrouping%602>物件，一個用於每個發現的相異索引鍵。 <xref:System.Linq.IGrouping%602>是<xref:System.Collections.Generic.IEnumerable%601>也具有其項目相關聯的索引鍵。  
  
 <xref:System.Linq.IGrouping%602>物件產生根據順序中的項目順序`source`產生第一個索引鍵，每個<xref:System.Linq.IGrouping%602>。 在群組中的項目中出現的順序產生`source`。  
  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 如果兩個金鑰會被視為相等於根據`comparer`，第一個索引鍵會被選為該群組的索引鍵。  
  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。 如需詳細資訊和使用方式範例，請參閱 < [group 子句](~/docs/csharp/language-reference/keywords/group-clause.md)並[By 子句群組](~/docs/visual-basic/language-reference/queries/group-by-clause.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <see cref="T:System.Linq.IGrouping`2" /> 中的項目類型。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="elementSelector">用來將每個來源項目對應至 <see cref="T:System.Linq.IGrouping`2" /> 之項目的函式。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並使用指定的函式來投影每個群組的項目。</summary>
        <returns>C# 中的 <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> 或 Visual Basic 中的 <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c>，其中每個 <see cref="T:System.Linq.IGrouping`2" /> 物件包含一個 <paramref name="TElement" /> 類型的物件集合和一個索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>方法傳回的集合<xref:System.Linq.IGrouping%602>物件，一個用於每個發現的相異索引鍵。 <xref:System.Linq.IGrouping%602>是<xref:System.Collections.Generic.IEnumerable%601>也具有其項目相關聯的索引鍵。  
  
 <xref:System.Linq.IGrouping%602>物件產生根據順序中的項目順序`source`產生第一個索引鍵，每個<xref:System.Linq.IGrouping%602>。 在群組中的項目產生的順序產生它們的項目會出現在`source`。  
  
 預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>來分組序列的項目。  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。 下列範例中的查詢運算式的轉譯相當於上述範例中的查詢。  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  Visual C# 或 Visual Basic 的查詢運算式中的項目和索引鍵選取範圍的運算式中發生相反的順序中呼叫的引數位置從<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <see cref="T:System.Linq.IGrouping`2" /> 中的項目類型。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="elementSelector">用來將每個來源項目對應至 <see cref="T:System.Linq.IGrouping`2" /> 之項目的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>依據索引鍵選取器函式來群組序列中的項目。 索引鍵是使用比較子來進行比較，而每個群組的項目都是利用指定的函式進行投影。</summary>
        <returns>C# 中的 <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> 或 Visual Basic 中的 <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c>，其中每個 <see cref="T:System.Linq.IGrouping`2" /> 物件包含一個 <paramref name="TElement" /> 類型的物件集合和一個索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
> [!NOTE]
>  如需範例的`GroupBy`，請參閱下列主題。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>方法傳回的集合<xref:System.Linq.IGrouping%602>物件，一個用於每個發現的相異索引鍵。 <xref:System.Linq.IGrouping%602>是<xref:System.Collections.Generic.IEnumerable%601>也具有其項目相關聯的索引鍵。  
  
 <xref:System.Linq.IGrouping%602>物件產生根據順序中的項目順序`source`產生第一個索引鍵，每個<xref:System.Linq.IGrouping%602>。 在群組中的項目產生的順序產生它們的項目會出現在`source`。  
  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 如果兩個金鑰會被視為相等於根據`comparer`，第一個索引鍵會被選為該群組的索引鍵。  
  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。 如需詳細資訊和使用方式範例，請參閱 < [group 子句](~/docs/csharp/language-reference/keywords/group-clause.md)並[By 子句群組](~/docs/visual-basic/language-reference/queries/group-by-clause.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TResult">
          <paramref name="resultSelector" /> 所傳回之結果值的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="resultSelector">用來從各個群組建立結果值的函式。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並從每個群組及其索引鍵建立結果值。</summary>
        <returns>
          <paramref name="TResult" /> 型別項目的集合，其中每個項目都代表群組及其索引鍵的投影。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>分組序列的項目，以及專案的型別的結果序列`TResult`。  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TResult">
          <paramref name="resultSelector" /> 所傳回之結果值的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="resultSelector">用來從各個群組建立結果值的函式。</param>
        <param name="comparer">用來比較索引鍵的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並從每個群組及其索引鍵建立結果值。 索引鍵是使用指定的比較子來進行比較。</summary>
        <returns>
          <paramref name="TResult" /> 型別項目的集合，其中每個項目都代表群組及其索引鍵的投影。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">每個 <see cref="T:System.Linq.IGrouping`2" /> 中的項目型別。</typeparam>
        <typeparam name="TResult">
          <paramref name="resultSelector" /> 所傳回之結果值的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="elementSelector">用來將每個來源項目對應至 <see cref="T:System.Linq.IGrouping`2" /> 之項目的函式。</param>
        <param name="resultSelector">用來從各個群組建立結果值的函式。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並從每個群組及其索引鍵建立結果值。 每個群組的項目都是利用指定的函式進行投影。</summary>
        <returns>
          <paramref name="TResult" /> 型別項目的集合，其中每個項目都代表群組及其索引鍵的投影。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在查詢運算式語法中， `group by` (Visual C#) 或`Group By Into`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupBy%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>分組序列的預測的項目，並接著按一下 專案類型的結果的序列`TResult`。  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">每個 <see cref="T:System.Linq.IGrouping`2" /> 中的項目型別。</typeparam>
        <typeparam name="TResult">
          <paramref name="resultSelector" /> 所傳回之結果值的型別。</typeparam>
        <param name="source">要群組其項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來擷取各項目之索引鍵的函式。</param>
        <param name="elementSelector">用來將每個來源項目對應至 <see cref="T:System.Linq.IGrouping`2" /> 之項目的函式。</param>
        <param name="resultSelector">用來從各個群組建立結果值的函式。</param>
        <param name="comparer">用來比較索引鍵的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>依據指定的索引鍵選取器函式來群組序列的項目，並從每個群組及其索引鍵建立結果值。 索引鍵值是使用指定的比較子來進行比較，而每個群組的項目則都是利用指定的函式進行投影。</summary>
        <returns>
          <paramref name="TResult" /> 型別項目的集合，其中每個項目都代表群組及其索引鍵的投影。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據索引鍵相等與否，將兩個序列的項目相互關聯，並群組產生的結果。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">第一個序列之項目的類型。</typeparam>
        <typeparam name="TInner">第二個序列之項目的類型。</typeparam>
        <typeparam name="TKey">索引鍵選取器函式所傳回之索引鍵的類型。</typeparam>
        <typeparam name="TResult">結果項目的類型。</typeparam>
        <param name="outer">要聯結的第一個序列。</param>
        <param name="inner">要加入第一個序列的序列。</param>
        <param name="outerKeySelector">用來從第一個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="innerKeySelector">用來從第二個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="resultSelector">函式，用來從第一個序列的項目以及第二個序列的相符項目集合建立結果項目。</param>
        <summary>根據索引鍵相等與否，將兩個序列的項目相互關聯，並群組產生的結果。 預設的相等比較子是用於比較索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含透過對兩個序列執行群組聯結所取得之型別 <paramref name="TResult" /> 的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來雜湊及比較索引鍵。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 產生階層式結果，這表示中的項目`outer`會與集合的相符項目配對`inner`。 `GroupJoin` 可讓您根據整組相符項目，每個項目結果`outer`。  
  
> [!NOTE]
>  如果不有任何相互關聯的項目，在`inner`給定項目的`outer`的相符項目順序會是空的但是仍然會出現在結果中。  
  
 `resultSelector`函式會呼叫一次，每個`outer`項目與所有集合`inner`相符的項目`outer`項目。 這不同於<xref:System.Linq.Enumerable.Join%2A>方法，在其中結果選取器函式會叫用包含一個項目配對`outer`和 從一個項目`inner`。  
  
 `GroupJoin` 保留的項目順序`outer`，和每個項目`outer`，從相符項目的順序`inner`。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 在傳統的關聯式資料庫詞彙中有沒有直接的對等。 不過，這個方法會實作內部聯結和左方外部聯結的超集。 這兩種作業可以撰寫以使用群組聯結。 請參閱[聯結作業](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)。  
  
 在查詢運算式語法中， `join … into` (Visual C#) 或`Group Join`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.GroupJoin%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29>上兩個序列執行群組的聯結。  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />、<paramref name="inner" />、<paramref name="outerKeySelector" />、<paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">聯結作業</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">join 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/37dbf79c-7b5c-421b-bbb7-dadfd2b92a1c">Group Join 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">第一個序列之項目的類型。</typeparam>
        <typeparam name="TInner">第二個序列之項目的類型。</typeparam>
        <typeparam name="TKey">索引鍵選取器函式所傳回之索引鍵的類型。</typeparam>
        <typeparam name="TResult">結果項目的類型。</typeparam>
        <param name="outer">要聯結的第一個序列。</param>
        <param name="inner">要加入第一個序列的序列。</param>
        <param name="outerKeySelector">用來從第一個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="innerKeySelector">用來從第二個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="resultSelector">函式，用來從第一個序列的項目以及第二個序列的相符項目集合建立結果項目。</param>
        <param name="comparer">用來雜湊及比較索引鍵的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據索引鍵相等與否，將兩個序列的項目相互關聯，並群組產生的結果。 指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 是用於比較索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含透過對兩個序列執行群組聯結所取得之型別 <paramref name="TResult" /> 的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來雜湊及比較索引鍵。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 產生階層式結果，這表示中的項目`outer`會與集合的相符項目配對`inner`。 `GroupJoin` 可讓您根據整組相符項目，每個項目結果`outer`。  
  
> [!NOTE]
>  如果不有任何相互關聯的項目，在`inner`給定項目的`outer`的相符項目順序會是空的但是仍然會出現在結果中。  
  
 `resultSelector`函式會呼叫一次，每個`outer`項目與所有集合`inner`相符的項目`outer`項目。 這不同於<xref:System.Linq.Enumerable.Join%2A>方法中結果選取器函式會叫用包含一個項目配對`outer`和 從一個項目`inner`。  
  
 `GroupJoin` 保留的項目順序`outer`，和每個項目`outer`，從相符項目的順序`inner`。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 在傳統的關聯式資料庫詞彙中有沒有直接的對等。 不過，這個方法會實作內部聯結和左方外部聯結的超集。 這兩種作業可以撰寫以使用群組聯結。 請參閱[聯結作業](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />、<paramref name="inner" />、<paramref name="outerKeySelector" />、<paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">執行聯結作業</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>產生兩個序列的交集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">傳回其獨特項目同時出現在 <paramref name="second" /> 中的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="second">傳回其獨特項目同時出現在第一個序列中的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>使用預設相等比較子來比較值，以便產生兩個序列的交集。</summary>
        <returns>序列，其中包含形成兩個序列之交集的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 A 與 B 兩個集合的交集會定義為包含所有項目同時出現在 B，但沒有其他項目集。  
  
 這個方法所傳回的物件列舉時，<xref:System.Linq.Enumerable.Intersect%2A>會產生不同的項目中兩個序列中出現的順序發生`first`。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值的類型可實作<xref:System.Collections.Generic.IEqualityComparer%601>泛型介面。 若要比較的自訂資料類型，您需要實作這個介面，並提供您自己<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>類型的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>傳回項目出現在每個整數的兩個序列中。  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 如果您想要比較之物件的自訂資料類型的序列，您必須實作<xref:System.Collections.Generic.IEqualityComparer%601>協助程式類別中的泛型介面。 下列程式碼範例示範如何實作這個介面中的自訂資料類型，並提供<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>方法。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 您實作這個介面之後，您可以使用的序列`ProductA`中的物件<xref:System.Linq.Enumerable.Intersect%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">傳回其獨特項目同時出現在 <paramref name="second" /> 中的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="second">傳回其獨特項目同時出現在第一個序列中的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="comparer">用來比較值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 來比較值，以便產生兩個序列的交集。</summary>
        <returns>序列，其中包含形成兩個序列之交集的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 A 與 B 兩個集合的交集會定義為包含所有項目同時出現在 B，但沒有其他項目集。  
  
 這個方法所傳回的物件列舉時，<xref:System.Linq.Enumerable.Intersect%2A>會產生不同的項目中兩個序列中出現的順序發生`first`。  
  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.Intersect%2A>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用連串`Product`中的物件<xref:System.Linq.Enumerable.Intersect%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據相符索引鍵，將兩個序列的項目相互關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">第一個序列之項目的類型。</typeparam>
        <typeparam name="TInner">第二個序列之項目的類型。</typeparam>
        <typeparam name="TKey">索引鍵選取器函式所傳回之索引鍵的類型。</typeparam>
        <typeparam name="TResult">結果項目的類型。</typeparam>
        <param name="outer">要聯結的第一個序列。</param>
        <param name="inner">要加入第一個序列的序列。</param>
        <param name="outerKeySelector">用來從第一個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="innerKeySelector">用來從第二個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="resultSelector">用來從兩個相符項目建立結果項目的函式。</param>
        <summary>根據相符索引鍵，將兩個序列的項目相互關聯。 預設的相等比較子是用於比較索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含透過對兩個序列執行內部聯結所取得之型別 <paramref name="TResult" /> 的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來雜湊及比較索引鍵。  
  
 聯結是指兩個來源的資訊，根據一般的索引鍵的項目建立相互關聯的作業。 <xref:System.Linq.Enumerable.Join%2A> 將兩個資訊來源和相符的索引鍵用它們會一起其中一種方法呼叫中。 這不同於使用`SelectMany`，這需要一個以上的方法呼叫來執行相同的作業。  
  
 <xref:System.Linq.Enumerable.Join%2A> 保留的項目順序`outer`，和每個這些項目，相符項目的順序`inner`。  
  
 在查詢運算式語法中， `join` (Visual C#) 或`Join`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Join%2A>。  
  
 在關聯式資料庫規定，<xref:System.Linq.Enumerable.Join%2A>方法會實作內部等聯結。 「 內部 」 表示只與另一個序列中有符合的項目都包含在結果中。 等聯結 ' 是聯結中的索引鍵比較是否相等。 左方外部聯結作業有沒有專用的標準查詢運算子，但可以使用來執行<xref:System.Linq.Enumerable.GroupJoin%2A>方法。 請參閱[聯結作業](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29>執行一般的索引鍵為基礎的兩個序列的內部聯結。  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />、<paramref name="inner" />、<paramref name="outerKeySelector" />、<paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">聯結</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">join 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6dd37936-b27c-4e00-98ad-154b23f4de64">Join 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">第一個序列之項目的類型。</typeparam>
        <typeparam name="TInner">第二個序列之項目的類型。</typeparam>
        <typeparam name="TKey">索引鍵選取器函式所傳回之索引鍵的類型。</typeparam>
        <typeparam name="TResult">結果項目的類型。</typeparam>
        <param name="outer">要聯結的第一個序列。</param>
        <param name="inner">要加入第一個序列的序列。</param>
        <param name="outerKeySelector">用來從第一個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="innerKeySelector">用來從第二個序列各個項目擷取聯結索引鍵的函式。</param>
        <param name="resultSelector">用來從兩個相符項目建立結果項目的函式。</param>
        <param name="comparer">用來雜湊及比較索引鍵的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據相符索引鍵，將兩個序列的項目相互關聯。 指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 是用於比較索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含透過對兩個序列執行內部聯結所取得之型別 <paramref name="TResult" /> 的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來雜湊及比較索引鍵。  
  
 聯結是指兩個來源的資訊，根據一般的索引鍵的項目建立相互關聯的作業。 <xref:System.Linq.Enumerable.Join%2A> 將兩個資訊來源和相符的索引鍵用它們會一起其中一種方法呼叫中。 這不同於使用`SelectMany`，這需要一個以上的方法呼叫來執行相同的作業。  
  
 <xref:System.Linq.Enumerable.Join%2A> 保留的項目順序`outer`，和每個這些項目，相符項目的順序`inner`。  
  
 在關聯式資料庫規定，<xref:System.Linq.Enumerable.Join%2A>方法會實作內部等聯結。 「 內部 」 表示只與另一個序列中有符合的項目都包含在結果中。 等聯結 ' 是聯結中的索引鍵比較是否相等。 左方外部聯結作業有沒有專用的標準查詢運算子，但可以使用來執行<xref:System.Linq.Enumerable.GroupJoin%2A>方法。 請參閱[聯結作業](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />、<paramref name="inner" />、<paramref name="outerKeySelector" />、<paramref name="innerKeySelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">聯結</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的最後一個項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回最後一個項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的最後一個項目。</summary>
        <returns>位於來源序列中最後一個位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法時擲回例外狀況`source`包含任何項目。 若要改為傳回預設值，當來源序列是空的使用<xref:System.Linq.Enumerable.LastOrDefault%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>傳回陣列的最後一個元素。  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">來源序列為空。</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回序列中符合指定之條件的最後一個元素。</summary>
        <returns>序列中通過指定之述詞函式所做測試的最後一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法擲回例外狀況，如果沒有相符的項目位於`source`。 若要找到任何相符的項目時，請改為傳回預設值，請使用<xref:System.Linq.Enumerable.LastOrDefault%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>傳回陣列，符合條件的最後一個元素。  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">沒有任何項目符合 <paramref name="predicate" /> 的條件。  
  
-或- 
來源序列為空。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的最後一個項目；如果找不到任何項目，則傳回預設值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回最後一個項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的最後一個元素；如果序列中沒有包含任何元素，則傳回預設值。</summary>
        <returns>如果來源序列是空的，則為 <see langword="default" />(<paramref name="TSource" />)，否則為 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 中的最後一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
 <xref:System.Linq.Enumerable.LastOrDefault%2A>方法不會提供方法來指定預設值。 如果您想要指定預設值以外`default(TSource)`，使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>範例 > 一節中所述的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>上的空陣列。  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 有時值`default(TSource)`不是您想要使用如果集合不包含任何元素的預設值。 除了檢查不必要的預設值的結果，並將它如有必要變更，您可以使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>方法，以指定您想要使用這個集合是空的預設值。 然後，呼叫<xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>取得最後一個項目。 下列程式碼範例會使用這兩種技術以取得預設值為 1，如果數字的每月天數的集合是空的。 整數，預設值為 0，這未對應到任何一天的月份，因為預設值必須被指定為 1。 查詢完成執行後不必要的預設值會檢查第一個結果變數。 第二個結果變數使用取得的<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>指定預設值為 1。  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回序列中符合條件的最後一個元素；如果找不到這類元素，則傳回預設值。</summary>
        <returns>如果序列是空的，或是沒有任何項目通過述詞函式中的測試，則為 <see langword="default" />(<paramref name="TSource" />)，否則為通過述詞函式之測試的最後一個項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>傳遞述詞中。 在第二個方法呼叫中，沒有任何項目中符合條件的順序。  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回代表序列中項目數目的 <see cref="T:System.Int64" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">包含要計算之項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回代表序列中項目總數的 <see cref="T:System.Int64" />。</summary>
        <returns>來源序列中的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法而非<xref:System.Linq.Enumerable.Count%2A>當您預期的結果是大於<xref:System.Int32.MaxValue>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into LongCount()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.LongCount%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>來計算陣列中的項目。  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">項目數目超出 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">包含要計算之項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>傳回 <see cref="T:System.Int64" />，其代表序列中符合條件的項目數目。</summary>
        <returns>數字，代表序列中符合述詞函式之條件的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法而非<xref:System.Linq.Enumerable.Count%2A>當您預期的結果是大於<xref:System.Int32.MaxValue>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into LongCount()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.LongCount%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>計算陣列中滿足條件的項目。  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">符合的項目數目超出 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值序列中的最大值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Decimal" /> 值序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Double" /> 值序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Int32" /> 值序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Int64" /> 值序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>來判斷序列中的最大值。  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值之可為 Null 的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Decimal" /> 值序列中的最大值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Decimal&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Decimal)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值之可為 Null 的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Double" /> 值序列中的最大值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Double&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Double)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>來判斷序列中的最大值。  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值之可為 Null 的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Int32" /> 值序列中的最大值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int32&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int32)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值之可為 Null 的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Int64" /> 值序列中的最大值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int64&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int64)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值之可為 Null 的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Single" /> 值序列中的最大值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Single&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Single)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最大值的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Single" /> 值序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>來判斷序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <summary>傳回泛型序列中的最大值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果型別`TSource`會實作<xref:System.IComparable%601>，則<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法會使用該實作來比較值。 否則，如果型別`TSource`實作<xref:System.IComparable>，該實作用來比較值。  
  
 如果`TSource`是參考類型，而且來源序列是空的或包含的值`null`，這個方法會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>來判斷序列中的最大值<xref:System.IComparable%601>物件。  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的 <see cref="T:System.Decimal" /> 值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Decimal>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的 <see cref="T:System.Double" /> 值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Double>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的 <see cref="T:System.Int32" /> 值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int32>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的 <see cref="T:System.Int64" /> 值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int64>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的可為 Null 之 <see cref="T:System.Decimal" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Decimal&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Decimal)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Decimal>`在 C# 或`Nullable(Of Decimal)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的可為 Null 之 <see cref="T:System.Double" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Double&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Double)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Double>`在 C# 或`Nullable(Of Double)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的可為 Null 之 <see cref="T:System.Int32" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int32&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int32)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Int32>`在 C# 或`Nullable(Of Int32)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的可為 Null 之 <see cref="T:System.Int64" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int64&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int64)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Int64>`在 C# 或`Nullable(Of Int64)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的可為 Null 之 <see cref="T:System.Single" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Single&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Single)</c> 的值，其對應於序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Single>`在 C# 或`Nullable(Of Single)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最大的 <see cref="T:System.Single" /> 值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Single>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回值的型別。</typeparam>
        <param name="source">要判斷最大值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在泛型序列的每個項目上叫用轉換函式，並傳回最大的結果值。</summary>
        <returns>序列中的最大值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果型別`TResult`實作<xref:System.IComparable%601>，這個方法會使用該實作來比較值。 否則，如果型別`TResult`實作<xref:System.IComparable>，該實作用來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Max()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Max%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最大值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值序列中的最小值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Decimal" /> 值序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Double" /> 值序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>來判斷序列中的最小值。  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Int32" /> 值序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Int64" /> 值序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值之可為 Null 的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Decimal" /> 值序列中的最小值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Decimal&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Decimal)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值之可為 Null 的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Double" /> 值序列中的最小值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Double&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Double)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值之可為 Null 的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Int32" /> 值序列中的最小值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int32&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int32)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>來判斷序列中的最小值。  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值之可為 Null 的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Int64" /> 值序列中的最小值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int64&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int64)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值之可為 Null 的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>傳回可為 Null 之 <see cref="T:System.Single" /> 值序列中的最小值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Single&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Single)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 如果來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要判斷最小值的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>傳回 <see cref="T:System.Single" /> 值序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>來判斷序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <summary>傳回泛型序列中的最小值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果型別`TSource`實作<xref:System.IComparable%601>，這個方法會使用該實作來比較值。 否則，如果型別`TSource`實作<xref:System.IComparable>，該實作用來比較值。  
  
 如果`TSource`是參考類型，而且來源序列是空的或包含的值`null`，此函數會傳回`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>來判斷序列中的最小值<xref:System.IComparable%601>物件。  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的 <see cref="T:System.Decimal" /> 值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Decimal>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的 <see cref="T:System.Double" /> 值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Double>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的 <see cref="T:System.Int32" /> 值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int32>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的 <see cref="T:System.Int64" /> 值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int64>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的可為 Null 之 <see cref="T:System.Decimal" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Decimal&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Decimal)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>方法會使用<xref:System.Decimal>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Decimal>`在 C# 或`Nullable(Of Decimal)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的可為 Null 之 <see cref="T:System.Double" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Double&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Double)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>方法會使用<xref:System.Double>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Double>`在 C# 或`Nullable(Of Double)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的可為 Null 之 <see cref="T:System.Int32" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int32&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int32)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>方法會使用<xref:System.Int32>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，投影來源成員成數值類型，特別`Nullable<Int32>`在 C# 或`Nullable(Of Int32)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的可為 Null 之 <see cref="T:System.Int64" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Int64&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Int64)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>方法會使用<xref:System.Int64>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Int64>`在 C# 或`Nullable(Of Int64)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的可為 Null 之 <see cref="T:System.Single" /> 值。</summary>
        <returns>C# 中類型為 <c>Nullable&lt;Single&gt;</c> 或 Visual Basic 中類型為 <c>Nullable(Of Single)</c> 的值，其對應於序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Single>`在 C# 或`Nullable(Of Single)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在序列的每個項目上叫用轉換函式，並傳回最小的 <see cref="T:System.Single" /> 值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>方法會使用<xref:System.Single>實作<xref:System.IComparable%601>來比較值。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Single>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 沒有包含任何項目。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回值的型別。</typeparam>
        <param name="source">要判斷最小值的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>在泛型序列的每個項目上叫用轉換函式，並傳回最小的結果值。</summary>
        <returns>序列中的最小值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果型別`TResult`實作<xref:System.IComparable%601>，這個方法會使用該實作來比較值。 否則，如果型別`TResult`實作<xref:System.IComparable>，該實作用來比較值。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Min()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Min%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>判斷預測的值序列中的最小值。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ OfType(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">用來做為序列項目之篩選依據的類型。</typeparam>
        <param name="source">要篩選其項目的 <see cref="T:System.Collections.IEnumerable" />。</param>
        <summary>根據指定的型別來篩選 <see cref="T:System.Collections.IEnumerable" /> 的項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含輸入序列中型別為 <paramref name="TResult" /> 的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29>方法會傳回這些元素中的`source`可以轉換為類型`TResult`。 如果項目無法轉換為類型，而是收到例外狀況`TResult`，使用<xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>。  
  
 這個方法是可以套用至集合，其中有一個非參數化型別，例如幾個標準查詢運算子方法的其中一個<xref:System.Collections.ArrayList>。 這是因為<xref:System.Linq.Enumerable.OfType%2A>擴充類型<xref:System.Collections.IEnumerable>。 <xref:System.Linq.Enumerable.OfType%2A> 無法只套用至為基礎的集合上參數化<xref:System.Collections.Generic.IEnumerable%601>型別，但根據非參數化的集合<xref:System.Collections.IEnumerable>也輸入。  
  
 藉由套用<xref:System.Linq.Enumerable.OfType%2A>至集合，實作<xref:System.Collections.IEnumerable>，您就可以使用標準查詢運算子來查詢集合。 例如，指定的類型引數<xref:System.Object>來<xref:System.Linq.Enumerable.OfType%2A>會傳回型別的物件`IEnumerable<Object>`在 C# 或`IEnumerable(Of Object)`在 Visual Basic 中，可以套用標準查詢運算子。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.OfType%2A>若要篩選的項目<xref:System.Collections.IEnumerable>。  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依遞增順序排序序列中的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要排序的值序列。</param>
        <param name="keySelector">用來從項目擷取索引鍵的函式。</param>
        <summary>依據索引鍵，按遞增順序排序序列中的項目。</summary>
        <returns>依據索引鍵排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 若要擴充的型別定義兩個方法<xref:System.Linq.IOrderedEnumerable%601>，這是這個方法的傳回型別。 這兩種方法，也就是`ThenBy`和`ThenByDescending`，讓您指定額外的排序準則來排序序列。 `ThenBy` 並`ThenByDescending`也會傳回<xref:System.Linq.IOrderedEnumerable%601>，這表示任何數目的連續呼叫`ThenBy`或`ThenByDescending`可以進行。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 這個方法會使用預設比較子來比較索引鍵<xref:System.Collections.Generic.Comparer%601.Default%2A>。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 在查詢運算式語法中， `orderby` (Visual C#) 或`Order By`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.OrderBy%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>來排序序列的項目。  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">orderby 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要排序的值序列。</param>
        <param name="keySelector">用來從項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
        <summary>使用指定的比較子，依遞增順序排序序列中的項目。</summary>
        <returns>依據索引鍵排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 若要擴充的型別定義兩個方法<xref:System.Linq.IOrderedEnumerable%601>，這是這個方法的傳回型別。 這兩種方法，也就是`ThenBy`和`ThenByDescending`，讓您指定額外的排序準則來排序序列。 `ThenBy` 並`ThenByDescending`也會傳回<xref:System.Linq.IOrderedEnumerable%601>，這表示任何數目的連續呼叫`ThenBy`或`ThenByDescending`可以進行。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 如果`comparer`已`null`，預設比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>用來比較索引鍵。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依遞減順序排序序列中的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要排序的值序列。</param>
        <param name="keySelector">用來從項目擷取索引鍵的函式。</param>
        <summary>依據索引鍵，按遞減順序排序序列中的項目。</summary>
        <returns>依據索引鍵按遞減順序排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 如需這個方法的範例，請參閱<xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>。  
  
 若要擴充的型別定義兩個方法<xref:System.Linq.IOrderedEnumerable%601>，這是這個方法的傳回型別。 這兩種方法，也就是`ThenBy`和`ThenByDescending`，讓您指定額外的排序準則來排序序列。 `ThenBy` 並`ThenByDescending`也會傳回<xref:System.Linq.IOrderedEnumerable%601>，這表示任何數目的連續呼叫`ThenBy`或`ThenByDescending`可以進行。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 這個方法會使用預設比較子來比較索引鍵<xref:System.Collections.Generic.Comparer%601.Default%2A>。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 在查詢運算式語法中， `orderby descending` (Visual C#) 或`Order By Descending`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.OrderByDescending%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">orderby 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">要排序的值序列。</param>
        <param name="keySelector">用來從項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
        <summary>使用指定的比較子，依遞減順序排序序列中的項目。</summary>
        <returns>依據索引鍵按遞減順序排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 若要擴充的型別定義兩個方法<xref:System.Linq.IOrderedEnumerable%601>，這是這個方法的傳回型別。 這兩種方法，也就是`ThenBy`和`ThenByDescending`，讓您指定額外的排序準則來排序序列。 `ThenBy` 並`ThenByDescending`也會傳回<xref:System.Linq.IOrderedEnumerable%601>，這表示任何數目的連續呼叫`ThenBy`或`ThenByDescending`可以進行。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 如果`comparer`已`null`，預設比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>用來比較索引鍵。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>來排序序列中使用轉換函式和自訂比較子，依遞減順序的項目。  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Prepend(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">一連串的值。</param>
        <param name="element">要新增在 <paramref name="source" /> 開頭的值。</param>
        <summary>將值新增至序列的開頭。</summary>
        <returns>以 <paramref name="element" /> 開頭的新序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[    
          
## Remarks  
  
> [!NOTE]
>  這個方法不會修改集合的元素。 相反地，它會建立集合的複本與新的項目。
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Prepend%2A>前面加上之序列開頭的值。  
  
 [!code-csharp[System.Linq.Enumerable#202](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#202)]
 [!code-vb[System.Linq.Enumerable#202](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As IEnumerable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; seq&lt;int&gt;" Usage="System.Linq.Enumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">序列中第一個整數的值。</param>
        <param name="count">要產生的循序整數數目。</param>
        <summary>產生在指定之範圍內的整數序列。</summary>
        <returns>包含一個循序整數範圍之 C# 的 <c>IEnumerable&lt;Int32&gt;</c> 或 Visual Basic 的 <c>IEnumerable(Of Int32)</c>。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Range%2A>產生一連串的值。  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小於 0。  
  
-或- 
 <paramref name="start" /> + <paramref name="count" /> -1 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">要在結果序列中重複出現的值之類型。</typeparam>
        <param name="element">要重複的值。</param>
        <param name="count">這個值要在產生的序列中重複出現的次數。</param>
        <summary>產生包含一個重複值的序列。</summary>
        <returns>包含重複值的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Repeat%2A>產生一連串的重複值。  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Reverse(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要反轉方向的值序列。</param>
        <summary>反轉序列中項目的排序方向。</summary>
        <returns>其項目對應於輸入序列中反向排序之項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 不同於<xref:System.Linq.Enumerable.OrderBy%2A>，這個排序方法不會考慮中的實際值自行決定的順序。 相反地，它只會傳回項目依相反順序從中產生基礎來源。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Reverse%2A>反轉陣列中項目的順序。  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將序列的每個元素規劃成一個新的表單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回值的型別。</typeparam>
        <param name="source">要對於叫用轉換函式的值序列。</param>
        <param name="selector">要套用到每個來源項目的轉換函式；此函式的第二個參數代表來源項目的索引。</param>
        <summary>透過加入項目的索引，將序列的每個項目投影成新的表單。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是對 <paramref name="source" /> 之各個項目叫用轉換函式所產生的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 第一個引數`selector`代表要處理的項目。 第二個引數`selector`代表來源序列中的該項目的以零為起始的索引。 如果項目是已知的順序，而且您想要運用特定的索引處的項目，例如，這可以是很有用。 它也可用如果您想要擷取的一或多個項目索引。  
  
 此投影方法需要轉換函式`selector`，以產生中來源序列中，每個值的一個值`source`。 如果`selector`本身就是集合的值傳回，是由取用者手動周遊個子序列。 在這種情況下，可能更適合您的查詢，以傳回單一值的結合的序列。 若要這麼做，請使用<xref:System.Linq.Enumerable.SelectMany%2A>方法，而非<xref:System.Linq.Enumerable.Select%2A>。 雖然`SelectMany`運作方式類似`Select`，它不同，因為轉換函式傳回一個集合，然後展開`SelectMany`傳回之前。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29>專案透過一連串的值，並使用每個項目的索引。  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回值的型別。</typeparam>
        <param name="source">要對於叫用轉換函式的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>將序列的每個元素規劃成一個新的表單。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是對 <paramref name="source" /> 之各個項目叫用轉換函式所產生的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 此投影方法需要轉換函式`selector`，以產生中來源序列中，每個值的一個值`source`。 如果`selector`本身就是集合的值傳回，是由取用者手動周遊個子序列。 在這種情況下，可能更適合您的查詢，以傳回單一值的結合的序列。 若要這麼做，請使用<xref:System.Linq.Enumerable.SelectMany%2A>方法，而非<xref:System.Linq.Enumerable.Select%2A>。 雖然`SelectMany`運作方式類似`Select`，它不同，因為轉換函式傳回一個集合，然後展開`SelectMany`傳回之前。  
  
 在查詢運算式語法中， `select` (Visual C#) 或`Select`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Select%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>專案透過一連串的值。  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/df01e266-5781-4aaa-80c4-67cf28ea093f">select 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/27a3f61c-5960-4692-9b91-4d0c4b6178fe">Select 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將序列的每個項目都投影成 <see cref="T:System.Collections.Generic.IEnumerable`1" />，並將產生的序列簡化成單一序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回序列之項目的型別。</typeparam>
        <param name="source">要投影的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>將序列的每個項目都投影成 <see cref="T:System.Collections.Generic.IEnumerable`1" />，並將產生的序列簡化成單一序列。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是在輸入序列的各個項目上叫用一對多轉換函式所產生的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>方法列舉輸入的序列中，使用轉換函式對應至每個項目<xref:System.Collections.Generic.IEnumerable%601>，然後列舉，並產生每個這類的項目<xref:System.Collections.Generic.IEnumerable%601>物件。 也就是說，每個項目`source`，`selector`叫用，而且會傳回一連串的值。 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> 然後將壓平合併成一維集合的這個二維集合<xref:System.Collections.Generic.IEnumerable%601>並將它傳回。 比方說，如果查詢使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>取得訂單 (型別的`Order`) 資料庫中每位客戶，則結果為類型`IEnumerable<Order>`在 C# 或`IEnumerable(Of Order)`Visual Basic 中。 如果改為查詢使用<xref:System.Linq.Enumerable.Select%2A>若要取得的訂單，未合併的訂單集合的集合，且結果為型別的`IEnumerable<List<Order>>`在 C# 或`IEnumerable(Of List(Of Order))`Visual Basic 中。  
  
 在查詢運算式語法中，每個`from`子句 (Visual C#) 或`From`初始子句 (Visual Basic) 其中一個將轉譯的引動過程<xref:System.Linq.Enumerable.SelectMany%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>對陣列進行反覆執行的一對多投影。  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">from 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TResult">
          <paramref name="selector" /> 所傳回序列之項目的型別。</typeparam>
        <param name="source">要投影的值序列。</param>
        <param name="selector">要套用到每個來源項目的轉換函式；此函式的第二個參數代表來源項目的索引。</param>
        <summary>將序列的每個項目都投影成 <see cref="T:System.Collections.Generic.IEnumerable`1" />，並將產生的序列簡化成單一序列。 各來源項目的索引是在該項目的投影表單中使用。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是對輸入序列中各個項目叫用一對多轉換函式後所產生的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>方法列舉輸入的序列中，使用轉換函式對應至每個項目<xref:System.Collections.Generic.IEnumerable%601>，然後列舉，並產生每個這類的項目<xref:System.Collections.Generic.IEnumerable%601>物件。 也就是說，每個項目`source`，`selector`叫用，而且會傳回一連串的值。 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> 然後將壓平合併成一維集合的這個二維集合<xref:System.Collections.Generic.IEnumerable%601>並將它傳回。 比方說，如果查詢使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>取得訂單 (型別的`Order`) 資料庫中每位客戶，則結果為類型`IEnumerable<Order>`在 C# 或`IEnumerable(Of Order)`Visual Basic 中。 如果改為查詢使用<xref:System.Linq.Enumerable.Select%2A>若要取得的訂單，未合併的訂單集合的集合，且結果為型別的`IEnumerable<List<Order>>`在 C# 或`IEnumerable(Of List(Of Order))`Visual Basic 中。  
  
 第一個引數`selector`代表要處理的項目。 第二個引數`selector`代表來源序列中的該項目的以零為起始的索引。 如果項目是已知的順序，而且您想要運用特定的索引處的項目，例如，這可以是很有用。 它也可用如果您想要擷取的一或多個項目索引。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>對陣列進行反覆執行的一對多投影，並使用每個外部項目的索引。  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TCollection">
          <paramref name="collectionSelector" /> 所收集之中繼項目的型別。</typeparam>
        <typeparam name="TResult">產生的序列之項目型別。</typeparam>
        <param name="source">要投影的值序列。</param>
        <param name="collectionSelector">要套用到輸入序列中各個項目的轉換函式。</param>
        <param name="resultSelector">要套用到中繼序列中各個項目的轉換函式。</param>
        <summary>將序列的每個項目投影為 <see cref="T:System.Collections.Generic.IEnumerable`1" />、將產生的序列簡化成單一序列，並對其中的每個項目叫用結果選取器函式。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是執行下列動作後所產生的結果：對 <paramref name="collectionSelector" /> 的各個項目叫用一對多轉換函式 <paramref name="source" />，然後再將每個序列項目及其對應的來源項目對應到結果項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>方法會很有用，當您要保留的項目`source`在呼叫之後，就會發生的查詢邏輯的範圍內<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>。 如需程式碼範例，請參閱＜範例＞一節。 如果類型的物件之間沒有雙向關聯性`TSource`和類型的物件`TCollection`，也就是如果型別的物件`TCollection`提供屬性，以擷取`TSource`物件產生，您並不需要此多載<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>。 相反地，您可以使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>並瀏覽回到`TSource`物件傳遞`TCollection`物件。  
  
 在查詢運算式語法中，每個`from`子句 (Visual C#) 或`From`初始子句 (Visual Basic) 其中一個將轉譯的引動過程<xref:System.Linq.Enumerable.SelectMany%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>對陣列進行反覆執行的一對多投影，並使用結果選取器函式保留來源序列中最後一個呼叫的範圍中的每個對應的項目`Select`。  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">from 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TCollection">
          <paramref name="collectionSelector" /> 所收集之中繼項目的型別。</typeparam>
        <typeparam name="TResult">產生的序列之項目型別。</typeparam>
        <param name="source">要投影的值序列。</param>
        <param name="collectionSelector">要套用到每個來源項目的轉換函式；此函式的第二個參數代表來源項目的索引。</param>
        <param name="resultSelector">要套用到中繼序列中各個項目的轉換函式。</param>
        <summary>將序列的每個項目投影為 <see cref="T:System.Collections.Generic.IEnumerable`1" />、將產生的序列簡化成單一序列，並對其中的每個項目叫用結果選取器函式。 各來源項目的索引是在該項目的中繼投影表單中使用。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其項目是執行下列動作後所產生的結果：對 <paramref name="collectionSelector" /> 的各個項目叫用一對多轉換函式 <paramref name="source" />，然後再將每個序列項目及其對應的來源項目對應到結果項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>方法會很有用，當您要保留的項目`source`在呼叫之後，就會發生的查詢邏輯的範圍內<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>。 如需程式碼範例，請參閱＜範例＞一節。 如果類型的物件之間沒有雙向關聯性`TSource`和類型的物件`TCollection`，也就是如果型別的物件`TCollection`提供屬性，以擷取`TSource`物件產生，您並不需要此多載<xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>。 相反地，您可以使用<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>並瀏覽回到`TSource`物件傳遞`TCollection`物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" /> 或 <paramref name="resultSelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據相等比較子，判斷兩個序列是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">要與 <paramref name="second" /> 比較的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="second">要與第一個序列比較的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>使用項目之型別的預設相等比較子來比較項目，以判斷兩個序列是否相等。</summary>
        <returns>如果根據其型別的預設相等比較子判斷，兩個來源序列的長度相等，而且其對應項目也相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法列舉兩個來源序列，以平行方式，並使用預設相等比較子來比較對應項目`TSource`， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>。 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值的類型可實作<xref:System.Collections.Generic.IEqualityComparer%601>泛型介面。 若要比較的自訂資料類型，您需要實作這個介面，並提供您自己<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>類型的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>來判斷兩個序列是否相等。 在前兩個範例中，此方法會決定相比較的序列是否包含相同物件的參考。 在第三個和第四個範例中，這個方法會比較實際的資料序列中的物件。  
  
 在此範例中的序列相等。  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 下列程式碼範例會比較不相等的兩個序列。 請注意，此序列會包含相同的資料，因為它們包含的物件有不同的參考，則不考慮其序列相等。  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 如果您想要比較的物件，而不是只比較其參考此序列中的實際資料，您必須實作<xref:System.Collections.Generic.IEqualityComparer%601>類別中的泛型介面。 下列程式碼範例示範如何實作這個介面協助程式類別中，並提供<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>方法。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 您實作這個介面之後，您可以使用的序列`ProductA`中的物件<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">要與 <paramref name="second" /> 比較的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="second">要與第一個序列比較的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="comparer">用來比較項目的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 來比較項目，以判斷兩個序列是否相等。</summary>
        <returns>如果根據 <paramref name="comparer" /> 判斷，兩個來源序列的長度相等，而且其對應項目的比較也相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>方法會列舉兩個來源序列，以平行方式，並比較使用指定的對應項目<xref:System.Collections.Generic.IEqualityComparer%601>。 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較項目。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用連串`Product`中的物件<xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的單一特定項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回單一項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的唯一一個元素，如果序列中不是正好一個元素，則擲回例外狀況。</summary>
        <returns>輸入序列的單一項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法擲回例外狀況，如果輸入的序列是空的。 若要改為傳回`null`輸入的序列是空的當使用<xref:System.Linq.Enumerable.SingleOrDefault%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>選取唯一元素的陣列。  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 下列程式碼範例示範<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>序列不包含只有一個項目時，會擲回例外狀況。  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">輸入序列包含一個以上的項目。  
  
-或- 
輸入序列是空的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回單一項目的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試項目是否符合條件的函式。</param>
        <summary>傳回序列中符合指定之條件的唯一一個元素，如果有一個以上這類元素，則擲回例外狀況。</summary>
        <returns>輸入序列中符合條件的單一項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法擲回例外狀況，如果輸入的序列不包含任何相符的項目。 若要改為傳回`null`找到任何相符的項目時，使用<xref:System.Linq.Enumerable.SingleOrDefault%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>選取陣列中符合條件的唯一項目。  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 下列程式碼範例示範<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>序列不包含只有一個符合條件的項目時，會擲回例外狀況。  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">沒有任何項目符合 <paramref name="predicate" /> 的條件。  
  
-或- 
超過一個項目符合 <paramref name="predicate" /> 中的條件。  
  
-或- 
來源序列為空。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回序列的單一特定項目；如果找不到該項目，則傳回預設值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回單一項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>傳回序列的唯一一個項目，如果序列是空白，則為預設值，如果序列中有一個以上的項目，這個方法就會擲回例外狀況。</summary>
        <returns>輸入序列的單一項目；如果序列沒有包含任何項目，則為 <see langword="default" />(<paramref name="TSource" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A>方法不會提供方法來指定預設值。 如果您想要指定預設值以外`default(TSource)`，使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>範例 > 一節中所述的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>選取唯一元素的陣列。  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 下列程式碼範例示範<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>序列不包含只有一個項目時，會傳回預設值。  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 有時值`default(TSource)`不是您想要使用如果集合不包含任何元素的預設值。 除了檢查不必要的預設值的結果，並將它如有必要變更，您可以使用<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>方法，以指定您想要使用這個集合是空的預設值。 然後，呼叫<xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>若要取得的項目。 下列程式碼範例會使用這兩種技術以取得預設值為 1，如果頁面號碼的集合是空的。 整數，預設值為 0，這是通常是有效的頁面編號，因為預設值必須被指定為 1。 查詢完成執行後不必要的預設值會檢查第一個結果變數。 第二個結果變數使用取得的<xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>指定預設值為 1。  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">輸入序列包含一個以上的項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要傳回單一項目的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試項目是否符合條件的函式。</param>
        <summary>傳回序列中符合指定之條件的唯一一個元素，如果沒有這類元素，則為預設值，如果有一個以上的元素符合條件，這個方法就會擲回例外狀況。</summary>
        <returns>輸入序列中符合條件的單一項目；如果找不到這類項目，則為 <see langword="default" />(<paramref name="TSource" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參考和可為 null 類型的預設值是`null`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>選取陣列中符合條件的唯一項目。  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 下列程式碼範例示範<xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>序列不包含只有一個符合條件的項目時，會傳回預設值。  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">超過一個項目符合 <paramref name="predicate" /> 中的條件。</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Skip(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="count">傳回其餘項目之前要略過的項目數目。</param>
        <summary>略過序列中指定的項目數目，然後傳回其餘項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含出現在輸入序列中指定之索引後面的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 如果`source`包含少於`count`項目、 空白<xref:System.Collections.Generic.IEnumerable%601>會傳回。 如果`count`小於或等於零的所有項目`source`產生。  
  
 <xref:System.Linq.Enumerable.Take%2A>和<xref:System.Linq.Enumerable.Skip%2A>方法都是功能補充項目。 從指定的序列`coll`和一個整數`n`，串連的結果`coll.Take(n)`並`coll.Skip(n)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Skip`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Skip%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Skip%2A>略過指定的已排序陣列中的元素數目，並傳回其餘項目。  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f00eb172-3907-4c43-9745-d8546ab86234">Skip 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>只要指定的條件為 true，便略過序列中的項目，然後傳回其餘項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>只要指定的條件為 true，便略過序列中的項目，然後傳回其餘項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含的項目位於輸入序列中，而且是從沒有通過 <paramref name="predicate" /> 所指定測試之線性系列中的第一個項目開始。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法藉由使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 這個方法會測試每個項目的`source`利用`predicate`，並略過的項目，如果結果是`true`。 述詞函式傳回之後`false`項目，該項目與中的其餘元素`source`產生且有沒有更多的引動過程的`predicate`。  
  
 如果`predicate`會傳回`true`在順序中，空的所有項目的<xref:System.Collections.Generic.IEnumerable%601>會傳回。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>和<xref:System.Linq.Enumerable.SkipWhile%2A>方法都是功能補充項目。 從指定的序列`coll`和純虛擬函式`p`，串連的結果`coll.TakeWhile(p)`並`coll.SkipWhile(p)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Skip While`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.SkipWhile%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>條件為 true 時，請略過陣列的項目。  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Skip While 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試各來源項目是否符合條件的函式；此函式的第二個參數代表來源項目的索引。</param>
        <summary>只要指定的條件為 true，便略過序列中的項目，然後傳回其餘項目。 項目的索引是用於述詞功能的邏輯中。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含的項目位於輸入序列中，而且是從沒有通過 <paramref name="predicate" /> 所指定測試之線性系列中的第一個項目開始。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>方法會測試每個項目的`source`利用`predicate`，並略過的項目，如果結果是`true`。 述詞函式傳回之後`false`項目，該項目與中的其餘元素`source`產生且有沒有更多的引動過程的`predicate`。  
  
 如果`predicate`會傳回`true`在順序中，空的所有項目的<xref:System.Collections.Generic.IEnumerable%601>會傳回。  
  
 第一個引數`predicate`表示要測試的項目。 第二個引數所代表的項目內的以零起始的索引`source`。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>和<xref:System.Linq.Enumerable.SkipWhile%2A>方法都是功能補充項目。 從指定的序列`coll`和純虛擬函式`p`，串連的結果`coll.TakeWhile(p)`並`coll.SkipWhile(p)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Skip While`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.SkipWhile%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>取決於項目的索引條件為 true 時，請略過陣列的項目。  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Skip While 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>計算數值序列的總和。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Decimal" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>方法會傳回零，如果`source`包含任何項目。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Double" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Int32" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Int64" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和之可為 Null 的 <see cref="T:System.Decimal" /> 值序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Decimal" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值的`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和之可為 Null 的 <see cref="T:System.Double" /> 值序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Double" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和之可為 Null 的 <see cref="T:System.Int32" /> 值序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Int32" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和之可為 Null 的 <see cref="T:System.Int64" /> 值序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Int64" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>加總的一連串的值。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和之可為 Null 的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>計算可為 Null 之 <see cref="T:System.Single" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>加總的一連串的值。  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">要計算總和的 <see cref="T:System.Single" /> 值序列。</param>
        <summary>計算 <see cref="T:System.Single" /> 值序列的總和。</summary>
        <returns>序列中值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>加總的一連串的值。  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Decimal" /> 值序列的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Decimal>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Double" /> 值序列的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Double>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Int32" /> 值序列的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int32>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Int64" /> 值序列的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Int64>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Decimal" /> 值的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不會不會包含值`null`。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Decimal>`在 C# 或`Nullable(Of Decimal)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Double" /> 值的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Double>`在 C# 或`Nullable(Of Double)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Int32" /> 值的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Int32>`在 C# 或`Nullable(Of Int32)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Int64" /> 值的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Int64>`在 C# 或`Nullable(Of Int64)`Visual Basic 中  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OverflowException">總和大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得可為 Null 之 <see cref="T:System.Single" /> 值的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回零，如果`source`包含任何項目。  
  
 結果不包含值`null`。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別`Nullable<Single>`在 C# 或`Nullable(Of Single)`Visual Basic 中。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來計算總和的值序列。</param>
        <param name="selector">要套用至每個項目的轉換函式。</param>
        <summary>計算在輸入序列中各項目上叫用轉換函式後所取得之 <see cref="T:System.Single" /> 值序列的總和。</summary>
        <returns>預計值的總合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>方法會傳回零，如果`source`包含任何項目。  
  
 您可以將這個方法套用至一連串的任意值，如果您提供函式， `selector`，，專案的成員`source`成數值類型，特別是<xref:System.Single>。  
  
 在 Visual Basic 查詢運算式語法中，`Aggregate Into Sum()`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Sum%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>加總的預計的值的序列。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="selector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Take(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的序列。</param>
        <param name="count">要傳回的項目數目。</param>
        <summary>從序列開頭傳回指定的連續項目數目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含輸入序列開頭處指定的項目數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.Take%2A> 列舉`source`產生項目，直到`count`項目已產生或`source`未包含多個項目。 如果`count`超過中的項目數`source`的所有項目`source`會傳回。  
  
 如果`count`小於或等於零，`source`不是列舉和空白<xref:System.Collections.Generic.IEnumerable%601>會傳回。  
  
 <xref:System.Linq.Enumerable.Take%2A>和<xref:System.Linq.Enumerable.Skip%2A>方法都是功能補充項目。 從指定的序列`coll`和一個整數`n`，串連的結果`coll.Take(n)`並`coll.Skip(n)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Take`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Take%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Take%2A>從序列開頭傳回項目。  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/77bf87b2-1476-4456-957f-fee922fbad8c">Take 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>只要指定的條件為 true，就會傳回序列中的項目，然後略過其餘項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的序列。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>只要指定的條件為 true，就會傳回序列中的項目。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 其中包含輸入序列中的項目，而這些項目出現在已無法通過測試的項目前面。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>方法會測試每個項目的`source`利用`predicate`，並產生項目，如果結果是`true`。 述詞函式傳回時，就會停止列舉`false`的項目或當`source`未包含多個項目。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>和<xref:System.Linq.Enumerable.SkipWhile%2A>方法都是功能補充項目。 從指定的序列`coll`和純虛擬函式`p`，串連的結果`coll.TakeWhile(p)`並`coll.SkipWhile(p)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Take While`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.TakeWhile%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>條件為 true 時，從序列開頭傳回項目。  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Take While 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">傳回項目的序列。</param>
        <param name="predicate">用來測試各來源項目是否符合條件的函式；此函式的第二個參數代表來源項目的索引。</param>
        <summary>只要指定的條件為 true，就會傳回序列中的項目。 項目的索引是用於述詞功能的邏輯中。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含輸入序列中的項目，而這些項目出現在已無法通過測試的項目前面。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>方法會測試每個項目的`source`利用`predicate`，並產生項目，如果結果是`true`。 述詞函式傳回時，就會停止列舉`false`的項目或當`source`未包含多個項目。  
  
 第一個引數`predicate`表示要測試的項目。 第二個引數所代表的項目內的以零起始的索引`source`。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A>和<xref:System.Linq.Enumerable.SkipWhile%2A>方法都是功能補充項目。 從指定的序列`coll`和純虛擬函式`p`，串連的結果`coll.TakeWhile(p)`並`coll.SkipWhile(p)`會產生相同的順序為`coll`。  
  
 在 Visual Basic 查詢運算式語法中，`Take While`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.TakeWhile%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>從序列開頭傳回項目，只要使用的項目索引的條件為 true。  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Take While 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依遞增順序，執行序列中項目的後續排序作業。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">包含要排序之項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <summary>依據索引鍵，按遞增順序執行序列中項目的後續排序作業。</summary>
        <returns>依據索引鍵排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> 並<xref:System.Linq.Enumerable.ThenByDescending%2A>定義為延伸類型<xref:System.Linq.IOrderedEnumerable%601>，這也是一種方法的傳回型別。 此設計可讓您藉由套用任意數目的指定多個排序準則<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>方法。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 這個方法會使用預設比較子來比較索引鍵<xref:System.Collections.Generic.Comparer%601.Default%2A>。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 在查詢運算式語法中， `orderby [first criterion], [second criterion]` (Visual C#) 或`Order By [first criterion], [second criterion]`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.ThenBy%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>執行次要排序序列中的項目。  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">orderby 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">包含要排序之項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
        <summary>使用指定的比較子，依遞增順序執行序列中項目的後續排序作業。</summary>
        <returns>依據索引鍵排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> 並<xref:System.Linq.Enumerable.ThenByDescending%2A>定義為延伸類型<xref:System.Linq.IOrderedEnumerable%601>，這也是一種方法的傳回型別。 此設計可讓您藉由套用任意數目的指定多個排序準則<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>方法。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 如果`comparer`已`null`，預設比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>用來比較索引鍵。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依遞減順序，執行序列中項目的後續排序作業。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">包含要排序之項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <summary>依據索引鍵，按遞減順序執行序列中項目的後續排序作業。</summary>
        <returns>依據索引鍵按遞減順序排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> 並<xref:System.Linq.Enumerable.ThenByDescending%2A>定義為延伸類型<xref:System.Linq.IOrderedEnumerable%601>，這也是一種方法的傳回型別。 此設計可讓您藉由套用任意數目的指定多個排序準則<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>方法。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 這個排序方法會使用預設比較子來比較索引鍵<xref:System.Collections.Generic.Comparer%601.Default%2A>。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
 在 Visual C# 查詢運算式語法中，`orderby [first criterion], [second criterion] descending`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.ThenByDescending%2A>。  
  
 在 Visual Basic 查詢運算式語法中，`Order By [first criterion], [second criterion] Descending`子句會轉譯成的引動過程<xref:System.Linq.Enumerable.ThenByDescending%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">orderby 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">包含要排序之項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IComparer`1" />。</param>
        <summary>使用指定的比較子，依遞減順序執行序列中項目的後續排序作業。</summary>
        <returns>依據索引鍵按遞減順序排序其項目的 <see cref="T:System.Linq.IOrderedEnumerable`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 若要排序序列的項目本身的值，指定識別函式 (`x => x` Visual C# 中或`Function(x) x`Visual Basic 中) 的`keySelector`。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> 並<xref:System.Linq.Enumerable.ThenByDescending%2A>定義為延伸類型<xref:System.Linq.IOrderedEnumerable%601>，這也是一種方法的傳回型別。 此設計可讓您藉由套用任意數目的指定多個排序準則<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>方法。  
  
> [!NOTE]
>  因為<xref:System.Linq.IOrderedEnumerable%601>繼承自<xref:System.Collections.Generic.IEnumerable%601>，您可以呼叫<xref:System.Linq.Enumerable.OrderBy%2A>或是<xref:System.Linq.Enumerable.OrderByDescending%2A>的呼叫結果<xref:System.Linq.Enumerable.OrderBy%2A>， <xref:System.Linq.Enumerable.OrderByDescending%2A>，<xref:System.Linq.Enumerable.ThenBy%2A>或<xref:System.Linq.Enumerable.ThenByDescending%2A>。 如此一來，引進了新的主要排序，會忽略先前建立的順序。  
  
 如果`comparer`已`null`，預設比較子<xref:System.Collections.Generic.Comparer%601.Default%2A>用來比較索引鍵。  
  
 這個方法會執行的穩定的排序;亦即，如果兩個項目的索引鍵相等，就會保留項目的順序。 相反地，不穩定的排序不會保留項目具有相同索引鍵的順序。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>執行次要排序序列中使用自訂比較子，依遞減順序中的項目。  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As IEnumerable(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.Enumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來建立陣列的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>從 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 建立陣列。</summary>
        <returns>陣列，其中包含輸入序列中的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法會強制立即查詢評估，並傳回陣列，其中包含查詢結果。 若要取得查詢結果的快取的複本，您可以將這個方法附加至您的查詢。  
  
 <xref:System.Linq.Enumerable.ToList%2A> 具有類似的行為，但傳回<xref:System.Collections.Generic.List%601>而不是陣列。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ToArray%2A>來強制立即查詢評估，並傳回結果的陣列。  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 建立 <see cref="T:System.Collections.Generic.Dictionary`2" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.Dictionary`2" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <summary>根據指定的索引鍵選擇器函式，從 <see cref="T:System.Collections.Generic.Dictionary`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>包含索引鍵和值的 <see cref="T:System.Collections.Generic.Dictionary`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>方法會使用預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>來比較索引鍵。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>來建立<xref:System.Collections.Generic.Dictionary%602>使用索引鍵選取器。  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="keySelector" /> 產生的索引鍵為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 產生兩個項目的重複索引鍵。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.Dictionary`2" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據指定的索引鍵選取器函式和索引鍵比較子，從 <see cref="T:System.Collections.Generic.Dictionary`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>包含索引鍵和值的 <see cref="T:System.Collections.Generic.Dictionary`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="keySelector" /> 產生的索引鍵為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 產生兩個項目的重複索引鍵。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <paramref name="elementSelector" /> 所傳回值的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.Dictionary`2" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="elementSelector">用來從每個項目產生結果項目值的轉換函式。</param>
        <summary>根據指定的索引鍵選取器和項目選取器函式，從 <see cref="T:System.Collections.Generic.Dictionary`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Dictionary`2" />，包含從輸入序列選取之 <paramref name="TElement" /> 類型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>方法會使用預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="keySelector" /> 產生的索引鍵為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 產生兩個項目的重複索引鍵。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <paramref name="elementSelector" /> 所傳回值的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.Dictionary`2" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="elementSelector">用來從每個項目產生結果項目值的轉換函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據指定的索引鍵選取器函式、比較子和項目選取器函式，從 <see cref="T:System.Collections.Generic.Dictionary`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Dictionary`2" />，包含從輸入序列選取之 <paramref name="TElement" /> 類型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="keySelector" /> 產生的索引鍵為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 產生兩個項目的重複索引鍵。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.HashSet`1" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <summary>從 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 建立 <see cref="T:System.Collections.Generic.HashSet`1" />。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" />，包含從輸入序列選取之 TSource 類型的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.HashSet`1" /> 的來源 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用 <paramref name="comparer" /> 從 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 建立 <see cref="T:System.Collections.Generic.HashSet`1" /> 以比較金鑰</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" />，包含從輸入序列選取之 <paramref name="TSource" /> 類型的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As IEnumerable(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : seq&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的來源 <see cref="T:System.Collections.Generic.List`1" />。</param>
        <summary>從 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 建立 <see cref="T:System.Collections.Generic.List`1" />。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" />，包含輸入序列中的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法會強制立即查詢評估，並傳回<xref:System.Collections.Generic.List%601>，其中包含查詢結果。 若要取得查詢結果的快取的複本，您可以將這個方法附加至您的查詢。  
  
 <xref:System.Linq.Enumerable.ToArray%2A> 具有類似的行為，但會傳回而不是陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ToList%2A>來強制立即查詢評估，並傳回<xref:System.Collections.Generic.List%601>，其中包含查詢結果。  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 <see cref="T:System.Linq.Lookup`2" /> 建立泛型 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的來源 <see cref="T:System.Linq.Lookup`2" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <summary>根據指定的索引鍵選擇器函式，從 <see cref="T:System.Linq.Lookup`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>包含索引鍵和值的 <see cref="T:System.Linq.Lookup`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>方法會傳回<xref:System.Linq.Lookup%602>，來從一對多字典，將索引鍵對應至值的集合。 A<xref:System.Linq.Lookup%602>不同於<xref:System.Collections.Generic.Dictionary%602>，會執行為單一值的索引鍵的一對一對應。  
  
 預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的來源 <see cref="T:System.Linq.Lookup`2" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據指定的索引鍵選取器函式和索引鍵比較子，從 <see cref="T:System.Linq.Lookup`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>包含索引鍵和值的 <see cref="T:System.Linq.Lookup`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>方法會傳回<xref:System.Linq.Lookup%602>，來從一對多字典，將索引鍵對應至值的集合。 A<xref:System.Linq.Lookup%602>不同<xref:System.Collections.Generic.Dictionary%602>，會執行為單一值的索引鍵的一對一對應。  
  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="keySelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <paramref name="elementSelector" /> 所傳回值的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的來源 <see cref="T:System.Linq.Lookup`2" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="elementSelector">用來從每個項目產生結果項目值的轉換函式。</param>
        <summary>根據指定的索引鍵選取器和項目選取器函式，從 <see cref="T:System.Linq.Lookup`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>
          <see cref="T:System.Linq.Lookup`2" />，包含從輸入序列選取之 <paramref name="TElement" /> 類型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>方法會傳回<xref:System.Linq.Lookup%602>，來從一對多字典，將索引鍵對應至值的集合。 A<xref:System.Linq.Lookup%602>不同於<xref:System.Collections.Generic.Dictionary%602>，會執行為單一值的索引鍵的一對一對應。  
  
 預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>來建立<xref:System.Linq.Lookup%602>使用索引鍵選取器函式和項目選取器函式。  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <typeparam name="TKey">
          <paramref name="keySelector" /> 所傳回之索引鍵的型別。</typeparam>
        <typeparam name="TElement">
          <paramref name="elementSelector" /> 所傳回值的型別。</typeparam>
        <param name="source">用來建立 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的來源 <see cref="T:System.Linq.Lookup`2" />。</param>
        <param name="keySelector">用來從各個項目擷取索引鍵的函式。</param>
        <param name="elementSelector">用來從每個項目產生結果項目值的轉換函式。</param>
        <param name="comparer">用來比較金鑰的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>根據指定的索引鍵選取器函式、比較子和項目選取器函式，從 <see cref="T:System.Linq.Lookup`2" /> 建立 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
        <returns>
          <see cref="T:System.Linq.Lookup`2" />，包含從輸入序列選取之 <paramref name="TElement" /> 類型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>方法會傳回<xref:System.Linq.Lookup%602>，來從一對多字典，將索引鍵對應至值的集合。 A<xref:System.Linq.Lookup%602>不同於<xref:System.Collections.Generic.Dictionary%602>，會執行為單一值的索引鍵的一對一對應。  
  
 如果`comparer`已`null`，預設相等比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>用來比較索引鍵。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" /> 或 <paramref name="elementSelector" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>產生兩個序列的集合等位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其獨特項目構成第一個等位集合。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其獨特項目構成第二個等位集合。</param>
        <summary>使用預設相等比較值來比較值，以便產生兩個序列的集合等位。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含來自兩個輸入序列的項目，但不包括重複的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 這個方法傳回集合中排除重複項目。 這是不同的行為，可<xref:System.Linq.Enumerable.Concat%2A>方法，以包括重複項目輸入序列中傳回的所有項目。  
  
 預設相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值的類型可實作<xref:System.Collections.Generic.IEqualityComparer%601>泛型介面。 若要比較的自訂資料類型，您需要實作這個介面，並提供您自己<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>類型的方法。  
  
 這個方法所傳回的物件列舉時，<xref:System.Linq.Enumerable.Union%2A>列舉`first`和`second`依此順序，並產生已產生每個項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>來取得整數的兩個序列的聯集。  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 如果您想要比較之物件的自訂資料類型的序列，您必須實作<xref:System.Collections.Generic.IEqualityComparer%601>helperclass 中的泛型介面。 下列程式碼範例示範如何實作這個介面中的自訂資料類型，並提供<xref:System.Object.GetHashCode%2A>和<xref:System.Object.Equals%2A>方法。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 您實作這個介面之後，您可以使用的序列`ProductA`中的物件<xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">輸入序列之項目的類型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其獨特項目構成第一個等位集合。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其獨特項目構成第二個等位集合。</param>
        <param name="comparer">用來比較值的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 產生兩個序列的集合等位。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含來自兩個輸入序列的項目，但不包括重複的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 如果`comparer`已`null`，預設的相等比較子， <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>，用來比較值。  
  
 這個方法所傳回的物件列舉時，<xref:System.Linq.Enumerable.Union%2A>列舉`first`和`second`依此順序，並產生已產生每個項目。  
  
 <xref:System.Linq.Enumerable.Concat%2A>方法不同於<xref:System.Linq.Enumerable.Union%2A>方法因為<xref:System.Linq.Enumerable.Concat%2A>方法會傳回包含重複項目，此輸入序列中的所有項目而<xref:System.Linq.Enumerable.Union%2A>傳回唯一值。  
  
   
  
## Examples  
 下列範例示範如何實作可用於相等比較子<xref:System.Linq.Enumerable.Union%2A>方法。  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 實作這個比較子之後，您可以使用連串`Product`中的物件<xref:System.Linq.Enumerable.Union%2A>方法，如下列範例所示。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據述詞來篩選值序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要篩選的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試每個項目是否符合條件的函式。</param>
        <summary>根據述詞來篩選值序列。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含輸入序列中符合條件的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 在查詢運算式語法中， `where` (Visual C#) 或`Where`(Visual Basic) 子句會轉譯成的引動過程<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>來篩選序列。  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7f9bf952-7744-4f91-b676-cddb55d107c3">where 子句 (C# 參考)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/48b5c2c5-3181-429c-8545-894296798c89">Where 子句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 項目的類型。</typeparam>
        <param name="source">要篩選的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</param>
        <param name="predicate">用來測試各來源項目是否符合條件的函式；此函式的第二個參數代表來源項目的索引。</param>
        <summary>根據述詞來篩選值序列。 述詞函式的邏輯中使用各項目的索引。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含輸入序列中符合條件的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 第一個引數`predicate`表示要測試的項目。 第二個引數所代表的項目內的以零起始的索引`source`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>來篩選序列，根據的述詞牽涉到每個項目的索引。  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As IEnumerable(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Zip(System::Collections::Generic::IEnumerable&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : seq&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">第一個輸入序列的項目型別。</typeparam>
        <typeparam name="TSecond">第二個輸入序列的項目型別。</typeparam>
        <typeparam name="TResult">結果序列的項目型別。</typeparam>
        <param name="first">要合併的第一個序列。</param>
        <param name="second">要合併的第二個序列。</param>
        <param name="resultSelector">指定如何從兩個序列合併項目的函式。</param>
        <summary>將指定的函式套用至兩個序列的對應項目，產生結果的序列。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含兩個輸入序列的合併項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法是使用延後的執行。 立即傳回值是儲存，才能執行此動作的所有資訊的物件。 這個方法所表示的查詢不會執行直到列舉物件可以藉由呼叫其`GetEnumerator`方法直接或透過`foreach`Visual C# 中或`For Each`Visual Basic 中。  
  
 方法會將合併的第一個序列的每個項目，與第二個序列中具有相同索引的項目。 如果序列沒有相同數目的項目，方法，直到它到達結尾的其中一個，就會合併序列。 例如，如果一個序列具有三個項目，另一個有四個結果序列必須只有三個項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Linq.Enumerable.Zip%2A>方法來合併兩個序列。  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> 或 <paramref name="second" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>