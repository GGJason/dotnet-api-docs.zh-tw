<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="698670494d510916b922e88a119093c8c15bf740" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36480111" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <TypeSignature Language="F#" Value="type SessionSecurityTokenHandler = class&#xA;    inherit SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>處理型別為 <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> 之安全性權杖的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>類別序列化、 還原序列化，以及驗證工作階段權杖。 工作階段權杖是型別的權杖<xref:System.IdentityModel.Tokens.SessionSecurityToken>。 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>類別序列化的權杖與 cookie 格式。 根據預設，此類別序列化權杖 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。 工作階段權杖由<xref:System.IdentityModel.Services.WSFederationAuthenticationModule>(WSFAM) 和<xref:System.IdentityModel.Services.SessionAuthenticationModule>(SAM) 來儲存資訊的工作階段中，這是主要<xref:System.Security.Claims.ClaimsPrincipal>與已驗證的使用者和工作階段開始和到期時間相關聯。  
  
 在被動的情況下，<xref:System.IdentityModel.Services.WSFederationAuthenticationModule>會呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule>(SAM) 從驗證管線，以建立從工作階段權杖<xref:System.Security.Claims.ClaimsPrincipal>，代表已驗證的使用者。 SAM 會使用其設定<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>才能建立語彙基元，並將它序列化為 cookie （和還原序列化的權杖上的後續要求的 cookie）。 SAM 會使用其設定的執行個體<xref:System.IdentityModel.Services.CookieHandler>寫回至 HTTP 回應 cookie 的類別。 此 cookie 則傳回至用戶端，並在後續要求的 cookie，而不是反覆存取進行重新取得安全性權杖的身分識別提供者，可以呈現用戶端。 如需有關如何使用 WIF 工作階段的運作方式的詳細資訊，請參閱 < [WIF 工作階段管理](~/docs/framework/security/wif-session-management.md)。  
  
> [!NOTE]
>  \<SecurityTokenHandlers > 組態項目可用來指定<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>可保護應用程式的工作階段的責任。 開發人員時應謹慎小心變更此設定，因為設定不正確的系統可能會導致應用程式遭到入侵。 例如，指定 衍生的超連結"http://msdn.microsoft.com/library/hh193426%28v=vs.110%29.aspx"\t"_blank"<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>和基底，傳遞空的 (CookieTransform) 的轉換集合時，會導致將序列化為未受保護的 cookie 的使用者身分識別。 這可能會允許攻擊者修改身分識別，並因此變更存取權限。  
  
 如果工作階段權杖是在參考模式中，也就是其<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`true`、 工作階段權杖處理常式只會序列化的工作階段權杖來重新產生其金鑰時所需的屬性<xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>。 在預設案例中，<xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey>類別用來表示快取索引鍵，並寫入的權杖處理常式<xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType>和<xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType>語彙基元的屬性。 如果工作階段權杖是不是處於參考模式，也就是<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`false`，然後除了先前所述的屬性，處理常式會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法語彙基元，並將序列化為位元組陣列cookie 也中產生的值。 如需進一步瞭解如何序列化此語彙基元的詳細資訊，請參閱<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性會取得清單的轉換套用至工作階段權杖<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法。 所有的轉換是衍生自<xref:System.IdentityModel.CookieTransform>類別。 在預設情況下<xref:System.IdentityModel.DeflateCookieTransform>而<xref:System.IdentityModel.ProtectedDataCookieTransform>會套用。 <xref:System.IdentityModel.ProtectedDataCookieTransform>使用資料保護 API (DPAPI) 來保護 cookie 資料。 DPAPI 會使用的電腦執行其保護演算法中的特定索引鍵。 基於這個理由，預設工作階段權杖處理常式不是可在 Web 伺服陣列案例中使用，因為在此情況下，一部電腦上寫入的權杖可能需要在另一部電腦上讀取。 若要避免這個問題，您可以使用許多策略。 例如，您可以：  
  
-   取代預設<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>與<xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>。 <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>可讓您指定簽署和加密金鑰，在 ASP.NET 之下`<machineKey>`組態檔中的項目。  
  
-   提供的處理常式<xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType>global.asax.cs 檔案和取代預設的工作階段中的事件語彙基元處理常式的執行個體<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>具有包含一份轉換<xref:System.IdentityModel.RsaSignatureCookieTransform>而<xref:System.IdentityModel.RsaEncryptionCookieTransform>。 您可以藉由叫用的建構函式可接受的轉換清單的其中一個來建立新的執行個體。  
  
-   衍生自訂的轉換，從<xref:System.IdentityModel.CookieTransform>基底類別，並使用上述的方法，把它納入要套用的轉換清單。  
  
-   衍生的自訂權杖處理常式從<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>並實作您自己的機制。  
  
 如需在 Web 伺服陣列案例中使用工作階段的詳細資訊，請參閱[WIF 和 Web 伺服陣列](~/docs/framework/security/wif-and-web-farms.md)。  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>包含在預設語彙基元處理常式集合中; 不過，您可以自訂工作階段權杖處理常式來取代第一個指定[&lt;移除&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md)項目底下[ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md)若要移除集合，然後再新增 [您的自訂權杖處理常式使用的預設處理常式的項目[&lt;新增&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md)項目。 根據預設，您可以指定預設權杖存留期包括[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)項目底下`<add>`項目。 您可以設計自訂的權杖處理常式來採取自訂組態項目底下`<add>`藉由覆寫的項目<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A>方法，以提供邏輯以處理它們。  
  
   
  
## Examples  
 下列 XML 會說明如何以取代預設工作階段安全性權杖處理常式的權杖處理常式集合中的執行個體<xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>組態中的類別。  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 類別的新執行個體，這個執行個體使用預設 cookie 轉換和權杖存留期。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>並<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性會初始化為<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler transforms" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">編碼或解碼 cookie 時要套用的轉換。 設定 <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> 屬性。</param>
        <summary>初始化 <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 類別的新執行個體，這個執行個體使用指定的 Cookie 轉換。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> 屬性會初始化為 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; * TimeSpan -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler (transforms, tokenLifetime)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">編碼或解碼 cookie 時要套用的轉換。 設定 <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> 屬性。</param>
        <param name="tokenLifetime">預設權杖存留期。 設定 <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" /> 屬性。</param>
        <summary>初始化 <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 類別的新執行個體，這個執行個體使用指定的 cookie 轉換和權杖存留期。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="tokenLifetime" /> 小於或等於 <see cref="F:System.TimeSpan.Zero" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberSignature Language="F#" Value="abstract member ApplyTransforms : byte[] * bool -&gt; byte[]&#xA;override this.ApplyTransforms : byte[] * bool -&gt; byte[]" Usage="sessionSecurityTokenHandler.ApplyTransforms (cookie, outbound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">將轉換的 Cookie。</param>
        <param name="outbound">如果 cookie 應該要編碼，則為 <see langword="true" />，如果 cookie 應該要解碼，則為 <see langword="false" />。</param>
        <summary>套用 <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> 屬性所指定的轉換，對指定的 Cookie 進行編碼或解碼。</summary>
        <returns>編碼或解碼的 cookie。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 cookie 的編碼方式轉換中的出現順序套用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性。 在解碼 cookie，它們會套用的相反順序。  
  
 從呼叫<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>來編碼和解碼 cookie 資料的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> 屬性為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="sessionSecurityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">連入之 <see cref="T:System.Xml.XmlReader" /> 上的 <see cref="T:System.IdentityModel.Tokens.SecurityToken" />。 讀取器應位於 <see langword="&lt;wsc:SecurityContextToken&gt;" /> 項目上。</param>
        <summary>傳回值，指出讀取器是否位在 <see langword="&lt;wsc:SecurityContextToken&gt;" /> 項目。</summary>
        <returns>如果讀取器指向 <see langword="true" />，則為 <see langword="&lt;wsc:SecurityContextToken&gt;" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個處理常式是否支援驗證 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 型別的權杖。</summary>
        <value>如果這個處理常式支援型別為 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的權杖的驗證，則為 <see langword="true" />，否則為 <see langword="false" />。 一定是 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個處理常式是否可寫入 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 型別的權杖。</summary>
        <value>如果這個處理常式可以撰寫型別為 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的權杖，則為 <see langword="true" />，否則為 <see langword="false" />。 一定是 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieElementName : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 Cookie 項目的名稱。</summary>
        <value>Cookie 項目的名稱。 預設項目名稱為"Cookie"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性用於<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>方法，以決定在其下的已編碼的語彙基元資料應寫入或讀取的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieNamespace : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 Cookie 項目的命名空間。</summary>
        <value>Cookie 項目的命名空間。 預設命名空間是 「http://schemas.microsoft.com/ws/2006/05/security"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性用於<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>方法，以決定在其下的已編碼的語彙基元資料應寫入或讀取之項目的命名空間。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="F#" Value="abstract member CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken&#xA;override this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionSecurityTokenHandler.CreateSessionSecurityToken (principal, context, endpointId, validFrom, validTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">宣告主體。</param>
        <param name="context">呼叫端定義的內容字串。</param>
        <param name="endpointId">語彙基元的範圍結束點的識別項。</param>
        <param name="validFrom">瞬間，到此瞬間權杖即變成有效。</param>
        <param name="validTo">瞬間，超過此瞬間之後權杖不再有效。</param>
        <summary>根據指定的宣告主體與權杖的有效時間範圍，建立 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>已建立的工作階段安全性權杖。 新工作階段權杖上的屬性是根據指定的參數所設定。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> 屬性為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">權杖描述元，要從其中建立權杖。</param>
        <summary>以指定的權杖描述元為基礎建立安全性權杖。</summary>
        <returns>已建立的安全性權杖。 這將會是 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立並傳回工作階段安全性權杖的權杖描述元中使用下列屬性： <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>，和<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType>。 如果<xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType>屬性會設定`true`上所指定的權杖處理常式組態<xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>屬性，啟動程序的內容從建立<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType>屬性並儲存在工作階段權杖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tokenDescriptor" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> 屬性為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultCookieTransforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>唯讀集合，包含套用至 Cookie 的預設轉換清單：<see cref="T:System.IdentityModel.DeflateCookieTransform" /> 和 <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>為 Cookie 指定預設存留期的常數 (十小時)。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTokenLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得預設權杖存留期。</summary>
        <value>預設權杖存留期。 一定是 <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="override this.GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="sessionSecurityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得此處理常式可處理的語彙基元型別的語彙基元型別 URI。</summary>
        <returns>可由這個處理常式處理的權杖型別的權杖型別識別項 URI。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援下列類型的 Uri:"http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation"，"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct"，和 「http://schemas.xmlsoap.org/ws/2005/02/sc/sct"。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberSignature Language="F#" Value="override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="sessionSecurityTokenHandler.LoadCustomConfiguration customConfigElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">自訂組態項目。</param>
        <summary>從 XML 載入自訂組態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定基礎結構呼叫來初始化<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>執行個體。 初始化<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>屬性從`lifetime`屬性[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)組態檔中的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customConfigElements" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="customConfigElements" /> 指定的組態無效。 例如，它不包含 <see langword="&lt;sessionTokenRequirement&gt;" /> 項目，它包含一個以上的 <see langword="&lt;sessionTokenRequirement&gt;" /> 項目，不能從 <see langword="lifetime" /> 屬性讀取有效的 <see cref="T:System.TimeSpan" /> 值，或 <see langword="lifetime" /> 屬性指定了小於 <see cref="F:System.TimeSpan.Zero" /> 的值。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會還原序列化的權杖從 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">連入之 <see cref="T:System.Xml.XmlReader" /> 上的 <see cref="T:System.IdentityModel.Tokens.SecurityToken" />。</param>
        <summary>使用指定的 XML 讀取器讀取 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>已讀取的工作階段安全性權杖，這是 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取器必須位於 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 預設實作會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType>使用預設的語彙基元解析程式的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">讀取器未放置在<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />，或<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />無法讀取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : byte[] * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (token, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">包含權杖的位元組資料流。</param>
        <param name="tokenResolver">要使用的權杖解析程式。</param>
        <summary>使用指定的語彙基元解析程式從位元組資料流讀取<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>已讀取的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會建立<xref:System.Xml.XmlDictionaryReader>透過語彙基元，並叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">連入之 <see cref="T:System.Xml.XmlReader" /> 上的 <see cref="T:System.IdentityModel.Tokens.SecurityToken" />。</param>
        <param name="tokenResolver">可用來解析 <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> 的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</param>
        <summary>使用指定的 XML 讀取器和權杖解析程式，讀取 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>已讀取的工作階段安全性權杖，這是 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取器必須位於 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 如果快取的權杖內容時，它會在從權杖的快取，也就是執行個體讀取的<xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>類別。 權杖的內容，否則為讀取的子項目`<wsc:SecurityContextToken>`所指定的項目<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A>並<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A>屬性和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法會叫用來解碼的 cookie。  
  
 如需有關如何將工作階段權杖序列化為`<SecurityContextToken`項目，請參閱<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="tokenResolver" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">讀取器未放置在<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />，或<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />無法讀取。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="member this.SetTransforms : seq&lt;System.IdentityModel.CookieTransform&gt; -&gt; unit" Usage="sessionSecurityTokenHandler.SetTransforms transforms" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">要使用的轉換。</param>
        <summary>設定會套用至 Cookie 的轉換。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定轉換所傳回的清單<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性。 轉換將會以其出現在清單中，編碼 cookie 時，並以反向順序解碼 cookie 時的順序套用。  
  
> [!WARNING]
>  如果`transforms`參數是`null`，將會擲回例外狀況，從<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法呼叫來編碼或解碼 cookie 時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TokenLifetime : TimeSpan with get, set" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定語彙基元存留期。</summary>
        <value>權杖存留期。 預設值為 <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，如果[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)組態檔中，指定元素<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>屬性會初始化為值`lifetime`屬性<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生設定小於或等於零之時間範圍的嘗試。</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理常式處理的權杖類型。</summary>
        <value>
          <see cref="T:System.Type" /> 的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得會套用至 Cookie 的轉換。</summary>
        <value>會套用至 Cookie 的轉換的清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 到底端套用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberSignature Language="F#" Value="abstract member ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.ValidateSession securityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">要檢查的權杖。</param>
        <summary>判斷與指定之權杖相關聯的工作階段是否仍然有效。 藉由檢查指定的權杖的 <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> 和 <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> 屬性，即可判斷有效性。 如果工作階段已不再有效，則擲回例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 無效的語彙基元，如果其<xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A>屬性設定為值，稍後就會發生比<xref:System.DateTime.UtcNow%2A>，或如果其<xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A>屬性設定為值，就會發生早於<xref:System.DateTime.UtcNow%2A>。  
  
 從呼叫<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A>方法來驗證工作階段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityToken" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> 屬性為 <see langword="null" />。</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">此權杖的<see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" />屬性晚於<see cref="P:System.DateTime.UtcNow" />。</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">此權杖的 <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> 屬性早於 <see cref="P:System.DateTime.UtcNow" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>驗證權杖，並傳回其宣告。</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">要驗證的語彙基元。 必須從 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 指派。</param>
        <summary>驗證指定的語彙基元，並傳回其宣告。</summary>
        <returns>包含在語彙基元中的識別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A>來驗證權杖的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" />
          <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> 無法從 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 指定。</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SessionSecurityToken * string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken (token, endpointId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">要驗證的語彙基元。 必須從 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 指派。</param>
        <param name="endpointId">語彙基元的範圍結束點的識別項。</param>
        <summary>驗證指定的工作階段權杖並傳回其宣告。</summary>
        <returns>包含在語彙基元中的識別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行檢查，以確定指定的語彙基元的範圍設定為指定的端點識別碼，而且，如果是的話，會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法; 否則會擲回<xref:System.IdentityModel.Tokens.SecurityTokenException>。  
  
> [!IMPORTANT]
>  有的工作階段權杖<xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A>屬於屬性`null`或全域範圍的範圍會被視為空白。 這代表潛在的安全性風險。 因此您應該確定<xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A>屬性會設定您的工作階段權杖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="endpointId" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> 無法從 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 指定。</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">指定之權杖的 <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /> 屬性不是 <see langword="null" /> 或空的，而且其值與 <paramref name="endpointId" /> 參數指定的值不同。</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將語彙基元序列化。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會將權杖序列化至 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; byte[]" Usage="sessionSecurityTokenHandler.WriteToken sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">要寫入的權杖。</param>
        <summary>將指定的語彙基元序列化至位元組陣列。</summary>
        <returns>編碼的位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立和 XML 寫入器序列化指定的權杖，透過<xref:System.IO.MemoryStream>，並叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。 該多載，如需詳細資訊，請參閱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessiontoken" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">XML 寫入器，用來序列化權杖。</param>
        <param name="token">要序列化的權杖。 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的執行個體。</param>
        <summary>使用指定的 XML 寫入器，序列化指定的語彙基元。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會將指定的權杖序列化為 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目，根據的值<xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType>屬性。 <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType>屬性會序列化為`Id`屬性。 <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType>屬性會序列化為`<Identifier>`子項目。 如果沒有`null`<xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType>屬性會序列化為`<Instance>`項目。 最後，如果<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`false`，將整個語彙基元序列化成二進位陣列傳遞至<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>要編碼的方法。 已編碼語彙基元接著會寫入為 base64 編碼值的項目和所指定的命名空間<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A>屬性。 如果<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`true`，則不會序列化此語彙基元。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="token" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> 無法從 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 指定。  
  
-或- 
權杖的 <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> 會指定處理常式不支援的 WS-Secure Conversation 版本。</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>