<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="698670494d510916b922e88a119093c8c15bf740" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36480111" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <TypeSignature Language="F#" Value="type SessionSecurityTokenHandler = class&#xA;    inherit SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>A <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> that processes security tokens of type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>類別序列化、 還原序列化，並驗證工作階段權杖。 工作階段權杖是權杖的型別<xref:System.IdentityModel.Tokens.SessionSecurityToken>。 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>類別會序列化的權杖與 cookie 格式。 根據預設，此類別序列化語彙基元 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。 工作階段權杖由<xref:System.IdentityModel.Services.WSFederationAuthenticationModule>(WSFAM) 和<xref:System.IdentityModel.Services.SessionAuthenticationModule>(SAM) 來儲存資訊的工作階段中，這主要是<xref:System.Security.Claims.ClaimsPrincipal>與已驗證的使用者和工作階段的開始日和到期時間相關聯。  
  
 在被動的情況下，<xref:System.IdentityModel.Services.WSFederationAuthenticationModule>呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule>(SAM) 從要建立從工作階段權杖驗證管線<xref:System.Security.Claims.ClaimsPrincipal>，代表已驗證的使用者。 SAM 會使用其設定<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>才能建立語彙基元並將它序列化成 cookie （和還原序列化的後續要求的 cookie 語彙基元）。 SAM 會使用其設定的執行個體<xref:System.IdentityModel.Services.CookieHandler>類別來寫入 HTTP 回應傳回的 cookie。 此 cookie 則傳回給用戶端，並在後續要求 cookie，而不是反覆存取進行重新取得安全性權杖的身分識別提供者，可以呈現用戶端。 如需有關如何使用 WIF 工作階段的運作方式的詳細資訊，請參閱[WIF 工作階段管理](~/docs/framework/security/wif-session-management.md)。  
  
> [!NOTE]
>  \<SecurityTokenHandlers > 組態項目可以用來指定<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>有責任保護應用程式的工作階段。 開發人員時應謹慎小心變更此組態設定，因為設定不正確的系統可能會導致應用程式的洩露。 例如，指定 衍生的超連結"http://msdn.microsoft.com/library/hh193426%28v=vs.110%29.aspx"\t"_blank"<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>和傳遞空轉換 (CookieTransform) 集合的基底，會導致將序列化為未受保護的 cookie 的使用者身分識別。 這可能會允許攻擊者修改的身分識別，因此會變更存取權限。  
  
 如果工作階段權杖是以參考模式，也就是其<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`true`，權杖處理常式只會序列化內容的工作階段權杖需要重新產生其金鑰中的工作階段<xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>。 在預設情況下，<xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey>類別用來代表快取索引鍵，且權杖處理常式寫入<xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType>和<xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType>語彙基元的屬性。 如果工作階段權杖是不能在參考的模式，也就是<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`false`，接著，除了先前所述的屬性，此處理常式會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>上序列化所來自的語彙基元和存放區的位元組陣列的方法cookie 也中產生的值。 如需有關如何序列化權杖的詳細資訊，請參閱<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性會取得套用到工作階段的轉換清單中的語彙基元<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法。 所有的轉換是衍生自<xref:System.IdentityModel.CookieTransform>類別。 在預設案例中<xref:System.IdentityModel.DeflateCookieTransform>和<xref:System.IdentityModel.ProtectedDataCookieTransform>會套用。 <xref:System.IdentityModel.ProtectedDataCookieTransform>使用資料保護 API (DPAPI) 來保護 cookie 資料。 DPAPI 會使用特定電腦上執行其保護演算法的金鑰。 基於這個理由，預設工作階段權杖處理常式不可以在 Web 伺服陣列案例因為在這種情況下，一部電腦上寫入的語彙基元可能需要另一部電腦上讀取。 如果要避免這個問題，您可以使用許多策略。 例如，您可以：  
  
-   取代預設<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>與<xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>。 <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>可讓您指定簽章和加密金鑰，在 ASP.NET`<machineKey>`組態檔中的項目。  
  
-   提供的處理常式<xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType>global.asax.cs 檔案和取代預設工作階段中的事件語彙基元處理常式的執行個體和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>轉換清單包含具有<xref:System.IdentityModel.RsaSignatureCookieTransform>和<xref:System.IdentityModel.RsaEncryptionCookieTransform>。 您可以叫用的建構函式會採用的轉換清單的其中一個來建立新的執行個體。  
  
-   衍生的自訂轉換從<xref:System.IdentityModel.CookieTransform>基底類別，並使用上述方法，將它包含在套用轉換清單。  
  
-   衍生的自訂語彙基元處理常式從<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>並實作您自己的機制。  
  
 如需在 Web 伺服陣列案例中使用工作階段的詳細資訊，請參閱[WIF 和 Web 伺服陣列](~/docs/framework/security/wif-and-web-farms.md)。  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>隨附於預設權杖處理常式集合中; 不過，您可以自訂工作階段權杖處理常式取代藉由先指定[&lt;移除&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md)項目底下[ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md)項目移除集合，然後將加入您的自訂權杖處理常式使用的預設處理常式[&lt;新增&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md)項目。 根據預設，您可以指定預設權杖存留期包括[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)項目底下`<add>`項目。 您可以設計自訂的語彙基元處理常式才會在自訂組態項目`<add>`藉由覆寫的項目<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A>方法，以提供邏輯以處理它們。  
  
   
  
## Examples  
 下列 XML 會說明如何以取代預設工作階段安全性權杖處理常式權杖處理常式集合中的執行個體<xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>組態中的類別。  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> class that uses the default cookie transforms and token lifetime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性會初始化為<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler transforms" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">The transforms to apply when encoding or decoding the cookie. Sets the <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> property.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> class that uses the specified cookie transforms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> 屬性會初始化為 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; * TimeSpan -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler (transforms, tokenLifetime)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">The transforms to apply when encoding or decoding the cookie. Sets the <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> property.</param>
        <param name="tokenLifetime">The default lifetime for a token. Sets the <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" /> property.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> class that uses the specified cookie transforms and token lifetime.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="tokenLifetime" /> is less than or equal to <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberSignature Language="F#" Value="abstract member ApplyTransforms : byte[] * bool -&gt; byte[]&#xA;override this.ApplyTransforms : byte[] * bool -&gt; byte[]" Usage="sessionSecurityTokenHandler.ApplyTransforms (cookie, outbound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">The cookie that will be transformed.</param>
        <param name="outbound">
          <see langword="true" /> if the cookie should be encoded; <see langword="false" /> if the cookie should be decoded.</param>
        <summary>Applies the transforms specified by the <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> property to either encode or decode the specified cookie.</summary>
        <returns>The encoded or decoded cookie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 cookie 的編碼方式轉換中的出現順序套用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性。 當解碼 cookie，它們會套用順序相反。  
  
 從呼叫<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>方法來編碼和解碼 cookie 資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> property is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="sessionSecurityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> over the incoming <see cref="T:System.IdentityModel.Tokens.SecurityToken" />. The reader should be positioned at a <see langword="&lt;wsc:SecurityContextToken&gt;" /> element.</param>
        <summary>Returns a value that indicates whether the reader is positioned at a <see langword="&lt;wsc:SecurityContextToken&gt;" /> element.</summary>
        <returns>
          <see langword="true" /> if the reader points to a <see langword="&lt;wsc:SecurityContextToken&gt;" /> element; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this handler supports validation of tokens of type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> 如果處理常式支援驗證類型的權杖<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />，否則<see langword="false" />。 一定是 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this handler can write tokens of type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> 如果此處理常式可以寫入類型的權杖<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />，否則<see langword="false" />。 一定是 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieElementName : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name for the cookie element.</summary>
        <value>Cookie 元素的名稱。 預設項目名稱是"Cookie"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性用在<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>方法來判斷的編碼語彙基元資料應該寫入或讀取的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieNamespace : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the namespace for the cookie element.</summary>
        <value>Cookie 元素的命名空間。 預設命名空間是"http://schemas.microsoft.com/ws/2006/05/security"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性用在<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A>方法來判斷的編碼語彙基元資料應該寫入或讀取的項目的命名空間。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="F#" Value="abstract member CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken&#xA;override this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionSecurityTokenHandler.CreateSessionSecurityToken (principal, context, endpointId, validFrom, validTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">The claims principal.</param>
        <param name="context">A caller-defined context string.</param>
        <param name="endpointId">The identifier of the endpoint to which the token is scoped.</param>
        <param name="validFrom">The time instant at which the token becomes valid.</param>
        <param name="validTo">The time instant after which the token is no longer valid.</param>
        <summary>Creates a <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> based on the specified claims principal and time range during which the token is valid.</summary>
        <returns>The session security token that was created. The properties on the new session token are set according to the specified parameters.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> property is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">The token descriptor from which to create the token.</param>
        <summary>Creates a security token based on the specified token descriptor.</summary>
        <returns>The security token that was created. This will be an instance of <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立並傳回工作階段安全性權杖，權杖的描述元中使用下列屬性： <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>，和<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType>。 如果<xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType>屬性設定`true`上所指定的語彙基元處理常式組態<xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>屬性，啟動程序的內容從建立<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType>屬性並儲存在工作階段權杖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tokenDescriptor" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> property is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultCookieTransforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A read only collection that contains the list of default transforms to be applied to cookies, the <see cref="T:System.IdentityModel.DeflateCookieTransform" /> and the <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A constant that specifies the default lifetime for cookies, ten hours.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTokenLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default token lifetime.</summary>
        <value>預設權杖存留期。 一定是 <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="override this.GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="sessionSecurityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the token type URIs for the token types that can be processed by this handler.</summary>
        <returns>The token type identifier URIs for token types that can be processed by this handler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援下列類型的 Uri:"http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation"，"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct」，和 「http://schemas.xmlsoap.org/ws/2005/02/sc/sct"。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberSignature Language="F#" Value="override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="sessionSecurityTokenHandler.LoadCustomConfiguration customConfigElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">The custom configuration elements.</param>
        <summary>Loads custom configuration from XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定基礎結構，來初始化呼叫<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>執行個體。 初始化<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>屬性從`lifetime`屬性[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)組態檔中的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customConfigElements" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The configuration specified by <paramref name="customConfigElements" /> is not valid. For example, it does not contain a <see langword="&lt;sessionTokenRequirement&gt;" /> element, it contains more than one <see langword="&lt;sessionTokenRequirement&gt;" /> element, a valid <see cref="T:System.TimeSpan" /> value cannot be read from the <see langword="lifetime" /> attribute, or the <see langword="lifetime" /> attribute specifies a value that is less than <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads a <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會還原序列化的語彙基元從 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> over the incoming <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</param>
        <summary>Reads the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> using the specified XML reader.</summary>
        <returns>The session security token that was read, an instance of <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取器必須定位在 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 預設實作會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType>方法使用預設的語彙基元解析程式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">The reader is not positioned at a <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> or the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> cannot be read.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : byte[] * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (token, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">The stream of bytes that contains the token.</param>
        <param name="tokenResolver">The token resolver to use.</param>
        <summary>Reads the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> from a stream of bytes by using the specified token resolver.</summary>
        <returns>The <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> that was read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會建立<xref:System.Xml.XmlDictionaryReader>透過語彙基元，並叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> over the incoming <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</param>
        <param name="tokenResolver">A <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> that can used to resolve the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Reads the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> using the specified XML reader and token resolver.</summary>
        <returns>The session security token that was read, an instance of <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取器必須定位在 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 如果快取權杖的內容時，它會讀取從權杖快取，也就是執行個體的<xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>類別。 否則，語彙基元資料讀取的子項目`<wsc:SecurityContextToken>`所指定的項目<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A>屬性和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>解碼 cookie 會叫用方法。  
  
 如需有關如何將工作階段權杖序列化成`<SecurityContextToken`項目，請參閱<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> is <see langword="null" />.  -or-  <paramref name="tokenResolver" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">The reader is not positioned at a <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> or the <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> cannot be read.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="member this.SetTransforms : seq&lt;System.IdentityModel.CookieTransform&gt; -&gt; unit" Usage="sessionSecurityTokenHandler.SetTransforms transforms" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">The transforms to use.</param>
        <summary>Sets the transforms that will be applied to cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定轉換所傳回的清單<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A>屬性。 將以它們出現在清單中，編碼 cookie 時，並以反向順序解碼 cookie 時的順序套用轉換。  
  
> [!WARNING]
>  如果`transforms`參數是`null`，將會擲回例外狀況，從<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法呼叫來編碼或解碼 cookie 時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TokenLifetime : TimeSpan with get, set" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the token lifetime.</summary>
        <value>權杖存留期。 預設值為 <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，如果[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)組態檔中，指定元素<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>屬性會初始化為值的`lifetime`屬性<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An attempt to set a time span that is less than or equal to zero occurs.</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the tokens that this handler processes.</summary>
        <value>
          <see cref="T:System.Type" /> 的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the transforms that will be applied to the cookie.</summary>
        <value>將 cookie 要套用的轉換清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 到底端套用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberSignature Language="F#" Value="abstract member ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.ValidateSession securityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">The token to be checked.</param>
        <summary>Determines whether the session associated with the specified token is still valid. Validity is determined by checking the <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> and <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> properties of the specified token. An exception is thrown if the session is no longer valid.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此權杖不是有效如果其<xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A>屬性設定為更晚出現的值比<xref:System.DateTime.UtcNow%2A>，或如果其<xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A>屬性設定為，就會發生值早於<xref:System.DateTime.UtcNow%2A>。  
  
 從呼叫<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A>方法來驗證工作階段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityToken" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> property is <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">The <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> property of the token is later than <see cref="P:System.DateTime.UtcNow" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">The <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> property of the token is earlier than <see cref="P:System.DateTime.UtcNow" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Validates a token and returns its claims.</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">The token to be validated. Must be assignable from <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Validates the specified token and returns its claims.</summary>
        <returns>The identities that are contained in the token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A>方法以驗證語彙基元。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" />
          <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> is not assignable from <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SessionSecurityToken * string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken (token, endpointId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">The token to be validated. Must be assignable from <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <param name="endpointId">The identifier of the endpoint to which the token is scoped.</param>
        <summary>Validates the specified session token and returns its claims.</summary>
        <returns>The identities that are contained in the token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行檢查，以確定指定的語彙基元的範圍設定為指定的端點識別碼，而且，如果是的話，會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法; 否則會擲回<xref:System.IdentityModel.Tokens.SecurityTokenException>。  
  
> [!IMPORTANT]
>  工作階段的 token<xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A>屬性`null`或全域範圍的範圍會被視為空白。 這代表潛在安全性風險。 因此您應該確定<xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A>屬性設定工作階段權杖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> is <see langword="null" />.  -or-  <paramref name="endpointId" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> is not assignable from <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">The <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /> property of the specified token is not <see langword="null" /> or empty and its value is different than that specified by the <paramref name="endpointId" /> parameter.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializes a token.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會將權杖序列化至 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; byte[]" Usage="sessionSecurityTokenHandler.WriteToken sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">The token to write.</param>
        <summary>Serializes the specified token into a byte array.</summary>
        <returns>An encoded byte array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立和 XML 寫入器序列化指定的語彙基元，透過<xref:System.IO.MemoryStream>及叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType>方法。 該多載，如需詳細資訊，請參閱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessiontoken" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">The XML writer with which to serialize the token.</param>
        <param name="token">The token to serialize. An instance of <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Serializes the specified token by using the specified XML writer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會序列化指定的語彙基元為 Ws-secure Conversation Feb2005 或 Ws-secure Conversation 1.3`<wsc:SecurityContextToken>`項目，根據的值<xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType>屬性。 <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType>屬性序列化為`Id`屬性。 <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType>屬性序列化為`<Identifier>`子項目。 如果沒有`null`<xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType>屬性序列化為`<Instance>`項目。 最後，如果<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`false`，將整個語彙基元序列化成二進位陣列傳遞給<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A>要編碼的方法。 已編碼的語彙基元接著會寫入做為 base64 編碼值的項目與所指定的命名空間<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A>和<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A>屬性。 如果<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>屬性是`true`，則不會序列化語彙基元。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> is <see langword="null" />.  -or-  <paramref name="token" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> is not assignable from <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.  -or-  The <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> of the token specifies a version of WS-Secure Conversation that is not supported by the handler.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>