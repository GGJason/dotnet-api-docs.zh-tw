<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d18e0d0b21e593733c17a8ad1b69a3fc64a6cfda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30481392" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在執行階段提供特定文化特性資源存取權限的資源管理員。  
  
 **安全性提示**：使用不受信任的資料呼叫這個類別中的方法會造成安全性風險。 只能使用信任的資料呼叫類別中的方法。 如需詳細資訊，請參閱 [Untrusted Data Security Risks](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks) (不受信任的資料安全性風險)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager>類別會從二進位.resources 檔內嵌於組件，或從獨立.resources 檔擷取資源。 如果應用程式已經被當地語系化，而且已經在部署的當地語系化的資源[附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)，它會查看特定文化特性的資源、 資源後援時提供當地語系化的資源不存在，以及支援資源序列化。  
  
 如需有關建立和管理桌面應用程式中的資源和[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請參閱下列各節：  
  
-   [桌面應用程式](#desktop)  
  
    -   [建立資源](#creating_resources)  
  
    -   [具現化 ResourceManager 物件](#instantiating)  
  
    -   [ResourceManager 和特定文化特性的資源](#CultureSpecific)  
  
    -   [擷取資源](#retrieving)  
  
    -   [MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況處理](#exception)  
  
    -   [資源的版本管理](#versioning)  
  
    -   [\<s > 設定檔 節點](#config)  
  
-   [Windows 市集應用程式](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>桌面應用程式  
 針對桌面應用程式，<xref:System.Resources.ResourceManager>類別會從二進位資源 (.resources) 檔擷取資源。 一般而言，語言編譯器或[組件連結器 (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md)這些資源檔嵌入組件。 您也可以使用<xref:System.Resources.ResourceManager>物件直接從沒有內嵌在組件，藉由呼叫的.resources 檔擷取資源<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法。  
  
> [!CAUTION]
>  使用獨立的.resources 檔案中的 ASP.NET 應用程式將會中斷 XCOPY 部署，因為資源保持鎖定，直到它們會明確地釋放<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法。 如果您想要部署在與 ASP.NET 應用程式的資源，您應該編譯您的.resources 檔案至附屬組件。  
  
 是以資源為基礎的應用程式，其中一個.resources 檔案會包含如果找不到任何特定文化特性資源所使用之資源的預設文化特性的資源。 例如，如果應用程式的預設文化特性是英文 (en)，英文語言資源可用時的特定文化特性，例如英文 （美國） (EN-US) 或法文 （法國） (FR-FR) 找不到當地語系化的資源。 一般而言，預設文化特性的資源會內嵌主應用程式的組件，並針對其他當地語系化的文化特性的資源會內嵌在附屬組件。 附屬組件只能包含資源。 它們有相同的根檔案名稱，以及主要組件的延伸模組 .resources.dll。 針對應用程式的組件並未登錄於全域組件快取，附屬組件會儲存在其名稱會對應至組件的文化特性的應用程式子目錄。  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>建立資源  
 當您開發以資源為基礎的應用程式時，您會將資源資訊儲存在文字檔 （.txt 或.restext 副檔名的檔案） 或 XML 檔案 （副檔名為.resx 檔案）。 然後編譯的文字或 XML 檔案，具有[資源檔產生器 (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md)建立二進位.resources 檔案。 您接著可以內嵌在可執行檔或程式庫產生的.resources 檔，使用編譯器選項，例如`/resources`的 C# 和 Visual Basic 編譯器，或者您可以將它內嵌在附屬組件中使用。 如果您在 Visual Studio 專案中包含的.resx 檔，Visual Studio 會處理在編譯和內嵌的預設值，並自動的建置程序一部分的當地語系化資源。  
  
 在理想情況下，您應該建立的每種語言資源應用程式支援，或至少每種語言有意義的子集。 二進位.resources 檔案名稱遵循命名慣例*basename*。*\language*.resources，其中*basename*應用程式名稱或類別，根據您想要的詳細層級的名稱。 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>屬性用來判斷*\language*。 應用程式的預設文化特性的資源應該命名為*basename*.resources。  
  
 例如，假設組件在 MyResources 基底名稱的資源檔有多項資源。 這些資源檔應該有日本 （日文） 文化特性，MyResources.de.resources 德文文化特性，MyResources.zh-CHS.resources 簡化繁體中文文化特性，例如 MyResources.ja JP.resources 名稱和MyResources.fr BE.resources 法文 （比利時） 文化特性。 預設資源檔應該命名 MyResources.resources。 特定文化特性資源檔通常封裝在每個文化特性的附屬組件。 預設資源檔應內嵌在應用程式的主要組件中。  
  
 請注意，可讓資源標示為私用，但您應該一律將它們標示為公用使得其他組件可以存取。 （附屬組件不包含程式碼，因為標示為私用的資源是透過任何機制的應用程式中無法使用）。  
  
 如需有關建立，封裝及部署資源，請參閱文章[建立資源檔](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md)，[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)，和[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>具現化 ResourceManager 物件  
 您具現化<xref:System.Resources.ResourceManager>呼叫其中一個其類別建構函式多載會從內嵌的.resources 檔擷取資源的物件。 這緊密結合<xref:System.Resources.ResourceManager>物件特定的.resources 檔與所有相關聯的當地語系化附屬組件中的.resources 檔案。  
  
 兩個最常呼叫的建構函式會：  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> 根據您所提供的資訊這兩項資源會查閱： 的基底名稱的.resources 檔，以及預設的.resources 檔案所在的組件。 基底名稱包含命名空間和根名稱的.resources 檔案，而不需要其文化特性或延伸模組。 請注意，通常會編譯從命令列的.resources 檔案不包含命名空間的名稱，而 Visual Studio 環境中建立的.resources 檔案。 例如，如果資源檔名為 MyCompany.StringResources.resources 和<xref:System.Resources.ResourceManager>建構函式會從名為的靜態方法呼叫`Example.Main`，下列程式碼會具現化<xref:System.Resources.ResourceManager>可以擷取從資源的物件。資源檔：  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> 查閱從型別物件的資訊為基礎的附屬組件中的資源。 類型的完整的名稱對應到不包含其副檔名名稱的.resources 檔的基底名稱。 使用 Visual Studio 資源設計工具所建立的桌面應用程式，Visual Studio 會建立其完整的名稱是.resources 檔的根名稱相同的包裝函數類別。 例如，如果名為 MyCompany.StringResources.resources 資源檔，而且沒有名為的包裝函數類別`MyCompany.StringResources`，下列程式碼會具現化<xref:System.Resources.ResourceManager>可以從.resources 檔擷取資源的物件：  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 如果找不到適當的資源，建立有效的建構函式呼叫<xref:System.Resources.ResourceManager>物件。 不過，嘗試擷取的資源會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況。 處理例外狀況的相關資訊，請參閱[處理 MissingManifestResourceException 和 MissingSatelliteAssembly 例外狀況](#exception)本文中稍後的章節。  
  
 下列範例示範如何具現化<xref:System.Resources.ResourceManager>物件。 它包含為 ShowTime.exe 可執行檔的原始程式碼。 它也包含名為包含單一字串資源的 Strings.txt 下列文字檔`TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 您可以使用批次檔產生資源檔，並將它內嵌至可執行檔。 以下是使用 C# 編譯器產生可執行檔的批次檔：  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 對於 Visual Basic 編譯器，您可以使用下列批次檔：  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager 和特定文化特性的資源  
 當地語系化的應用程式需要部署的資源，發行項中所述[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。 如果組件已正確設定，資源管理員會決定哪些資源来擷取根據目前的執行緒<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 （該屬性也會傳回目前的執行緒 UI 文化特性）。例如，如果已編譯的應用程式預設英文語言資源的主要組件，並使用兩個附屬組件中的法文和俄文語言資源和<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性設為 FR-FR，資源管理員擷取法國資源。  
  
 您可以設定<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性明確或隱含的方式。 您將它設定的方式會決定如何<xref:System.Resources.ResourceManager>物件擷取根據文化特性的資源：  
  
-   如果您明確地設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性，以特定文化特性的資源管理員一律會擷取該文化特性，不論使用者的瀏覽器或作業系統語言的資源。 請考慮以預設的英文語言資源的方式編譯的應用程式和三個英文 （美國）、 法文 （法國），和俄文 （俄羅斯） 包含資源的附屬組件。 如果<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性設為 FR-FR，<xref:System.Resources.ResourceManager>物件一律會擷取法文 （法國） 資源，即使使用者的作業系統語言不是法文。 請確定這是所要的行為之前您明確地設定屬性。  
  
     在 ASP.NET 應用程式，您必須設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性明確，因為它是不太可能在伺服器上的設定會比對連入用戶端要求。 ASP.NET 應用程式可以設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性明確設使用者的瀏覽器接受語言。  
  
     明確設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性會定義該執行緒的目前 UI 文化特性。 它不會影響應用程式中的任何其他執行緒的目前 UI 文化特性。  
  
-   您可以藉由指定應用程式定義域中設定的所有執行緒的 UI 文化特性<xref:System.Globalization.CultureInfo>物件，代表該文化特性為靜態<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>屬性。  
  
-   如果您未明確設定的目前 UI 文化特性，而且您未定義的預設文化特性，目前的應用程式定義域，<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性隱含謔 Windows 廑飶`GetUserDefaultUILanguage`函式。 此函式提供的多語系使用者介面 (MUI)，可讓使用者設定預設語言。 如果 UI 語言不由使用者設定，則預設的系統安裝的語言，這是作業系統資源的語言。  
  
 下列簡單"Hello world"範例明確設定的目前 UI 文化特性。 它包含三個文化特性的資源： 英文 （美國） 或英文、 法文 （法國） 或 FR-FR，和俄文 （俄羅斯） 或 RU-RU。 名為 Greetings.txt 文字檔案中包含 EN-US 資源：  
  
```  
HelloString=Hello world!  
```  
  
 若為 FR-FR 資源都包含在名為 Greetings.fr 文字檔-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 RU-RU 資源都包含在名為 Greetings.ru 文字檔-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 以下是範例 (Visual Basic 版本 Example.vb) 或 Example.cs C# 版本的原始程式碼：  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 若要編譯此範例中，建立包含下列命令，並從命令提示字元中執行的批次 (.bat) 檔。 如果您使用 C#，指定`csc`而不是`vbc`和`Example.cs`而不是`Example.vb`。  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>擷取資源  
 您呼叫<xref:System.Resources.ResourceManager.GetObject%28System.String%29>和<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法來存取特定資源。 您也可以呼叫<xref:System.Resources.ResourceManager.GetStream%28System.String%29>方法來擷取位元組陣列形式的非字串資源。 根據預設，在應用程式中，已當地語系化的資源，這些方法會傳回取決於進行呼叫的執行緒的目前 UI 文化特性的文化特性的資源。 請參閱上一節[ResourceManager 和特定文化特性資源](#CultureSpecific)，如需有關定義執行緒的目前 UI 文化特性的方式。 如果資源管理員找不到目前的執行緒 UI 文化特性的資源，它會使用後援程序，來擷取指定的資源。 如果資源管理員中，找不到任何當地語系化的資源，它會使用的預設文化特性的資源。 如需資源後援規則的詳細資訊，請參閱本文的 「 資源後援處理序 」 一節[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
> [!NOTE]
>  如果在指定的.resources 檔<xref:System.Resources.ResourceManager>找不到類別建構函式，嘗試擷取的資源會擲回<xref:System.Resources.MissingManifestResourceException>或<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 處理例外狀況的相關資訊，請參閱[處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況](#exception)本主題稍後的章節。  
  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取特定文化特性資源。 它包含英文 (en)、 法文 （法國） (FR-FR)，及俄文 （俄羅斯） (RU-RU) 從.txt 檔案編譯的資源的文化特性。 此範例將目前的文化特性和目前 UI 文化特性變更為英文 （美國）、 法文 （法國）、 俄文 （俄羅斯） 和瑞典文 （瑞典）。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取它會顯示目前的日期和月份的當地語系化的字串。 請注意，輸出會顯示適當的當地語系化的字串，除非目前 UI 文化特性是瑞典文 （瑞典）。 因為無法使用瑞典文語言資源，應用程式會改為使用的預設文化特性，亦即英文的資源。  
  
 這個範例需要下表所列的文字為基礎的資源檔。 每個具有名為的單一字串資源`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|zh-TW|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 以下是範例 (Visual Basic 版本 ShowDate.vb) 或 C# 版本的程式碼的 ShowDate.cs 的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 若要編譯此範例中，建立包含下列命令，並從命令提示字元中執行的批次檔。 如果您使用 C#，指定`csc`而不是`vbc`和`showdate.cs`而不是`showdate.vb`。  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 有兩種方式，來擷取目前 UI 文化特性以外的特定文化特性的資源：  
  
-   您可以呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>， <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>，或<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29>方法來擷取特定文化特性的資源。 如果找不到當地語系化的資源，資源管理員會使用資源後援程序來找出適當的資源。  
  
-   您可以呼叫<xref:System.Resources.ResourceManager.GetResourceSet%2A>方法，以取得<xref:System.Resources.ResourceSet>物件，代表特定文化特性的資源。 在方法呼叫中，您可以判斷是否資源管理員探查父文化特性的如果找不到當地語系化的資源，或是否則只會回到預設文化特性的資源。 然後您可以使用<xref:System.Resources.ResourceSet>方法存取的資源 （為該文化特性當地語系化） 名稱，或列舉集合中的資源。  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況處理  
 如果您嘗試擷取特定的資源，但已定義資源和任何預設文化特性或找不到的預設文化特性的資源，資源管理員就會擲回，找不到資源管理員<xref:System.Resources.MissingManifestResourceException>例外狀況如果它必須要有主要組件中尋找的資源或<xref:System.Resources.MissingSatelliteAssemblyException>如果它預期附屬組件中尋找的資源。 請注意當您呼叫這類資源擷取方法時擲回例外狀況<xref:System.Resources.ResourceManager.GetString%2A>或<xref:System.Resources.ResourceManager.GetObject%2A>，當您具現化和<xref:System.Resources.ResourceManager>物件。  
  
 在下列情況下，通常會擲回例外狀況：  
  
-   適當的資源檔或附屬組件不存在。 如果資源管理員會預期要在主應用程式組件中內嵌的應用程式的預設資源，它們不存在。 如果<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性表示應用程式的預設資源位於附屬組件，找不到組件。 當您編譯您的應用程式時，請確定資源會內嵌在主要組件，或所需的附屬組件會產生，並適當地命名。 其名稱格式應為*appName* .resources.dll，而且應該位於名為之後它所包含之資源的文化特性的目錄。  
  
-   您的應用程式沒有預設值或定義的中性文化特性。 新增<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性至原始程式碼檔或專案資訊檔 (在 Visual Basic 應用程式中 AssemblyInfo.vb) 或 C# 應用程式的 AssemblyInfo.cs 檔案。  
  
-   `baseName`中的參數<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>建構函式未指定.resources 檔的名稱。 此名稱應該包含資源檔的完整命名空間，但沒有檔案的副檔名。 一般而言，會在 Visual Studio 中建立的資源檔案包含命名空間名稱，但不是這麼做，建立和在命令提示字元進行編譯資源檔。 您可以編譯並執行下列公用程式，以判斷內嵌的.resources 檔的名稱。 這是主控台應用程式可接受的主要組件或附屬組件做為命令列參數的名稱。 它會顯示應該做為提供的字串`baseName`參數，讓資源管理員可以正確辨識的資源。  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 如果您要明確地變更您的應用程式的目前文化特性，您也應該記住資源管理員擷取的值為基礎的資源組<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性，而非<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。 一般而言，如果您變更一個值，您也應該變更其他。  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>資源的版本管理  
 因為主要組件，其中包含應用程式的預設資源是與應用程式的附屬組件分開，您可以釋放主要組件的新版本，而不必重新部署的附屬組件。 您使用<xref:System.Resources.SatelliteContractVersionAttribute>屬性使用現有的附屬組件，並指示資源管理員不是要以新版本的主要組件，將其重新佈署  
  
 如需附屬組件的版本支援的詳細資訊，請參閱文章[擷取資源](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)。  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<s > 設定檔 節點  
 針對可執行檔，並從網站 （HREF.exe 檔） 執行<xref:System.Resources.ResourceManager>物件可能會降低您的應用程式效能從網路探查附屬組件。 若要排除效能問題，您可以限制此探查您已部署應用程式的附屬組件。 若要這樣做，您建立`<satelliteassemblies>`您的應用程式組態檔，以指定您已為您的應用程式和部署一組特定的文化特性中的節點<xref:System.Resources.ResourceManager>物件不應嘗試探查未列在該節點的任何文化特性。  
  
> [!NOTE]
>  若要建立慣用的替代做法`<satelliteassemblies>`節點是使用[ClickOnce 部署資訊清單](http://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b)功能。  
  
 您的應用程式組態檔中，建立區段如下所示：  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 編輯此組態資訊，如下所示：  
  
-   指定一或多個`<assembly>`部署時，每個主要組件的節點上，每個節點指定完整格式組件名稱。 指定的取代主要組件名稱*MainAssemblyName*，並指定`Version`， `PublicKeyToken`，和`Culture`主要組件的屬性對應的值。  
  
     如`Version`屬性，指定您的組件的版本號碼。 例如，您的組件的第一版可能是版本號碼 1.0.0.0。  
  
     如`PublicKeyToken`屬性，指定關鍵字`null`如果您有未簽署組件具有強式名稱，或指定您公開金鑰語彙基元，如果您已登入您的組件。  
  
     如`Culture`屬性，指定關鍵字`neutral`指定主要組件，而造成<xref:System.Resources.ResourceManager>類別中所列的文化特性只有探查`<culture>`節點。  
  
     如需完整的組件名稱的詳細資訊，請參閱文章[組件名稱](~/docs/framework/app-domains/assembly-names.md)。 如需強式名稱組件的詳細資訊，請參閱文章[Creating and using strong-named Assemblies](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md)。  
  
-   指定一或多個`<culture>`具有特定文化特性名稱，例如 「 FR-FR 」 或中性文化特性名稱，例如"fr"節點。  
  
 如果資源所需的下面沒有列出任何組件`<satelliteassemblies>` 節點，<xref:System.Resources.ResourceManager>類別探查使用標準的探查規則的文化特性。  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，我們不建議使用它。 只有在您開發時使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]可以搭配使用的專案[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請使用[Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 如[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager>類別會從封裝資源索引 (PRI) 檔案中擷取資源。 在單一 PRI 檔案 （應用程式封裝 PRI 檔案） 包含的預設文化特性和任何資源當地語系化文化特性而有所不同。 您可以使用 MakePRI 公用程式來建立 PRI 檔案從一或多個資源檔的 XML 資源 (.resw) 格式。 如需 Visual Studio 專案中包含的資源，Visual Studio 會處理程序建立及自動封裝 PRI 檔案。 然後，您可以使用.NET Framework<xref:System.Resources.ResourceManager>類別來存取應用程式庫的資源。  
  
 您可以具現化<xref:System.Resources.ResourceManager>物件[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]相同的方式，您的桌面應用程式執行的應用程式。  
  
 您接著可以藉由傳遞至要擷取資源的名稱來存取特定的文化特性的資源<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法。 根據預設，這個方法會傳回由進行呼叫的執行緒的目前 UI 文化特性的文化特性的資源。 您也可以藉由傳遞的資源名稱擷取特定文化特性的資源和<xref:System.Globalization.CultureInfo>物件，代表要擷取其資源的文化特性<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法。 如果找不到目前的 UI 文化特性或指定的文化特性的資源，資源管理員會使用 UI 語言後援清單尋找適當的資源。  
  
   
  
## Examples  
 下列範例會示範如何使用明確的文化特性和隱含的目前 UI 文化特性來取得從主要組件和附屬組件的字串資源。 如需詳細資訊，請參閱 「 目錄位置的附屬組件不安裝在全域組件快取 」 一節[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)主題。  
  
 若要執行此範例中：  
  
1.  在應用程式目錄中，建立名為 rmc.txt 包含下列資源字串的檔案：  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  使用[資源檔產生器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)從 rmc.txt 輸入檔產生 rmc.resources 資源檔時，也將，如下所示：  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  建立應用程式目錄的子目錄，並命名"ES-MX"。 這是您將在接下來三個步驟建立的附屬組件的文化特性名稱。  
  
4.  建立名為 rmc.es-MX.txt ES-MX 目錄包含下列資源字串中的檔案：  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  使用[資源檔產生器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)從 rmc.es MX.txt 輸入檔產生 rmc.es MX.resources 資源檔時，也將，如下所示：  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  假設此範例中的檔案名稱是 rmc.vb 或 rmc.cs。 將下列原始程式碼複製到檔案。 然後編譯它，並將主要組件資源檔 rmc.resources，內嵌在可執行的組件。 如果您使用 Visual Basic 編譯器，語法如下：  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     C# 編譯器的對應的語法是：  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  使用[組件連結器](~/docs/framework/tools/al-exe-assembly-linker.md)建立附屬組件。 如果應用程式的主檔名是 rmc，附屬組件名稱必須是 rmc.resources.dll。 附屬組件應該 ES-MX 目錄中建立。 如果 ES-MX 目前的目錄，請使用此命令：  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  運行rmc.exe以獲取並顯示嵌入的資源字符串。  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設值，初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會很有用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">資源管理員從中衍生尋找 .resources 檔所需所有資訊的型別。</param>
        <summary>根據指定之型別物件的資訊，初始化可查閱附屬組件中資源之 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>桌面應用程式  
 在桌面應用程式，資源管理員會使用`resourceSource`參數來載入特定的資源檔，如下所示：  
  
-   如果<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性不會用來表示的預設文化特性的資源位於附屬組件，請在資源管理員會假設預設文化特性的資源檔位於所指定之類型相同的組件`resourceSource`參數。  
  
-   資源管理員會假設預設資源檔具有相同的基底名稱為所指定之類型`resourceSource`參數。  
  
-   資源管理員會使用預設<xref:System.Resources.ResourceSet>類別來操作的資源檔。  
  
 例如，假設名為 MyCompany.MyProduct.MyType 的類型，資源管理員會尋找定義 MyType 的組件中命名 MyCompany.MyProduct.MyType.resources.resources 檔。  
  
 在 Visual Studio 資源設計工具自動產生程式碼定義`internal`（C# 中） 或`Friend`（在 Visual Basic) 類別的名稱會做為預設文化特性的.resources 檔的基底名稱相同。 這樣做可具現化<xref:System.Resources.ResourceManager>物件，並藉由取得型別物件，其名稱會對應至資源的名稱，因為只要類別為可見編譯器，資源必須為結合一組特定的資源使用區域。 例如，如果在將.resources 檔名為 Resource1，下列陳述式具現化<xref:System.Resources.ResourceManager>物件，以管理名為 Resource1 的.resources 檔案：  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 如果您不使用 Visual Studio，您可以建立不包含成員的命名空間和名稱是預設的.resources 檔案相同的類別。 這個範例將提供說明。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，我們不建議使用它。 只有在您開發時使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]可以搭配使用的專案[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請使用[Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager>使用`resourceSource`參數推斷組件，基底的名稱和命名空間可以位於應用程式的封裝資源索引 (PRI) 檔內的資源項目。 例如，假設名為 MyCompany.MyProduct.MyType 中所定義的型別`MyAssembly`，資源管理員會尋找資源設定名為 MyAssembly 的識別項，並尋找該資源集內的範圍 MyCompany.MyProduct.MyType。 資源管理員會搜尋此範圍內的預設內容 （目前的文化特性，目前的高對比設定，以及等等） 下的資源項目。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>建構函式來具現化<xref:System.Resources.ResourceManager>物件。 它包含英文 (en)、 法文 （法國） (FR-FR)，及俄文 （俄羅斯） (RU-RU) 從.txt 檔案編譯的資源的文化特性。 此範例將目前的文化特性和目前 UI 文化特性變更為英文 （美國）、 法文 （法國）、 俄文 （俄羅斯） 和瑞典文 （瑞典）。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法來擷取當地語系化的字串中，顯示問候語，取決於一天的時間。  
  
 這個範例需要三個以文字為基礎的資源檔案，如下表中所列。 每個檔案包含字串資源名稱為`Morning`， `Afternoon`，和`Evening`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|zh-TW|GreetingResources.txt|`Morning`|早安|  
|zh-TW|GreetingResources.txt|`Afternoon`|良好的下午|  
|zh-TW|GreetingResources.txt|`Evening`|良好晚上|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|Доброе утро|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|Добрый день|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 您可以使用下列批次檔，以編譯 Visual Basic 範例並建立名為 Greet.exe 的可執行檔。 若要使用 C# 編譯，變更編譯器名稱從`vbc`至`csc`和副檔名從`.vb`至`.cs`。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 以下是範例 (Visual Basic 版本 ShowDate.vb) 或 C# 版本的程式碼的 ShowDate.cs 的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 除了定義應用程式類別名稱為`Example`的原始程式碼定義內部的類別名稱， `GreetingResources`，做為基底的資源檔名稱相同。 這樣做可成功地具現化<xref:System.Resources.ResourceManager>藉由呼叫物件<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>建構函式。  
  
 請注意，輸出會顯示適當的當地語系化字串除非目前 UI 文化特性是瑞典文 （瑞典），在此情況下，否則它會使用英文語言資源。 因為無法使用瑞典文語言資源，應用程式使用的預設文化特性資源所定義的<xref:System.Resources.NeutralResourcesLanguageAttribute>改為屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceSource" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">資源檔的根名稱，不含副檔名但包括任何完整的命名空間。 例如，名為 MyApplication.MyResource.en-US.resources 的資源檔根目錄名稱是 MyApplication.MyResource。</param>
        <param name="assembly">資源的主要組件。</param>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體，這個執行個體會在所指的組件中查閱具有指定根名稱之檔案中的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>桌面應用程式  
 桌面應用程式，個別的特定文化特性資源檔應該包含在附屬組件，而預設文化特性的資源檔案應該包含在主要組件。 附屬組件會假設為包含在這個組件資訊清單中指定了單一文化的資源，而且會視需要載入。  
  
> [!NOTE]
>  若要從直接而不是擷取組件的.resources 檔案中擷取資源，您必須呼叫<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法而具現化<xref:System.Resources.ResourceManager>物件。  
  
 如果所識別的資源檔`baseName`中找不到`assembly`，方法會具現化<xref:System.Resources.ResourceManager>物件，但嘗試擷取特定的資源就會擲回例外狀況，通常<xref:System.Resources.MissingManifestResourceException>。 如需例外狀況原因的診斷資訊，請參閱的 「 處理 MissingManifestResourceException 例外狀況 」 一節<xref:System.Resources.ResourceManager>類別主題。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，我們不建議使用它。 只有在您開發時使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]可以搭配使用的專案[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請使用[Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，資源管理員使用的簡單名稱`assembly`應用程式的封裝資源索引 (PRI) 檔中設定的參數，以尋找相符的資源。 `baseName`參數用來查閱的資源集內的資源項目。 例如，PortableLibrary1.Resource1.de DE.resources 的根目錄名稱是 PortableLibrary1.Resource1。  
  
   
  
## Examples  
 下列範例會使用簡單的非當地語系化"Hello World"應用程式說明<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>建構函式。 以下顯示名為 ExampleResources.txt 文字檔的內容。 當應用程式編譯時，資源會內嵌在主應用程式組件。  
  
```  
Greeting=Hello  
```  
  
 文字檔可以轉換成二進位資源檔，藉由在命令提示字元，如下所示：  
  
```  
resgen ExampleResources.txt  
```  
  
 下列範例提供具現化的可執行程式碼<xref:System.Resources.ResourceManager>物件，會提示使用者輸入的名稱，並顯示問候語。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 它可以編譯的 Visual Basic 中使用下列命令：  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 或者，使用下列命令，在 C# 中：  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 請注意此範例會擷取藉由傳遞至該組件中定義的型別包含的資源檔的組件的參考`typeof`函式 （C# 中） 或`GetType`函式 （在 Visual Basic)，並擷取其值<xref:System.Type.Assembly%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> 或 <paramref name="assembly" /> 參數為 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>這個建構函式會使用系統提供<see cref="T:System.Resources.ResourceSet" />實作。 若要使用自訂資源的檔案格式，您應該從衍生<see cref="T:System.Resources.ResourceSet" />類別，覆寫<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />和<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />方法和類型的行程<see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />建構函式。 使用自訂<see cref="T:System.Resources.ResourceSet" />可以是很有用，控制資源快取原則或支援您自己的資源檔格式，但通常不是必要的。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">資源檔的根名稱，不含副檔名但包括任何完整的命名空間。 例如，名為 MyApplication.MyResource.en-US.resources 的資源檔根目錄名稱是 MyApplication.MyResource。</param>
        <param name="assembly">資源的主要組件。</param>
        <param name="usingResourceSet">要使用之自訂 <see cref="T:System.Resources.ResourceSet" /> 的型別。 如果是 <see langword="null" />，就會使用預設的執行階段 <see cref="T:System.Resources.ResourceSet" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體，這個執行個體使用指定的 <see cref="T:System.Resources.ResourceSet" /> 類別查閱所指組件中具有指定根名稱的檔案所包含的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 個別的特定文化特性資源檔應該會包含在附屬組件，而且預設文化特性的資源檔案應該包含在主要組件。 附屬組件會假設為包含在這個組件資訊清單中指定了單一文化的資源，而且會視需要載入。  
  
> [!NOTE]
>  若要從直接而不是擷取組件的.resources 檔案中擷取資源，您必須呼叫<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法而具現化<xref:System.Resources.ResourceManager>物件。  
  
 如果所識別的資源檔`baseName`中找不到`assembly`，方法會具現化<xref:System.Resources.ResourceManager>物件，但嘗試擷取特定的資源就會擲回例外狀況，通常<xref:System.Resources.MissingManifestResourceException>。 如需例外狀況原因的診斷資訊，請參閱的 「 處理 MissingManifestResourceException 例外狀況 」 一節<xref:System.Resources.ResourceManager>類別主題。  
  
> [!NOTE]
>  `usingResourceSet`參數用來支援您自己的資源格式，且通常會`null`。 這是不同的建構函式的<xref:System.Type>只。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" /> 不是 <see cref="T:System.Resources.ResourceSet" /> 的衍生類別。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> 或 <paramref name="assembly" /> 參數為 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>這個建構函式可讓您指定<see cref="T:System.Resources.ResourceSet" />實作。 若不想讓特定<see cref="T:System.Resources.ResourceSet" />實作但就像若要使用自訂資源的檔案格式，您應該從衍生<see cref="T:System.Resources.ResourceSet" />類別，覆寫<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />和<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />方法，並將傳遞的輸入給這個建構函式。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</summary>
        <value>
          <see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A>屬性會反映完整命名空間名稱和資源檔，不含文化特性或檔案名稱副檔名的根資源名稱。 例如，如果應用程式的預設資源檔名為`SampleApps.StringResources.resources`，值<xref:System.Resources.ResourceManager.BaseName%2A>屬性是 「 SampleApps.StringResources"。 如果應用程式的預設資源檔的名稱為`SampleApps.StringResources.en-US.resources`，並內嵌於附屬組件的值<xref:System.Resources.ResourceManager.BaseName%2A>屬性仍然是 「 SampleApps.StringResources"。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A>編譯和命令列從內嵌資源檔的屬性值不包含命名空間名稱，除非您明確地加入一個編譯檔案時。 相反地，<xref:System.Resources.ResourceManager.BaseName%2A>資源檔編譯和通常內嵌於 Visual Studio 環境的屬性值包含預設命名空間名稱。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A>屬性值為相同字串傳遞至<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>或<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>建構函式具現化時<xref:System.Resources.ResourceManager>執行個體。  
  
   
  
## Examples  
 您可以編譯並執行下列公用程式，以判斷內嵌的.resources 檔的名稱。 這是主控台應用程式可接受的主要組件或附屬組件做為命令列參數的名稱。 它會顯示應該做為提供的字串`baseName`參數<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>或<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>建構函式，讓資源管理員可以正確辨識的資源。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 <see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField>欄位非常實用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">資源的根目錄名稱。 例如，命名為「MyResource.en-US.resources」資源檔的根目錄名稱是「MyResource」。</param>
        <param name="resourceDir">要搜尋資源的目錄名稱。 <c>resourceDir</c> 可以是絕對路徑或相對於應用程式目錄的路徑。</param>
        <param name="usingResourceSet">要使用之自訂 <see cref="T:System.Resources.ResourceSet" /> 的型別。 如果是 <see langword="null" />，就會使用預設的執行階段 <see cref="T:System.Resources.ResourceSet" /> 物件。</param>
        <summary>傳回 <see cref="T:System.Resources.ResourceManager" /> 物件，該物件會搜尋特定目錄而不是資源的組件資訊清單。</summary>
        <returns>資源管理員的新執行個體，會搜尋指定的目錄，而不是搜尋資源的組件資訊清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回從沒有組件中內嵌的.resources 檔擷取資源的資源管理員。 您可以使用這個<xref:System.Resources.ResourceManager>物件載入 ASP.NET 網頁資源，或測試<xref:System.Resources.ResourceSet>實作。  如需從獨立的.resources 檔擷取資源的範例，請參閱[擷取資源](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)發行項。  
  
 這個方法可讓您指定<xref:System.Resources.ResourceSet>實作。 如果您不需要特定<xref:System.Resources.ResourceSet>實作中，但想要使用自訂資源檔案格式，您應該從衍生<xref:System.Resources.ResourceSet>類別，覆寫<xref:System.Resources.ResourceSet.GetDefaultReader%2A>和<xref:System.Resources.ResourceSet.GetDefaultWriter%2A>方法，並將傳遞的輸入給這個建構函式。  
  
> [!CAUTION]
>  使用獨立的.resources 檔案中的 ASP.NET 應用程式將會中斷 XCOPY 部署，因為資源保持鎖定，直到它們會明確地釋放<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法。 如果您想要部署在與 ASP.NET 應用程式的資源，編譯附屬組件.resources 檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> 或 <paramref name="resourceDir" /> 參數為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要擷取預設後援資源的位置。</summary>
        <value>其中一個列舉值，指定資源管理員可以在何處尋找後援資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A>屬性會很實用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 您可以使用<xref:System.Resources.NeutralResourcesLanguageAttribute>通知資源管理員如何尋找應用程式的預設文化特性的屬性: （預設值） 的主要組件或附屬組件中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">為其傳回特定文化特性資訊的組件。</param>
        <summary>藉由擷取指定之組件上的 <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 屬性的值，傳回主要組件的預設資源的文化特性資訊。</summary>
        <returns>如果找到則為 <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 屬性中的文化特性，否則為不因國別而異的文化特性。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回針對目前文化特性所指定非字串資源的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要取得的資源名稱。</param>
        <summary>傳回指定的非字串資源的值。</summary>
        <returns>為呼叫端目前文化特性設定當地語系化的資源的值。 如果有適當的資源集，但找不到 <paramref name="name" />，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A>方法用來擷取非字串資源。 這些包括例如屬於基本資料型別值<xref:System.Int32>或<xref:System.Double>，點陣圖 (例如<xref:System.Drawing.Bitmap?displayProperty=nameWithType>物件)，或自訂序列化的物件。 通常，傳回的物件必須轉換 （C# 中） 或者 （在 Visual Basic) 轉換成適當型別的物件。  
  
 傳回的資源已針對目前的執行緒所定義的 UI 文化特性當地語系化<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果未針對該文化特性當地語系化的資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，<xref:System.Resources.ResourceManager>就會回到預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤是部署或安裝的附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化型別時，會擲回使用者定義的例外狀況。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您呼叫<xref:System.Resources.ResourceManager.GetObject%2A>多次使用相同的方法`name`參數，不相依於傳回的參考，每次呼叫相同物件的方法。 這是因為<xref:System.Resources.ResourceManager.GetObject%2A>方法可以傳回現有的資源物件的參考，在快取，或它可以重新載入資源，並傳回新的資源物件的參考。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> 方法來還原序列化自訂物件。 此範例包含名為 UIElements.cs (UIElements.vb 如果您使用 Visual Basic) 的原始程式碼檔，定義名為下列結構`PersonTable`。 此結構是為了供一般資料表顯示常式使用，以顯示資料表資料行的當地語系化名稱。 請注意， `PersonTable` 結構會以 <xref:System.SerializableAttribute> 屬性標記。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 下列程式碼來自於名為 CreateResources.cs (若是 Visual Basic 則為 CreateResources.vb) 的檔案，會建立用以儲存資料表標題的 XML 資源檔 UIResources.resx，以及包含針對英文語言當地語系化之應用程式資訊的 `PersonTable` 物件。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 原始程式碼檔 GetObject.cs (GetObject.vb) 中的下列程式碼會接著擷取資源，並將其顯示到主控台。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 您可以建立必要的資源檔和組件，並藉由執行下列批次檔來執行應用程式。 您必須使用 `/r` 選項將 UIElements.dll 的參考提供給 Resgen.exe，使其可以存取有關 `PersonTable` 結構的資訊。 如果使用 C#，請將 `vbc` 編譯器名稱取代成 `csc`，並將 `.vb` 副檔名取代成 `.cs`。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的當地語系化資源，也沒有預設的文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">要取得的資源名稱。</param>
        <param name="culture">要當地語系化資源的文化特性。 如果此文化特性的資源未當地語系化，則資源管理員會使用後援規則來尋找適當的資源。  
  
 如果這個值是 <see langword="null" />，則會使用 <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> 屬性取得 <see cref="T:System.Globalization.CultureInfo" /> 物件。</param>
        <summary>取得針對指定的文化特性當地語系化之所指定非字串資源的值。</summary>
        <returns>為指定文化特性當地語系化的資源的值。 如果有適當的資源集，但找不到 <paramref name="name" />，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>方法用來擷取非字串資源。 這些包括例如屬於基本資料型別值<xref:System.Int32>或<xref:System.Double>，點陣圖 (例如<xref:System.Drawing.Bitmap?displayProperty=nameWithType>物件)，或自訂序列化的物件。 通常，傳回的物件必須轉換 （C# 中） 或者 （在 Visual Basic) 轉換成適當型別的物件。  
  
 傳回的資源已針對所指定的文化特性當地語系化`culture`，或針對所指定的文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性如果`culture`是`null`。 如果未針對該文化特性當地語系化的資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，資源管理員會回復預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤是部署或安裝的附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化型別時，會擲回使用者定義的例外狀況。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您呼叫<xref:System.Resources.ResourceManager.GetObject%2A>多次使用相同的方法`name`參數，不相依於傳回的參考，每次呼叫相同物件的方法。 這是因為<xref:System.Resources.ResourceManager.GetObject%2A>方法可以傳回現有的資源物件的參考，在快取，或它可以重新載入資源，並傳回新的資源物件的參考。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> 方法來還原序列化自訂物件。 此範例包含名為 NumberInfo.cs (NumberInfo.vb 如果您使用 Visual Basic) 的原始程式碼檔，定義名為下列結構`Numbers`。 此結構會使用簡單的教育性應用程式，將教導您說話學生在非英文計數設為十個 in 英文。 請注意，`Numbers`類別標示為<xref:System.SerializableAttribute>屬性。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 檔案中的下列原始程式碼具名的 CreateResources.cs (CreateResources.vb 適用於 Visual Basic) 會建立預設的英文語言，以及法文，葡萄牙文、 俄文語言，XML 資源檔。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 下列應用程式，將目前的 UI 文化特性設定為法文 （法國）、 葡萄牙文 （巴西） 或俄文 （俄羅斯） 所耗用的資源。 它會呼叫<xref:System.Resources.ResourceManager.GetObject%28System.String%29>方法來取得`Numbers`物件，其中包含當地語系化的數字和<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>方法來取得`Numbers`物件，其中包含英文語言的數字。 然後，它會顯示使用目前的 UI 文化特性和英文語言的奇數。 原始程式碼檔名為 ShowNumbers.cs (ShowNumbers.vb)。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 若要建置和執行範例的 Visual Basic 版本，您可以使用下列批次檔。 如果您使用 C#，取代`vbc`與`csc`，並取代`.vb`副檔名`.cs`。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />方法是安全執行緒。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">要建構資源檔案名稱的文化特性物件。</param>
        <summary>為所指 <see cref="T:System.Globalization.CultureInfo" /> 物件產生資源檔的名稱。</summary>
        <returns>可用於所指 <see cref="T:System.Globalization.CultureInfo" /> 物件之資源檔的名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A>方法會很有用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 這個方法會使用<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>屬性做為所有文化特性而異的文化特性以外的檔案名稱的一部分。 這個方法不會查看組件資訊清單或觸控磁碟，並僅用來建構資源檔案名稱 (適用於傳遞給<xref:System.Resources.ResourceReader>建構函式) 或資訊清單資源的 blob 名稱。  
  
 在衍生的類別可以覆寫這個方法來尋找不同的擴充功能，例如"。ResX"或完全不同的配置資源的檔案命名。 請注意，此方法可以自訂資源檔內的附屬組件的名稱，而非自訂的附屬組件本身的名稱。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">要擷取其資源的文化特性。</param>
        <param name="createIfNotExists">
          要載入尚未載入的資源集合則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="tryParents">
          <see langword="true" /> 表示如果找不到資源集時，就要使用資源後援來載入適當的資源；<see langword="false" /> 表示要略過資源後援程序。</param>
        <summary>擷取特定文化特性設定的資源。</summary>
        <returns>所指定文化特性的資源集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的資源集表示會針對指定的文化特性當地語系化的資源。 如果未針對該文化特性當地語系化的資源和`tryParents`是`true`，<xref:System.Resources.ResourceManager.GetResourceSet%2A>載入適當的資源使用資源後援規則。 如果`tryParents`是`false`而且找不到特定文化特性的資源集，則方法會傳回`null`。 如需後援資源的詳細資訊，請參閱中的 「 資源後援處理序 」 一節[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)發行項。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Resources.ResourceManager.GetResourceSet%2A>方法來擷取法文 （法國） 文化特性的文化特性資源。 然後列舉所有的資源集合中的資源。 它包含為 ShowNumbers.exe 可執行檔的原始程式碼。 它也包含下列兩個文字檔包含數字的名稱。 第一個，NumberResources.txt，包含數字，介於 1 到 10 的英文語言的名稱：  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 第二個，NumberResources.fr FR.txt，包含一到四個 in 法文語言的數字的名稱：  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 您可以使用批次檔，以產生資源檔、 英文語言資源檔嵌入可執行檔，並建立法文語言資源的附屬組件。 以下是批次檔所使用的 Visual Baisc 編譯器產生可執行檔：  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 對於 C# 編譯器，您可以使用下列批次檔：  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 請注意，如果您變更的值`createIfNotExists`引數`false`，方法呼叫傳回`null`，因為資源管理員尚未載入的法文語言資源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /> 為 <see langword="true" />，找不到一組可用的資源，也沒有預設文化特性資源。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">要檢查其 <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 屬性的組件。</param>
        <summary>傳回所指組件中 <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 屬性所指定的版本。</summary>
        <returns>指定組件的附屬合約版本，如果找不到版本，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需附屬組件版本控制的詳細資訊，請參閱<xref:System.Resources.SatelliteContractVersionAttribute>參考主題。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在組件 <paramref name="a" /> 中找到的 <see cref="T:System.Version" /> 無效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從指定的資源傳回 Unmanaged 記憶體資料流物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">資源的名稱。</param>
        <summary>從指定的資源傳回 Unmanaged 記憶體資料流物件。</summary>
        <returns>代表資源的 Unmanaged 記憶體資料流物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>方法會儲存為資源名稱<xref:System.IO.MemoryStream>物件中取得的值<xref:System.Object>資源，並傳回<xref:System.IO.UnmanagedMemoryStream>物件。 它需要，您可以直接處理的資料流的位元組，然後轉換成物件。 此方法相當實用，基於效能原因： 擷取資源，而不是明確的物件的位元組資料流可以改善效能。  
  
 傳回的資源已針對目前的執行緒所定義的 UI 文化特性當地語系化<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果未針對該文化特性當地語系化的資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，<xref:System.Resources.ResourceManager>就會回到預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> 方法來擷取應用程式開頭顯示畫面視窗中使用的點陣圖。 下列來源檔案，名為程式碼 CreateResources.cs （適用於 C#) 或 （適用於 Visual Basic) CreateResources.vb 會產生名為包含已序列化的映像的 AppResources.resx.resx 檔。 在此情況下，會從名為 SplashScreen.jpg 的檔案載入影像；您可以修改檔案名稱以替代成您自己的影像。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 下列程式碼會從名為檔案 GetStream.cs （C#) 或 GetStream.vb （適用於 Visual Basic) 然後擷取資源，並顯示在影像<xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType>控制項。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 您可以使用下列批次檔來建立 C# 範例。 Visual basic 中，變更`csc`至`vbc`，並將變更從原始程式碼檔的副檔名`.cs`至`.vb`...  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定之資源的值不是 <see cref="T:System.IO.MemoryStream" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">資源的名稱。</param>
        <param name="culture">物件，其指定要用於資源查閱的文化特性。 如果 <c>culture</c> 為 <see langword="null" />，則會使用目前執行緒的文化特性。</param>
        <summary>使用指定的文化特性，從指定的資源傳回 Unmanged 記憶體資料流物件。</summary>
        <returns>代表資源的 Unmanaged 記憶體資料流物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>方法會儲存為資源名稱<xref:System.IO.MemoryStream>物件中取得的值<xref:System.Object>資源，並傳回<xref:System.IO.UnmanagedMemoryStream>物件。 它需要，您可以直接處理的資料流的位元組，然後轉換成物件。 此方法相當實用，基於效能原因： 擷取資源，而不是明確的物件的位元組資料流可以改善效能。  
  
 傳回的資源已針對所指定的文化特性當地語系化`culture`，或針對所指定的文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性如果`culture`是`null`。 如果未針對該文化特性當地語系化的資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，<xref:System.Resources.ResourceManager>就會回到預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定之資源的值不是 <see cref="T:System.IO.MemoryStream" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定的文化特性或目前 UI 文化特性的指定字串資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要擷取的資源名稱。</param>
        <summary>傳回指定的字串資源的值。</summary>
        <returns>針對呼叫端的目前 UI 文化特性當地語系化的資源的值，或者為<see langword="null" /> (如果在資源集中找不到<paramref name="name" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>桌面應用程式  
 桌面應用程式，則會傳回該資源已當地語系化目前執行緒的 UI 文化特性所定義的<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果沒有當地語系化文化特性的資源，資源管理員來探查資源的 「 資源後援處理序 」 一節所述的步驟[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)發行項。 如果找到一組可用的當地語系化資源，資源管理員會回復預設文化特性的資源。 如果資源管理員無法載入預設文化特性的資源集，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤是部署或安裝的附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化型別時，會擲回使用者定義的例外狀況。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，我們不建議使用它。 只有在您開發時使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]可以搭配使用的專案[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請使用[Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法傳回的值`name`字串呼叫端的目前 UI 文化特性設定當地語系化的資源。 文化特性的清單衍生自作業系統的慣用 UI 語言清單。 如果不符合資源管理員`name`，方法會傳回`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取特定文化特性資源。 它包含英文 (en)、 法文 （法國） (FR-FR)，及俄文 （俄羅斯） (RU-RU) 從.txt 檔案編譯的資源的文化特性。 此範例將目前的文化特性和目前 UI 文化特性變更為英文 （美國）、 法文 （法國）、 俄文 （俄羅斯） 和瑞典文 （瑞典）。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取它會顯示目前的日期和月份的當地語系化的字串。 請注意，輸出會顯示適當的當地語系化的字串，除非目前 UI 文化特性是瑞典文 （瑞典）。 因為無法使用瑞典文語言資源，應用程式會改為使用的預設文化特性，亦即英文的資源。 這個範例需要下表所列的文字為基礎的資源檔。 每個具有名為的單一字串資源`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|zh-TW|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 若要編譯 C# 範例，您可以使用下列批次檔。 若是 Visual Basic，請將 `csc` 變更為 `vbc`，並將原始程式碼檔案的副檔名從 `.cs` 變更為 `.vb`。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 以下是範例 (Visual Basic 版本 ShowDate.vb) 或 ShowDate.cs C# 版本的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定資源的值不是字串。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的資源，也沒有預設文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />方法是安全執行緒。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">要擷取的資源名稱。</param>
        <param name="culture">物件，表示資源要當地語系化的文化特性。</param>
        <summary>傳回為指定文化特性當地語系化之字串資源的值。</summary>
        <returns>針對指定文化特性當地語系化的資源的值，或者為<see langword="null" /> (如果在資源集中找不到<paramref name="name" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>桌面應用程式  
 在桌面應用程式，如果`culture`是`null`、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法會使用從取得的目前 UI 文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。  
  
 針對指定的文化特性會傳回資源當地語系化`culture`參數。 如果未針對當地語系化的資源`culture`，資源管理員資源的 「 資源後援處理序 」 一節所述的步驟探查[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主題。 如果找到一組可用的資源，資源管理員會回復預設文化特性的資源。 如果資源管理員無法載入預設文化特性的資源集，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或預期的資源集位於附屬組件，<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較的`name`與資源的名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤是部署或安裝的附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化型別時，會擲回使用者定義的例外狀況。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式中，我們不建議使用它。 只有在您開發時使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]可以搭配使用的專案[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請使用[Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法傳回的值`name`字串所指定的文化特性當地語系化的資源`culture`參數。 如果資源並未當地語系化為`culture`文化特性，查閱使用整個[!INCLUDE[win8](~/includes/win8-md.md)]後援語言的清單，並停駐點之後的預設文化特性中尋找。 如果不符合資源管理員`name`，方法會傳回`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法來擷取特定文化特性資源。 此範例的預設文化特性是英文 (en)，而且它包含附屬組件俄文 （俄羅斯） (RU-RU) 與法文 （法國） (FR-FR) 文化特性而有所不同。 範例會變更目前 UI 文化特性與目前的文化特性為俄文 （俄羅斯） 然後再呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法和<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法，並傳遞<xref:System.Globalization.CultureInfo>代表每個方法的法文 （法國） 和瑞典文 （瑞典） 文化特性的物件。 在輸出中，月份和日期的月份，以及位於這些字串會出現以法文顯示，因為<xref:System.Resources.ResourceManager.GetString%2A>方法是能夠擷取法文語言資源。 不過，使用瑞典文 （瑞典） 文化特性時，月份和日期的月份出現瑞典文中，雖然它們前面的字串是以英文。 這是因為資源管理員找不到當地語系化瑞典文語言資源，所以它會改為傳回預設的英文文化特性的資源。  
  
 這個範例需要下表所列的文字為基礎的資源檔。 每個具有名為的單一字串資源`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|zh-TW|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 若要編譯 Visual Basic 範例，您可以使用下列批次檔。 若要編譯 C# 中，變更`vbc`至`csc`，並將變更從原始程式碼檔的副檔名`.vb`至`.cs`。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 以下是範例 (Visual Basic 版本 ShowDate.vb) 或 ShowDate.cs C# 版本的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定資源的值不是字串。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的資源，也沒有預設文化特性的資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />方法是安全執行緒。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定目前 <see cref="T:System.Resources.ResourceManager" /> 的實作能夠解譯和產生的資源檔標頭版本。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出資源管理員是否允許在 <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> 和 <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> 方法中進行不區分大小寫的資源查詢。</summary>
        <value>
          若要在資源查閱時忽略大小寫則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值<xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性是`false`，有名稱為 「 資源 」 的資源不等同於 「 資源 」 名稱的資源。 如果<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`，有名稱為 「 資源 」 的資源就相當於 「 資源 」 名稱的資源。 不過請注意，當<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`、<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType>和<xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType>方法使用而異的文化特性執行不區分大小寫字串比較。 優點是，這些方法所執行的不區分大小寫字串比較的結果是不論文化特性的所有電腦上相同。 缺點是結果不一致的所有文化特性的大小寫規則。  
  
 比方說，土耳其文的字母會有兩個版本的字元 i： 一個點，一個沒有點。 在土耳其文，字元我 (Unicode 0049) 會視為不同的字元 (Unicode 0131) ı 的大寫版本。 I (Unicode 0069) 的字元會被視為另一個字元 İ (Unicode 0130) 的小寫版本。 根據這些大小寫規則，不區分大小寫字串比較的字元 (Unicode 0069) i 和 I (Unicode 0049) 應該文化特性"TR-TR"（在土耳其土耳其文） 失敗。 不過，如果使用的文化特性而異的大小寫規則進行比較，因為<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`，這項比較會成功。  
  
> [!NOTE]
>  基於效能考量，最好一律指定正確的大小寫的資源名稱。 設定<xref:System.Resources.ResourceManager.IgnoreCase%2A>至`true`可能會大幅增加造成工作集和效能的大幅下降。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">要尋找的文化特性物件。</param>
        <param name="createIfNotExists">
          要載入尚未載入的資源集合則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="tryParents">
          如果無法載入資源集，就要檢查父代 <see cref="T:System.Globalization.CultureInfo" /> 物件則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>提供用來尋找資源集的實作。</summary>
        <returns>指定的資源集。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">主要組件不包含 .resources 檔，該檔案為查閱資源所必要。</exception>
        <exception cref="T:System.ExecutionEngineException">執行階段發生內部錯誤。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">找不到與 <paramref name="culture" />相關聯的附屬組件。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <block subset="none" type="overrides">
          <para>此方法完成所有必要資源設定，而且可以遞迴和 reentrant 尋找工作。 換句話說，這個方法可能會載入的組件和觸發程序<see cref="E:System.AppDomain.AssemblyLoad" />事件，然後會呼叫回<see cref="T:System.Resources.ResourceManager" />尚未完全初始化的物件。 若要避免採用額外的鎖定，這個方法不具備執行緒安全。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />， <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />，和<see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />方法都會執行所有必要的同步處理。</para>
        </block>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>保留用來識別資源檔的編號。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值設定為 0xBEEFCACE。 第一個系統預設的檔案格式的四個位元組包含 32 位元帶正負號的整數，以位元組由小到大格式 (請參閱<xref:System.Text.Encoding>)。  
  
 如果<xref:System.Resources.ResourceManager.MagicNumber>找到，其後的位元組會的版本號碼<xref:System.Resources.ResourceManager>標頭，後面接著數字，指出要如何繼續此標頭應該略過多少個位元組。 下一個數字表示的版本<xref:System.Resources.ResourceManager>建立之標頭，後面接著版本特定資訊。  
  
 目前的實作中的版本號碼是其中一個。 下一個位元組是固定長度的字串，包含名稱<xref:System.Resources.IResourceReader>，它可以讀取此檔案。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定包含資源的主要組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly>欄位非常實用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示資源管理員要呼叫所有 <see cref="T:System.Resources.ResourceSet" /> 物件上的 <see cref="M:System.Resources.ResourceSet.Close" /> 方法並釋放所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會壓縮執行的應用程式中的工作集。 任何未來資源上的查閱這<xref:System.Resources.ResourceManager>物件將會第一次尋查，成本，因為資源管理員需要搜尋重新載入資源。 這可用於複雜執行緒案例，其中建立新<xref:System.Resources.ResourceManager>物件是適當的行為。  
  
> [!NOTE]
>  以.NET Framework 2.0 版中，啟動<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法不具備執行緒安全，相對於<xref:System.Resources.ResourceManager.GetObject%2A>， <xref:System.Resources.ResourceManager.GetString%2A>，和<xref:System.Resources.ResourceManager.GetStream%2A>作業。 這項變更的優點是多個執行緒存取資源的效能改進。 不過，如果您呼叫<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法在一個執行緒同時取得另一個執行緒的資源時，取得作業會擲回<xref:System.ObjectDisposedException>例外狀況。  
  
 您也可以在受管理的執行個體目前的資源管理員所建立的資源，必須釋出決定性，而不等候資源管理員完全超出範圍而遭到記憶體回收的情況下使用這個方法。  
  
> [!NOTE]
>  呼叫這個方法不會卸載附屬組件。 若要卸除附屬組件，請使用<xref:System.AppDomain.Unload%2A>方法。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含 <see cref="T:System.Collections.Hashtable" />，其傳回從文化特性到 <see cref="T:System.Resources.ResourceSet" /> 物件的對應。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資源管理員用來建構 <see cref="T:System.Resources.ResourceSet" /> 物件之資源集物件的型別。</summary>
        <value>資源管理員用來建構 <see cref="T:System.Resources.ResourceSet" /> 物件之資源集物件的型別。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>