<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="30d9e5bf9c2a3a84a1462baf6a29670e165bca21" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53332997" /></Metadata><TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.2">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在執行階段提供特定文化特性資源存取權限的資源管理員。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceManager>類別會在從二進位.resources 檔案內嵌於組件或獨立.resources 檔擷取資源。 如果已當地語系化的應用程式，而且已經在部署當地語系化的資源[附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)，它會查詢特定文化特性的資源、 資源後援時提供當地語系化的資源不存在，以及支援資源序列化。  
  
 如需有關建立和管理桌面應用程式中的資源和[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請參閱下列各節：  
  
-   [傳統型應用程式](#desktop)  
  
    -   [建立資源](#creating_resources)  
  
    -   [具現化 ResourceManager 物件](#instantiating)  
  
    -   [ResourceManager 和特定文化特性的資源](#CultureSpecific)  
  
    -   [擷取資源](#retrieving)  
  
    -   [處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況](#exception)  
  
    -   [資源的版本管理](#versioning)  
  
    -   [\<satelliteassemblies > 組態檔 節點](#config)  
  
-   [Windows 市集應用程式](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>傳統型應用程式  
 傳統型應用程式，<xref:System.Resources.ResourceManager>類別從二進位資源 (.resources) 檔擷取資源。 一般而言，語言編譯器或[組件連結器 (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md)這些資源檔嵌入組件。 您也可以使用<xref:System.Resources.ResourceManager>直接從沒有內嵌在組件，藉由呼叫的.resources 檔擷取資源的物件<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法。  
  
> [!CAUTION]
>  使用獨立.resources 檔中的 ASP.NET 應用程式會中斷 XCOPY 部署，因為資源保持鎖定狀態，直到明確發行<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法。 如果您想要使用您的 ASP.NET 應用程式來部署資源，您應該編譯到附屬組件的.resources 檔案。  
  
 在資源為基礎的應用程式，其中一個的.resources 檔案會包含如果找不到任何特定文化特性的資源使用其資源的預設文化特性的資源。 例如，如果應用程式的預設文化特性是英文 (en)，英文語言資源會使用特定文化特性，例如英文 （美國） (EN-US) 或法文 （法國） (FR-FR) 找不到當地語系化的資源時。 一般而言，預設文化特性的資源內嵌在主應用程式的組件，而其他當地語系化的文化特性的資源內嵌在附屬組件中。 附屬組件只能包含資源。 它們有相同的根檔案名稱，以及主要組件的延伸模組 .resources.dll。 針對應用程式的組件未登錄在全域組件快取，附屬組件會儲存在其名稱會對應至組件的文化特性的應用程式子目錄中。  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>建立資源  
 當您開發的資源為基礎的應用程式時，您會將資源資訊儲存在文字檔 （.txt 或.restext 副檔名的檔案） 或 XML 檔案 （副檔名為.resx 檔案）。 然後編譯的文字或 XML 檔案，具有[資源檔產生器 (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md)建立二進位.resources 檔案。 您接著可以將內嵌產生的.resources 檔案中的可執行檔或程式庫使用編譯器選項，例如`/resources`的 C# 和 Visual Basic 編譯器，或者您可以將它內嵌在附屬組件使用。 如果您在 Visual Studio 專案中包含.resx 檔，Visual Studio 會處理在編譯和內嵌的預設值，並建置程序的過程中自動當地語系化資源。  
  
 在理想情況下，您應該建立的每種語言的資源應用程式支援，或至少意義的子集的每一種語言。 二進位的.resources 檔案名稱會遵循命名慣例*basename*。*cultureName*.resources，其中*basename*應用程式的名稱或類別，根據您想要的詳細層級的名稱。 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>屬性用來判斷*cultureName*。 應該命名為應用程式的預設文化特性的資源*basename*.resources。  
  
 例如，假設組件，基底名稱 MyResources 資源檔中有幾個資源。 這些資源檔應該具有 MyResources.ja JP.resources 例如日本 （日文） 文化特性，MyResources.de.resources 德文文化特性，MyResources.zh-CHS.resources 簡化繁體中文文化特性的名稱和MyResources.fr BE.resources 法文 （比利時） 文化特性。 預設資源檔應該命名為 MyResources.resources。 特定文化特性資源檔通常封裝在每個文化特性的附屬組件。 預設資源檔應內嵌在應用程式的主要組件中。  
  
 請注意，可讓資源標示為私用，但您應該一律將它們標示為公用讓其他組件可以存取。 （附屬組件會不包含任何程式碼，因此標示為私用的資源是您的應用程式，透過任何機制無法使用）。  
  
 如需有關如何建立的詳細資訊，請封裝和部署資源，請參閱文章[建立資源檔](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md)，[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)，和[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>具現化 ResourceManager 物件  
 您具現化<xref:System.Resources.ResourceManager>從內嵌的.resources 檔擷取資源，其類別建構函式多載的呼叫其中的物件。 這緊密結合兩者<xref:System.Resources.ResourceManager>物件與特定的.resources 檔案和所有相關聯的當地語系化附屬組件中的.resources 檔案。  
  
 兩個最常呼叫的建構函式如下：  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> 查閱兩項您所提供的資訊為基礎的資源： 到.resources 檔案，而且預設.resources 檔所在的組件的基底名稱。 基底名稱包含命名空間和根名稱的.resources 檔案，而不需要其文化特性或延伸模組。 請注意，從命令列通常編譯的.resources 檔不會包含命名空間的名稱，而在 Visual Studio 環境中所建立的.resources 檔案執行。 比方說，如果資源檔名為 MyCompany.StringResources.resources 並<xref:System.Resources.ResourceManager>建構函式會從名為的靜態方法呼叫`Example.Main`，下列程式碼會具現化<xref:System.Resources.ResourceManager>可以擷取從資源的物件。資源檔：  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> 查閱從型別物件的資訊為基礎的附屬組件中的資源。 型別的完整格式的名稱對應至不含其副檔名的.resources 檔的基底名稱。 使用 Visual Studio 資源設計工具所建立的桌面應用程式，Visual Studio 會建立包裝函式類別，其完整的名稱是.resources 檔的根名稱相同。 例如，如果資源檔命名為 MyCompany.StringResources.resources 並沒有名為的包裝函式類別`MyCompany.StringResources`，下列程式碼會具現化<xref:System.Resources.ResourceManager>可以從.resources 檔擷取資源的物件：  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 如果找不到適當的資源，建構函式呼叫會建立有效<xref:System.Resources.ResourceManager>物件。 不過，嘗試擷取資源會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況。 如需處理的例外狀況資訊，請參閱[處理 MissingManifestResourceException 和 MissingSatelliteAssembly 例外狀況](#exception)本文稍後的章節。  
  
 下列範例示範如何具現化<xref:System.Resources.ResourceManager>物件。 它包含名為 ShowTime.exe 的可執行檔的原始程式碼。 它也包含名為 Strings.txt 包含單一字串資源，下列文字檔`TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 您可以使用批次檔，產生資源檔，並將它內嵌至可執行檔。 以下是使用 C# 編譯器產生可執行檔的批次檔：  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Visual Basic 編譯器，您可以使用下列的批次檔：  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager 和特定文化特性的資源  
 當地語系化的應用程式需要要部署資源，如本文所述[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。 如果組件已正確設定，資源管理員會決定要擷取哪些資源會根據目前的執行緒<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 （該屬性也會傳回目前的執行緒 UI 文化特性）。例如，如果已編譯的應用程式預設主要組件以及兩個附屬組件中的法文和俄文語言資源的英文語言資源和<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性設定為 FR-FR，資源管理員擷取法文資源。  
  
 您可以設定<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性明確或隱含的方式。 您將它設定的方式會決定如何<xref:System.Resources.ResourceManager>物件擷取根據文化特性的資源：  
  
-   如果您明確設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性到特定的文化特性，資源管理員一律會擷取該文化特性，不論使用者的瀏覽器或作業系統語言的資源。 請考慮使用預設的英文語言資源所編譯的應用程式和三個英文 （美國）、 法文 （法國） 和俄文 （俄羅斯） 包含資源的附屬組件。 如果<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性設為 FR-FR，<xref:System.Resources.ResourceManager>物件一律會擷取法文 （法國） 資源，即使使用者的作業系統語言不是法文。 請確定這是所要的行為之前明確設定屬性。  
  
     在 ASP.NET 應用程式，您必須設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性明確，因為它是不太可能在伺服器上的設定會比對傳入的用戶端要求。 ASP.NET 應用程式可以設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性明確地為使用者的瀏覽器接受的語言。  
  
     明確設定<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>屬性會定義該執行緒的目前 UI 文化特性。 它不會影響應用程式中的任何其他執行緒的目前 UI 文化特性。  
  
-   您也可以指派應用程式定義域中設定的所有執行緒的 UI 文化特性<xref:System.Globalization.CultureInfo>物件，表示該文化特性為靜態<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>屬性。  
  
-   如果您未明確設定目前 UI 文化特性，而且您沒有定義目前的應用程式定義域中，預設文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性在 Windows 中有不同的設定會隱含地`GetUserDefaultUILanguage`函式。 此函數隨附的多語系使用者介面 (MUI)，可讓使用者設定的預設語言。 如果使用者未設定的 UI 語言，則會預設為系統安裝的語言，也就是作業系統資源的語言。  
  
 下列的簡單"Hello world"範例會明確地設定目前 UI 文化特性。 它包含三個文化特性的資源：英文 （美國） 或 EN-US、 法文 （法國） FR-FR 和俄文 （俄羅斯） 或 RU-RU。 名為 Greetings.txt 文字檔案中包含 EN-US 資源：  
  
```  
HelloString=Hello world!  
```  
  
 若為 FR-FR 資源包含在名為 Greetings.fr 文字檔中-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 RU-RU 資源包含在名為 Greetings.ru 文字檔-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 以下是範例 (Visual Basic 版本的 Example.vb) 或 Example.cs C# 版本的原始程式碼：  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 若要編譯此範例中，建立包含下列命令，並從命令提示字元中執行的批次 (.bat) 檔。 如果您使用 C#，指定`csc`而非`vbc`並`Example.cs`而不是`Example.vb`。  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>擷取資源  
 您呼叫<xref:System.Resources.ResourceManager.GetObject%28System.String%29>和<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法來存取特定資源。 您也可以呼叫<xref:System.Resources.ResourceManager.GetStream%28System.String%29>方法來擷取非字串資源做為位元組陣列。 根據預設，在應用程式已當地語系化的資源，這些方法會傳回進行呼叫之執行緒的目前 UI 文化特性所決定的文化特性的資源。 請參閱上一節[ResourceManager 和特定文化特性的資源](#CultureSpecific)，如需有關定義執行緒的目前 UI 文化特性的方式。 如果 resource manager 找不到目前的執行緒 UI 文化特性的資源，它會使用後援程序，來擷取指定的資源。 如果資源管理員中，找不到任何當地語系化的資源，它會使用預設文化特性的資源。 如需資源後援規則的詳細資訊，請參閱本文的 「 資源後援處理序 」 一節[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
> [!NOTE]
>  如果在指定的.resources 檔案<xref:System.Resources.ResourceManager>找不到類別建構函式，嘗試擷取資源會擲回<xref:System.Resources.MissingManifestResourceException>或<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如需處理的例外狀況資訊，請參閱[處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況](#exception)本主題稍後的章節。  
  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取特定文化特性的資源。 它包含英文 (en)、 法文 （法國） (FR-FR) 和俄文 （俄羅斯） (RU-RU).txt 檔案從所編譯的資源文化特性。 範例變更英文 （美國）、 法文 （法國）、 俄文 （俄國） 和瑞典文 （瑞典） 的目前 UI 文化特性與目前的文化特性。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取當地語系化的字串，它會顯示與目前的日期和月份。 請注意，輸出會顯示適當的當地語系化的字串，除非目前 UI 文化特性是瑞典文 （瑞典）。 因為瑞典文語言資源無法使用，應用程式會改為使用預設文化特性的資源，也就是英文。  
  
 這個範例需要下表所列的文字為基礎的資源檔。 每個都有單一的字串資源，名為`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 以下是範例 (Visual Basic 版本的 ShowDate.vb) 或 ShowDate.cs C# 版本的程式碼的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 若要編譯此範例中，建立包含下列命令，並從命令提示字元中執行的批次檔。 如果您使用 C#，指定`csc`而非`vbc`並`showdate.cs`而不是`showdate.vb`。  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 有兩種方式可擷取目前 UI 文化特性以外的特定文化特性的資源：  
  
-   您可以呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>， <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>，或<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29>方法來擷取特定文化特性的資源。 如果找不到當地語系化的資源，資源管理員會使用資源後援處理序來找出適當的資源。  
  
-   您可以呼叫<xref:System.Resources.ResourceManager.GetResourceSet%2A>方法，以取得<xref:System.Resources.ResourceSet>物件，代表特定文化特性的資源。 在方法呼叫中，您可以判斷是否 「 資源管理員會探查父文化特性如果找不到當地語系化的資源，或是否只會回復為預設文化特性的資源。 您可以接著使用<xref:System.Resources.ResourceSet>方法名稱，來存取 （用於該文化特性當地語系化） 的資源，或列舉集合中的資源。  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況  
 如果您嘗試擷取特定的資源，但已定義資源並沒有預設文化特性或找不到預設文化特性的資源，資源管理員就會擲回，找不到資源管理員<xref:System.Resources.MissingManifestResourceException>例外狀況如果它預期會在主要組件中尋找的資源或<xref:System.Resources.MissingSatelliteAssemblyException>如果預期應找到附屬組件中的資源。 請注意，當您呼叫資源擷取方法，例如將擲回例外狀況<xref:System.Resources.ResourceManager.GetString%2A>或是<xref:System.Resources.ResourceManager.GetObject%2A>，以及當您具現化<xref:System.Resources.ResourceManager>物件。  
  
 在下列情況下，通常會擲回例外狀況：  
  
-   適當的資源檔或附屬組件不存在。 如果資源管理員會預期要內嵌在主應用程式組件中的應用程式的預設資源，它們不存在。 如果<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性會指出應用程式的預設資源位於附屬組件，找不到組件。 當您編譯您的應用程式時，請確定資源會內嵌在主要組件，或會產生所需的附屬組件，並適當地命名。 其名稱格式應為*appName* .resources.dll，而且應該位於名為之後它所包含之資源的文化特性的目錄。  
  
-   您的應用程式沒有預設值或定義的中性文化特性。 新增<xref:System.Resources.NeutralResourcesLanguageAttribute>原始程式碼檔或專案資訊檔案 (Visual Basic 應用程式的 AssemblyInfo.vb) 或 C# 應用程式的 AssemblyInfo.cs 檔案的屬性。  
  
-   `baseName`中的參數<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>建構函式未指定的.resources 檔案的名稱。 此名稱應該包含資源檔的完整命名空間，但不要其檔案名稱副檔名。 一般而言，在 Visual Studio 中建立的資源檔包含命名空間名稱，但不是這麼做會建立，並在命令提示字元編譯的資源檔。 您可以編譯並執行下列公用程式，以判斷內嵌的.resources 檔案的名稱。 這是主控台應用程式可接受的主要組件或附屬組件，做為命令列參數的名稱。 它會顯示應該提供做為字串`baseName`參數，讓資源管理員能夠正確地識別資源。  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 如果您明確變更您的應用程式的目前文化特性，您也應該記住，資源管理員擷取的值為基礎的資源集<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性，而非<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。 一般而言，如果您變更一個值時，您也應該變更其他。  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>資源的版本管理  
 因為主要組件，其中包含應用程式的預設資源是與應用程式的附屬組件分開的您可以釋放新版本的主要組件不需重新部署附屬組件。 您使用<xref:System.Resources.SatelliteContractVersionAttribute>使用現有的附屬組件，並指示資源管理員不重新部署這些主要組件，以新版本的屬性  
  
 如需詳細的附屬組件版本控制支援的詳細資訊，請參閱文章[擷取資源](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)。  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > 組態檔 節點  
 可執行檔，部署和執行網站 （HREF.exe 檔），從<xref:System.Resources.ResourceManager>物件時，可探查是否有附屬組件上，透過網頁，會降低您的應用程式效能。 若要排除效能問題，您可以限制探查您部署您的應用程式的附屬組件。 若要這樣做，您建立`<satelliteassemblies>`在您的應用程式組態檔，以指定您已部署您的應用程式，和一組特定的文化特性中的節點<xref:System.Resources.ResourceManager>物件不應該嘗試探查未列在該節點的任何文化特性。  
  
> [!NOTE]
>  慣用的替代做法，以建立`<satelliteassemblies>`節點是使用[ClickOnce 部署資訊清單](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b)功能。  
  
 在您的應用程式組態檔中，建立區段如下所示：  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 編輯此組態資訊，如下所示：  
  
-   指定一或多個`<assembly>`節點，可供您部署時，每個主要組件的每個節點上，指定完整格式組件名稱。 指定的位置是主要組件名稱*MainAssemblyName*，並指定`Version`， `PublicKeyToken`，和`Culture`主要組件的屬性對應的值。  
  
     針對`Version`屬性，指定您的組件的版本號碼。 比方說，您的組件的第一個版本可能是版本號碼 1.0.0.0。  
  
     針對`PublicKeyToken`屬性，指定關鍵字`null`如果您有未簽署您的組件以強式名稱，或指定您的公開金鑰 token，如果您已登入您的組件。  
  
     針對`Culture`屬性，指定關鍵字`neutral`若要指定主要組件，並使得<xref:System.Resources.ResourceManager>來探查只中所列的文化特性的類別`<culture>`節點。  
  
     如需完整的組件名稱的詳細資訊，請參閱文章[組件名稱](~/docs/framework/app-domains/assembly-names.md)。 如需有關強式名稱組件的詳細資訊，請參閱文章[建立和使用強式名稱組件](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md)。  
  
-   指定一或多個`<culture>`與特定文化特性名稱，例如"FR-FR"或中性文化特性名稱，例如"fr"的節點。  
  
 如果資源所需的下面沒有列出任何組件`<satelliteassemblies>`節點，<xref:System.Resources.ResourceManager>類別使用標準的探查規則的文化特性的探查。  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，我們不建議使用它。 只有當您開發時，才使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]專案，可以搭配[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，使用[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 針對[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager>類別會擷取封裝資源索引 (PRI) 檔案中的資源。 單一 PRI 檔案 （應用程式封裝 PRI 檔案） 包含預設文化特性和任何資源當地語系化文化特性。 您可以使用 MakePRI 公用程式來建立 PRI 檔案從一或多個資源檔的 XML 資源 (.resw) 格式。 如需 Visual Studio 專案中包含的資源，Visual Studio 會處理程序的建立及自動封裝 PRI 檔案。 然後，您可以使用.NET Framework<xref:System.Resources.ResourceManager>類別來存取應用程式庫的資源。  
  
 您可以具現化<xref:System.Resources.ResourceManager>物件[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]相同的方式執行您的桌面應用程式對執行中應用程式。  
  
 傳遞至要擷取資源的名稱，您可以再存取特定的文化特性的資源<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法。 根據預設，這個方法會傳回進行呼叫之執行緒的目前 UI 文化特性所決定的文化特性的資源。 您也可以藉由傳遞的資源名稱擷取特定文化特性的資源和<xref:System.Globalization.CultureInfo>物件，表示要擷取至其資源的文化特性<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法。 如果找不到目前的 UI 文化特性或指定的文化特性的資源，資源管理員會使用 UI 語言後援清單來尋找適當的資源。  
  
   
  
## Examples  
 下列範例示範如何使用明確的文化特性和隱含的目前 UI 文化特性來從主要組件和附屬組件中取得字串資源。 如需詳細資訊，請參閱"目錄位置的附屬組件不安裝在全域組件快取 」 一節[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)主題。  
  
 若要執行此範例中：  
  
1.  在應用程式目錄中，建立名為 rmc.txt 包含下列的資源字串的檔案：  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  使用[資源檔產生器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)rmc.txt 輸入檔中，如下所示產生 rmc.resources 資源檔：  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  建立應用程式目錄的子目錄並將它 「 ES-MX"命名。 這是您將在接下來三個步驟建立的附屬組件的文化特性名稱。  
  
4.  建立名為 rmc.es-MX.txt ES-MX 目錄，其中包含下列的資源字串中的檔案：  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  使用[資源檔產生器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)rmc.es MX.txt 輸入檔中，如下所示產生 rmc.es MX.resources 資源檔：  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  假設此範例中的檔案名稱是 rmc.vb 或 rmc.cs。 將下列原始程式碼複製到檔案。 然後編譯它，並可執行組件中嵌入主要組件資源檔，rmc.resources。 如果您使用 Visual Basic 編譯器，語法為：  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     C# 編譯器對應的語法是：  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  使用[組件連結器](~/docs/framework/tools/al-exe-assembly-linker.md)建立附屬組件。 如果應用程式的主檔名是 rmc，附屬組件名稱必須是 rmc.resources.dll。 ES-MX 目錄中，就應該建立附屬組件。 如果 ES-MX 是目前的目錄，請使用下列命令：  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  運行rmc.exe以獲取並顯示嵌入的資源字符串。  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">在應用程式中的資源</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設值，初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式是很有用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">資源管理員從中衍生尋找 .resources 檔所需所有資訊的型別。</param>
        <summary>根據指定之型別物件的資訊，初始化可查閱附屬組件中資源之 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>傳統型應用程式  
 桌面應用程式，資源管理員會使用`resourceSource`參數來載入特定的資源檔，如下所示：  
  
-   如果<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性不會用來表示的預設文化特性的資源位於附屬組件中，resource manager 會假設預設文化特性的資源檔位於所指定之類型相同的組件`resourceSource`參數。  
  
-   Resource manager 會假設預設資源檔具有相同的基底名稱所指定之類型為`resourceSource`參數。  
  
-   資源管理員會使用預設<xref:System.Resources.ResourceSet>類別來操作的資源檔。  
  
 比方說，假設名為 MyCompany.MyProduct.MyType 的類型，資源管理員會尋找名 MyCompany.MyProduct.MyType.resources 為定義 MyType 的組件中的.resources 檔案。  
  
 在 Visual Studio 中，資源設計工具會自動產生程式碼定義`internal`（在 C# 中) 或`Friend`（在 Visual Basic) 類別名稱是預設文化特性的.resources 檔案的基底名稱相同。 這樣可以具現化<xref:System.Resources.ResourceManager>物件，並結合其取得型別物件，其名稱會對應至資源的名稱，因為只要類別為可見的編譯器，資源必須與一組特定的資源好吧， 例如，如果.resources 檔名為 Resource1，下列陳述式會具現化<xref:System.Resources.ResourceManager>物件來管理名為 Resource1.resources 檔案：  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 如果您不使用 Visual Studio，您可以建立不含成員的命名空間和名稱是預設.resources 檔相同的類別。 這個範例將提供說明。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，我們不建議使用它。 只有當您開發時，才使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]專案，可以搭配[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，使用[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，<xref:System.Resources.ResourceManager>使用`resourceSource`推斷組件，基底的名稱和命名空間資源項目可以是位於應用程式的封裝資源索引 (PRI) 檔的參數。 例如，假設名為 MyCompany.MyProduct.MyType 中所定義的類型`MyAssembly`，resource manager 會尋找資源集名稱為 MyAssembly 的識別項，並尋找該資源集內的範圍 MyCompany.MyProduct.MyType。 資源管理員會搜尋這個範圍內的預設內容 （目前的文化特性、 目前的高對比設定，等等） 下的資源項目。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>建構函式來具現化<xref:System.Resources.ResourceManager>物件。 它包含英文 (en)、 法文 （法國） (FR-FR) 和俄文 （俄羅斯） (RU-RU).txt 檔案從所編譯的資源文化特性。 範例變更英文 （美國）、 法文 （法國）、 俄文 （俄國） 和瑞典文 （瑞典） 的目前 UI 文化特性與目前的文化特性。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法來擷取當地語系化的字串，其中會顯示問候語，取決於一天的時間。  
  
 這個範例中將需要三個以文字為基礎的資源檔下, 表所示。 每個檔案包含名為的字串資源`Morning`， `Afternoon`，和`Evening`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|en-US|GreetingResources.txt|`Morning`|早安|  
|en-US|GreetingResources.txt|`Afternoon`|午安|  
|en-US|GreetingResources.txt|`Evening`|晚安|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|Доброе утро|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 您可以使用下列的批次檔，以編譯 Visual Basic 範例並建立名為 Greet.exe 的可執行檔。 若要使用 C# 編譯，變更 將編譯器名稱從`vbc`要`csc`和從副檔名`.vb`至`.cs`。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 以下是範例 (Visual Basic 版本的 ShowDate.vb) 或 ShowDate.cs C# 版本的程式碼的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 除了定義應用程式類別名為`Example`，原始程式碼定義內部的類別名稱， `GreetingResources`，等同於資源檔的基底名稱。 這讓您能夠成功地具現化<xref:System.Resources.ResourceManager>藉由呼叫物件<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>建構函式。  
  
 請注意，輸出顯示適當的當地語系化字串除非目前 UI 文化特性是瑞典文 （瑞典），在此情況下，否則它會使用英文語言資源。 因為瑞典文語言資源無法使用，應用程式會使用預設文化特性的資源所定義<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性，改為。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceSource" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">資源檔的根名稱，不含副檔名但包括任何完整的命名空間。 例如，名為 MyApplication.MyResource.en-US.resources 的資源檔根目錄名稱是 MyApplication.MyResource。</param>
        <param name="assembly">資源的主要組件。</param>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體，這個執行個體會在所指的組件中查閱具有指定根名稱之檔案中的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>傳統型應用程式  
 在桌面應用程式，個別的特定文化特性的資源檔案應包含在附屬組件，並應該在主要組件中包含預設文化特性的資源檔。 附屬組件會假設包含在這個組件資訊清單中指定之單一文化特性的資源，而且會視需要載入。  
  
> [!NOTE]
>  若要從直接而不是擷取組件的.resources 檔擷取資源，您必須呼叫<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法而是要具現化<xref:System.Resources.ResourceManager>物件。  
  
 如果所識別的資源檔`baseName`中找不到`assembly`，此方法會具現化<xref:System.Resources.ResourceManager>物件，但嘗試擷取特定的資源則會擲回例外狀況，通常<xref:System.Resources.MissingManifestResourceException>。 如需診斷例外狀況的原因之詳細資訊，請參閱的 「 處理 MissingManifestResourceException 例外狀況 」 一節<xref:System.Resources.ResourceManager>類別主題。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，我們不建議使用它。 只有當您開發時，才使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]專案，可以搭配[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，使用[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，資源管理員使用的簡單名稱`assembly`應用程式的封裝資源索引 (PRI) 檔中設定的參數，以尋找相符的資源。 `baseName`參數用來查閱資源項目內的資源集。 比方說，PortableLibrary1.Resource1.de-DE.resources 根目錄名稱是 PortableLibrary1.Resource1。  
  
   
  
## Examples  
 下列範例會使用簡單的非當地語系化"Hello World"應用程式來說明<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>建構函式。 下圖顯示名為 ExampleResources.txt 文字檔的內容。 當編譯應用程式時，會將資源內嵌在主應用程式組件中。  
  
```  
Greeting=Hello  
```  
  
 文字檔可以轉換成二進位資源檔，藉由在命令提示字元，如下所示：  
  
```  
resgen ExampleResources.txt  
```  
  
 下列範例提供的可執行檔的程式碼，會具現化<xref:System.Resources.ResourceManager>物件，會提示使用者輸入名稱，並顯示問候語。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 它可以編譯 Visual Basic 中使用下列命令：  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 或者，在 C# 中使用下列命令：  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 請注意此範例會擷取藉由傳遞至該組件中定義的型別包含資源檔的組件的參考`typeof`函式 （在 C# 中) 或`GetType`函式 （Visual Basic 中），並擷取其值<xref:System.Type.Assembly%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> 或 <paramref name="assembly" /> 參數為 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>這個建構函式會使用系統提供<see cref="T:System.Resources.ResourceSet" />實作。 若要使用自訂資源檔案格式，您應該衍生自<see cref="T:System.Resources.ResourceSet" />類別中覆寫<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />並<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />方法和類型的 pass<see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />建構函式。 使用自訂<see cref="T:System.Resources.ResourceSet" />適合用於快取原則，或支援您自己的資源檔格式，控制資源，但通常不是必要的。</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">資源檔的根名稱，不含副檔名但包括任何完整的命名空間。 例如，名為 MyApplication.MyResource.en-US.resources 的資源檔根目錄名稱是 MyApplication.MyResource。</param>
        <param name="assembly">資源的主要組件。</param>
        <param name="usingResourceSet">要使用之自訂 <see cref="T:System.Resources.ResourceSet" /> 的型別。 如果是 <see langword="null" />，就會使用預設的執行階段 <see cref="T:System.Resources.ResourceSet" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Resources.ResourceManager" /> 類別的新執行個體，這個執行個體使用指定的 <see cref="T:System.Resources.ResourceSet" /> 類別查閱所指組件中具有指定根名稱的檔案所包含的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 個別的特定文化特性的資源檔案應包含在附屬組件，並應該在主要組件中包含預設文化特性的資源檔。 附屬組件會假設包含在這個組件資訊清單中指定之單一文化特性的資源，而且會視需要載入。  
  
> [!NOTE]
>  若要從直接而不是擷取組件的.resources 檔擷取資源，您必須呼叫<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>方法而是要具現化<xref:System.Resources.ResourceManager>物件。  
  
 如果所識別的資源檔`baseName`中找不到`assembly`，此方法會具現化<xref:System.Resources.ResourceManager>物件，但嘗試擷取特定的資源則會擲回例外狀況，通常<xref:System.Resources.MissingManifestResourceException>。 如需診斷例外狀況的原因之詳細資訊，請參閱的 「 處理 MissingManifestResourceException 例外狀況 」 一節<xref:System.Resources.ResourceManager>類別主題。  
  
> [!NOTE]
>  `usingResourceSet`參數用來支援您自己的資源格式，和執行個體通常會`null`。 這是不同的建構函式<xref:System.Type>只。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingResourceset" /> 不是 <see cref="T:System.Resources.ResourceSet" /> 的衍生類別。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> 或 <paramref name="assembly" /> 參數為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>這個建構函式可讓您指定<see cref="T:System.Resources.ResourceSet" />實作。 如果您不想在特定<see cref="T:System.Resources.ResourceSet" />但會實作例如若要使用自訂資源檔案格式，您應該從衍生<see cref="T:System.Resources.ResourceSet" />類別中覆寫<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />和<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />方法，並將傳遞類型給這個建構函式。</para></block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</summary>
        <value><see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A>屬性會反映完整命名空間名稱和資源檔，不含文化特性或檔案名稱副檔名的根資源名稱。 例如，如果名為應用程式的預設資源檔`SampleApps.StringResources.resources`，值<xref:System.Resources.ResourceManager.BaseName%2A>屬性是 「 SampleApps.StringResources"。 如果應用程式的預設資源檔的名稱為`SampleApps.StringResources.en-US.resources`內嵌在附屬組件的值和<xref:System.Resources.ResourceManager.BaseName%2A>屬性仍然是 「 SampleApps.StringResources"。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A>編譯並從命令列內嵌資源檔的屬性值不包含命名空間名稱，除非您明確加入一個編譯檔案時。 相反地，<xref:System.Resources.ResourceManager.BaseName%2A>資源檔編譯及通常內嵌於 Visual Studio 環境的屬性值包含預設命名空間名稱。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A>屬性值會是相同的字串傳遞至<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>或是<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>建構函式具現化時<xref:System.Resources.ResourceManager>執行個體。  
  
   
  
## Examples  
 您可以編譯並執行下列公用程式，以判斷內嵌的.resources 檔案的名稱。 這是主控台應用程式可接受的主要組件或附屬組件，做為命令列參數的名稱。 它會顯示應該做為提供的字串`baseName`的參數<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>或<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>建構函式，讓資源管理員能夠正確地識別資源。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 <see cref="T:System.Resources.ResourceManager" /> 搜尋資源的資源檔之根目錄名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField>的欄位非常實用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">資源的根目錄名稱。 例如，命名為「MyResource.en-US.resources」資源檔的根目錄名稱是「MyResource」。</param>
        <param name="resourceDir">要搜尋資源的目錄名稱。 <paramref name="resourceDir" /> 可以是絕對路徑或相對於應用程式目錄的路徑。</param>
        <param name="usingResourceSet">要使用之自訂 <see cref="T:System.Resources.ResourceSet" /> 的型別。 如果是 <see langword="null" />，就會使用預設的執行階段 <see cref="T:System.Resources.ResourceSet" /> 物件。</param>
        <summary>傳回 <see cref="T:System.Resources.ResourceManager" /> 物件，該物件會搜尋特定目錄而不是資源的組件資訊清單。</summary>
        <returns>資源管理員的新執行個體，會搜尋指定的目錄，而不是搜尋資源的組件資訊清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回的資源管理員可從沒有內嵌在組件的.resources 檔擷取資源。 您可以使用此<xref:System.Resources.ResourceManager>物件來載入 ASP.NET 網頁的資源，或測試<xref:System.Resources.ResourceSet>實作。  如需從獨立.resources 檔擷取資源的範例，請參閱 <<c0> [ 擷取資源](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)文章。  
  
 這個方法可讓您指定<xref:System.Resources.ResourceSet>實作。 如果您不想在特定<xref:System.Resources.ResourceSet>實作，但想要使用的自訂資源檔案格式中，您應該從衍生<xref:System.Resources.ResourceSet>類別中覆寫<xref:System.Resources.ResourceSet.GetDefaultReader%2A>和<xref:System.Resources.ResourceSet.GetDefaultWriter%2A>方法，並將傳遞類型給這個建構函式。  
  
> [!CAUTION]
>  使用獨立.resources 檔中的 ASP.NET 應用程式會中斷 XCOPY 部署，因為資源保持鎖定狀態，直到明確發行<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法。 如果您想要使用您的 ASP.NET 應用程式來部署資源，您.resources 檔案編譯成附屬組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> 或 <paramref name="resourceDir" /> 參數為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要擷取預設後援資源的位置。</summary>
        <value>其中一個列舉值，指定資源管理員可以在何處尋找後援資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A>屬性會很有用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 您可以使用<xref:System.Resources.NeutralResourcesLanguageAttribute>屬性，以通知資源管理員尋找應用程式中的預設文化特性的位置： 主要組件 （預設值） 或附屬組件中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">封裝和部署資源</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">為其傳回特定文化特性資訊的組件。</param>
        <summary>藉由擷取指定之組件上的 <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 屬性的值，傳回主要組件的預設資源的文化特性資訊。</summary>
        <returns>如果找到則為 <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 屬性中的文化特性，否則為不因國別而異的文化特性。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回針對目前文化特性所指定非字串資源的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要取得的資源名稱。</param>
        <summary>傳回指定的非字串資源的值。</summary>
        <returns>為呼叫端目前文化特性設定當地語系化的資源的值。 如果有適當的資源集，但找不到 <paramref name="name" />，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A>方法用來擷取非字串資源。 這些包括例如屬於基本資料類型的值<xref:System.Int32>或是<xref:System.Double>，點陣圖 (例如<xref:System.Drawing.Bitmap?displayProperty=nameWithType>物件)，或自訂序列化的物件。 一般而言，傳回的物件必須轉型 （在 C# 中)，或者 （在 Visual Basic) 轉換成適當型別的物件。  
  
 傳回的資源已針對目前的執行緒，所定義的 UI 文化特性當地語系化<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果未針對該文化特性當地語系化資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，則<xref:System.Resources.ResourceManager>切換回預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤已部署或安裝附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化的型別時，會擲回使用者定義的例外狀況。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您呼叫<xref:System.Resources.ResourceManager.GetObject%2A>方法多次相同`name`參數不相依於傳回的參考，每次呼叫相同物件的方法。 這是因為<xref:System.Resources.ResourceManager.GetObject%2A>方法可以傳回現有的資源物件的參考，在快取，或可以重新載入資源，並傳回新的資源物件的參考。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> 方法來還原序列化自訂物件。 此範例也包含名為 UIElements.cs （其中如果您使用 Visual Basic） 的原始程式碼檔，定義名為下列結構`PersonTable`。 此結構是為了供一般資料表顯示常式使用，以顯示資料表資料行的當地語系化名稱。 請注意， `PersonTable` 結構會以 <xref:System.SerializableAttribute> 屬性標記。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 下列程式碼來自於名為 CreateResources.cs (若是 Visual Basic 則為 CreateResources.vb) 的檔案，會建立用以儲存資料表標題的 XML 資源檔 UIResources.resx，以及包含針對英文語言當地語系化之應用程式資訊的 `PersonTable` 物件。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 原始程式碼檔 GetObject.cs (GetObject.vb) 中的下列程式碼會接著擷取資源，並將其顯示到主控台。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 您可以建立必要的資源檔和組件，並藉由執行下列批次檔來執行應用程式。 您必須使用 `/r` 選項將 UIElements.dll 的參考提供給 Resgen.exe，使其可以存取有關 `PersonTable` 結構的資訊。 如果使用 C#，請將 `vbc` 編譯器名稱取代成 `csc`，並將 `.vb` 副檔名取代成 `.cs`。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的當地語系化資源，也沒有預設的文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">封裝和部署資源</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">要取得的資源名稱。</param>
        <param name="culture">要當地語系化資源的文化特性。 如果此文化特性的資源未當地語系化，則資源管理員會使用後援規則來尋找適當的資源。  
  
如果這個值是 <see langword="null" />，則會使用 <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> 屬性取得 <see cref="T:System.Globalization.CultureInfo" /> 物件。</param>
        <summary>取得針對指定的文化特性當地語系化之所指定非字串資源的值。</summary>
        <returns>為指定文化特性當地語系化的資源的值。 如果有適當的資源集，但找不到 <paramref name="name" />，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>方法用來擷取非字串資源。 這些包括例如屬於基本資料類型的值<xref:System.Int32>或是<xref:System.Double>，點陣圖 (例如<xref:System.Drawing.Bitmap?displayProperty=nameWithType>物件)，或自訂序列化的物件。 一般而言，傳回的物件必須轉型 （在 C# 中)，或者 （在 Visual Basic) 轉換成適當型別的物件。  
  
 傳回的資源已當地語系化為所指定的文化特性`culture`，或所指定的文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性若`culture`是`null`。 如果未針對該文化特性當地語系化資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，資源管理員便會回到預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤已部署或安裝附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化的型別時，會擲回使用者定義的例外狀況。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您呼叫<xref:System.Resources.ResourceManager.GetObject%2A>方法多次相同`name`參數不相依於傳回的參考，每次呼叫相同物件的方法。 這是因為<xref:System.Resources.ResourceManager.GetObject%2A>方法可以傳回現有的資源物件的參考，在快取，或可以重新載入資源，並傳回新的資源物件的參考。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> 方法來還原序列化自訂物件。 此範例也包含名為 NumberInfo.cs (NumberInfo.vb 如果您使用 Visual Basic) 的原始程式碼檔，定義名為下列結構`Numbers`。 此結構被要教導 non-alpha Non-english 讀出學生，計數為 10 英文的簡單教育應用程式使用。 請注意，`Numbers`類別標示有<xref:System.SerializableAttribute>屬性。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 從檔案的下列原始程式碼具名的 CreateResources.cs （若是 Visual Basic 則） 會建立預設的英文語言，以及法文、 葡萄牙文和俄文語言，XML 資源檔。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 下列應用程式，將目前的 UI 文化特性設定為法文 （法國）、 葡萄牙文 （巴西） 或俄文 （俄羅斯） 所耗用的資源。 它會呼叫<xref:System.Resources.ResourceManager.GetObject%28System.String%29>方法來取得`Numbers`物件，其中包含當地語系化的數字並<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>方法來取得`Numbers`物件，其中包含英文語言的數字。 然後，它會顯示使用目前的 UI 文化特性和英文語言的奇數。 原始程式碼檔名為 ShowNumbers.cs (ShowNumbers.vb)。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 您可以使用下列的批次檔來建置並執行範例的 Visual Basic 版本。 如果您使用 C#，取代`vbc`具有`csc`，並取代`.vb`副檔名`.cs`。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />方法是安全執行緒。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">封裝和部署資源</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">要建構資源檔案名稱的文化特性物件。</param>
        <summary>為所指 <see cref="T:System.Globalization.CultureInfo" /> 物件產生資源檔的名稱。</summary>
        <returns>可用於所指 <see cref="T:System.Globalization.CultureInfo" /> 物件之資源檔的名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A>方法會很有用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 這個方法會使用<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>一部分而異的文化特性以外的所有文化特性的檔案名稱的屬性。 這個方法不會尋找組件資訊清單或觸控磁碟，並僅用來建構資源檔案名稱 (適用於傳遞至<xref:System.Resources.ResourceReader>建構函式) 或資訊清單資源的 blob 名稱。  
  
 在衍生的類別可以覆寫這個方法，以尋找不同的副檔名，例如"。ResX"或完全不同的配置，來命名資源檔。 請注意，自訂的附屬組件內的資源檔名稱，而非自訂的附屬組件本身的名稱，可以使用方法。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">全球化與當地語系化 .NET 應用程式</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">要擷取其資源的文化特性。</param>
        <param name="createIfNotExists">要載入尚未載入的資源集合則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="tryParents"><see langword="true" /> 表示如果找不到資源集時，就要使用資源後援來載入適當的資源；<see langword="false" /> 表示要略過資源後援程序。</param>
        <summary>擷取特定文化特性設定的資源。</summary>
        <returns>所指定文化特性的資源集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會傳回資源集表示指定的文化特性當地語系化的資源。 如果未針對該文化特性當地語系化的資源並`tryParents`已`true`，<xref:System.Resources.ResourceManager.GetResourceSet%2A>會使用資源後援規則來載入適當的資源。 如果`tryParents`已`false`且找不到特定文化特性的資源集，則方法會傳回`null`。 如需有關資源後援的詳細資訊，請參閱 「 資源後援處理序 」 一節[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)文章。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Resources.ResourceManager.GetResourceSet%2A>方法來擷取特定文化特性的資源，法文 （法國） 文化特性。 接著它會列舉中的所有資源的資源集。 它包含名為 ShowNumbers.exe 的可執行檔的原始程式碼。 它也包含下列兩個文字檔包含數字的名稱。 第一天，NumberResources.txt，包含數字，介於 1 到 10 的英文語言的名稱：  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 第二個，NumberResources.fr-FR.txt，包含一到四個法文語言的數字的名稱：  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 您可以使用批次檔，以產生資源檔，將英文語言資源檔內嵌到可執行檔，並建立法文語言資源的附屬組件。 以下是使用 Visual Baisc 編譯器產生可執行檔的批次檔：  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 對於 C# 編譯器，您可以使用下列的批次檔：  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 請注意，如果您變更的值`createIfNotExists`引數`false`，方法呼叫傳回`null`，因為 Resource Manager 尚未載入的法文語言資源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents" /> 為 <see langword="true" />，找不到一組可用的資源，也沒有預設文化特性資源。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">全球化與當地語系化 .NET 應用程式</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">要檢查其 <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 屬性的組件。</param>
        <summary>傳回所指組件中 <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 屬性所指定的版本。</summary>
        <returns>指定組件的附屬合約版本，如果找不到版本，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關附屬組件版本控制的詳細資訊，請參閱<xref:System.Resources.SatelliteContractVersionAttribute>參考主題。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在組件 <paramref name="a" /> 中找到的 <see cref="T:System.Version" /> 無效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="a" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從指定的資源傳回 Unmanaged 記憶體資料流物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">資源的名稱。</param>
        <summary>從指定的資源傳回 Unmanaged 記憶體資料流物件。</summary>
        <returns>代表資源的 Unmanaged 記憶體資料流物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>方法會儲存為資源名稱<xref:System.IO.MemoryStream>物件中取得的值<xref:System.Object>資源，並傳回<xref:System.IO.UnmanagedMemoryStream>物件。 它需要您直接與您再將它轉換成物件的位元組資料流工作。 此方法適合主要是基於效能考量：擷取的位元組資料流，而不是明確的物件形式的資源，可以改善效能。  
  
 傳回的資源已針對目前的執行緒，所定義的 UI 文化特性當地語系化<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果未針對該文化特性當地語系化資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，則<xref:System.Resources.ResourceManager>切換回預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
   
  
## Examples  
 下列範例使用 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> 方法來擷取應用程式開頭顯示畫面視窗中使用的點陣圖。 下列原始程式碼檔案，名為 CreateResources.cs （適用於 C#) 或 CreateResources.vb （適用於 Visual Basic 中) 會產生名為 AppResources.resx 包含序列化的影像的.resx 檔案。 在此情況下，會從名為 SplashScreen.jpg 的檔案載入影像；您可以修改檔案名稱以替代成您自己的影像。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 下列程式碼會從名為 GetStream.cs （C# 中) 的檔案，或 （適用於 Visual Basic) GetStream.vb 然後擷取資源，並會顯示在 映像<xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType>控制項。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 您可以使用下列批次檔來建立 C# 範例。 若是 Visual Basic，請將 `csc` 變更為 `vbc`，並將原始程式碼檔案的副檔名從 `.cs` 變更為 `.vb`。 
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定之資源的值不是 <see cref="T:System.IO.MemoryStream" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">資源的名稱。</param>
        <param name="culture">物件，其指定要用於資源查閱的文化特性。 如果 <paramref name="culture" /> 為 <see langword="null" />，則會使用目前執行緒的文化特性。</param>
        <summary>使用指定的文化特性，從指定的資源傳回 Unmanged 記憶體資料流物件。</summary>
        <returns>代表資源的 Unmanaged 記憶體資料流物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>方法會儲存為資源名稱<xref:System.IO.MemoryStream>物件中取得的值<xref:System.Object>資源，並傳回<xref:System.IO.UnmanagedMemoryStream>物件。 它需要您直接與您再將它轉換成物件的位元組資料流工作。 此方法適合主要是基於效能考量：擷取的位元組資料流，而不是明確的物件形式的資源，可以改善效能。  
  
 傳回的資源已當地語系化為所指定的文化特性`culture`，或所指定的文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性若`culture`是`null`。 如果未針對該文化特性當地語系化資源，資源管理員會使用後援規則來載入適當的資源。 如果找到一組可用的當地語系化資源，則<xref:System.Resources.ResourceManager>切換回預設文化特性的資源。 如果找不到設定的預設文化特性的資源，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定之資源的值不是 <see cref="T:System.IO.MemoryStream" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到一組可用的資源，也沒有預設資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定的文化特性或目前 UI 文化特性的指定字串資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要擷取的資源名稱。</param>
        <summary>傳回指定的字串資源的值。</summary>
        <returns>針對呼叫端的目前 UI 文化特性當地語系化的資源的值，或者為<see langword="null" /> (如果在資源集中找不到<paramref name="name" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>傳統型應用程式  
 桌面應用程式，將資源傳回當地語系化的 UI 文化特性，目前的執行緒，所定義<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。 如果沒有當地語系化文化特性的資源，資源管理員來探查資源中的 < Resource Fallback Process > 一節所述的步驟[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)文章。 如果找到一組可用的當地語系化資源，資源管理員便會回到預設文化特性的資源。 如果資源管理員無法載入預設文化特性的資源集，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤已部署或安裝附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化的型別時，會擲回使用者定義的例外狀況。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，我們不建議使用它。 只有當您開發時，才使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]專案，可以搭配[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，使用[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請<xref:System.Resources.ResourceManager.GetString%28System.String%29>方法傳回的值`name`字串呼叫端的目前 UI 文化特性設定當地語系化的資源。 文化特性的清單被來自作業系統的慣用 UI 語言清單。 如果資源管理員不符合`name`，則方法會傳回`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取特定文化特性的資源。 它包含英文 (en)、 法文 （法國） (FR-FR) 和俄文 （俄羅斯） (RU-RU).txt 檔案從所編譯的資源文化特性。 範例變更英文 （美國）、 法文 （法國）、 俄文 （俄國） 和瑞典文 （瑞典） 的目前 UI 文化特性與目前的文化特性。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法來擷取當地語系化的字串，它會顯示與目前的日期和月份。 請注意，輸出會顯示適當的當地語系化的字串，除非目前 UI 文化特性是瑞典文 （瑞典）。 因為瑞典文語言資源無法使用，應用程式會改為使用預設文化特性的資源，也就是英文。 這個範例需要下表所列的文字為基礎的資源檔。 每個都有單一的字串資源，名為`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 您可以使用下列批次檔來編譯 C# 範例。 若是 Visual Basic，請將 `csc` 變更為 `vbc`，並將原始程式碼檔案的副檔名從 `.cs` 變更為 `.vb`。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 以下是範例 (Visual Basic 版本的 ShowDate.vb) 或 ShowDate.cs C# 版本的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定資源的值不是字串。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的資源，也沒有預設文化特性資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String)" />方法是安全執行緒。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">封裝和部署資源</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">擷取附屬組件中的資源</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">要擷取的資源名稱。</param>
        <param name="culture">物件，表示資源要當地語系化的文化特性。</param>
        <summary>傳回為指定文化特性當地語系化之字串資源的值。</summary>
        <returns>針對指定文化特性當地語系化的資源的值，或者為<see langword="null" /> (如果在資源集中找不到<paramref name="name" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>傳統型應用程式  
 桌面應用程式，如果`culture`已`null`，則<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法會使用目前的 UI 文化特性取自<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>屬性。  
  
 會傳回該資源已針對指定的文化特性當地語系化`culture`參數。 如果未針對當地語系化的資源`culture`，資源管理員會探查資源中的 < Resource Fallback Process > 一節所述的步驟[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主題。 如果找到一組可用的資源，資源管理員便會回到預設文化特性的資源。 如果資源管理員無法載入預設文化特性的資源集，方法會擲回<xref:System.Resources.MissingManifestResourceException>例外狀況或，如果位於附屬組件中，預期的資源集<xref:System.Resources.MissingSatelliteAssemblyException>例外狀況。 如果資源管理員可以載入適當的資源設定，但找不到名為的資源`name`，則方法會傳回`null`。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性會決定是否比較`name`的資源名稱不區分大小寫 （預設值） 或區分大小寫。  
  
> [!CAUTION]
>  這個方法可以擲回非列出的例外狀況。 這可能會發生的其中一個原因是如果這個方法會呼叫的方法會擲回例外狀況。  例如，<xref:System.IO.FileLoadException>可能會擲回例外狀況，如果錯誤已部署或安裝附屬組件，或<xref:System.Runtime.Serialization.SerializationException>可能會擲回例外狀況，如果使用者定義型別在還原序列化的型別時，會擲回使用者定義的例外狀況。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式  
  
> [!IMPORTANT]
>  雖然<xref:System.Resources.ResourceManager>類別支援[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，我們不建議使用它。 只有當您開發時，才使用這個類別[!INCLUDE[net_portable](~/includes/net-portable-md.md)]專案，可以搭配[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式。 若要擷取的資源[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，使用[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)類別。  
  
 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]應用程式，請<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法傳回的值`name`字串所指定文化特性當地語系化的資源`culture`參數。 如果未針對當地語系化的資源`culture`文化特性，查閱會使用到整個[!INCLUDE[win8](~/includes/win8-md.md)]後援語言的清單，以及查詢中的預設文化特性的停駐點。 如果資源管理員不符合`name`，則方法會傳回`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>方法來擷取特定文化特性的資源。 此範例的預設文化特性是英文 (en)，以及它包含法文 （法國） (FR-FR) 和俄文 （俄羅斯） (RU-RU) 的附屬組件文化特性。 範例會變更目前文化特性和目前 UI 文化特性為俄文 （俄羅斯） 然後再呼叫<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>。 然後它會呼叫<xref:System.Resources.ResourceManager.GetString%2A>方法和<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法，並傳遞<xref:System.Globalization.CultureInfo>代表每個方法的法文 （法國） 和瑞典文 （瑞典） 文化特性的物件。 在輸出中，月份和日期的月份，以及在它們前面的字串會以法文顯示，因為<xref:System.Resources.ResourceManager.GetString%2A>方法也能夠將擷取的法文語言資源。 不過，使用瑞典文 （瑞典） 文化特性時，月份的日期與月份出現在瑞典文，雖然它們在前面的字串都使用英文。 這是因為 resource manager 找不到當地語系化瑞典文語言資源，使其改為傳回預設的英文文化特性的資源。  
  
 這個範例需要下表所列的文字為基礎的資源檔。 每個都有單一的字串資源，名為`DateStart`。  
  
|culture|檔案名稱|資源名稱|資源值|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|假設今天是|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui，愜意 le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 您可以使用下列的批次檔來編譯 Visual Basic 範例。 若要編譯 C# 中，變更`vbc`來`csc`，並將變更從原始程式碼檔的副檔名`.vb`至`.cs`。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 以下是範例 (Visual Basic 版本的 ShowDate.vb) 或 ShowDate.cs C# 版本的原始程式碼。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定資源的值不是字串。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">找不到任何一組可用的資源，也沒有預設文化特性的資源。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">預設文化特性的資源位於找不到的附屬組件中。 如需如何處理這個例外狀況的詳細資訊，請參閱 <see cref="T:System.Resources.ResourceManager" /> 類別主題中的＜處理 MissingManifestResourceException 和 MissingSatelliteAssemblyException 例外狀況＞一節。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />方法是安全執行緒。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">封裝和部署資源</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定目前 <see cref="T:System.Resources.ResourceManager" /> 的實作能夠解譯和產生的資源檔標頭版本。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出資源管理員是否允許在 <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> 和 <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> 方法中進行不區分大小寫的資源查詢。</summary>
        <value>若要在資源查閱時忽略大小寫則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值<xref:System.Resources.ResourceManager.IgnoreCase%2A>屬性是`false`，名為 「 資源 」 資源並不相同的名稱 「 資源 」 的資源。 如果<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`，名為 「 資源 」 資源相當於具有名稱 「 資源 」 的資源。 不過請注意，當<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`，則<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType>和<xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType>方法使用而異的文化特性執行不區分大小寫的字串比較。 優點是，這些方法所執行的不區分大小寫的字串比較的結果是不論文化特性的所有電腦上相同。 缺點是，結果不一致的所有文化特性的大小寫規則。  
  
 比方說，土耳其文的字母會有兩個字元 i： 一個加上一個點版本，一個沒有點。 在土耳其文，字元我 (Unicode 0049) 會視為不同字元 ı (Unicode 0131) 的大寫版本。 I (Unicode 0069) 的字元會被視為另一個字元 İ (Unicode 0130) 的小寫版本。 根據這些大小寫規則，不區分大小寫的字串比較的字元 (Unicode 0069) i 和 I (Unicode 0049) 應該會失敗"TR-TR"（在土耳其買的土耳其文） 的文化特性。 不過，因為使用的文化特性而異的大小寫規則，如果執行的比較<xref:System.Resources.ResourceManager.IgnoreCase%2A>是`true`，這項比較會成功。  
  
> [!NOTE]
>  基於效能考量，最好是一律指定正確的大小寫，為您的資源名稱。 設定<xref:System.Resources.ResourceManager.IgnoreCase%2A>至`true`可能會大幅增加造成工作集和效能的大幅下降。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">要尋找的文化特性物件。</param>
        <param name="createIfNotExists">要載入尚未載入的資源集合則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="tryParents">如果無法載入資源集，就要檢查父代 <see cref="T:System.Globalization.CultureInfo" /> 物件則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>提供用來尋找資源集的實作。</summary>
        <returns>指定的資源集。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">主要組件不包含 .resources 檔，該檔案為查閱資源所必要。</exception>
        <exception cref="T:System.ExecutionEngineException">執行階段發生內部錯誤。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">找不到與 <paramref name="culture" />相關聯的附屬組件。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <block subset="none" type="overrides"><para>這個方法會完成尋找資源集，並可以是遞迴和可重新進入所需的所有工作。 換句話說，這個方法可能會載入組件和觸發程序<see cref="E:System.AppDomain.AssemblyLoad" />事件，然後呼叫回<see cref="T:System.Resources.ResourceManager" />尚未完全初始化的物件。 若要避免額外的鎖定，這個方法不是安全執行緒。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />， <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />，和<see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />方法進行所有必要的同步處理。</para></block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">全球化與當地語系化 .NET 應用程式</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>保留用來識別資源檔的編號。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值設定為 0xBEEFCACE。 第一個系統預設的檔案格式的四個位元組包含位元組由小到大格式的 32 位元帶正負號的整數 (請參閱<xref:System.Text.Encoding>)。  
  
 如果<xref:System.Resources.ResourceManager.MagicNumber>找到，則其後的位元組會的版本號碼<xref:System.Resources.ResourceManager>標頭，後面接著數字，指出應該略過多少個位元組，以通過此標頭。 下一個數字表示的版本<xref:System.Resources.ResourceManager>所建立的標頭中，然後再加上版本特定資訊。  
  
 目前的實作的版本號碼是其中一個。 下一個位元組會包含名稱的長度前置字串<xref:System.Resources.IResourceReader>，可以讀取此檔案的來源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定包含資源的主要組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly>的欄位非常實用，只有當您撰寫您自己的類別衍生自<xref:System.Resources.ResourceManager>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示資源管理員要呼叫所有 <see cref="T:System.Resources.ResourceSet" /> 物件上的 <see cref="M:System.Resources.ResourceSet.Close" /> 方法並釋放所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會壓縮執行中應用程式中的工作集。 這在任何未來的資源查閱<xref:System.Resources.ResourceManager>物件會耗費資源的第一個查閱，因為資源管理員需要搜尋重新載入資源。 這可用於一些複雜的執行緒案例，其中建立新<xref:System.Resources.ResourceManager>物件是適當的行為。  
  
> [!NOTE]
>  從.NET Framework 2.0 版中，開始<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>方法並不是執行緒安全相對於<xref:System.Resources.ResourceManager.GetObject%2A>， <xref:System.Resources.ResourceManager.GetString%2A>，和<xref:System.Resources.ResourceManager.GetStream%2A>作業。 這項變更的優點是多個執行緒存取資源的效能改善。 不過，如果您呼叫<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>同時又在另一個執行緒取得資源的一個執行緒中的方法，取得作業會擲回<xref:System.ObjectDisposedException>例外狀況。  
  
 您也可以在受管理的執行個體，由目前的資源管理員所建立的資源，必須確定的方式，發行，而不需等到完全超出範圍而遭到記憶體回收，資源管理員的情況下使用這個方法。  
  
> [!NOTE]
>  呼叫這個方法不會卸載附屬組件。 若要卸載附屬組件，使用<xref:System.AppDomain.Unload%2A>方法。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含 <see cref="T:System.Collections.Hashtable" />，其傳回從文化特性到 <see cref="T:System.Resources.ResourceSet" /> 物件的對應。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資源管理員用來建構 <see cref="T:System.Resources.ResourceSet" /> 物件之資源集物件的型別。</summary>
        <value>資源管理員用來建構 <see cref="T:System.Resources.ResourceSet" /> 物件之資源集物件的型別。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>