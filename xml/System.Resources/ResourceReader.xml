<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2814539bf76d998ae0f4c7bdb789f22102804ce" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52734769" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>讀取循序資源名稱/值組，以列舉二進位資源 (.resources) 檔案中的資源。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceReader>類別提供的標準實作<xref:System.Resources.IResourceReader>介面。 A<xref:System.Resources.ResourceReader>獨立.resources 檔或.resources 檔案內嵌於組件執行個體所表示。 它用來列舉.resources 檔案中的資源，並擷取其名稱/值組。 不同於<xref:System.Resources.ResourceManager>類別，用來擷取組件中內嵌的.resources 檔案中指定的具名的資源。 <xref:System.Resources.ResourceManager>類別用來擷取其名稱事先已知的資源，而<xref:System.Resources.ResourceReader>類別可用於擷取其數字或確切名稱不在編譯時期已知的資源。 比方說，應用程式可能會使用資源檔來儲存組態資訊會組織成各節，並在區段中，其中的區段或區段中的項目數目事先不知道的項目。 可以再以一般方式命名資源 (例如`Section1`， `Section1Item1`，`Section1Item2`等等) 以及使用抓取的<xref:System.Resources.ResourceReader>物件。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 如需有關使用<xref:System.Resources.ResourceReader>類別，請參閱下列各節：  
  
-   [Objekt ResourceReader 物件具現化](#instantiate)  
  
-   [列舉 objekt ResourceReader 物件的資源](#enumerate)  
  
    -   [藉由使用 IDictionaryEnumerator 屬性擷取的資源](#idictionaryenumerator)  
  
    -   [依名稱和 GetResourceData 擷取資源](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Objekt ResourceReader 物件具現化  
 .Resources 檔案是二進位檔案已從文字檔或 XML.resx 檔案編譯[Resgen.exe （資源檔產生器）](~/docs/framework/tools/resgen-exe-resource-file-generator.md)。 A<xref:System.Resources.ResourceReader>物件可代表獨立.resources 檔或.resources 檔案包含已內嵌在組件。  
  
 若要具現化<xref:System.Resources.ResourceReader>物件讀取從獨立.resources 檔，使用<xref:System.Resources.ResourceReader>類別建構函式的輸入資料流或包含的.resources 檔案名稱的字串。 下列範例說明這兩種方法。 第一個具現化<xref:System.Resources.ResourceReader>物件，代表名為.resources 檔案`Resources1.resources`使用其檔案名稱。 第二個具現化<xref:System.Resources.ResourceReader>物件，代表名為.resources 檔案`Resources2.resources`藉由建立從檔案資料流。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 若要建立<xref:System.Resources.ResourceReader>物件，表示內嵌的.resources 檔案中，具現化<xref:System.Reflection.Assembly>從內嵌的.resources 檔所在的組件的物件。 其<xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>方法會傳回<xref:System.IO.Stream>可以傳遞給物件<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>建構函式。 下列範例會具現化<xref:System.Resources.ResourceReader>物件，表示內嵌的.resources 檔案。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>列舉 objekt ResourceReader 物件的資源  
 若要列舉的.resources 檔案中的資源，請呼叫<xref:System.Resources.ResourceReader.GetEnumerator%2A>方法，以傳回<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>物件。 您呼叫`IDictionaryEnumerator.MoveNext`方法，以從一個資源移到下一步。 此方法會傳回`false`當.resources 檔案中的所有資源皆已都列舉。  
  
> [!NOTE]
>  雖然<xref:System.Resources.ResourceReader>類別會實作<xref:System.Collections.IEnumerable>介面並<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>方法，<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法不會提供<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>實作。 相反地，<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法會傳回<xref:System.Collections.IDictionaryEnumerator>介面的物件，可讓您存取每個資源的名稱/值組。  
  
 您可以擷取個別的資源集合中兩種方式：  
  
-   您可以逐一查看每個資源中的<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>收集與使用<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>来擷取的資源名稱和值的屬性。 所有資源都都相同的類型，或您知道每個資源的資料類型時，我們會建議這項技術。  
  
-   您可以擷取每個資源的名稱，當您逐一查看<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>集合並且呼叫<xref:System.Resources.ResourceReader.GetResourceData%2A>方法來擷取資源的資料。 當您不知道每個資源的資料類型，或上一個方法會擲回的例外狀況，我們會建議這種方法。  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>藉由使用 IDictionaryEnumerator 屬性擷取的資源  
 列舉資源的.resources 檔案中的第一個方法牽涉到直接擷取每個資源的名稱/值組。 在您呼叫後`IDictionaryEnumerator.MoveNext`方法來移動每個資源，在集合中，您可以擷取資源名稱<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>屬性和資源資料<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性。  
  
 下列範例示範如何使用擷取的名稱和值的每個.resources 檔案中的資源<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性。 若要執行範例，請建立下列名為 ApplicationResources.txt 定義字串資源的文字檔。  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 然後，您可以將文字資源檔轉換為二進位檔案，使用下列命令來命名 ApplicationResources.resources:  
  
 **resgen ApplicationResources.txt**  
  
 下列範例會接著使用<xref:System.Resources.ResourceReader>類別列舉在獨立二進位.resources 檔中的每個資源，並顯示其索引鍵名稱和對應的值。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 嘗試擷取資源資料，從<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性可能會擲回下列例外狀況：  
  
-   A<xref:System.FormatException>如果資料不是預期的格式。  
  
-   A<xref:System.IO.FileNotFoundException>如果找不到組件，其中包含資料所屬的類型。  
  
-   A<xref:System.TypeLoadException>找不到如果資料所屬的類型不能。  
  
 一般而言，如果.resources 檔案已經手動修改，如果型別定義所在的組件未包含與應用程式，或已意外刪除，或組件是較舊的版本之前會擲回這些例外狀況一種類型。 如果擲回其中一個例外狀況時，您可以列舉每個資源，並呼叫來擷取資源<xref:System.Resources.ResourceReader.GetResourceData%2A>方法，如下一節所示。 此方法會提供您一些資料相關資訊類型<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性嘗試傳回。  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>依名稱和 GetResourceData 擷取資源  
 列舉資源的.resources 檔案中的第二個方法也牽涉到巡覽檔案中的資源，藉由呼叫`IDictionaryEnumerator.MoveNext`方法。 您可以針對每個資源，擷取資源的名稱，從<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>屬性，然後傳遞至<xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29>方法來擷取資源的資料。 這會當做位元組陣列傳回`resourceData`引數。  
  
 這個方法會比擷取的資源名稱和值，從更棘手<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性，因為它會傳回表單資源值的實際位元組數。 不過，如果嘗試擷取資源則會擲回例外狀況，<xref:System.Resources.ResourceReader.GetResourceData%2A>方法可協助您識別例外狀況的來源，藉由提供資源的資料類型的相關資訊。 如需有關此字串會指出資源的資料類型的詳細資訊，請參閱<xref:System.Resources.ResourceReader.GetResourceData%2A>。  
  
 下列範例說明如何使用這種方法，來擷取資源，並處理所擲回任何例外狀況。 以程式設計方式建立包含四個字串、 一個布林值、 一個整數，一個點陣圖和一個自訂的二進位.resources 檔案`DateTimeTZI`物件。 若要執行範例，請執行下列作業：  
  
1.  建立名為 Golden/library/bin/debug/netstandard1.4 包含組件`DateTimeTZI`結構。 以下是組件的原始程式碼。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     編譯 C# 原始程式碼使用下列命令：  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     或者，您可以先將它在 Visual Basic 中編譯，使用下列命令：  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  編譯並執行以下的原始碼，這會建立名為 ContactResources.resources 的.resources 檔案。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     原始程式碼檔名為 CreateResources.cs。 您可以編譯，則 C# 中使用下列命令：  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     或者，您可以先將它在 Visual Basic 中編譯，使用下列命令：  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  編譯並執行下列的程式碼，以列舉 ContactResources.resources 檔案中的資源。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     修改原始碼之後 (比方說，是藉由刻意擲回<xref:System.FormatException>結尾處`try`區塊) 或重新命名 Golden/library/bin/debug/netstandard1.4 組件，以便在執行階段無法使用，您可以執行以查看範例如何呼叫<xref:System.Resources.ResourceReader.GetResourceData%2A>可讓您擷取或重新建立某些資源資訊。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Resources.ResourceReader" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用於讀取資源的輸入資料流。</param>
        <summary>為指定的資料流，初始化 <see cref="T:System.Resources.ResourceReader" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>建構函式具現化<xref:System.Resources.ResourceReader>物件，擷取的資源或獨立.resources 檔從.resources 檔，內嵌在組件。 若要讀取從獨立.resources 檔，具現化<xref:System.IO.Stream>物件，並將它傳遞給<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>建構函式。 若要從內嵌的.resources 檔案讀取，呼叫<xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>.resources 檔案，並傳遞所傳回的區分大小寫名稱的方法<xref:System.IO.Stream>物件到<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>建構函式。  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 本章節中的範例使用下列的.txt 檔名為`PatientForm.txt`來定義應用程式所使用的資源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 您可以編譯成.resources 檔案的.txt 檔案，藉由發出下列命令：  
  
 **resgen PatientForm.txt**  
  
 下列範例會假設資源檔嵌入組件，其中包含應用程式的可執行程式碼。 它會擷取名為`PatientForm.resources`從目前正在執行的組件，並顯示的名稱和其資源的每個值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 若為 C# 範例`Example.cs`，您可以使用下列命令來編譯：  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 若為 Visual Basic 範例`Example.vb`，您可以使用下列命令來編譯：  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> 參數無法讀取。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">存取 <paramref name="stream" /> 時發生 I/O 錯誤。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供序列化服務。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要讀取的資源檔路徑和名稱。 <c>filename</c> 不區分大小寫。</param>
        <summary>為指定的具名資源檔初始化 <see cref="T:System.Resources.ResourceReader" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29>建構函式具現化<xref:System.Resources.ResourceReader>從獨立.resources 檔擷取資源的物件。 若要從內嵌的.resources 檔擷取資源，請使用<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>建構函式。  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 本章節中的範例使用下列的.txt 檔名為`PatientForm.txt`來定義應用程式所使用的資源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 您可以編譯成.resources 檔案的這個.txt 檔案，藉由發出下列命令：  
  
 **resgen PatientForm.txt**  
  
 下列範例會列舉中的資源`PatientForm.resources`並顯示名稱和每個值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.BadImageFormatException">資源檔的格式無效。 例如，檔案的長度可為零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將與這個 <see cref="T:System.Resources.ResourceReader" /> 物件相關聯的所有作業系統資源釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> 可以安全地呼叫多次。  
  
   
  
## Examples  
 下列範例會通過檔案的資源，並顯示找到的所有索引鍵/值組。 程式碼接著會使用<xref:System.Resources.ResourceReader.Close%2A>方法來關閉<xref:System.Resources.ResourceReader>並釋放它所使用的所有資源。  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Resources.ResourceReader" /> 類別目前的執行個體所使用的全部資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您完成使用這個執行個體<xref:System.Resources.ResourceReader>，呼叫<xref:System.Resources.ResourceReader.Dispose%2A>釋放這個執行個體所使用的所有資源。 您應該刪除此的進一步參考<xref:System.Resources.ResourceReader>執行個體，以便記憶體回收行程可以回收的執行個體，而不是讓它保持運作進行最終處理的記憶體。  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> 會呼叫私用的 dispose （boolean） 方法，其中包含要釋放 managed 和 unmanaged 資源的程式碼。 如需詳細資訊，請參閱 <<c0> [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Resources.ResourceReader" /> 物件的列舉值。</summary>
        <returns>這個物件 <see cref="T:System.Resources.ResourceReader" /> 的列舉值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，您藉由呼叫，會在列舉資源時<xref:System.Resources.ResourceReader.GetEnumerator%2A>方法，然後重複呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>方法傳回<xref:System.Collections.IDictionaryEnumerator>物件，直到此方法會傳回`false`。 資源名稱是可從<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>屬性，它的值，從<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>屬性。 此範例說明如何列舉在這種方式中的資源。  
  
 實作<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>依據屬性<xref:System.Resources.ResourceReader>類別可能會擲回下列例外狀況：  
  
-   <xref:System.IO.FileNotFoundException>  
  
     找不到組件，其中包含資料所屬的類型。  
  
-   <xref:System.FormatException>  
  
     資料不是預期的格式。  
  
-   <xref:System.TypeLoadException>  
  
     找不到資料所屬的類型。  
  
 您可以藉由呼叫處理例外狀況<xref:System.Resources.ResourceReader.GetResourceData%2A>方法來擷取資訊的資料類型和位元組陣列指派給具名的資源。 如需詳細資訊，請參閱中的 「 擷取資源的名稱與 GetResourceData 」 一節<xref:System.Resources.ResourceReader>類別主題。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader>類別包含兩個方法會傳回列舉值。 <xref:System.Resources.ResourceReader.GetEnumerator%2A>方法會傳回<xref:System.Collections.IDictionaryEnumerator>介面物件，並會列舉資源時要呼叫的建議的方法。  
  
   
  
## Examples  
 本章節中的範例使用下列的.txt 檔名為`PatientForm.txt`來定義應用程式所使用的資源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 您可以編譯成.resources 檔案的.txt 檔案，藉由發出下列命令：  
  
 **resgen PatientForm.txt**  
  
 下列範例會列舉中的資源`PatientForm.resources`並顯示名稱和每個值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">讀取器已關閉或已處置，因此無法存取。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">資源的名稱。</param>
        <param name="resourceType">這個方法傳回時，包含表示所擷取資源類型名稱的字串。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="resourceData">當這個方法傳回時，會包含以所擷取類型之二進位表示的位元組陣列。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>從開啟的資源檔或資料流，擷取具名資源的類型名稱和資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A>方法會擷取具名的資源做為位元組陣列值。 這通常是使用<xref:System.Collections.IDictionaryEnumerator.Value%2A>屬性在嘗試擷取資源的值時，會擲回例外狀況。  
  
 `resourceType` 是字串，表示資源的資料類型。 它可以是下列值之一：  
  
-   字串表示`ResourceTypeCode`列舉的成員，表示資源的資料類型。 `ResourceTypeCode` 是。 若要使用的私用列舉表示特殊的二進位格式用來儲存一種 19 一般的資料類型。 這些包括.NET Framework 的基本資料型別 (<xref:System.Boolean>， <xref:System.Byte>， <xref:System.Char>， <xref:System.Decimal>， <xref:System.Double>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.Single>， <xref:System.SByte>， <xref:System.UInt16>， <xref:System.UInt32>， <xref:System.UInt64>)，以及<xref:System.String>， <xref:System.DateTime>，和<xref:System.TimeSpan>，此外，`ResourceTypeCode`列舉會包含下表中顯示的值。  
  
    |ResourceTypeCode 值|描述|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|資料是一個位元組陣列。 通常，這個資料類型是從呼叫的結果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType>方法。|  
    |`ResourceTypeCode.Null`|資料為 null 參考。 通常，這個資料類型是從呼叫的結果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType>物件，其值為具有方法`null`。|  
    |`ResourceTypeCode.Stream`|資料會儲存在資料流。 通常，這個資料類型是從呼叫的結果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType>或<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType>方法。|  
  
     假設`resourceData`已損毀，它通常可轉換從位元組陣列回到其原始值呼叫<xref:System.BitConverter>或<xref:System.IO.BinaryReader>方法。  
  
-   包含指派給其序列化的資料型別的完整的名稱的字串`resourceData`引數 (例如`System.String`)。 此外，對於不屬於.NET Framework 類別庫的類型，字串包含名稱、 版本、 文化特性和公開金鑰組件包含型別。 例如，下列字串，表示序列化的資料表示的執行個體`Person`輸入`Extensions`命名空間，在 1.0 版的名為 公用程式，都沒有公用的索引鍵和任何指定的文化特性的組件中找到。  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     假設`resourceData`並未損毀且來源類型為的話`resourceData`可以回到其原始值從位元組陣列轉換，轉換位元組陣列並<xref:System.IO.Stream>物件並將資料流傳遞至<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>方法。  
  
-   用來描述中的資料類型的字串<xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType>方法呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> 不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="resourceName" /> 具有不正確的型別。</exception>
        <exception cref="T:System.FormatException">擷取的資源資料已損毀。</exception>
        <exception cref="T:System.InvalidOperationException">目前的<see cref="T:System.Resources.ResourceReader" />物件尚未初始化，可能因為它已關閉。</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Resources.ResourceReader" /> 物件的列舉值。</summary>
        <returns>這個物件 <see cref="T:System.Resources.ResourceReader" /> 的列舉值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> 是明確介面實作。 只有在 <xref:System.Resources.ResourceReader> 執行個體轉換成 <xref:System.Collections.IEnumerable> 介面時，才能使用這個成員。 列舉的.resources 檔案中的資源的建議的方法是呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>方法<xref:System.Collections.IDictionaryEnumerator>所傳回的物件<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">讀取器已經關閉，因此無法存取。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Resources.ResourceReader" /> 使用的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
呼叫 Dispose，可讓所使用的資源<xref:System.Resources.ResourceReader>重新配置用於其他用途。 如需 Dispose 的詳細資訊，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。

## Examples  
下列程式碼範例會通過檔案的資源，並印出它找到的所有索引鍵/值組。 程式碼接著會使用 theIDisposable.Dispose 方法來關閉<xref:System.Resources.ResourceReader>並釋放它所使用的所有資源。

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>