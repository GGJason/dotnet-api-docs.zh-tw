<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XamlReader.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cb6251512dd75740e1b01a33ceb7e3470f3a68d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb6251512dd75740e1b01a33ceb7e3470f3a68d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">使用 WPF 預設 XAML 讀取器和相關聯的 XAML 物件寫入器，讀取 XAML 輸入並建立物件圖形。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> methods are static, but the asynchronous <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> methods are not static and require an instance of the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class to use.</source>
          <target state="translated">同步<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法是靜態的但非同步<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>方法不是靜態的而且需要的執行個體<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別，才能使用。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">輸出<ph id="ph1">`Load`</ph>方法為單一物件，表示樹狀目錄中建立的物件或物件圖形的根物件。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Object graphs that are created by <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">物件所建立的圖形<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>通常會加入到現有的物件樹狀結構的 WPF 應用程式在執行階段。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">否則新的物件圖形視為中斷連線的 WPF 應用程式模型的用途。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</source>
          <target state="translated">這表示不會呈現，而且無法存取使用任何的物件樹狀結構方法，以套用至 WPF 應用程式的主要物件樹狀結構 (例如，應用程式開發介面<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>， <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">如需有關物件樹狀結構的概念的詳細資訊，請參閱<bpt id="p1">[</bpt>中 WPF 樹狀架構<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> supports the following primary scenarios:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 支援下列主要案例：</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>複製/物件 factory<ept id="p1">**</ept>： 沒有其他的機制，參考類型通常不能包含在 WPF 物件樹狀結構中的多個位置。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, or support for commonly shareable objects such as <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> that are referenced as an item from a <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) One way to clone an object that is already in the object tree is to serialize the object using <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">(其他的機制，提供共用的支援，或在 WPF 中重複使用的範例包括物件為基礎的<ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>，或支援通常可共用的物件，例如<ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph>為從一個項目所參考之<ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>。)序列化物件使用的其中一種方式複製的物件已經在物件樹狀結構是<ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You then use the serialized string as input for a call to <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, with a stream or <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> as an intermediary.</source>
          <target state="translated">用於序列化的字串做為輸入呼叫<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>，與資料流或<ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>做為媒介。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>建構物件會根據在 just-in-time 資訊<ept id="p1">**</ept>： 通常是其他的方式有晚期繫結或使用者提供輸入變更現有物件的狀態。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">例如您無法使用相同的值來設定多個屬性，或使用資料繫結。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> input is often a useful technique.</source>
          <target state="translated">如果您有的案例，其中甚至建立物件的類型是僅判斷在執行階段或使用者互動，然後建立這類物件建置的字串，但<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>輸入通常是一個實用的方法。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated"><bpt id="p1">**</bpt>使用現有的資源技術<ept id="p1">**</ept>:<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>型別用於經常在於其他 framework 或技術傳送跨應用程式界限的資料或物件或類似的情況。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can then use the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">然後您可以使用<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>技術來儲存，或取得 XAML 格式的資料，最後使用建立的物件做為您的應用程式的一部分。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated"><bpt id="p1">**</bpt>固定的文件：<ept id="p1">**</ept>您的應用程式可能會載入包含在 WPF 應用程式物件樹狀結構和 UI 中的本機或下載 XPS 文件。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">這份文件有時會描述物件圖形，而不是物件樹狀結構。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">嚴格的父子式關聯性不一律存在於執行的階段物件關聯性的執行的階段 WPF 應用程式，因此物件圖形是更廣泛套用的術語。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, because WPF also includes two different tree conceptualization APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">不過，因為 WPF 還包含兩個不同的樹狀目錄概念化應用程式開發介面 (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) 樹狀目錄象徵仍適用於適當地在 WPF 中大部分的真實情況。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">從 XAML 語言的觀點來看，物件圖形其實通常，最好考慮超出 XAML，會建立物件本身為 XAML 語言不一定會指定讓更多的關聯性的 helper 類別方法至樹狀結構中一次。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Code Access Security, Loose XAML, and XamlReader</source>
          <target state="translated">程式碼存取安全性、 鬆散的 XAML 和 XamlReader</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">XAML 是直接表示物件執行個體化和執行的標記語言。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">因此，XAML 中建立的元素在與系統資源互動方面 (例如網路存取、檔案系統 IO)，跟對等的產生程式碼具有一樣的能力。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 支援<ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph>安全性架構<ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">這表示在網際網路區域中執行的 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 內容的執行權限會降低。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">「鬆散的 XAML」(於載入時間由 XAML 檢視器解譯的未編譯 XAML 的頁面) 和 <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> 通常是在這個網際網路區域中執行，並具有相同的權限設定。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">然而，完全信任應用程式中載入的 XAML，具有與裝載應用程式相同的系統資源存取權限。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>WPF 部分信任安全性<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The implications of these statements for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">這些陳述式中的含意<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>這是您應用程式的設計必須讓您決定要載入的 XAML 相關的信任決策。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">如果您載入未受信任的 XAML，請考慮實作您自己的沙箱技術的載入結果的物件圖形的方式。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> can also be called by partial trust code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 也可以呼叫由部分信任程式碼。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">在此情況下，網際網路安全性區域就會套用程式碼存取安全性。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">如果在載入的 XAML 中的任何項目無效網際網路安全性區域底下，XAML 剖析例外狀況會擲回。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Under XBAP and other cases that are partial trust at the platform level, where <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">XBAP 和其他平台層級中，在部分信任的案例下其中<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>是一部分的執行時，您必須取得相同的例外狀況行為如同明確的部分信任的呼叫。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning</source>
          <target state="translated">WPF XAML、 XAML 讀取器/寫入器和 XAML 的語言版本控制</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> 包含語言功能，例如與。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">您可以使用的簽章<ph id="ph1">`Load`</ph>或<ph id="ph2">`Parse`</ph>載入會使用這些功能的 XAML。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">不過，這些語言功能不支援，需要進行標記編譯 xaml (例如 XAML<bpt id="p1">**</bpt>頁面<ept id="p1">**</ept>建置 WPF 應用程式或建置動作以標記編譯工作牽涉到任何 XAML 中的動作)。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">WPF 型別和 WPF 技術通常支援依賴存取可 WPF 內部的概念。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">比方說，WPF 會相依性屬性的實作依賴內部技術有效率的型別成員查閱。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> from the <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace and PresentationFramework assembly.</source>
          <target state="translated">存取這些內部項目會啟用讀取和寫入應用程式開發介面中提供的 XAML<ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>和<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>從<ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph>命名空間和 PresentationFramework 組件。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) do not have access to the WPF internals.</source>
          <target state="translated">不過，較低層級的 XAML 讀取器和 XAML 寫入器透過 System.Xaml 組件 (類別根據<ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) 確實可以存取 WPF 內部項目。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">沒有任何特定的 WPF 組件從 System.Xaml 相依性。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">如果沒有 WPF 內部存取，System.Xaml 讀取器和寫入器無法正確載入或儲存所有 WPF 類型根據 WPF 類型。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">特別是，System.Xaml 讀取器和寫入器不了解概念，例如支援屬性存放區或所有的細節 WPF 會使用樣式、 資源字典和範本的 WPF 相依性屬性。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore you have a choice to make:</source>
          <target state="translated">因此，您可以進行選擇：</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">如果您正在載入 WPF 類型，及/或您使用 XAML 以任何方式 BAML 形式中，使用 PresentationFramework XAML 讀取器和 XAML 寫入器。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">如果您不依賴任何 WPF 類型或 BAML 形式的 XAML，並不使用另一種特定技術的 XAML 讀取器或 XAML 寫入器實作專屬於該架構的原因，請使用 System.Xaml XAML 讀取器和 XAML 寫入器。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>System.Xaml Backing Implementation in .NET 4</source>
          <target state="translated">System.Xaml 實作.NET 4 中的備份</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 是可呼叫的 API 介面，WPF 架構層級 XAML 剖析器。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">相同的基礎 XAML 剖析器也會執行載入及剖析 WPF 應用程式為目標的執行階段 XAML<ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph>和<ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">如果您的目標<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，外部應用程式開發介面都相同，但實作的部分之上<ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>System.Xaml 組件，可改善剖析 XAML 的技術和報告方面的許多一般 XAML 實作。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">目標<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>一定需要包括 System.Xaml 的參考，以及實作的詳細資料，例如例外狀況的報告可能來自於 System.Xaml 中定義型別。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">下列範例會將轉換<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>字串使用<ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">字串接著會載入回<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用靜態<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">中止目前的非同步載入作業 (如果有暫止的非同步載入作業的話)。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> 是非同步作業;因此，在作業中止之前，可能會發生部分載入。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> 物件，表示 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 的 WPF 結構描述內容設定。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> 物件，表示 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 的 WPF 結構描述內容設定。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取 XAML 輸入並傳回所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">要載入的 XAML，格式為資料流。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 輸入並傳回 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>，這是所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">位於所建立物件樹狀結構根的物件。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The following example saves a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> using the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">下列範例會將儲存<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>到<ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>使用<ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The stream is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">資料流然後重新載入到<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用靜態<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">這個物件預期會與輸入 XAML 一併初始化。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>Reads the XAML input through a provided <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">透過所提供的 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> 讀取 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">屬於所建立之物件樹狀結構根的物件。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The input <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</source>
          <target state="translated">輸入<ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph>可以<ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">這是在執行階段，或當地語系化工具的目的而言，如何載入 BAML。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded the XAML input to load in XML form.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>，已載入 XAML 輸入以使用 XML 格式進行載入。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">屬於所建立之物件樹狀結構根的物件。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">下列範例會將轉換<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>字串使用<ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">字串接著會載入回<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用靜態<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">資料流，包含要載入的 XAML 輸入。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">屬於所建立之物件樹狀結構根的物件。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML markup and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取 XAML 標記並傳回物件，這個物件對應至指定之標記的根。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">資料流，包含要載入的 XAML 輸入。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">屬於所建立之物件樹狀結構根的物件。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">通常會將傳回的物件指派給 WPF 應用程式的物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>處理。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>載入 XAML 輸入以非同步方式，XAML 輸入中的根元素必須包含的屬性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</source>
          <target state="translated">如果不包含 XAML 輸入的根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別可以執行一次。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>就會擲回。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Multiple load operations are pending concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">多重載入作業會與同一個 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 並行暫止。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An existing  <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded/read the XAML input.</source>
          <target state="translated">現有的 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>，已載入/讀取 XAML 輸入。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The root of the created object tree.</source>
          <target state="translated">所建立之物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>You typically would assign the returned object from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">您通常會指派從傳回的物件<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>應用程式的物件樹狀結構中某些位置，該內容的知識可能仍然填入，如果整個內容公開為的一部分，可能造成累加配置更新UI。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>處理。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>載入 XAML 輸入以非同步方式，在 XAML 標記中的根項目必須包含的屬性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</source>
          <target state="translated">如果不包含 XAML 標記根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載改為處理的呼叫 (請參閱<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別可以執行一次。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>就會擲回。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">多重載入作業會與同一個 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 並行執行。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">資料流，包含要載入的 XAML 輸入。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">讀取指定之 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">所建立之物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">通常會將傳回的物件指派給您的應用程式物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>處理。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">為了讓<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>若要以非同步方式載入標記，在 XAML 標記中的根項目必須包含的屬性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">此值視為區分大小寫。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</source>
          <target state="translated">如果不包含 XAML 標記根<ph id="ph1">`x:SynchronousMode="Async"`</ph>、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每個執行個體只有一個非同步載入作業<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別可以執行一次。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多個非同步作業會嘗試在相同的執行個體上<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>類別<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>就會擲回。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">多重載入作業會與同一個 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 並行執行。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">在非同步載入作業完成時發生。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is also raised when an asynchronous load operation aborts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 也會引發非同步載入作業中止時。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取指定之文字字串中的標記，並傳回與指定之標記的根相對應的物件。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">輸入 XAML 做為文字字串。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取指定之文字字串中的 XAML 輸入，並傳回與指定之標記的根相對應的物件。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The root of the created object tree.</source>
          <target state="translated">所建立之物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">實作會呼叫<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>內部之後從字串建立資料流。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">請參閱<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>如需詳細資訊，例如可能的例外狀況。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">輸入 XAML 做為文字字串。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">剖析器使用的內容資訊。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML markup in the specified text string (using a specified <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">讀取指定之文字字串中的 XAML 標記 (使用指定的 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>)，並傳回與指定之標記的根相對應的物件。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">所建立之物件樹狀結構的根。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">實作會呼叫<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>內部之後從字串建立資料流。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">請參閱<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>如需詳細資訊，例如可能的例外狀況。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>