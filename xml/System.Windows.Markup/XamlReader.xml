<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb6251512dd75740e1b01a33ceb7e3470f3a68d1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30660622" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>使用 WPF 預設 XAML 讀取器和相關聯的 XAML 物件寫入器，讀取 XAML 輸入並建立物件圖形。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同步<xref:System.Windows.Markup.XamlReader.Load%2A>方法是靜態的但非同步<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>方法不是靜態的而且需要的執行個體<xref:System.Windows.Markup.XamlReader>類別，才能使用。  
  
 輸出`Load`方法為單一物件，表示樹狀目錄中建立的物件或物件圖形的根物件。 物件所建立的圖形<xref:System.Windows.Markup.XamlReader>通常會加入到現有的物件樹狀結構的 WPF 應用程式在執行階段。 否則新的物件圖形視為中斷連線的 WPF 應用程式模型的用途。 這表示不會呈現，而且無法存取使用任何的物件樹狀結構方法，以套用至 WPF 應用程式的主要物件樹狀結構 (例如，應用程式開發介面<xref:System.Windows.FrameworkElement.FindName%2A>， <xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>)。 如需有關物件樹狀結構的概念的詳細資訊，請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 <xref:System.Windows.Markup.XamlReader> 支援下列主要案例：  
  
-   **複製/物件 factory**： 沒有其他的機制，參考類型通常不能包含在 WPF 物件樹狀結構中的多個位置。 (其他的機制，提供共用的支援，或在 WPF 中重複使用的範例包括物件為基礎的<xref:System.Windows.Freezable>，或支援通常可共用的物件，例如<xref:System.Windows.Media.Brush>為從一個項目所參考之<xref:System.Windows.ResourceDictionary>。)序列化物件使用的其中一種方式複製的物件已經在物件樹狀結構是<xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>。 用於序列化的字串做為輸入呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>，與資料流或<xref:System.Xml.XmlReader>做為媒介。  
  
-   **建構物件會根據在 just-in-time 資訊**： 通常是其他的方式有晚期繫結或使用者提供輸入變更現有物件的狀態。 例如您無法使用相同的值來設定多個屬性，或使用資料繫結。 如果您有的案例，其中甚至建立物件的類型是僅判斷在執行階段或使用者互動，然後建立這類物件建置的字串，但<xref:System.Windows.Markup.XamlReader.Load%2A>輸入通常是一個實用的方法。  
  
-   **使用現有的資源技術**:<xref:System.IO.Stream>型別用於經常在於其他 framework 或技術傳送跨應用程式界限的資料或物件或類似的情況。 然後您可以使用<xref:System.IO.Stream>技術來儲存，或取得 XAML 格式的資料，最後使用建立的物件做為您的應用程式的一部分。  
  
-   **固定的文件：** 您的應用程式可能會載入包含在 WPF 應用程式物件樹狀結構和 UI 中的本機或下載 XPS 文件。  
  
> [!NOTE]
>  這份文件有時會描述物件圖形，而不是物件樹狀結構。 嚴格的父子式關聯性不一律存在於執行的階段物件關聯性的執行的階段 WPF 應用程式，因此物件圖形是更廣泛套用的術語。 不過，因為 WPF 還包含兩個不同的樹狀目錄概念化應用程式開發介面 (<xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>) 樹狀目錄象徵仍適用於適當地在 WPF 中大部分的真實情況。 從 XAML 語言的觀點來看，物件圖形其實通常，最好考慮超出 XAML，會建立物件本身為 XAML 語言不一定會指定讓更多的關聯性的 helper 類別方法至樹狀結構中一次。  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>程式碼存取安全性、 鬆散的 XAML 和 XamlReader  
 XAML 是直接表示物件執行個體化和執行的標記語言。 因此，XAML 中建立的元素在與系統資源互動方面 (例如網路存取、檔案系統 IO)，跟對等的產生程式碼具有一樣的能力。  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 支援[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]安全性架構[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]。 這表示在網際網路區域中執行的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 內容的執行權限會降低。 「鬆散的 XAML」(於載入時間由 XAML 檢視器解譯的未編譯 XAML 的頁面) 和 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 通常是在這個網際網路區域中執行，並具有相同的權限設定。  然而，完全信任應用程式中載入的 XAML，具有與裝載應用程式相同的系統資源存取權限。 如需詳細資訊，請參閱 [WPF 部分信任安全性](~/docs/framework/wpf/wpf-partial-trust-security.md)。  
  
 這些陳述式中的含意<xref:System.Windows.Markup.XamlReader>這是您應用程式的設計必須讓您決定要載入的 XAML 相關的信任決策。 如果您載入未受信任的 XAML，請考慮實作您自己的沙箱技術的載入結果的物件圖形的方式。  
  
 <xref:System.Windows.Markup.XamlReader> 也可以呼叫由部分信任程式碼。 在此情況下，網際網路安全性區域就會套用程式碼存取安全性。 如果在載入的 XAML 中的任何項目無效網際網路安全性區域底下，XAML 剖析例外狀況會擲回。 XBAP 和其他平台層級中，在部分信任的案例下其中<xref:System.Windows.Markup.XamlReader>是一部分的執行時，您必須取得相同的例外狀況行為如同明確的部分信任的呼叫。  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>WPF XAML、 XAML 讀取器/寫入器和 XAML 的語言版本控制  
 [!INCLUDE[xaml2009](~/includes/xaml2009-md.md)] 包含語言功能，例如與。 您可以使用的簽章`Load`或`Parse`載入會使用這些功能的 XAML。 不過，這些語言功能不支援，需要進行標記編譯 xaml (例如 XAML**頁面**建置 WPF 應用程式或建置動作以標記編譯工作牽涉到任何 XAML 中的動作)。  
  
 WPF 型別和 WPF 技術通常支援依賴存取可 WPF 內部的概念。 比方說，WPF 會相依性屬性的實作依賴內部技術有效率的型別成員查閱。 存取這些內部項目會啟用讀取和寫入應用程式開發介面中提供的 XAML<xref:System.Windows.Markup.XamlWriter>和<xref:System.Windows.Markup.XamlReader>從<xref:System.Windows.Markup>命名空間和 PresentationFramework 組件。 不過，較低層級的 XAML 讀取器和 XAML 寫入器透過 System.Xaml 組件 (類別根據<xref:System.Xaml.XamlReader?displayProperty=nameWithType>， <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) 確實可以存取 WPF 內部項目。 沒有任何特定的 WPF 組件從 System.Xaml 相依性。 如果沒有 WPF 內部存取，System.Xaml 讀取器和寫入器無法正確載入或儲存所有 WPF 類型根據 WPF 類型。 特別是，System.Xaml 讀取器和寫入器不了解概念，例如支援屬性存放區或所有的細節 WPF 會使用樣式、 資源字典和範本的 WPF 相依性屬性。 因此，您可以進行選擇：  
  
-   如果您正在載入 WPF 類型，及/或您使用 XAML 以任何方式 BAML 形式中，使用 PresentationFramework XAML 讀取器和 XAML 寫入器。  
  
-   如果您不依賴任何 WPF 類型或 BAML 形式的 XAML，並不使用另一種特定技術的 XAML 讀取器或 XAML 寫入器實作專屬於該架構的原因，請使用 System.Xaml XAML 讀取器和 XAML 寫入器。  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>System.Xaml 實作.NET 4 中的備份  
 <xref:System.Windows.Markup.XamlReader> 是可呼叫的 API 介面，WPF 架構層級 XAML 剖析器。 相同的基礎 XAML 剖析器也會執行載入及剖析 WPF 應用程式為目標的執行階段 XAML[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]和[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]。  
  
 如果您的目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，外部應用程式開發介面都相同，但實作的部分之上[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]System.Xaml 組件，可改善剖析 XAML 的技術和報告方面的許多一般 XAML 實作。 目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]一定需要包括 System.Xaml 的參考，以及實作的詳細資料，例如例外狀況的報告可能來自於 System.Xaml 中定義型別。  
  
## Examples  
 下列範例會將轉換<xref:System.Windows.Controls.Button>字串使用<xref:System.Windows.Markup.XamlWriter>類別。  字串接著會載入回<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Markup.XamlReader" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中止目前的非同步載入作業 (如果有暫止的非同步載入作業的話)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A> 是非同步作業;因此，在作業中止之前，可能會發生部分載入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.XamlSchemaContext" /> 物件，表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 結構描述內容設定。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlSchemaContext" /> 物件，表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 結構描述內容設定。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取 XAML 輸入並傳回所對應物件樹狀結構的根。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要載入的 XAML，格式為資料流。</param>
        <summary>讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回 <see cref="T:System.Object" />，這是所對應物件樹狀結構的根。</summary>
        <returns>位於所建立物件樹狀結構根的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將儲存<xref:System.Windows.Controls.Button>到<xref:System.IO.MemoryStream>使用<xref:System.Windows.Markup.XamlWriter>類別。 資料流然後重新載入到<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xaml.XamlReader" /> 物件。 這個物件預期會與輸入 XAML 一併初始化。</param>
        <summary>透過所提供的 <see cref="T:System.Xaml.XamlReader" /> 讀取 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</summary>
        <returns>屬於所建立之物件樹狀結構根的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入<xref:System.Xaml.XamlReader>可以<xref:System.Windows.Baml2006.Baml2006Reader>。 這是在執行階段，或當地語系化工具的目的而言，如何載入 BAML。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />，已載入 XAML 輸入以使用 XML 格式進行載入。</param>
        <summary>讀取指定之 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</summary>
        <returns>屬於所建立之物件樹狀結構根的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將轉換<xref:System.Windows.Controls.Button>字串使用<xref:System.Windows.Markup.XamlWriter>類別。  字串接著會載入回<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">資料流，包含要載入的 XAML 輸入。</param>
        <param name="parserContext">剖析器使用的內容資訊。</param>
        <summary>讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</summary>
        <returns>屬於所建立之物件樹狀結構根的物件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="parserContext" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取 XAML 標記並傳回物件，這個物件對應至指定之標記的根。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">資料流，包含要載入的 XAML 輸入。</param>
        <summary>讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</summary>
        <returns>屬於所建立之物件樹狀結構根的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。 以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。 這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。 一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。 該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。  
  
 通常會將傳回的物件指派給 WPF 應用程式的物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。 基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。  
  
 為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>載入 XAML 輸入以非同步方式，XAML 輸入中的根元素必須包含的屬性和值`x:SynchronousMode="Async"`。 此值視為區分大小寫。 如果不包含 XAML 輸入的根`x:SynchronousMode="Async"`、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>)。  
  
 每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。  如果多個非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行暫止。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">現有的 <see cref="T:System.Xml.XmlReader" />，已載入/讀取 XAML 輸入。</param>
        <summary>讀取指定之 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</summary>
        <returns>所建立之物件樹狀結構的根。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。 以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。 這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。 一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。 該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。  
  
 您通常會指派從傳回的物件<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>應用程式的物件樹狀結構中某些位置，該內容的知識可能仍然填入，如果整個內容公開為的一部分，可能造成累加配置更新UI。 基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。  
  
 為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>載入 XAML 輸入以非同步方式，在 XAML 標記中的根項目必須包含的屬性和值`x:SynchronousMode="Async"`。 此值視為區分大小寫。 如果不包含 XAML 標記根`x:SynchronousMode="Async"`、 擲回任何例外狀況，以及同步負載改為處理的呼叫 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>)。  
  
 每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。  如果多個非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行執行。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">資料流，包含要載入的 XAML 輸入。</param>
        <param name="parserContext">剖析器使用的內容資訊。</param>
        <summary>讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</summary>
        <returns>所建立之物件樹狀結構的根。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步的 XAML 載入作業一開始會傳回單純的根物件的物件。 以非同步的方式，XAML 剖析然後仍繼續，和任何子物件會填入根目錄下。 這是相較於一般的 WPF XAML 處理行為以及其與互動的物件存留期的 WPF 概念。 一般 （非同步） 互動，包括所有子物件的所有屬性會傳回項目，並報告其在載入之前都填入。 該行為等同於建立樹狀結構的根物件所在的最後一個物件變成可用的由下而上的方法。  
  
 通常會將傳回的物件指派給您的應用程式物件樹狀結構中有些位置、 內容的知識可能仍然會填入，如果 UI 的一部分公開的整個內容可能會造成累加配置更新。 基於這個原因是隔離，或將虛擬化 xaml，任何以非同步方式載入的物件，並使用特定應用程式邏輯或應用程式狀態通知時，一般<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。  
  
 為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要以非同步方式載入標記，在 XAML 標記中的根項目必須包含的屬性和值`x:SynchronousMode="Async"`。 此值視為區分大小寫。 如果不包含 XAML 標記根`x:SynchronousMode="Async"`、 擲回任何例外狀況，以及同步負載處理呼叫 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>)。  
  
 每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。  如果多個非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行執行。</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在非同步載入作業完成時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted> 也會引發非同步載入作業中止時。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取指定之文字字串中的標記，並傳回與指定之標記的根相對應的物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">輸入 XAML 做為文字字串。</param>
        <summary>讀取指定之文字字串中的 XAML 輸入，並傳回與指定之標記的根相對應的物件。</summary>
        <returns>所建立之物件樹狀結構的根。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作會呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>內部之後從字串建立資料流。 請參閱<xref:System.Windows.Markup.XamlReader.Load%2A>如需詳細資訊，例如可能的例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">輸入 XAML 做為文字字串。</param>
        <param name="parserContext">剖析器使用的內容資訊。</param>
        <summary>讀取指定之文字字串中的 XAML 標記 (使用指定的 <see cref="T:System.Windows.Markup.ParserContext" />)，並傳回與指定之標記的根相對應的物件。</summary>
        <returns>所建立之物件樹狀結構的根。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作會呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>內部之後從字串建立資料流。 請參閱<xref:System.Windows.Markup.XamlReader.Load%2A>如需詳細資訊，例如可能的例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>