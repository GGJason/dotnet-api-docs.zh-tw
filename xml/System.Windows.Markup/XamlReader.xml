<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="576d952bef27932173a6f1898d9b6f595dd80d4a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37502538" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="2df32-101">使用 WPF 預設 XAML 讀取器和相關聯的 XAML 物件寫入器，讀取 XAML 輸入並建立物件圖形。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2df32-101">Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-102">同步<xref:System.Windows.Markup.XamlReader.Load%2A>方法是靜態的但是非同步<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>不是靜態方法，而且需要的執行個體<xref:System.Windows.Markup.XamlReader>類別使用。</span><span class="sxs-lookup"><span data-stu-id="2df32-102">The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the <xref:System.Windows.Markup.XamlReader> class to use.</span></span>  
  
 <span data-ttu-id="2df32-103">輸出`Load`方法是單一物件，表示樹狀目錄中建立的物件或物件圖形的根物件。</span><span class="sxs-lookup"><span data-stu-id="2df32-103">The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph.</span></span> <span data-ttu-id="2df32-104">物件所建立的圖形<xref:System.Windows.Markup.XamlReader>通常會新增到現有的物件樹狀目錄中，在執行階段的 WPF 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2df32-104">Object graphs that are created by <xref:System.Windows.Markup.XamlReader> are typically added to the existing object tree of a WPF application at run time.</span></span> <span data-ttu-id="2df32-105">否則新的物件圖形會視為中斷連線的 WPF 應用程式模型的用途。</span><span class="sxs-lookup"><span data-stu-id="2df32-105">Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</span></span> <span data-ttu-id="2df32-106">這表示不會呈現，而且無法存取使用任何物件樹狀結構技術，以套用至 WPF 應用程式的主要物件樹狀結構 (例如，Api <xref:System.Windows.FrameworkElement.FindName%2A>， <xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>)。</span><span class="sxs-lookup"><span data-stu-id="2df32-106">This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>).</span></span> <span data-ttu-id="2df32-107">如需有關物件樹狀結構概念的詳細資訊，請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="2df32-107">For more information on object tree concepts, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="2df32-108"><xref:System.Windows.Markup.XamlReader> 支援下列主要案例：</span><span class="sxs-lookup"><span data-stu-id="2df32-108"><xref:System.Windows.Markup.XamlReader> supports the following primary scenarios:</span></span>  
  
-   <span data-ttu-id="2df32-109">**複製/物件 factory**： 沒有其他的機制，是參考型別通常不能包含在 WPF 物件樹狀結構中的多個位置。</span><span class="sxs-lookup"><span data-stu-id="2df32-109">**Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</span></span> <span data-ttu-id="2df32-110">(其他的機制，可提供共用的支援，或在 WPF 中重複使用的範例包括為基礎的物件<xref:System.Windows.Freezable>，或支援通常可共用的物件，例如<xref:System.Windows.Media.Brush>做為項目，從所參考之<xref:System.Windows.ResourceDictionary>。)要序列化的物件使用的其中一種方式複製的物件已經在物件樹狀結構是<xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2df32-110">(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2df32-111">用於序列化的字串做為輸入來呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>，使用資料流或<xref:System.Xml.XmlReader>做為媒介。</span><span class="sxs-lookup"><span data-stu-id="2df32-111">You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.</span></span>  
  
-   <span data-ttu-id="2df32-112">**在即時資訊建構物件根據**： 通常會有其他方法可讓現有物件的狀態變更的晚期繫結或使用者提供輸入。</span><span class="sxs-lookup"><span data-stu-id="2df32-112">**Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</span></span> <span data-ttu-id="2df32-113">比方說您無法使用相同的值來設定多個屬性，或使用資料繫結。</span><span class="sxs-lookup"><span data-stu-id="2df32-113">For example you could use the same value to set more than one property, or use data binding.</span></span> <span data-ttu-id="2df32-114">如果您有其中甚至要建立物件的類型是僅 determinable 在執行階段或使用者互動的案例，然後建立這類物件所建立的字串，但<xref:System.Windows.Markup.XamlReader.Load%2A>輸入通常是很有用的技巧。</span><span class="sxs-lookup"><span data-stu-id="2df32-114">But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.</span></span>  
  
-   <span data-ttu-id="2df32-115">**使用現有的資源技術**:<xref:System.IO.Stream>類型常用於其他架構或技術傳送的資料或物件跨應用程式界限或類似的情況下。</span><span class="sxs-lookup"><span data-stu-id="2df32-115">**Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</span></span> <span data-ttu-id="2df32-116">您可以接著使用<xref:System.IO.Stream>技術來儲存，或取得 XAML 格式的資料，您最後用來做為您的應用程式的一部分建立的物件。</span><span class="sxs-lookup"><span data-stu-id="2df32-116">You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</span></span>  
  
-   <span data-ttu-id="2df32-117">**已修正文件：** 您的應用程式可能會載入包含在 WPF 應用程式物件樹狀結構和 UI 中的本機或下載 XPS 文件。</span><span class="sxs-lookup"><span data-stu-id="2df32-117">**Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2df32-118">這份文件有時會描述物件圖形，而不是物件樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="2df32-118">This documentation sometimes describes an object graph, as opposed to an object tree.</span></span> <span data-ttu-id="2df32-119">嚴格的父子式關聯性不一律存在於執行的階段物件關聯性的執行的階段的 WPF 應用程式，因此物件圖形是更廣泛適用的術語。</span><span class="sxs-lookup"><span data-stu-id="2df32-119">A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</span></span> <span data-ttu-id="2df32-120">不過，因為 WPF 也包含兩個不同的樹狀結構概念化 Api (<xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>) 樹狀結構比喻仍適用於適當地在 WPF 中的大部分真實世界案例。</span><span class="sxs-lookup"><span data-stu-id="2df32-120">However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF.</span></span> <span data-ttu-id="2df32-121">從 XAML 語言的觀點來看不過，物件圖形通常是最佳的方式思考物件的建立從 XAML，因為 XAML 語言本身不一定會指定讓更多的關聯性的協助程式類別方法到樹狀結構中一次。</span><span class="sxs-lookup"><span data-stu-id="2df32-121">From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</span></span>  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a><span data-ttu-id="2df32-122">程式碼存取安全性 」、 「 鬆散的 XAML 和 「 XamlReader</span><span class="sxs-lookup"><span data-stu-id="2df32-122">Code Access Security, Loose XAML, and XamlReader</span></span>  
 <span data-ttu-id="2df32-123">XAML 是直接表示物件執行個體化和執行的標記語言。</span><span class="sxs-lookup"><span data-stu-id="2df32-123">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="2df32-124">因此，XAML 中建立的元素在與系統資源互動方面 (例如網路存取、檔案系統 IO)，跟對等的產生程式碼具有一樣的能力。</span><span class="sxs-lookup"><span data-stu-id="2df32-124">Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="2df32-125"> 支援[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]安全性架構[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="2df32-125"> supports the [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)].</span></span> <span data-ttu-id="2df32-126">這表示在網際網路區域中執行的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 內容的執行權限會降低。</span><span class="sxs-lookup"><span data-stu-id="2df32-126">This means that [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions.</span></span> <span data-ttu-id="2df32-127">「鬆散的 XAML」(於載入時間由 XAML 檢視器解譯的未編譯 XAML 的頁面) 和 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 通常是在這個網際網路區域中執行，並具有相同的權限設定。</span><span class="sxs-lookup"><span data-stu-id="2df32-127">"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.</span></span>  <span data-ttu-id="2df32-128">然而，完全信任應用程式中載入的 XAML，具有與裝載應用程式相同的系統資源存取權限。</span><span class="sxs-lookup"><span data-stu-id="2df32-128">However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</span></span> <span data-ttu-id="2df32-129">如需詳細資訊，請參閱 [WPF 部分信任安全性](~/docs/framework/wpf/wpf-partial-trust-security.md)。</span><span class="sxs-lookup"><span data-stu-id="2df32-129">For more information, see [WPF Partial Trust Security](~/docs/framework/wpf/wpf-partial-trust-security.md).</span></span>  
  
 <span data-ttu-id="2df32-130">這些陳述式中的含意<xref:System.Windows.Markup.XamlReader>這是您的應用程式的設計必須讓您決定要載入的 XAML 相關的信任決策。</span><span class="sxs-lookup"><span data-stu-id="2df32-130">The implications of these statements for <xref:System.Windows.Markup.XamlReader> is that your application design must make trust decisions about the XAML you decide to load.</span></span> <span data-ttu-id="2df32-131">如果您載入未受信任的 XAML，請考慮實作您自己的沙箱技術載入結果的物件圖形的方式。</span><span class="sxs-lookup"><span data-stu-id="2df32-131">If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</span></span>  
  
 <span data-ttu-id="2df32-132"><xref:System.Windows.Markup.XamlReader> 也可以呼叫由部分信任程式碼。</span><span class="sxs-lookup"><span data-stu-id="2df32-132"><xref:System.Windows.Markup.XamlReader> can also be called by partial trust code.</span></span> <span data-ttu-id="2df32-133">在此情況下，網際網路安全性區域就會套用程式碼存取安全性。</span><span class="sxs-lookup"><span data-stu-id="2df32-133">In this case, Internet security zone is applied for code access security.</span></span> <span data-ttu-id="2df32-134">如果在載入的 XAML 中的任何項目無效 Internet 安全性區域底下，XAML 剖析例外狀況會擲回。</span><span class="sxs-lookup"><span data-stu-id="2df32-134">If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</span></span> <span data-ttu-id="2df32-135">XBAP 和是部分信任的平台層級中，在其他情況下，<xref:System.Windows.Markup.XamlReader>是一部分的執行時，您必須取得相同的例外狀況行為如同明確的部分信任的呼叫。</span><span class="sxs-lookup"><span data-stu-id="2df32-135">Under XBAP and other cases that are partial trust at the platform level, where <xref:System.Windows.Markup.XamlReader> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</span></span>  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a><span data-ttu-id="2df32-136">WPF XAML，XAML 讀取器/寫入器和 XAML 的語言版本控制</span><span class="sxs-lookup"><span data-stu-id="2df32-136">WPF XAML, XAML Readers/Writers, and XAML Language Versioning</span></span>  
 [!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]<span data-ttu-id="2df32-137"> 包含語言功能，例如與。</span><span class="sxs-lookup"><span data-stu-id="2df32-137"> includes language features such as  and .</span></span> <span data-ttu-id="2df32-138">您可以使用的簽章`Load`或`Parse`載入會使用這些功能的 XAML。</span><span class="sxs-lookup"><span data-stu-id="2df32-138">You can use signatures of `Load` or `Parse` to load XAML that uses these features.</span></span> <span data-ttu-id="2df32-139">不過，這些語言功能不支援的 XAML 標記編譯需要 (例如 for XAML ** 頁面**建置 WPF 應用程式或任何牽涉到標記編譯工作，在建置動作中的 XAML 中的動作)。</span><span class="sxs-lookup"><span data-stu-id="2df32-139">However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</span></span>  
  
 <span data-ttu-id="2df32-140">WPF 類型及 WPF 科技一般支援依賴 WPF 內部存取的概念。</span><span class="sxs-lookup"><span data-stu-id="2df32-140">WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</span></span> <span data-ttu-id="2df32-141">比方說，WPF 如何實作相依性屬性依賴內部的技術，有效的型別成員查閱。</span><span class="sxs-lookup"><span data-stu-id="2df32-141">For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</span></span> <span data-ttu-id="2df32-142">存取這些內部項目會啟用 XAML 的讀取和寫入提供的 Api<xref:System.Windows.Markup.XamlWriter>並<xref:System.Windows.Markup.XamlReader>從<xref:System.Windows.Markup>命名空間和 PresentationFramework 組件。</span><span class="sxs-lookup"><span data-stu-id="2df32-142">Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and <xref:System.Windows.Markup.XamlReader> from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly.</span></span> <span data-ttu-id="2df32-143">不過，較低層級的 XAML 讀取器和 XAML 寫入器，透過 System.Xaml 組件 (類別根據<xref:System.Xaml.XamlReader?displayProperty=nameWithType>， <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) 沒有 WPF 內部存取。</span><span class="sxs-lookup"><span data-stu-id="2df32-143">However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) do not have access to the WPF internals.</span></span> <span data-ttu-id="2df32-144">任何 WPF 特定組件從 System.Xaml 沒有相依性。</span><span class="sxs-lookup"><span data-stu-id="2df32-144">There is no dependency from System.Xaml to any WPF-specific assembly.</span></span> <span data-ttu-id="2df32-145">WPF 內部存取，System.Xaml 讀取器和寫入器無法正確載入或儲存所有 WPF 類型依據 WPF 類型。</span><span class="sxs-lookup"><span data-stu-id="2df32-145">Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</span></span> <span data-ttu-id="2df32-146">特別是，System.Xaml 讀取器和寫入器不了解概念，例如 WPF 相依性屬性支援屬性存放區或 WPF 如何使用樣式、 資源字典和範本的所有細節。</span><span class="sxs-lookup"><span data-stu-id="2df32-146">In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</span></span> <span data-ttu-id="2df32-147">因此，您可以進行選擇：</span><span class="sxs-lookup"><span data-stu-id="2df32-147">Therefore you have a choice to make:</span></span>  
  
-   <span data-ttu-id="2df32-148">如果您正在載入 WPF 類型，及/或您使用 XAML 以任何方式的 BAML 表單中，使用 PresentationFramework XAML 讀取器和 XAML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="2df32-148">If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</span></span>  
  
-   <span data-ttu-id="2df32-149">如果您不依賴在 WPF 中的任何型別或 BAML 形式的 XAML，並不使用另一個的特定技術的 XAML 讀取器或 XAML 寫入器實作專屬於該架構的原因，請使用 System.Xaml XAML 讀取器和 XAML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="2df32-149">If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</span></span>  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a><span data-ttu-id="2df32-150">System.Xaml 支援.NET 4 中的實作</span><span class="sxs-lookup"><span data-stu-id="2df32-150">System.Xaml Backing Implementation in .NET 4</span></span>  
 <span data-ttu-id="2df32-151"><xref:System.Windows.Markup.XamlReader> 是可呼叫的 API 介面，WPF 架構層級的 XAML 剖析器。</span><span class="sxs-lookup"><span data-stu-id="2df32-151"><xref:System.Windows.Markup.XamlReader> is the callable API surface for the WPF framework-level XAML parser.</span></span> <span data-ttu-id="2df32-152">相同的基礎 XAML 剖析器也會執行載入和剖析 WPF 應用程式的目標執行階段 XAML[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]和[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="2df32-152">The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].</span></span>  
  
 <span data-ttu-id="2df32-153">如果您的目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、 外部 API 相同，但是實作的組件都建置在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]System.Xaml 組件，可改善許多剖析 XAML 的技術和報告等方面的一般 XAML 實作。</span><span class="sxs-lookup"><span data-stu-id="2df32-153">If you are targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</span></span> <span data-ttu-id="2df32-154">目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]一定需要包括 System.Xaml 的參考，以及實作的詳細資訊，例如例外狀況的報告可能來自於 System.Xaml 中定義型別。</span><span class="sxs-lookup"><span data-stu-id="2df32-154">Targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</span></span>  
  
## Examples  
 <span data-ttu-id="2df32-155">下列範例會將轉換<xref:System.Windows.Controls.Button>字串，使用<xref:System.Windows.Markup.XamlWriter>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-155">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="2df32-156">字串接著會載入回<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-156">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2df32-157">初始化 <see cref="T:System.Windows.Markup.XamlReader" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-157">Initializes a new instance of the <see cref="T:System.Windows.Markup.XamlReader" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2df32-158">中止目前的非同步載入作業 (如果有暫止的非同步載入作業的話)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-158">Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> 是非同步作業;因此，作業就會中止之前，可能會發生部分載入。</span><span class="sxs-lookup"><span data-stu-id="2df32-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2df32-160">傳回 <see cref="T:System.Xaml.XamlSchemaContext" /> 物件，表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 結構描述內容設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-160">Returns a <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-161">
            <see cref="T:System.Xaml.XamlSchemaContext" /> 物件，表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 結構描述內容設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-161">A <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2df32-162">讀取 XAML 輸入並傳回所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-162">Reads XAML input and returns the root of the corresponding object tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="2df32-163">要載入的 XAML，格式為資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-163">The XAML to load, in stream form.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-164">讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回 <see cref="T:System.Object" />，這是所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-164">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an <see cref="T:System.Object" /> that is the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-165">位於所建立物件樹狀結構根的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-165">The object at the root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2df32-166">下列範例會儲存<xref:System.Windows.Controls.Button>成<xref:System.IO.MemoryStream>使用<xref:System.Windows.Markup.XamlWriter>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-166">The following example saves a <xref:System.Windows.Controls.Button> into a <xref:System.IO.MemoryStream> using the <xref:System.Windows.Markup.XamlWriter> class.</span></span> <span data-ttu-id="2df32-167">資料流則會載入回<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-167">The stream is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-168">
            <paramref name="stream" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-168">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="2df32-169">
            <see cref="T:System.Xaml.XamlReader" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-169">A <see cref="T:System.Xaml.XamlReader" /> object.</span>
          </span>
          <span data-ttu-id="2df32-170">這個物件預期會與輸入 XAML 一併初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-170">This is expected to be initialized with input XAML.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-171">透過所提供的 <see cref="T:System.Xaml.XamlReader" /> 讀取 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-171">Reads the XAML input through a provided <see cref="T:System.Xaml.XamlReader" /> and returns an object that is the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-172">屬於所建立之物件樹狀結構根的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-172">The object that is the root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-173">輸入<xref:System.Xaml.XamlReader>可以是<xref:System.Windows.Baml2006.Baml2006Reader>。</span><span class="sxs-lookup"><span data-stu-id="2df32-173">The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>.</span></span> <span data-ttu-id="2df32-174">這是在執行階段，或當地語系化工具的目的而言，如何載入 BAML。</span><span class="sxs-lookup"><span data-stu-id="2df32-174">This is how you can load BAML at run time, or for localization tool purposes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-175">
            <paramref name="reader" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-175">
              <paramref name="reader" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="2df32-176">
            <see cref="T:System.Xml.XmlReader" />，已載入 XAML 輸入以使用 XML 格式進行載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-176">The <see cref="T:System.Xml.XmlReader" /> that has already loaded the XAML input to load in XML form.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-177">讀取指定之 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-177">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns an object that is the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-178">屬於所建立之物件樹狀結構根的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-178">The object that is the root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2df32-179">下列範例會將轉換<xref:System.Windows.Controls.Button>字串，使用<xref:System.Windows.Markup.XamlWriter>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-179">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="2df32-180">字串接著會載入回<xref:System.Windows.Controls.Button>使用靜態<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>類別。</span><span class="sxs-lookup"><span data-stu-id="2df32-180">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-181">
            <paramref name="reader" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-181">
              <paramref name="reader" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="2df32-182">資料流，包含要載入的 XAML 輸入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-182">The stream that contains the XAML input to load.</span>
          </span>
        </param>
        <param name="parserContext">
          <span data-ttu-id="2df32-183">剖析器使用的內容資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-183">Context information used by the parser.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-184">讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回物件，這個物件是所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-184">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an object that is the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-185">屬於所建立之物件樹狀結構根的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-185">The object that is the root of the created object tree.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-186">
            <paramref name="stream" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-186">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2df32-187">或 <paramref name="parserContext" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-187">-or-  <paramref name="parserContext" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2df32-188">讀取 XAML 標記並傳回物件，這個物件對應至指定之標記的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-188">Reads XAML markup and returns an object that corresponds to the root of the specified markup.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="2df32-189">資料流，包含要載入的 XAML 輸入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-189">The stream containing the XAML input to load.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-190">讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-190">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-191">屬於所建立之物件樹狀結構根的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-191">The object that is the root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-192">非同步 XAML 載入作業一開始會傳回單純的根物件的物件。</span><span class="sxs-lookup"><span data-stu-id="2df32-192">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="2df32-193">以非同步的方式，XAML 剖析再繼續，，和任何子物件會填入的根目錄下。</span><span class="sxs-lookup"><span data-stu-id="2df32-193">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="2df32-194">這是相較於一般的 WPF XAML 處理行為和物件存留期的 WPF 概念與它互動。</span><span class="sxs-lookup"><span data-stu-id="2df32-194">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="2df32-195">一般 （非同步） 互動，包括所有子系集合物件的所有屬性會傳回項目，並報告它載入前都填入。</span><span class="sxs-lookup"><span data-stu-id="2df32-195">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="2df32-196">該行為相當於由下往上方法，來建立樹狀結構的根物件所在的最後一個物件變成可用。</span><span class="sxs-lookup"><span data-stu-id="2df32-196">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="2df32-197">您通常會將傳回的物件指派給您的 WPF 應用程式的物件樹狀結構中的某些位置、 內容的知識可能仍然會填入和如果整個內容公開為組件的 ui 可能會造成累加配置更新。</span><span class="sxs-lookup"><span data-stu-id="2df32-197">You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="2df32-198">基於這個原因通常會以隔離或虛擬化 XAML，從任何以非同步方式載入的物件，並將應用程式特定邏輯或應用程式狀態通知時<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。</span><span class="sxs-lookup"><span data-stu-id="2df32-198">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="2df32-199">為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要載入 XAML 輸入以非同步方式，在輸入 XAML 中的根項目必須包含的屬性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="2df32-199">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="2df32-200">值會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2df32-200">The value is treated as case sensitive.</span></span> <span data-ttu-id="2df32-201">如果不包含 XAML 輸入的根`x:SynchronousMode="Async"`擲回任何例外狀況，且呼叫會以同步載入處理 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>)。</span><span class="sxs-lookup"><span data-stu-id="2df32-201">If the XAML input root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).</span></span>  
  
 <span data-ttu-id="2df32-202">每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。</span><span class="sxs-lookup"><span data-stu-id="2df32-202">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="2df32-203">如果一個以上的非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="2df32-203">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-204">
            <paramref name="stream" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-204">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2df32-205">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行暫止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-205">Multiple load operations are pending concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="2df32-206">現有的 <see cref="T:System.Xml.XmlReader" />，已載入/讀取 XAML 輸入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-206">An existing  <see cref="T:System.Xml.XmlReader" /> that has already loaded/read the XAML input.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-207">讀取指定之 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-207">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-208">所建立之物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-208">The root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-209">非同步 XAML 載入作業一開始會傳回單純的根物件的物件。</span><span class="sxs-lookup"><span data-stu-id="2df32-209">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="2df32-210">以非同步的方式，XAML 剖析再繼續，，和任何子物件會填入的根目錄下。</span><span class="sxs-lookup"><span data-stu-id="2df32-210">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="2df32-211">這是相較於一般的 WPF XAML 處理行為和物件存留期的 WPF 概念與它互動。</span><span class="sxs-lookup"><span data-stu-id="2df32-211">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="2df32-212">一般 （非同步） 互動，包括所有子系集合物件的所有屬性會傳回項目，並報告它載入前都填入。</span><span class="sxs-lookup"><span data-stu-id="2df32-212">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="2df32-213">該行為相當於由下往上方法，來建立樹狀結構的根物件所在的最後一個物件變成可用。</span><span class="sxs-lookup"><span data-stu-id="2df32-213">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="2df32-214">您通常會指派給傳回的物件，從<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>至您的應用程式物件樹狀結構中某些位置，與內容的知識可能仍然會填入，而且可能會導致累加配置更新，如果整個內容公開為的一部分UI。</span><span class="sxs-lookup"><span data-stu-id="2df32-214">You typically would assign the returned object from <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="2df32-215">基於這個原因通常會以隔離或虛擬化 XAML，從任何以非同步方式載入的物件，並將應用程式特定邏輯或應用程式狀態通知時<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。</span><span class="sxs-lookup"><span data-stu-id="2df32-215">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="2df32-216">為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要載入 XAML 輸入以非同步方式，在 XAML 標記中的根項目必須包含的屬性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="2df32-216">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="2df32-217">值會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2df32-217">The value is treated as case sensitive.</span></span> <span data-ttu-id="2df32-218">如果不包含 XAML 標記根`x:SynchronousMode="Async"`擲回任何例外狀況，且呼叫改為處理同步的負載 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>)。</span><span class="sxs-lookup"><span data-stu-id="2df32-218">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).</span></span>  
  
 <span data-ttu-id="2df32-219">每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。</span><span class="sxs-lookup"><span data-stu-id="2df32-219">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="2df32-220">如果一個以上的非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="2df32-220">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-221">
            <paramref name="reader" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-221">
              <paramref name="reader" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2df32-222">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-222">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="2df32-223">資料流，包含要載入的 XAML 輸入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-223">A stream containing the XAML input to load.</span>
          </span>
        </param>
        <param name="parserContext">
          <span data-ttu-id="2df32-224">剖析器使用的內容資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-224">Context information used by the parser.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-225">讀取指定之 <see cref="T:System.IO.Stream" /> 中的 XAML 輸入並傳回所對應物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-225">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-226">所建立之物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-226">The root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-227">非同步 XAML 載入作業一開始會傳回單純的根物件的物件。</span><span class="sxs-lookup"><span data-stu-id="2df32-227">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="2df32-228">以非同步的方式，XAML 剖析再繼續，，和任何子物件會填入的根目錄下。</span><span class="sxs-lookup"><span data-stu-id="2df32-228">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="2df32-229">這是相較於一般的 WPF XAML 處理行為和物件存留期的 WPF 概念與它互動。</span><span class="sxs-lookup"><span data-stu-id="2df32-229">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="2df32-230">一般 （非同步） 互動，包括所有子系集合物件的所有屬性會傳回項目，並報告它載入前都填入。</span><span class="sxs-lookup"><span data-stu-id="2df32-230">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="2df32-231">該行為相當於由下往上方法，來建立樹狀結構的根物件所在的最後一個物件變成可用。</span><span class="sxs-lookup"><span data-stu-id="2df32-231">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="2df32-232">您通常會將傳回的物件指派給您的應用程式物件樹狀結構中的某些位置、 內容的知識可能仍然會填入和如果整個內容公開為組件的 ui 可能會造成累加配置更新。</span><span class="sxs-lookup"><span data-stu-id="2df32-232">You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="2df32-233">基於這個原因通常會以隔離或虛擬化 XAML，從任何以非同步方式載入的物件，並將應用程式特定邏輯或應用程式狀態通知時<xref:System.Windows.Markup.XamlReader.LoadCompleted>處理。</span><span class="sxs-lookup"><span data-stu-id="2df32-233">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="2df32-234">為了讓<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要以非同步方式載入標記，在 XAML 標記中的根項目必須包含的屬性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="2df32-234">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="2df32-235">值會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2df32-235">The value is treated as case sensitive.</span></span> <span data-ttu-id="2df32-236">如果不包含 XAML 標記根`x:SynchronousMode="Async"`擲回任何例外狀況，且呼叫會以同步載入處理 (請參閱<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>)。</span><span class="sxs-lookup"><span data-stu-id="2df32-236">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).</span></span>  
  
 <span data-ttu-id="2df32-237">每個執行個體只有一個非同步載入作業<xref:System.Windows.Markup.XamlReader>類別可以執行一次。</span><span class="sxs-lookup"><span data-stu-id="2df32-237">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="2df32-238">如果一個以上的非同步作業會嘗試在相同的執行個體上<xref:System.Windows.Markup.XamlReader>類別<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="2df32-238">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2df32-239">
            <paramref name="stream" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-239">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2df32-240">多重載入作業會與同一個 <see cref="T:System.Windows.Markup.XamlReader" /> 並行執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-240">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2df32-241">在非同步載入作業完成時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-241">Occurs when an asynchronous load operation completes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-242"><xref:System.Windows.Markup.XamlReader.LoadCompleted> 也會引發非同步載入作業中止時。</span><span class="sxs-lookup"><span data-stu-id="2df32-242"><xref:System.Windows.Markup.XamlReader.LoadCompleted> is also raised when an asynchronous load operation aborts.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2df32-243">讀取指定之文字字串中的標記，並傳回與指定之標記的根相對應的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-243">Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">
          <span data-ttu-id="2df32-244">輸入 XAML 做為文字字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-244">The input XAML, as a single text string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-245">讀取指定之文字字串中的 XAML 輸入，並傳回與指定之標記的根相對應的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-245">Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-246">所建立之物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-246">The root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-247">實作會呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>從字串建立資料流之後，在內部。</span><span class="sxs-lookup"><span data-stu-id="2df32-247">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="2df32-248">請參閱<xref:System.Windows.Markup.XamlReader.Load%2A>如需詳細資訊，例如可能的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2df32-248">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">
          <span data-ttu-id="2df32-249">輸入 XAML 做為文字字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-249">The input XAML, as a single text string.</span>
          </span>
        </param>
        <param name="parserContext">
          <span data-ttu-id="2df32-250">剖析器使用的內容資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-250">Context information used by the parser.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2df32-251">讀取指定之文字字串中的 XAML 標記 (使用指定的 <see cref="T:System.Windows.Markup.ParserContext" />)，並傳回與指定之標記的根相對應的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-251">Reads the XAML markup in the specified text string (using a specified <see cref="T:System.Windows.Markup.ParserContext" />) and returns an object that corresponds to the root of the specified markup.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2df32-252">所建立之物件樹狀結構的根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2df32-252">The root of the created object tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2df32-253">實作會呼叫<xref:System.Windows.Markup.XamlReader.Load%2A>從字串建立資料流之後，在內部。</span><span class="sxs-lookup"><span data-stu-id="2df32-253">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="2df32-254">請參閱<xref:System.Windows.Markup.XamlReader.Load%2A>如需詳細資訊，例如可能的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2df32-254">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>