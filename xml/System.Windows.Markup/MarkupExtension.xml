<Type Name="MarkupExtension" FullName="System.Windows.Markup.MarkupExtension">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9ca66d6767b24c82ce7eed1a97d822b87a0fe9c3" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37560037" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MarkupExtension extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarkupExtension abstract" />
  <TypeSignature Language="F#" Value="type MarkupExtension = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b7c11-101">為 .NET Framework XAML 服務及其他 XAML 讀取器和 XAML 寫入器可支援的 XAML 標記延伸實作，提供基底類別。</span>
      <span class="sxs-lookup">
        <span data-stu-id="b7c11-101">Provides a base class for XAML markup extension implementations that can be supported by .NET Framework XAML Services and other XAML readers and XAML writers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b7c11-102">標記延伸模組會將物件傳回至呼叫端，根據輸入的字串屬性值或 XAML 中的標記項目。</span><span class="sxs-lookup"><span data-stu-id="b7c11-102">Markup extensions return objects to callers, based on the input of string attribute values or markup elements in XAML.</span></span> <span data-ttu-id="b7c11-103">標記延伸比單獨的型別轉換子可以完成更複雜的方式傳回物件。</span><span class="sxs-lookup"><span data-stu-id="b7c11-103">Markup extensions return objects in a more sophisticated way than type converters alone can accomplish.</span></span> <span data-ttu-id="b7c11-104">在 XAML 物件寫入器會叫用型別轉換子，因為型別或成員具有與它相關聯的型別轉換子實作。</span><span class="sxs-lookup"><span data-stu-id="b7c11-104">A XAML object writer invokes a type converter because a type or member has a type converter implementation associated with it.</span></span> <span data-ttu-id="b7c11-105">從 CLR 參考框架，這表示型別或成員是<xref:System.ComponentModel.TypeConverterAttribute>屬性化。</span><span class="sxs-lookup"><span data-stu-id="b7c11-105">From the CLR frame of reference, this means that a type or member is <xref:System.ComponentModel.TypeConverterAttribute> attributed.</span></span> <span data-ttu-id="b7c11-106">從 XAML 類型系統觀點來看，這表示 XAML 型別或 XAML 成員的值及其`TypeConverter`屬性。</span><span class="sxs-lookup"><span data-stu-id="b7c11-106">From the XAML type system perspective, this means that a XAML type or a XAML member has a value for its `TypeConverter` property.</span></span> <span data-ttu-id="b7c11-107">型別轉換子的引動過程會繫結至的型別或屬性的定義，並永遠會叫用的 XAML 處理在這些情況下。</span><span class="sxs-lookup"><span data-stu-id="b7c11-107">The invocation of a type converter is tied to the type or property definition, and is always invoked by XAML processing for these cases.</span></span> <span data-ttu-id="b7c11-108">相較之下，標記延伸是在使用者程式碼和使用者產生的標記，控制下更多，而且每當應用程式案例需要它可以套用。</span><span class="sxs-lookup"><span data-stu-id="b7c11-108">In contrast, a markup extension is more under the control of user code and user-produced markup, and can be applied whenever an application scenario demands it.</span></span> <span data-ttu-id="b7c11-109">標記延伸可以叫用，並可用於設定不同的型別成員的值，只要標記延伸的傳回類型是指派給的值。</span><span class="sxs-lookup"><span data-stu-id="b7c11-109">A markup extension can be invoked and can be used for setting different type-member values, so long as the markup extension's return type is assignable to that value.</span></span>  
  
 <span data-ttu-id="b7c11-110">如需建立自訂標記延伸的詳細資訊，請參閱<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="b7c11-110">For information on creating a custom markup extension, see <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="b7c11-111">如需有關一般的標記延伸的詳細資訊，請參閱[Markup Extensions for XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b7c11-111">For more information on markup extensions in general, see [Markup Extensions for XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).</span></span> <span data-ttu-id="b7c11-112">如果您要建置在 WPF 和使用或建立 XAML 標記延伸模組，可以在主題中找到其他相關資訊[標記延伸和 WPF XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="b7c11-112">If you are building on WPF and using or creating markup extensions for XAML, other relevant information can be found in the topic [Markup Extensions and WPF XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
 <span data-ttu-id="b7c11-113"><xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>的每個標記延伸實作的方法可以使用<xref:System.IServiceProvider>在執行階段可以提供內容。</span><span class="sxs-lookup"><span data-stu-id="b7c11-113">The <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> method of each markup extension implementation can use an <xref:System.IServiceProvider> at run time that can provide context.</span></span> <span data-ttu-id="b7c11-114">這<xref:System.IServiceProvider>接著會查詢特定的服務，傳遞的詳細資訊，例如<xref:System.Windows.Markup.IProvideValueTarget>或<xref:System.Windows.Markup.IXamlTypeResolver>。</span><span class="sxs-lookup"><span data-stu-id="b7c11-114">This  <xref:System.IServiceProvider> is then queried for specific services that pass information, such as <xref:System.Windows.Markup.IProvideValueTarget> or <xref:System.Windows.Markup.IXamlTypeResolver>.</span></span> <span data-ttu-id="b7c11-115">如需有關標記延伸的服務內容的詳細資訊，請參閱[Service Contexts Available to Type Converters and Markup Extensions](~/docs/framework/xaml-services/service-contexts-available-to-type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="b7c11-115">For more information on service contexts for a markup extension, see [Service Contexts Available to Type Converters and Markup Extensions](~/docs/framework/xaml-services/service-contexts-available-to-type-converters-and-markup-extensions.md).</span></span>  
  
 <span data-ttu-id="b7c11-116">在衍生的類別應該屬性具有<xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>通知的最明確的傳回類型可以從標記延伸的取用者<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>實作。</span><span class="sxs-lookup"><span data-stu-id="b7c11-116">Derived classes should be attributed with <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> to inform consumers of the most specific return type available from the markup extension's <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.MarkupExtension.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarkupExtension();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b7c11-117">初始化衍生自 <see cref="T:System.Windows.Markup.MarkupExtension" /> 之類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-117">Initializes a new instance of a class derived from <see cref="T:System.Windows.Markup.MarkupExtension" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b7c11-118"><xref:System.Windows.Markup.MarkupExtension>抽象類別不會保留任何需要初始化的私用值。</span><span class="sxs-lookup"><span data-stu-id="b7c11-118">The <xref:System.Windows.Markup.MarkupExtension> abstract class does not hold any private values that require initialization.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="b7c11-119">
            <para>功能的標記延伸模組應該定義自己的公用預設建構函式。此外，標記延伸模組應該實作適用於擴充功能的預定的功能和標記使用方式的建構函式。如需詳細資訊，請參閱 [Markup Extensions for XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md)。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-119">
              <para>A functional markup extension should define its own public default constructor. Additionally, the markup extension should implement constructors that are appropriate for the extension's intended capabilities and markup usage. For more information, see [Markup Extensions for XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProvideValue">
      <MemberSignature Language="C#" Value="public abstract object ProvideValue (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ProvideValue(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ProvideValue (serviceProvider As IServiceProvider) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ProvideValue(IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="abstract member ProvideValue : IServiceProvider -&gt; obj" Usage="markupExtension.ProvideValue serviceProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">
          <span data-ttu-id="b7c11-120">可以為標記延伸提供服務的服務提供者 Helper。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-120">A service provider helper that can provide services for the markup extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b7c11-121">在衍生類別中實作時，傳回物件，這個物件提供為這個標記延伸的目標屬性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-121">When implemented in a derived class, returns an object that is provided as the value of the target property for this markup extension.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b7c11-122">要在套用延伸的屬性上設定的物件值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-122">The object value to set on the property where the extension is applied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b7c11-123">當 XAML 處理器處理是標記延伸的型別節點和成員值時，它會叫用<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>該標記延伸的方法，並將結果寫入至物件圖形或序列化資料流。</span><span class="sxs-lookup"><span data-stu-id="b7c11-123">When a XAML processor processes a type node and member value that is a markup extension, it invokes the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> method of that markup extension and writes the result into the object graph or serialization stream.</span></span> <span data-ttu-id="b7c11-124">XAML 物件寫入器會將服務內容傳遞給每個這類實作透過`serviceProvider`參數。</span><span class="sxs-lookup"><span data-stu-id="b7c11-124">The XAML object writer passes service context to each such implementation through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="b7c11-125">如需如何實作的詳細資訊，請參閱 「 備忘稿實施者 」 一節<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>自訂標記延伸模組中。</span><span class="sxs-lookup"><span data-stu-id="b7c11-125">See "Notes to Implementers" section for more information on how to implement <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> in a custom markup extension.</span></span>  
  
## <a name="wpf-usage-notes"></a><span data-ttu-id="b7c11-126">WPF 使用注意事項</span><span class="sxs-lookup"><span data-stu-id="b7c11-126">WPF Usage Notes</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b7c11-127">具有特定標記設定作業的互動的 WPF 類別不應依賴<xref:System.Windows.Markup.IReceiveMarkupExtension>針對[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]實作。</span><span class="sxs-lookup"><span data-stu-id="b7c11-127">WPF classes that have specific interactions with markup set operations should not rely on <xref:System.Windows.Markup.IReceiveMarkupExtension> for a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementation.</span></span> <span data-ttu-id="b7c11-128">使用<xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>-改為屬性化回呼。</span><span class="sxs-lookup"><span data-stu-id="b7c11-128">Use <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>-attributed callbacks instead.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="b7c11-129">
            <para>傳回預設服務提供者，這通常是可自訂的或現有的通用服務<see cref="T:System.Windows.Markup.MarkupExtension" />實作包含下列主要服務。 -<see cref="T:System.Windows.Markup.IProvideValueTarget" />報告的物件參考，以及從使用標記延伸的位置-內容屬性的識別項<see cref="T:System.Windows.Markup.IXamlTypeResolver" />公開服務的一般 XAML 物件寫入可以提供的行為<see cref="T:System.Type" />根據 XAML型別名稱。名稱可以選擇性地包含對應的 XAML 命名空間前置詞。 -<see cref="T:System.Xaml.IXamlSchemaContextProvider" />直接公開 （expose) 的使用中的 XAML 結構描述內容。從報告<see cref="T:System.Xaml.XamlSchemaContext" />，您可以取得 XAML 結構描述內容資訊這類類型支援，組件中的慣用前置詞所對應的組件如何列出每個<see cref="T:System.Xaml.XamlType" />中組件，依此類推。 -提供的其他服務的更具特製化標記延伸模組的案例包括:- <see cref="T:System.Windows.Markup.IUriContext" />   
  
    -    <see cref="T:System.Xaml.IAmbientProvider" />   
  
    -    <see cref="T:System.Xaml.IDestinationTypeProvider" />   
  
    -    <see cref="T:System.Xaml.IRootObjectProvider" />   
  
    -    <see cref="T:System.Xaml.IXamlNameResolver" />   
  
    -   <see cref="T:System.Xaml.IXamlNamespaceResolver" />可能會實作<see cref="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)" />可以忽略<paramref name="serviceProvider" />參數。這是可行的一些基本的案例，其中沒有內容完全是必要的傳回值。典型的用法，.NET Framework XAML 服務以及實作的 XAML 物件寫入器會提供所有的值轉換器方法叫用期間 XAML 的服務提供者處理。不過，以提供健全度，您應該提供程式碼路徑為 null 值的服務提供者本身和任何要求的服務。Null 值可能是如果您的標記延伸模組套用一種情況在 XAML 處理器基礎結構所提供的一般服務支援不提供。如需有關可用的服務，從XAML 服務提供者內容，以及如何使用它們的詳細資訊，請參閱 [Type Converters and Markup Extensions for XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)。需要特定服務可供使用才能產生有用的實作<see cref="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)" />結果應擲回例外狀況，如果該服務無法使用。建議要擲回的例外狀況是<see cref="T:System.InvalidOperationException" />。如果其中一個引數的自訂標記延伸模組必須以提供的值為 null，它的資料類型無效或不包含標記延伸可處理的值，實作也可能會擲回例外狀況。建議要擲回的例外狀況是<see cref="T:System.InvalidOperationException" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b7c11-129">
              <para>Common services returned by the default service provider that is typically available to a custom or existing <see cref="T:System.Windows.Markup.MarkupExtension" /> implementation include the following primary services.  -   <see cref="T:System.Windows.Markup.IProvideValueTarget" /> reports the object reference and a property identifier from the context where the markup extension is used  -   <see cref="T:System.Windows.Markup.IXamlTypeResolver" /> exposes a service that parallels the general XAML object writing behavior that can provide a <see cref="T:System.Type" /> based on a XAML type name. The name can optionally include a prefix for a mapped XAML namespace.  -   <see cref="T:System.Xaml.IXamlSchemaContextProvider" /> exposes the active XAML schema context directly. From the reported <see cref="T:System.Xaml.XamlSchemaContext" />, you can obtain XAML schema context information such as how assemblies are mapped for type support, preferred prefix in assemblies, lists of each <see cref="T:System.Xaml.XamlType" /> in an assembly, and so on.  -   Other services available for more specialized markup extension scenarios include:  -   <see cref="T:System.Windows.Markup.IUriContext" />  
  
    -   <see cref="T:System.Xaml.IAmbientProvider" />  
  
    -   <see cref="T:System.Xaml.IDestinationTypeProvider" />  
  
    -   <see cref="T:System.Xaml.IRootObjectProvider" />  
  
    -   <see cref="T:System.Xaml.IXamlNameResolver" />  
  
    -   <see cref="T:System.Xaml.IXamlNamespaceResolver" />  Potentially, implementations of <see cref="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)" /> can ignore the <paramref name="serviceProvider" /> parameter. This is viable for some basic scenarios, where no context at all is required for returning a value.  In typical usage, the .NET Framework XAML Services and the implemented XAML object writers will provide a service provider to all value converter methods that are invoked during XAML processing. However, for robustness, you should provide code paths for null values both for the service provider itself and for any requested service. Null values might occur if your markup extension is applied in a circumstance where the typical service support provided by a XAML processor infrastructure is not available.  For more information on available services from the XAML service provider context and how to use them, see [Type Converters and Markup Extensions for XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  Implementations that require a certain service to be available in order to produce a useful <see cref="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)" /> result are expected to throw exceptions if that service is not available. The recommended exception to throw is <see cref="T:System.InvalidOperationException" />.  The implementation may also throw exceptions if one of the arguments that the custom markup extension needs in order to provide a value is null, is invalid for its data type, or does not contain a value that the markup extension is capable of processing. The recommended exception to throw is <see cref="T:System.InvalidOperationException" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Windows.Markup.IProvideValueTarget" />
        <altmember cref="T:System.Windows.Markup.IXamlTypeResolver" />
      </Docs>
    </Member>
  </Members>
</Type>