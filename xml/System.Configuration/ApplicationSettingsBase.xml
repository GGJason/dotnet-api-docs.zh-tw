<Type Name="ApplicationSettingsBase" FullName="System.Configuration.ApplicationSettingsBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="23db5a6d3eb52dad9746e2dc1b1e945b8f2d8558" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52225828" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ApplicationSettingsBase : System.Configuration.SettingsBase, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ApplicationSettingsBase extends System.Configuration.SettingsBase implements class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ApplicationSettingsBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ApplicationSettingsBase&#xA;Inherits SettingsBase&#xA;Implements INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationSettingsBase abstract : System::Configuration::SettingsBase, System::ComponentModel::INotifyPropertyChanged" />
  <TypeSignature Language="F#" Value="type ApplicationSettingsBase = class&#xA;    inherit SettingsBase&#xA;    interface INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.SettingsBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>做為衍生實體包裝函式類別的基底類別，以實作 Windows Form 應用程式中的應用程式設定功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase> 新增下列功能來<xref:System.Configuration.SettingsBase>Web 為基礎的應用程式所使用的類別：  
  
-   能夠偵測的衍生，設定包裝函式類別上的屬性。 <xref:System.Configuration.ApplicationSettingsBase> 支援宣告式模型用於包裝函式的類別屬性，如稍後所述。  
  
-   較高層級<xref:System.Configuration.ApplicationSettingsBase.Save%2A>和<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>方法。  
  
-   您可以處理以確保正確性的個別設定的額外的驗證事件。  
  
 在應用程式設定架構中，若要存取的設定屬性群組您需要衍生實體包裝函式類別從<xref:System.Configuration.ApplicationSettingsBase>。 包裝函式類別自訂<xref:System.Configuration.ApplicationSettingsBase>如下：  
  
-   若要存取每個設定屬性，對應的強型別的公用屬性會加入包裝函式類別。 此屬性具有`get`並`set`存取子讀取/寫入應用程式設定，但僅限於`get`唯讀設定的存取子。  
  
-   適當的屬性必須套用至包裝函式類別的公用屬性是否設定應該支援漫遊的預設值，表示設定屬性，例如設定的領域 （應用程式或使用者） 的特性設定，以自動設定提供者使用，然後依此類推。 每個屬性，才可指定其範圍中，使用<xref:System.Configuration.ApplicationScopedSettingAttribute>或<xref:System.Configuration.UserScopedSettingAttribute>。 應用程式範圍的設定是唯讀如果預設<xref:System.Configuration.LocalFileSettingsProvider>用。  
  
 <xref:System.Configuration.ApplicationSettingsBase>類別會使用反映來偵測這些屬性在執行階段。 大部分的這項資訊傳遞至設定提供者層，也就是負責儲存體、 保存格式等等。  
  
 當應用程式有多個設定包裝函式類別，每個類別定義*設定群組*。 每個群組具有下列特性：  
  
-   群組可以包含任何數目或類型屬性設定。  
  
-   如果群組名稱不明確設定裝飾的包裝函式類別，則<xref:System.Configuration.SettingsGroupNameAttribute>，則會自動產生的名稱。  
  
 根據預設，所有的用戶端應用程式使用<xref:System.Configuration.LocalFileSettingsProvider>提供儲存體。 如果想要使用替代的設定提供者，則包裝函式類別或屬性必須有對應裝飾<xref:System.Configuration.SettingsProviderAttribute>。  
  
 如需使用應用程式設定的詳細資訊，請參閱[適用於 Windows Form 應用程式設定](~/docs/framework/winforms/advanced/application-settings-for-windows-forms.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用的應用程式設定，以保存主要表單的下列屬性： 位置、 大小、 背景色彩和標題列文字。 所有這些屬性會保存為單一應用程式中的設定屬性`FormSettings`類別，名為`FormLocation`， `FormSize`，`FormBackColor`和`FormText`分別。 所有以外的`FormText`並`Size`是資料繫結至其相關聯的表單屬性，而且具有預設設定值，套用使用<xref:System.Configuration.DefaultSettingValueAttribute>。  
  
 表單包含四個子控制項具有下列名稱和函式：  
  
-   名為按鈕`btnBackColor`用來顯示**色彩**通用對話方塊。  
  
-   名為按鈕`btnReload`用以<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>應用程式設定。  
  
-   名為按鈕`btnReset`用以<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>應用程式設定。  
  
-   名為 textbox`tbStatus`用來顯示程式的狀態資訊。  
  
 請注意，在每次執行的應用程式之後，其他的句號字元會附加到表單的標題文字。  
  
 此程式碼範例需要表單<xref:System.Windows.Forms.ColorDialog>名為類別`colorDialog1`，，<xref:System.Windows.Forms.StatusStrip>用來控制<xref:System.Windows.Forms.ToolStripStatusLabel>名為`tbStatus`。 此外，它需要三個<xref:System.Windows.Forms.Button>命名的物件`btnReload`， `btnReset`，和`btnBackColor`。  
  
 [!code-cpp[AppSettingsSample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#1)]
 [!code-csharp[AppSettingsSample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#1)]
 [!code-vb[AppSettingsSample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Configuration.LocalFileSettingsProvider" />
    <altmember cref="T:System.Configuration.ApplicationScopedSettingAttribute" />
    <altmember cref="T:System.Configuration.UserScopedSettingAttribute" />
    <altmember cref="T:System.Configuration.SettingsGroupNameAttribute" />
    <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/64090a34-8556-4904-8ea0-20efe9f8c886">Windows Form 的應用程式設定</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 類別的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 類別的執行個體初始化成其預設狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式應在工作時，沒有與目前的設定包裝函式類別，衍生自相關聯的元件假設<xref:System.Configuration.ApplicationSettingsBase>。  
  
 建立包裝函式類別的執行個體時，繼承的程式碼會自動執行下列動作：  
  
1.  反映類別。  
  
2.  使用標記包裝函式的每個屬性`[UserScopedSettingAttribute]`或是`[ApplicationScopedSettingAttribute]`，對應<xref:System.Configuration.SettingsProperty>建立。  
  
3.  每個<xref:System.Configuration.SettingsProperty>有一些其根據其他屬性，則會選擇性地包裝函式的屬性，例如預設值或設定提供者的屬性集內。  
  
4.  所有其他屬性會直接放入屬性包，<xref:System.Configuration.SettingsProperty.Attributes%2A>屬性<xref:System.Configuration.SettingsProperty>類別。  
  
5.  所有<xref:System.Configuration.SettingsProperty>物件加入至<xref:System.Configuration.SettingsPropertyCollection>由<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>屬性<xref:System.Configuration.ApplicationSettingsBase>類別。 這個集合會傳遞至<xref:System.Configuration.SettingsBase.Initialize%2A>方法。  
  
 步驟 3 先前所述，為隱含<xref:System.Configuration.ApplicationSettingsBase>原生搭配數個屬性的屬性，特別是下列： <xref:System.Configuration.SettingsProviderAttribute>， <xref:System.Configuration.DefaultSettingValueAttribute>，和<xref:System.Configuration.SettingsSerializeAsAttribute>。 所有其他設定屬性會直接傳遞給適當的基礎提供者。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SettingsProperty" />
        <altmember cref="T:System.Configuration.SettingsPropertyCollection" />
        <altmember cref="M:System.Configuration.SettingsBase.Initialize(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection,System.Configuration.SettingsProviderCollection)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (owner As IComponent)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::ComponentModel::IComponent ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : System.ComponentModel.IComponent -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase owner" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">將做為應用程式設定物件之擁有者的元件。</param>
        <summary>使用提供的擁有者元件，初始化 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式就完全相當於<xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.ComponentModel.IComponent%2CSystem.String%29>叫用的建構函式：  
  
 `ApplicationSettingsBase(owner, String.Empty)`  
  
 包裝函式類別的具現化期間，如何使用反映相關的資訊，請參閱預設<xref:System.Configuration.ApplicationSettingsBase.%23ctor>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="P:System.ComponentModel.Component.Site" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (settingsKey As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::String ^ settingsKey);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : string -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase settingsKey" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="settingsKey">
          <see cref="T:System.String" />，可以唯一識別包裝函式類別的個別執行個體。</param>
        <summary>使用提供的設定索引鍵，初始化 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式初始化<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>屬性設為值的`settingsKey`參數。 這個屬性可用於釐清設定包裝函式類別，在相同的應用程式定義域中的不同執行個體。  
  
 包裝函式類別的具現化期間，如何使用反映相關的資訊，請參閱預設<xref:System.Configuration.ApplicationSettingsBase.%23ctor>建構函式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner, string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner, string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (owner As IComponent, settingsKey As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::ComponentModel::IComponent ^ owner, System::String ^ settingsKey);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : System.ComponentModel.IComponent * string -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase (owner, settingsKey)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">將做為應用程式設定物件之擁有者的元件。</param>
        <param name="settingsKey">
          <see cref="T:System.String" />，可以唯一識別包裝函式類別的個別執行個體。</param>
        <summary>使用提供的擁有者元件和設定索引鍵，初始化 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IComponent>所指定的物件`owner`參數做為此應用程式設定類別的目前執行個體擁有者。 包裝函式類別衍生自的設定初始化期間<xref:System.Configuration.ApplicationSettingsBase>，擁有者的站台針對查詢<xref:System.Configuration.ISettingsProviderService>。 如果有的話，它會偏好使用原生的設定提供者給包裝函式類別，所指定的所有屬性<xref:System.Configuration.SettingsProviderAttribute>。  
  
 這個建構函式初始化<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>屬性設為值的`settingsKey`參數。 這個屬性可用於釐清不同的執行個體相同的應用程式定義域中的包裝函式類別。  
  
 包裝函式類別的具現化期間，如何使用反映相關的資訊，請參閱預設<xref:System.Configuration.ApplicationSettingsBase.%23ctor>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Configuration.ISettingsProviderService" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Context" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Context As SettingsContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsContext ^ Context { System::Configuration::SettingsContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Configuration.SettingsContext" Usage="System.Configuration.ApplicationSettingsBase.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與設定群組相關的應用程式設定內容。</summary>
        <value>與設定群組相關的 <see cref="T:System.Configuration.SettingsContext" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個設定包裝函式類別衍生自<xref:System.Configuration.ApplicationSettingsBase>具有與其相關聯的內容。 內容會傳遞至每個屬性的設定提供者找出如何使用屬性。 因此，內容做為提示，以協助判斷最有效方式保存相關聯的應用程式設定值的設定提供者。  
  
 相反地，<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>屬性可讓設定提供者，以釐清具有相同的包裝函式類別的多個執行個體。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="T:System.Configuration.SettingsContext" />
        <altmember cref="T:System.Configuration.SettingsProvider" />
        <altmember cref="T:System.Configuration.ApplicationSettingsGroup" />
      </Docs>
    </Member>
    <Member MemberName="GetPreviousVersion">
      <MemberSignature Language="C#" Value="public object GetPreviousVersion (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPreviousVersion(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPreviousVersion (propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPreviousVersion(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetPreviousVersion : string -&gt; obj" Usage="applicationSettingsBase.GetPreviousVersion propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <see cref="T:System.String" />，包含要傳回其值的設定屬性名稱。</param>
        <summary>傳回同一應用程式之前一版本的具名設定屬性值。</summary>
        <returns>如果找到，則為包含指定 <see cref="T:System.Object" /> 值的 <see cref="T:System.Configuration.SettingsProperty" />，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A>方法通常用於搭配<xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>新版應用程式在安裝期間移轉應用程式設定時的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">屬性不存在。 屬性計數為零，或在資料存放區中找不到屬性。</exception>
        <altmember cref="T:System.Configuration.SettingsProperty" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.GetPreviousVersion(System.Configuration.SettingsContext,System.Configuration.SettingsProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string propertyName] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ propertyName); void set(System::String ^ propertyName, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Configuration.ApplicationSettingsBase.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <see cref="T:System.String" />，包含要存取的屬性名稱。</param>
        <summary>取得或設定指定應用程式設定屬性的值。</summary>
        <value>如果找到，則為已命名設定屬性的值，否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A>屬性，也就是索引子，經常會在包裝函式類別衍生自設定<xref:System.Configuration.ApplicationSettingsBase>。 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 將包裝函式類別的公用屬性繫結至對應的設定屬性。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 會引發數個事件，根據正在執行的作業：  
  
-   擷取屬性時，第一次<xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded>就會引發事件。  
  
-   當屬性設定時，<xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A>就會引發事件。 如果處理常式並不會取消事件，則在設定屬性值和<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>就會引發事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">沒有與目前包裝函式相關的屬性，或找不到指定屬性。</exception>
        <exception cref="T:System.Configuration.SettingsPropertyIsReadOnlyException">已嘗試設定唯讀屬性。</exception>
        <exception cref="T:System.Configuration.SettingsPropertyWrongTypeException">在設定作業期間，提供之值的型別與設定屬性不相容。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">無法剖析組態檔。</exception>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="P:System.Configuration.SettingsProperty.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (object sender, System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(object sender, class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (sender As Object, e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Object ^ sender, System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : obj * System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : obj * System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="applicationSettingsBase.OnPropertyChanged (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。</param>
        <param name="e">
          <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnPropertyChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingChanging (object sender, System.Configuration.SettingChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingChanging(object sender, class System.Configuration.SettingChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingChanging (sender As Object, e As SettingChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingChanging(System::Object ^ sender, System::Configuration::SettingChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingChanging : obj * System.Configuration.SettingChangingEventArgs -&gt; unit&#xA;override this.OnSettingChanging : obj * System.Configuration.SettingChangingEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingChanging (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。</param>
        <param name="e">
          <see cref="T:System.Configuration.SettingChangingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingsLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsLoaded (object sender, System.Configuration.SettingsLoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsLoaded(object sender, class System.Configuration.SettingsLoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingsLoaded (sender As Object, e As SettingsLoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingsLoaded(System::Object ^ sender, System::Configuration::SettingsLoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingsLoaded : obj * System.Configuration.SettingsLoadedEventArgs -&gt; unit&#xA;override this.OnSettingsLoaded : obj * System.Configuration.SettingsLoadedEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingsLoaded (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingsLoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。</param>
        <param name="e">
          <see cref="T:System.Configuration.SettingsLoadedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingsSaving">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsSaving (object sender, System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsSaving(object sender, class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingsSaving (sender As Object, e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingsSaving(System::Object ^ sender, System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingsSaving : obj * System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnSettingsSaving : obj * System.ComponentModel.CancelEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingsSaving (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。</param>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsSaving%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Properties As SettingsPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsPropertyCollection ^ Properties { System::Configuration::SettingsPropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Configuration.SettingsPropertyCollection" Usage="System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包裝函式中設定屬性的集合。</summary>
        <value>
          <see cref="T:System.Configuration.SettingsPropertyCollection" />，包含目前包裝函式中使用的所有 <see cref="T:System.Configuration.SettingsProperty" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `get`存取子<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>屬性會反映之中繼資料的設定包裝函式類別，衍生自<xref:System.Configuration.ApplicationSettingsBase>、 動態決定的一組可用的應用程式設定屬性。  
  
 <xref:System.Configuration.ApplicationSettingsBase>類別原本就會辨識某些特性的應用程式設定，例如其名稱、 屬性型別、 設定提供者、 預設值，讀取唯一的狀態，以及序列化喜好設定。 這些特性會鏡像處理中以內容形式<xref:System.Configuration.SettingsProperty>類別。 設定屬性的所有其他屬性只被傳遞到其相關聯的設定提供者。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">找不到相關的設定提供者，或其執行個體化已失敗。</exception>
        <altmember cref="P:System.Configuration.SettingsBase.PropertyValues" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="T:System.Configuration.SettingsProperty" />
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PropertyChanged As PropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberSignature Language="F#" Value="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " Usage="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式設定屬性值變更之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>透過變更一個設定屬性時，會引發事件`set`存取子<xref:System.Configuration.ApplicationSettingsBase.Item%2A>方法，或針對每個屬性時進行呼叫，以還原<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>或<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>方法。  
  
 沒有對應的`PropertyChanging`這個事件類別; 相反地，請參閱<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
        <altmember cref="T:System.ComponentModel.PropertyChangedEventArgs" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
      </Docs>
    </Member>
    <Member MemberName="PropertyValues">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyValueCollection PropertyValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyValueCollection PropertyValues" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PropertyValues As SettingsPropertyValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsPropertyValueCollection ^ PropertyValues { System::Configuration::SettingsPropertyValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyValues : System.Configuration.SettingsPropertyValueCollection" Usage="System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得屬性值的集合。</summary>
        <value>屬性值的 <see cref="T:System.Configuration.SettingsPropertyValueCollection" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Providers As SettingsProviderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsProviderCollection ^ Providers { System::Configuration::SettingsProviderCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Providers : System.Configuration.SettingsProviderCollection" Usage="System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包裝函式使用之應用程式設定提供者的集合。</summary>
        <value>
          <see cref="T:System.Configuration.SettingsProviderCollection" />，包含目前設定包裝函式之設定屬性使用的所有 <see cref="T:System.Configuration.SettingsProvider" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.SettingsProviderAttribute>判斷何種設定提供者由設定包裝函式類別或個別設定屬性。 如果未指定此屬性，用戶端應用程式會使用<xref:System.Configuration.LocalFileSettingsProvider>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="M:System.Configuration.SettingsBase.Initialize(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection,System.Configuration.SettingsProviderCollection)" />
      </Docs>
    </Member>
    <Member MemberName="Reload">
      <MemberSignature Language="C#" Value="public void Reload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reload();" />
      <MemberSignature Language="F#" Value="member this.Reload : unit -&gt; unit" Usage="applicationSettingsBase.Reload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新整理持續性儲存體 (Persistent Storage) 的應用程式設定屬性值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>方法會清除目前快取的屬性值，在後續存取時，造成重新載入這些值從永續性儲存體。 這個方法會執行下列動作：  
  
-   它會清除目前快取的屬性，藉由清除所表示之集合<xref:System.Configuration.SettingsBase.PropertyValues%2A>屬性。  
  
-   它會引發<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>事件的每位成員<xref:System.Configuration.ApplicationSettingsBase.Properties%2A>集合。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 相反<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>在於前者會載入最後一集的已儲存的應用程式設定值，而後者會載入已儲存的預設值。  
  
   
  
## Examples  
 下列程式碼範例所示<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>方法的主體中叫用<xref:System.Windows.Forms.Control.Click>名為按鈕的事件處理常式`btnReload`。 此呼叫後，應用程式設定的目前儲存的值會重新載入至其對應的屬性。 完整的程式碼範例會列在<xref:System.Configuration.ApplicationSettingsBase>類別概觀。  
  
 [!code-cpp[AppSettingsSample#6](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#6)]
 [!code-csharp[AppSettingsSample#6](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#6)]
 [!code-vb[AppSettingsSample#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
        <altmember cref="P:System.Configuration.SettingsBase.PropertyValues" />
        <altmember cref="M:System.Configuration.SettingsPropertyValueCollection.Clear" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="applicationSettingsBase.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將保存的應用程式設定值還原至其對應的預設屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A>方法會覆寫使用者範圍的設定屬性來還原每個應用程式設定的目前保存的值。 這個方法會執行下列動作：  
  
-   它會呼叫<xref:System.Configuration.IApplicationSettingsProvider.Reset%2A?displayProperty=nameWithType>上支援此選擇性方法，每個設定提供者的方法。  
  
-   它會呼叫<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>方法，以強制重新整理的設定屬性值。  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 相反<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>在於前者會載入最後一集的已儲存的應用程式設定值，而後者會載入已儲存的預設值。  
  
   
  
## Examples  
 下列程式碼範例所示<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>方法的主體中叫用<xref:System.Windows.Forms.Control.Click>名為按鈕的事件處理常式`btnReset`。 此呼叫後，應用程式設定的預存的預設值，會重新載入至其對應的屬性。 完整的程式碼範例會列在<xref:System.Configuration.ApplicationSettingsBase>類別概觀。  
  
 [!code-cpp[AppSettingsSample#5](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#5)]
 [!code-csharp[AppSettingsSample#5](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#5)]
 [!code-vb[AppSettingsSample#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">無法剖析組態檔。</exception>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.Reset(System.Configuration.SettingsContext)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public override void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Save" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Save();" />
      <MemberSignature Language="F#" Value="override this.Save : unit -&gt; unit" Usage="applicationSettingsBase.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存應用程式設定屬性的目前值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Save%2A>方法會寫入其相關聯的資料存放區中的每個設定屬性的目前值。 每一個屬性，這個方法會呼叫<xref:System.Configuration.SettingsProvider.SetPropertyValues%2A>相關聯的設定提供者上的方法。  
  
 這個方法不同於 基底類別實作，便會產生<xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>前的值會寫入事件。  
  
 如果所定義的唯一設定是應用程式範圍的設定，<xref:System.Configuration.ApplicationSettingsBase.Save%2A>沒有任何影響，並不傳回任何錯誤，如果使用預設值來呼叫<xref:System.Configuration.LocalFileSettingsProvider>。 <xref:System.Configuration.LocalFileSettingsProvider> 只會儲存使用者範圍的設定。  
  
> [!IMPORTANT]
>  沒有對應的 Load 方法，因為在包裝函式類別初始設定期間自動載入應用程式設定的值。 相反地，這些值不會自動儲存應用程式結束時。 因此，您必須明確呼叫<xref:System.Configuration.ApplicationSettingsBase.Save%2A>方法，將應用程式設定的目前值。 這通常會在執行<xref:System.Windows.Forms.Form.Closing>事件處理常式的主要或包含<xref:System.Windows.Forms.Form>。  
  
   
  
## Examples  
 下列程式碼範例所示<xref:System.Configuration.ApplicationSettingsBase.Save%2A>方法呼叫從<xref:System.Windows.Forms.Form.Closing>主要表單的事件處理常式。 這個方法也會提供額外的週期附加到表單的相關聯之設定屬性<xref:System.Windows.Forms.Control.Text%2A>屬性。  
  
 完整的程式碼範例會列在<xref:System.Configuration.ApplicationSettingsBase>類別概觀。  
  
 [!code-cpp[AppSettingsSample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#3)]
 [!code-csharp[AppSettingsSample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#3)]
 [!code-vb[AppSettingsSample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
        <altmember cref="M:System.Configuration.SettingsProvider.SetPropertyValues(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyValueCollection)" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SettingChanging">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingChangingEventHandler SettingChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingChangingEventHandler SettingChanging" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingChanging As SettingChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingChangingEventHandler ^ SettingChanging;" />
      <MemberSignature Language="F#" Value="member this.SettingChanging : System.Configuration.SettingChangingEventHandler " Usage="member this.SettingChanging : System.Configuration.SettingChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式設定屬性值變更之前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging>應用程式設定值，屬性透過在變更之前，就會發生事件<xref:System.Configuration.ApplicationSettingsBase.Item%2A>方法。 這個事件就不會引發的時機<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>或<xref:System.Configuration.ApplicationSettingsBase.Reset%2A>方法受到呼叫。 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 您可以透過取消<xref:System.Configuration.SettingChangingEventArgs>事件資料類別。  
  
 您通常會使用<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>来處理個別的設定屬性的立即驗證事件。 如需有關驗證的詳細資訊，請參閱 <<c0> [ 如何： 驗證應用程式設定](~/docs/framework/winforms/advanced/how-to-validate-application-settings.md)。  
  
 沒有對應的`SettingChanged`這個事件類別; 相反地，請參閱<xref:System.Configuration.ApplicationSettingsBase.PropertyChanged>事件。  
  
   
  
## Examples  
 下列程式碼範例所示<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>型別的物件的事件處理常式`FormSettings`，包裝函式類別衍生自<xref:System.Configuration.ApplicationSettingsBase>。 這個處理常式將事件資訊顯示在文字方塊中名為`tbStatus`。 完整的程式碼範例會列在<xref:System.Configuration.ApplicationSettingsBase>類別概觀。  
  
 [!code-cpp[AppSettingsSample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#7)]
 [!code-csharp[AppSettingsSample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#7)]
 [!code-vb[AppSettingsSample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="T:System.Configuration.SettingChangingEventArgs" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/9f145ada-4267-436a-aa4c-c4dcffd0afb7">如何：驗證應用程式設定</related>
      </Docs>
    </Member>
    <Member MemberName="SettingsKey">
      <MemberSignature Language="C#" Value="public string SettingsKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SettingsKey" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberSignature Language="VB.NET" Value="Public Property SettingsKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SettingsKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SettingsKey : string with get, set" Usage="System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式設定群組的設定索引鍵。</summary>
        <value>
          <see cref="T:System.String" />，包含目前設定群組的設定索引鍵。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>屬性，可讓用戶端程式碼，在特定的設定提供者，來區分相同的應用程式設定類別的多個執行個體。  
  
 除非設定包裝函式類別設計為使用單一子句模式，可能會有相同的應用程式設定類別，在單一應用程式中的多個執行個體。 值<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>應該根據屬性值是如何共用設定。  
  
-   如果設定屬性的包裝函式要在相同的應用程式，然後包裝函式的所有執行個體之間共用<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>應該在所有執行個體具有相同的值。 這是預設行為<xref:System.Configuration.ApplicationSettingsBase>類別。  
  
-   如果包裝函式的設定屬性主要做為每個執行個體，然後<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>應該有唯一的值，每個執行個體。 <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.String%29>建構函式的版本可讓您在初始化<xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A>的唯一字串。  
  
 相反地，<xref:System.Configuration.ApplicationSettingsBase.Context%2A>屬性來設定提供者，讓它能夠將值保存在以有效率且進行有條理的方式提供的提示。  
  
 <xref:System.Configuration.SettingChangingEventArgs>類別包含類似<xref:System.Configuration.SettingChangingEventArgs.SettingKey%2A>屬性，可協助識別來源<xref:System.Configuration.ApplicationSettingsBase.SettingChanging>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Context" />
        <altmember cref="T:System.Configuration.SettingChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SettingsLoaded">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsLoadedEventHandler SettingsLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsLoadedEventHandler SettingsLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingsLoaded As SettingsLoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingsLoadedEventHandler ^ SettingsLoaded;" />
      <MemberSignature Language="F#" Value="member this.SettingsLoaded : System.Configuration.SettingsLoadedEventHandler " Usage="member this.SettingsLoaded : System.Configuration.SettingsLoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsLoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於從儲存區擷取應用程式設定之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded>只有在初始之後發生的事件`get`存取第一個組態屬性使用，通常透過<xref:System.Configuration.ApplicationSettingsBase.Item%2A>方法。 後續的存取會使用在本機快取的設定屬性的值。 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A>和<xref:System.Configuration.ApplicationSettingsBase.Reload%2A>方法將會清除所有快取的值，因此將會再次引發這個事件，在後續的屬性存取。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
        <altmember cref="T:System.Configuration.SettingsLoadedEventArgs" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
      </Docs>
    </Member>
    <Member MemberName="SettingsSaving">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsSavingEventHandler SettingsSaving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsSavingEventHandler SettingsSaving" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingsSaving As SettingsSavingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingsSavingEventHandler ^ SettingsSaving;" />
      <MemberSignature Language="F#" Value="member this.SettingsSaving : System.Configuration.SettingsSavingEventHandler " Usage="member this.SettingsSaving : System.Configuration.SettingsSavingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsSavingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於值儲存至資料存放區之前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>引發事件<xref:System.Configuration.ApplicationSettingsBase.Save%2A>之前它會儲存到其相關聯的資料存放區的應用程式設定屬性的方法。 相關聯的事件處理常式可以取消這個事件。  
  
   
  
## Examples  
 下列程式碼範例所示<xref:System.Configuration.ApplicationSettingsBase.SettingsSaving>型別的物件的事件處理常式`FormSettings`，包裝函式類別衍生自<xref:System.Configuration.ApplicationSettingsBase>。 處理常式會要求使用者儲存目前的應用程式設定屬性值。 完整的程式碼範例會列在<xref:System.Configuration.ApplicationSettingsBase>類別概觀。  
  
 [!code-cpp[AppSettingsSample#8](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#8)]
 [!code-csharp[AppSettingsSample#8](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#8)]
 [!code-vb[AppSettingsSample#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
      </Docs>
    </Member>
    <Member MemberName="Upgrade">
      <MemberSignature Language="C#" Value="public virtual void Upgrade ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Upgrade() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Upgrade ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Upgrade();" />
      <MemberSignature Language="F#" Value="abstract member Upgrade : unit -&gt; unit&#xA;override this.Upgrade : unit -&gt; unit" Usage="applicationSettingsBase.Upgrade " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>更新應用程式設定，以反映應用程式的最近安裝。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>方法會執行兩個動作，以確保順利轉換到新版的應用程式：  
  
-   它會通知所有對應的設定提供者的存在升級的應用程式透過呼叫其<xref:System.Configuration.IApplicationSettingsProvider.Upgrade%2A?displayProperty=nameWithType>方法，假設他們已實作<xref:System.Configuration.IApplicationSettingsProvider>介面。 如果設定包裝函式類別標示為不會執行此動作<xref:System.Configuration.NoSettingsVersionUpgradeAttribute>。  
  
-   它會重新載入所有應用程式設定的值。  
  
 您可以覆寫預設行為<xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A>來實作自訂升級或合併行為。 使用<xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A>方法來擷取個別的值，對於舊版的應用程式的設定。 自訂升級行為的範例包括：  
  
-   使用新的 「 原則 」 預設值覆寫一個或多個先前的使用者指定值或先前的預設值。  
  
-   特殊的相容性，使用較新範圍、 不同的設定屬性群組和等等的舊值的翻譯。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">無法剖析組態檔。</exception>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
        <altmember cref="T:System.Configuration.NoSettingsVersionUpgradeAttribute" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.Upgrade(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection)" />
      </Docs>
    </Member>
  </Members>
</Type>