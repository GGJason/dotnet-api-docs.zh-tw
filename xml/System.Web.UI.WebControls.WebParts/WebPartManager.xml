<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9547ea91f11aaf1618012121bb5893b5e180940a" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51911025" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>作為 Web 組件控制項集合的中心類別，管理在網頁上發生的所有 Web 組件控制項、功能和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項可當做 Web 組件應用程式的集線器或控制中心。 必須要有一個，且只有一個-<xref:System.Web.UI.WebControls.WebParts.WebPartManager>使用 Web 組件控制項的每個頁面上的控制項執行個體。 如同 Web 組件的應用程式的大部分層面<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項只適用於已驗證的使用者。 此外，它的功能適用於幾乎完全位於繼承自的 Web 組件區域內的伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebZone>類別。 這些區域之外的頁面上的伺服器控制項可以有極少的 Web 組件的功能或互動<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 為 Web 組件功能，在頁面上，中樞<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項執行下表中所述的工作種類。  
  
|工作分類|控制項的功能|  
|-------------------|---------------------------|  
|追蹤 Web 組件控制項|追蹤的許多不同種類的頁面上的控制項提供 Web 組件功能，包括<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 連線、 區域和其他項目。|  
|新增和移除 Web 組件控制項|提供方法來新增、 刪除和關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>網頁上的控制項。|  
|管理連線|建立控制項之間的連線，並且會監視連線，以及新增和移除它們的處理程序。|  
|個人化的控制項和網頁|可讓使用者在頁面上，移至不同位置的控制項，並啟動外觀、 屬性和控制項的行為，可以編輯使用者的檢視。 會維護每個頁面上的特定使用者個人化設定。|  
|不同的網頁檢視之間切換|之間切換不同的頁面上，特製化的檢視，讓使用者可以執行特定工作，例如變更頁面配置或編輯控制項。|  
|引發 Web 組件生命週期事件|定義、 引發，並可讓開發人員處理的 Web 組件控制項，例如當控制項正在加入、 移除、 已連線，或刪除的生命週期事件。|  
|啟用匯入和匯出的控制項|匯出包含的屬性狀態的 XML 資料流<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並可讓使用者匯入為了方便起見，在個人化複雜的控制項，在其他網頁或網站中的檔案。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別有大量的屬性。 配合<xref:System.Web.UI.WebControls.WebParts.WebPartManager>追蹤其他控制項的角色，它有一些參考的 Web 組件控制項或其他特殊的 Web 組件物件集合的屬性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>，並<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性所使用的所有集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager>其追蹤和其他控制項管理工作。  
  
 屬性的另一個群組包含可自訂的 Web 組件應用程式中發生特定情況套用的警告。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>，則<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會覆寫其基底的繼承屬性，許多 Web 伺服器控制項所使用的部分。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性。  
  
 最後，還有一組屬性可用來存取應用程式的目前狀態。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性會指出目前的頁面是中的顯示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>屬性會指出是否允許控制項呈現用戶端指令碼，也就是相關的情況下，使用者可能有不同的功能的瀏覽器或的指令碼處理已關閉。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性可用於參考包含數個重要的 Web 組件方法所使用的擴充性的情況下呼叫的公用程式類別。 藉由隱藏個別的類別中的這些方法的呼叫 (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>類別)，則<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別自己的 API 已經過簡化。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性可儲存使用者的個人化設定與該資料保存到永久儲存區的個人化物件的存取。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性可指出哪些<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項在網頁上的目前選取的使用者或應用程式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性會指出是否在上的自訂個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項已變更。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項包含五個內建的顯示模式或網頁的檢視。 開發人員可以擴充此功能，例如擴充型別建立自訂的顯示模式<xref:System.Web.UI.WebControls.WebParts.WebZone>類別或<xref:System.Web.UI.WebControls.WebParts.ToolZone>類別。 使用者可以到各種不同的顯示模式中，切換頁面上，前提是適當對應至指定的顯示模式的控制項類型會出現在頁面上。  
  
> [!NOTE]
>  可以擴充此功能，讓使用者可以切換到自訂的顯示模式，而不需要對應的區域在頁面上。 不過，預設行為是顯示模式會對應至區域。  
  
 在標準的顯示模式都由公用欄位<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。 下表摘要說明的欄位，且它們參考的顯示模式。 目前的顯示模式的頁面上，如先前所述，固定會參考中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，並可在特定的頁面上，指定的區域出現在頁面上，類型的顯示模式集合包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
|欄位|顯示模式的詳細資料|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|一般使用者的檢視網頁;預設值和最常見的顯示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|使用者可以重新排列或刪除控制項，以變更頁面配置 檢視。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|變成可見的。 編輯的使用者介面 (UI) 的檢視使用者可以編輯的外觀、 屬性和行為，會顯示在一般的瀏覽模式的控制項。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|變成可見的; 目錄 UI 的檢視使用者可以從 類別目錄中可用的控制項，將控制項加入頁面。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|變成可見的; 連接 UI 的檢視使用者可以連接、 管理或中斷控制項之間的連接。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會包含在 Web 組件頁面和控制項的生命週期中不可或缺的事件數目。 這些事件提供精確地以程式設計方式控制 Web 組件控制項的行為。 大部分的方法與直接相關<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或其他伺服器或使用者控制項置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域，讓它們可以做<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項)。 不過，少數事件有關的頁面或頁面上的連接狀態。 下表列出可用的事件，並摘要說明其用途。  
  
> [!NOTE]
>  在下表中的所有情況下，「 控制項 」 是指<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項或任何伺服器控制項位於區域中，會包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在執行階段的物件。  
  
|Event - 事件|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|控制項加入至頁面，以便確認它已獲授權之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在頁面上的所有連線都已都啟動後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|啟動頁面上的所有連接的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|目前的顯示模式的頁面已變更之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|變更頁面的顯示模式的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|已取消選取的控制項之後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|取消選取的控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|將控制項新增至區域之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|將控制項新增至區域的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|發生於控制項已關閉 （從頁面移除） 之後。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|關閉控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|動態控制項 （一個以程式設計方式建立或新增從類別目錄） 的執行個體已永久刪除之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|刪除動態控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控制項已移動在其區域或另一個區域之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|移動控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|選取要參與連線的兩個控制項都已建立連接之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|連接兩個控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|連線已經中斷連接的兩個控制項之後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|中斷連線的兩個控制項的程序之前發生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項有許多方法來管理網頁組件頁面。 大量的方法，未列在這裡，是其名稱會採用的方法*EventName*。 這些方法通常引發其相關聯的事件，並提供事件類型的處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>。 繼承自開發人員可以覆寫這些方法大多<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。 此外，網頁程式開發人員可以使用這些方法相關聯的事件提供自訂處理常式。 比方說，如果是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件，為網頁開發人員可以加入`OnWebPartAdded`屬性設定為`<asp:webpartmanager>`的標記網頁，然後將指派的自訂方法名稱屬性，以提供自訂事件的處理中的項目。 屬性會對應<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法和事件處理適用於大部分的 Web 組件事件和其相關聯的方法的這個基本模式。  
  
 颾魤 ㄛ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項都有特定的管理工作的方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (與伺服器或使用者控制項作為<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項)。 這些方法包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 另一組方法，被專門用來連線。 這包括方法，例如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>，以及<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>。  
  
 最後，某些<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法著重於個人化功能。 這些包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 如需其他詳細資訊<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法，可透過存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性，請參閱文件<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>類別。  
  
   
  
## Examples  
 下列程式碼範例示範宣告式和以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 使用者控制項有下拉式清單控制項在頁面上，指定 Web 組件控制項出現在頁面上顯示可能的顯示模式。 在網頁上，此程式碼範例中，這個使用者控制項宣告的正下方<xref:System.Web.UI.WebControls.WebParts.WebPartManager>網頁的標記中的項目，而且沒有`Register`指示詞來註冊控制項的網頁頂端附近。 For 詳細資料會顯示在此控制項模式和原始碼的描述，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web 網頁的宣告式標記包含`Register`使用者控制項和自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目以包含自訂控制項，並有`<asp:connectionszone>`項目。 這個頁面也包含一些內嵌程式碼，處理連接相關的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制; 您可以看到這段程式碼的效果，當您連接和中斷連接控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 請注意，沒有名為的介面`IZipCode`，並在實作這個介面`ZipCodeWebPart`類別。 這個類別具有一個名為的特殊回呼方法`ProvideIZipCode`做為提供者。 其他類型，名為`WeatherWebPart`，也利用特殊的方法，名為實作`GetIZipCode`，使得控制項做為其他控制項的取用者。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此程式碼範例假設您有組件中，編譯的來源和`Register`網頁中的指示詞參考的組件名稱。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接 UI 出現後，按一下**建立取用者的連接**連結。 資料格會顯示具有下拉式清單控制項。 選取 **天氣控制項**中的下拉式清單中，然後按一下**Connect**完成兩個控制項的連線。 按一下 **關閉**，然後使用**顯示模式**頁面返回標準瀏覽模式的下拉式清單。 您可以輸入郵遞區號，和消費者控制項將會更新與您所輸入的值。 因為`ZipCode`屬性標記為`Personalizable`在原始程式碼中，這個屬性值的屬性將瀏覽器工作階段之間保存，因此儲存由使用者所輸入的值。 更複雜的消費者控制項無法接受郵遞區號資訊、 天氣資訊根據程式碼中，查詢和顯示給使用者。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項的設計是要擴充。 因為它是 Web 組件應用程式，當您想要擴充某種特定類型或控制 Web 組件控制集，在許多情況下的中心必須也延伸讓<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，因為很可能會有一些屬性或方法，才能讓 您的自訂類型的 Web 組件應用程式的內容中運作。 Web 組件參考文件 (請參閱<see cref="N:System.Web.UI.WebControls.WebParts" />)，討論如何擴充 Web 組件輸入時，經常提及哪些項目要進行擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，或示範如何擴充在程式碼範例。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>建構函式會初始化所使用的數個重要變數<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 會直接影響所有的網頁組件頁面的第一個指派為預設頁面顯示模式設定為瀏覽模式的事實 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使網頁上目前非現用的所有連接成為現用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>至頁面每個要求，啟動之間的現有連接上呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>和位於其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域。 在某些情況下，執行個體，如果沒有衝突的連接中啟用，這個方法又呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法以結束有問題的連線。 在中斷連線程序期間<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>就會引發事件。 通常開發人員可以取消這個事件，但在情況下，這是衝突的連接，便無法予以取消，因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項需要解決的衝突，才能完成啟用連線處理程序。 如需詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要加入至網頁或在頁面上開啟的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (或伺服器或使用者控制項)。</param>
        <param name="zone">
          <c>webPart</c> 正在加入至的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">整數，表示 <c>webPart</c> 在 <c>zone</c> 佔用的序號位置，相對於 <c>zone</c> 中的其他控制項。</param>
        <summary>為加入 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項至網頁，提供標準的程式設計方法。</summary>
        <returns>已加入至頁面的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法可同時加入新的動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制頁面上，並重新開啟先前已關閉網頁的靜態或動態控制項。 呼叫方法時，若要加入新的控制項，它實際上會建立一份中參考的控制項`webPart`參數。 複本的控制項，會產生新的識別碼，因此開發人員應該參考<xref:System.Web.UI.WebControls.WebParts.WebPart>控制傳回的方法，以取得新的識別碼值。 若要重新開啟先前已關閉的控制項呼叫方法時，它會傳回所參考的控制項的直接參考`webPart`參數。  
  
> [!IMPORTANT]
>  您應該一律使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，而非<xref:System.Web.UI.ControlCollection.Add%2A>方法所參考的控制項集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType>屬性，以新增<xref:System.Web.UI.WebControls.WebParts.WebPart>到頁面上，以程式設計方式控制，因為使用<xref:System.Web.UI.ControlCollection.Add%2A>方法會擲回例外狀況。 若要將控制項不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (換句話說，就會將它換行，與伺服器控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段)，您應該先呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法來建立控制項，並接著呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法來加入控制項。 如需示範這種方法，請參閱 < 範例 > 一節。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>要以程式設計方式新增至網頁的伺服器控制項的方法。 在網頁標記包含空`<asp:webpartzone>`項目，和`<asp:webpartmanager>`項目。 第一次**加入行事曆**按一下按鈕時，程式碼在事件處理常式會建立<xref:System.Web.UI.WebControls.Calendar>控制項，並將它新增至區域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件，呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。  
  
\-或- 
 <paramref name="zone" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> 並未在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的區域集合中註冊。  
  
\-或- 
 <paramref name="webPart" /> 已經在 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定的值小於零。<paramref name="zoneIndex" /></exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當呼叫 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法，以判斷 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項是否可以加入至頁面時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件就會發生<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項正在加入至頁面。 有幾個常見的案例，其中加入控制項至頁面。 這些完整說明，請參閱 < 備註 > 一節<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。 當控制項加入時，必須檢查以查看是否其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>已經設定屬性，而且如果是的話，是否控制項獲得授權可加入至頁面。  
  
 開發人員可以建立事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，來提供篩選控制項。 如果控制項的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值不符合事件處理常式程式碼中的條件，控制項不會加入至頁面。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定的自訂事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，會自動覆寫預設<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。  
  
 中的程式碼`mgr1_AuthorizeWebPart`方法會檢查頁面上的控制項是否有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`user`而且，如果是的話，會傳回`true`，這表示將會獲得授權並新增至頁面。 這是假設的預設方法是允許使用者檢視與頁面的控制項在使用者的個人化範圍。 請注意，不過，在控制項的其中一個範例中具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`admin`。 開發人員可能會專為系統管理使用者只查看的特製化控制項上放置此篩選器。 這個控制項將會失敗期間的授權檢查<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，並不會顯示。 請注意並沒有設定之屬性的控制項; 也會顯示它們會假設不是篩選案例的一部分，因為其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>沒有設定的屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件的集合，這些物件可用於建立伺服器控制項之間的 Web 組件連接。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" />，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法用來建立集合。 根據預設，它會從應用程式組態檔讀取可用的轉換程式。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/d98cfd0f-ebd6-4871-89d5-abbd2cdef67b">Web 組件連線概觀</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在建立連接的控制項。</param>
        <summary>啟動連接兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法是否存在，以便建立控制項之間連接的程序可在不同的階段，讓開發人員更充分掌控連線程序。 此方法會執行一組初始的檢查，以確保`webPart`處於的其中一個連線可以合法組成。 如果`webPart`通過所有檢查時，它接著會設定為目前選取的控制項 (請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性)，而且連接的程序可以繼續。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">頁面上目前的顯示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已關閉。  
  
\-或- 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的一部分。  
  
-或- 
 <paramref name="webPart" /> 等於 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控制項。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 其中一個方法是呼叫基底方法，然後再加入其他自訂處理;或者，您可能想要完全自訂啟動控制項之間連接的程序。 比方說，您可以確認特定的資料可供使用，然後再建立連線。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要編輯的控制項。</param>
        <summary>啟動編輯 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法是否存在，以便編輯控制項的程序可在不同的階段，讓開發人員更充分掌控的處理程序。 此方法會執行一組初始的檢查，以確保`webPart`處於的狀態，可以編輯它。 如果`webPart`通過所有檢查時，它接著會設定為目前選取的控制項 (請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性)，而且可以繼續編輯程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">頁面上目前的顯示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已關閉。  
  
\-或- 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的一部分。  
  
-或- 
 <paramref name="webPart" /> 等於 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控制項。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 組件控制項之頁面的預設顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>欄位會參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要控制項的執行個體。  
  
 包含 Web 組件的頁面控制項第一次載入時，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 如同一般的網頁上，使用者只要瀏覽，頁面仍保留在瀏覽模式。 如果使用者想要個人化頁面的版面配置、 控制項、 外觀或行為，他們必須將網頁切換成其中一個特製化的顯示模式可透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>欄位以程式設計的方式。 支援的顯示模式，在此情況下為 瀏覽和設計下拉式清單中填入程式碼。 請注意，在`Page_PreRender`方法中，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>。 如果是的話`Label1`會顯示，如果沒有的話，`Label1`會隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意，指出您的瀏覽模式在頁面上的標籤。 使用下拉式清單控制項，將頁面切換到設計模式。 請注意，因為中的程式碼`Page_PreRender`方法中，標籤現在會隱藏起來。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，以判斷這些控制項是否可以連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法用來判斷兩個<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可以連接。 方法通常用做為條件式的檢查，才能呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法會檢查幾個兩個控制項可以形成連線之前必須符合的條件。 下列清單摘要說明主要的準則進行連接。 如果已符合所有這些準則 （加上一些額外的內部狀況），則方法會傳回`true`，表示控制項可以連接：  
  
-   提供者和消費者控制項不能`null`，它們必須包含在所參考的控制項的集合和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
-   提供者和取用者不能在同一個控制項。 亦即<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項無法連線到本身。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>提供者和取用者的物件 （連接點） 不能是`null`。  
  
-   無法關閉提供者和取用者 (沒有控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>屬性可以是`true`)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>連接點控制項的屬性必須比對的消費者和提供者的控制項型別。  
  
-   連接點皆必須啟用 (及其<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>方法必須都傳回`true`)。  
  
-   每一個連接點必須未嘗試形成更多的連線，在它自己所指定者<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>屬性。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件 (transformer)，才能連接不相容的控制項，它不能為`null`。 不過，如果控制項已經相容，必須是 transformer `null`。  
  
-   轉換器 （如果使用） 必須在中參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>集合。  
  
-   轉換器 （如果使用） 必須是相容的提供者和取用者，以便它可以將兩個控制項之間的資料轉換的介面。 次要介面的消費者和提供者也必須相容。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">當兩個控制項連線時，提供資料給 <c>consumer</c> 的控制項。</param>
        <param name="providerConnectionPoint">讓 <c>provider</c> 參與連線的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">當兩個控制項連線時，從 <c>provider</c> 接收資料的控制項。</param>
        <param name="consumerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>consumer</c> 可以參與連線。</param>
        <summary>當提供者和消費者控制項有相容的介面，並且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件時，檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控制項是否可以連接。</summary>
        <returns>布林值，指出 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來連接`provider`並`consumer`當兩個控制項有相容的連接點型別，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>不需要物件。 您可能想要使用這個方法來確認兩個控制項都可以連接然後再呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>建立的程式設計連線。  
  
 這個多載會使用相同的實作，做為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法多載，在這個多載不需要轉換程式唯一的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項`<asp:webpartmanager>`項目，並建立連線，使用一些事件處理程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 網頁的宣告式標記包含`Register`使用者控制項和自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目以包含自訂控制項，並有`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法中，程式碼會檢查是否連線可和，若是如此，定義提供者、 取用者，以及其各自的連接點，然後將新的連線新增至所參考的靜態連接集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 它包含介面和兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，做為提供者和取用者為另一個。 因為它們有相容的連接點 (它們兩者皆認定`IZipCode`介面)，轉換程式不需要進行連接。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會出現之後，請注意，連線已經存在的程式碼中包含`Page_Load`方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">當兩個控制項連線時，提供資料給 <c>consumer</c> 的控制項。</param>
        <param name="providerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>provider</c> 可以參與連線。</param>
        <param name="consumer">當兩個控制項連線時，從 <c>provider</c> 接收資料的控制項。</param>
        <param name="consumerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>consumer</c> 可以參與連線。</param>
        <param name="transformer">讓不相容的 <c>provider</c> 和 <c>consumer</c> 連線的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，以判斷它們是否可以連接，並且使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件，來建立不相容消費者和提供者之間的連接。</summary>
        <returns>布林值，指出 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以建立連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來連接`provider`並`consumer`當兩個控制項都有不相容連接點型別，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>需要物件時。 您可能想要使用這個方法來確認兩個控制項都可以連接然後再呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>建立的程式設計連線。  
  
 這個多載會使用相同的實作，做為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法多載，在這個多載都需要轉換程式唯一的例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示從控制項目錄將伺服器控制項加入至網頁時所使用的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>欄位會參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要控制項的執行個體。  
  
 當使用者想要將控制項加入至頁面，如果可用的伺服器控制項的目錄時，它們可以切換至頁面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>（目錄模式），並出現類別目錄的使用者介面 (UI)。 Web 組件類別目錄的 UI 由提供<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>區域控制項。 開發人員加入網頁中的這個區域，在設計階段，並，讓使用者將能夠在執行階段將這些控制項加入其頁面，再將伺服器控制項新增到區域。 開發人員已加入這些控制項之後，目錄模式會成為頁面上的受支援的顯示模式，因為必要的控制項有啟用目錄的模式。  
  
 當使用者切換目錄模式、 區域和就會變得可見，已加入的所有伺服器控制項的頁面，使用者可以選取控制項從類別目錄 頁面上，新增或移除從頁面的控制項。 控制項都已加入至頁面之後，它們會出現在一般的瀏覽模式，並更新頁面。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單中的頁面上，在此情況下會瀏覽、 設計和類別目錄支援的顯示模式。 目錄模式可因`<asp:CatalogZone>`項目和其子項目在網頁中的。 請注意，在`Page_PreRender`方法中，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>。 如果是的話`Label1`會顯示，如果沒有的話，`Label1`會隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意頁面上的標籤會隱藏。 使用下拉式清單控制項，將頁面切換至目錄模式。 請注意，因為中的程式碼`Page_PreRender`方法中，標籤現在會顯示。 您可以在目錄中選取的控制項，並將它新增至其中一個頁面上的兩個區域。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>檢查提出要求之瀏覽器的功能，以及 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 屬性的值，以判斷是否要呈現用戶端指令碼。</summary>
        <returns>布林值，指出是否要呈現用戶端指令碼。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定警告，當使用者關閉連接中做為其他控制項之提供者的控制項時顯示此警告。</summary>
        <value>包含警告訊息的字串。 預設值為 .NET Framework 所提供的文化特性訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，通常會顯示任何訊息。 如需有關如何關閉控制項的意義的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法。  
  
 不過，當控制項已連線到另一個控制項，並做為資料提供者的其他控制項，預設的警告訊息會顯示，當使用者嘗試關閉控制項。 訊息會告知使用者，提供者控制項即將關閉，表示控制項連接到此提供者，取用者將不再有任何要取用的資料。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性可讓開發人員可以自訂向使用者顯示警告訊息。  
  
 當使用者關閉時，如果頁面開發人員會指派給這個屬性空白或 null 字串值，會顯示任何警告訊息方塊<xref:System.Web.UI.WebControls.WebParts.WebPart>是提供者的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性對使用者顯示自訂的警告。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只有網頁的部分範例。 您也需要自訂使用者控制項和先前所述的自訂控制項的原始程式碼。 從的範例 > 一節中取得這兩項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 下列的網頁程式碼示範如何指派自訂的警告訊息，來<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性中的宣告式標記`<asp:webpartmanager>`項目。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會出現之後，請按一下**建立取用者的連接**連結。 資料格會顯示具有下拉式清單控制項。 選取 **天氣控制項**中的下拉式清單中，按一下**Connect**完成兩個控制項的連線。 按一下 **關閉**，然後使用**顯示模式**頁面返回標準瀏覽模式的下拉式清單。 最後，按一下 的動詞命令功能表**郵遞區號**控制項 （此為提供者控制項在此情況下），並選取**關閉**。 自訂訊息給您指派給<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性會顯示。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中正在關閉的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或伺服器控制項。</param>
        <summary>關閉 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，使其不會在網頁上呈現，但可重新開啟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法會移除<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項，使它不會是原本包含網頁上呈現。 已關閉的控制項新增至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>物件，它會維護已關閉的控制項的參考，並且可讓要還原至頁面的控制項。 已關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項仍然會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
 關閉控制項與不同刪除它。 已關閉的控制項仍然能夠還原至 頁面上，但已刪除的控制項執行個體便會永久移除和絕對無法還原。 無論<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項 （在頁面標記中宣告） 的靜態或動態 （新增至頁面以程式設計方式或由使用者從 Web 組件類別目錄），您可以關閉並重新開啟頁面上。  
  
 一般而言，使用者可以關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>按一下其動詞命令功能表然後選取 關閉動詞命令的控制項。 控制項也可以透過直接呼叫關閉<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法並傳遞它的參考`webPart`。  
  
 在頁面上， <xref:System.Web.UI.WebControls.WebParts.WebPart> ，也都已關閉的控制項，如果開發人員宣告`<asp:catalogzone>`項目，並在其中新增`<asp:pagecatalogpart>`項目，它會提供使用者頁面還原關閉的控制項，在執行階段中使用簡單的使用者介面 (UI)。 使用者可以將頁面切換成目錄顯示模式，並已關閉的控制項將會出現在頁面目錄中。 使用者可以選取 已關閉的控制項，並將它們新增至頁面上的任意位置中，他們想要和選取的控制項是還原至頁面，然後正常地呈現。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>呼叫方法，它會引發數個事件︰ <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> （如果有多個控制項），和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>（如果有連接的控制項）。 通常開發人員可以取消這些事件，但在某些情況下不可能取消它們。 如需詳細資訊，請參閱文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更網頁顯示模式。  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   Web 網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 在程式碼範例的第二個部分是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此範例會使用動態編譯的方法;因此沒有任何`Assembly`屬性中`Register`指示詞，這個網頁頂端的控制項。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 在程式碼範例的第三個部分是網頁。 此頁面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域中，使用 <`asp:pagecatalogpart>`在其中宣告之項目。 這是將會包含哪些內容的封閉型<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並讓使用者將它加入至頁面。 `Button1_Click`方法會直接呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法以關閉自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不過使用者也可以關閉透過動詞命令功能表。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，請關閉自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制按一下控制項的標頭中的動詞命令功能表 （箭號符號），然後按一下**關閉**。 現在將頁面變更為目錄模式中，選取變更**Catalog**中**顯示模式**下拉式清單控制項。 頁面類別目錄會顯示已關閉的控制項。 選取 已關閉的控制項旁的核取方塊，按一下**新增**以將它新增至頁面上，然後按一下**關閉**返回頁面，即可瀏覽模式。 控制項被還原頁面。 現在將它關閉，這次請再次依序按一下**關閉網頁組件** 按鈕。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
\-或- 
 <paramref name="webPart" /> 是共用控制項，並且已經被另一個使用者關閉。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用來顯示特別使用者介面 (UI) 的顯示模式，供使用者管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間的連接。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>欄位會參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要控制項的執行個體。  
  
 當使用者想要管理之間的連線<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項在網頁上，如果<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>已宣告區域在頁面上，它們可以切換至頁面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。 連接顯示模式顯示特殊的 UI 來管理連接，其中包含連接或中斷連接的控制項，並編輯現有連線的詳細資料的能力。  
  
 如果您想要讓使用者能夠使用 Web 組件控制集所提供的 UI 中的連線，您必須宣告`<asp:connectionszone>`頁面標記中的項目。 不同於其他類型的項目<xref:System.Web.UI.WebControls.WebParts.WebZone>區域，您不需要新增任何其他標記這個項目內，您只是宣告的項目本身。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
 在程式碼範例有三個部分：  
  
-   原始程式檔，其中包含介面和自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，可構成的連接。  
  
-   網頁上，提供連接 UI，並示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
-   如何執行範例的說明。  
  
 在程式碼範例的第一個部分是原始程式檔，其中包含介面和兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>的設計是讓它們可以同時連線的控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此程式碼範例會使用動態編譯的方法。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 此範例的第二個部分是裝載的自訂控制項的網頁。 在伺服器內`<script>`頁面上的標籤是填入下拉式清單可在頁面的顯示模式的數種方法。 使用者可以選取從下拉式清單中，若要變更頁面的顯示模式。 其中一個可用的顯示模式是連線顯示模式，因為`<asp:connectionszone>`在網頁標記中宣告的項目。 請注意，這個項目不包含任何其他子項目;它的存在只為了啟用使用者的連接管理 UI。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式會出現在此範例中的兩個地方。 首先，在`Page_Init`方法，連線顯示模式會加入至下拉式清單中的顯示模式，為程式碼中參考的集合執行迴圈<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 第二個，`Page_PreRender`方法會檢查目前的顯示模式，在頁面上，以及目前的模式是否<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>，訊息會顯示在<xref:System.Web.UI.WebControls.Label>控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，按一下下拉式清單，然後選取**Connect**頁面切換成連接顯示模式。 請注意，會出現一則訊息，告訴您在頁面位於連接顯示模式。 現在按一下其中一個的標題列中的動詞命令功能表 （箭號符號）<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，然後再按一下**Connect**動詞命令功能表中。 UI 會顯示連線之後，按一下連結以建立連線。 使用下拉式清單中的，連接 UI 顯示中，請選取其他控制項將參與連接，並按一下**Connect**  按鈕。 建立連線。 按一下 **關閉**按鈕，並返回頁面，即可瀏覽顯示模式然後使用頁面頂端的下拉式清單。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上所有目前連接之集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性可用來存取目前頁面上連接的集合。 集合本身是唯讀的並想要管理集合的特定連線開發人員應該使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>這類方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範宣告式和以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只有網頁的部分範例。 您也需要自訂使用者控制項和先前所述的自訂控制項的原始程式碼。 從的範例 > 一節中取得這兩項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 下列網頁程式碼示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性以程式設計方式取得頁面上的目前連線數的計數。 請注意，在`<script>`標記區段中，程式碼來處理兩個事件，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性，以取得計數。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會顯示之後，請按一下**建立取用者的連接**連結。 資料格會顯示具有下拉式清單控制項。 選取 **天氣控制項**中的下拉式清單中，按一下**Connect**完成兩個控制項的連線。 按一下 **關閉**，然後使用**顯示模式**頁面返回標準瀏覽模式的下拉式清單。 請注意，標籤現在會顯示連線的數目和數目<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 如果您現在會傳回連接模式，並中斷連線的兩個控制項，當您返回瀏覽模式中，應該更新標籤的內容，而且應該沒有任何連接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在頁面上所有目前的 Web 組件連接不僅已建立，而且每個連接中的消費者和提供者控制項也已經開始共用資料之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在連線的生命週期，在頁面完成載入程序之後，就會發生此事件。 這也會發生之後<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件，只表示<xref:System.Web.UI.WebControls.WebParts.WebPart>或參與之特定連線的伺服器控制項已成功連接。 萬一其中有多個連線，在頁面上，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>方法會指示所有頁面上的有效 Web 組件連線都已作用中，以共用資料。 了解所有連接都作用中，開發人員可以執行任意數目的工作，包括通知使用者狀態的所有連線時，通知處理和顯示資料，其提供者，然後依此類推的消費者控制項。  
  
 此事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法，它會引發事件，並讓開發人員建立自訂事件處理常式。  
  
 網頁程式開發人員可以建立自訂事件處理常式加`OnConnectionsActivated`屬性設定為`<asp:webpartmanager>`頁面，並再將自訂的方法名稱指派給屬性中的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在網頁上啟動所有已建立之 Web 組件連接的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在連線的生命週期，此事件會發生頁面之前完成載入程序，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>呼叫方法。 它是不同於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，這牽涉到特定連線之間<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>當頁面上，所有可能的連接已連線，而且即將啟動時，就會發生事件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，這會引發事件。 控制項開發人員想要擴充可以加入至頁面的連線類型可以覆寫受保護<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法並且啟用其他類型的連線。  
  
 網頁程式開發人員可以建立自訂事件處理常式加`OnConnectionsActivating`屬性設定為`<asp:webpartmanager>`頁面，並再將自訂的方法名稱指派給屬性中的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控制項 (或能建立連接的其他伺服器控制項) 之間的連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法會形成連接之間的任何兩個<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項。 之前呼叫這個方法，以建立連線，您也可以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>中條件式的檢查，以確保控制項符合需求的建立連接的方法。  
  
> [!NOTE]
>  您也可建立不是兩個伺服器控制項之間的連線<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 一般情況下，兩個控制項必須以進行自訂伺服器控制項 (例如繼承的控制項<xref:System.Web.UI.WebControls.WebControl>或現有的 ASP.NET 伺服器控制項)，讓您可以新增必要的成員。 控制項也必須符合以下指定之需求。  
  
 連線的情況下，兩個控制項之間的任何型別必須符合下列需求，要能夠連線：  
  
-   每個控制項位於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>（它不一定要相同的區域） 的區域。  
  
-   Web 組件控制集實作時，連接之中提供者控制項實作介面的公用方法來做為提供者的回呼，並已為`ConnectionProvider`方法，將其識別為提供者連接上的中繼資料屬性點。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>擷取提供者連接點是虛擬的方法，衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項不一定要使用相同的中繼資料屬性。  
  
-   Web 組件控制集實作時，連接之中消費者控制項也會有特殊的方法，讓它能夠在提供者的回呼方法中，會公開介面的參考，而且取用者有`ConnectionConsumer`上的中繼資料屬性方法，將其識別為消費者連接點。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>擷取取用者連接點是虛擬的方法，衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項不一定要使用相同的中繼資料屬性。  
  
-   回呼方法必須是相容、 中 （亦即，取用者和提供者可以共用的資料直接） 提供者的回呼方法或開發人員提供的介面，取用者可以使用的型別必須使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件從提供者將資料轉換的取用者可以使用的表單。  
  
    > [!IMPORTANT]
    >  當您不需要轉換程式時，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法多載。 當您需要轉換程式時，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法多載。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，其角色為提供資料給另一個連接的控制項。</param>
        <param name="providerConnectionPoint">方法，做為連接的回呼方法。 當 Web 組件控制集實作時，這是 <c>provider</c> 中標記著 <see langword="ConnectionProvider" /> 中繼資料屬性的公用方法。</param>
        <param name="consumer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，其角色為從 <c>provider</c> 接收資料，然後處理或顯示此資料。</param>
        <param name="consumerConnectionPoint">與 <c>providerConnectionPoint</c> 連線的方法，以接收連線資料。 當 Web 組件控制集實作時，這是 <c>consumer</c> 中標記著 <see langword="ConnectionConsumer" /> 中繼資料屬性的公用方法。</param>
        <summary>只使用控制項的參考及其指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件，建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> (或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />) 控制項之間的連接。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含連接所需之提供者和消費者的各種相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載用於連接控制項，其連接點充分相容，而且可以連線而不使用時<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件。 當呼叫這個方法的多載時，它只會傳遞至另一個多載版本; 方法的呼叫，並將傳遞`null`參數需要<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件。  
  
 當您嘗試以程式設計方式連線兩個控制項時，您可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>中條件式的檢查，以判斷是否可以直接連線之控制項的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法來以程式設計方式建立連接。 完整的程式碼才能執行範例時，請參閱 < 範例 > 一節的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 從該範例中，您需要可讓您變更顯示模式，在頁面上，使用者控制項的原始程式碼和原始碼的兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 裝載兩個網頁的程式碼會控制如下所示。 此頁面使用`Register`頂端指示詞來宣告的使用者控制項和自訂控制項。 自訂控制項接著會以宣告方式內參考`<asp:webpartzone>`項目。 處理的程式碼`Button1_Click`方法會建立使用控制項之間連接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，請按一下**連接 WebPart 控制項**連接 按鈕。 您接著可以在文字方塊中，輸入一些資料，然後按一下**輸入 5 位數郵遞區號**示範連接控制項，，和在第一個控制項中輸入該資料會在第二個更新的按鈕。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的動態連接集合是唯讀。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，其角色為提供資料給另一個連接的控制項。</param>
        <param name="providerConnectionPoint">
          <c>provider</c> 中的公用方法，這個方法標記著 <see langword="ConnectionProvider" /> 中繼資料屬性，並作為連線的回呼方法。</param>
        <param name="consumer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，其角色為從 <c>provider</c> 或 <c>transformer</c> 接收資料，然後處理或顯示此資料。</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c> 中的公用方法，這個方法標記著 <see langword="ConnectionConsumer" /> 中繼資料屬性，並與 <c>providerConnectionPoint</c> 連線以接收連線資料。</param>
        <param name="transformer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，藉著將來自 <c>provider</c> 的資料轉換成 <c>consumer</c> 可以處理的格式，允許兩個控制項之間的連線。</param>
        <summary>使用控制項的參考、其指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件和 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 物件，建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> (或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />) 控制項之間的連接。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含連接所需之提供者、消費者和轉換程式的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載用來連接其連接點不相容時的控制項。 不相容的問題發生時`consumer`實作不同的介面比`provider`為其連接點。 轉換器會將資料轉換成可以理解的型別`consumer`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">連接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中啟動。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中所包含並且由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控制項管理之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、伺服器或使用者控制項的集合。</summary>
        <value>
          <see cref="T:System.Web.UI.ControlCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項管理的所有控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>屬性未參考所參考的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，例如各種區域控制項<xref:System.Web.UI.WebControls.WebParts.EditorPart>或<xref:System.Web.UI.WebControls.WebParts.CatalogPart>控制項和其他項目。  
  
 Web 組件控制項集合，以及在它不是從您的程式碼呼叫大部分的開發情況下，將使用這個屬性。 基於這個理由，雖然此屬性是公用的它會隱藏 IntelliSense。 開發人員想要存取的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>或由其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項應使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要複製的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</param>
        <summary>為了將控制項加入至網頁，由 Web 組件控制集用來建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的複本。</summary>
        <returns>要加入至頁面的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不能呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>直接從程式碼的方法。 這個方法會在內部呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項新增新的動態的程序的一部分<xref:System.Web.UI.WebControls.WebParts.WebPart>或頁面伺服器控制項。 動態控制項已加入至頁面以程式設計方式或透過 Web 組件的使用者介面 (UI)，例如由使用者從目錄的控制項，而不是直接在網頁標記中宣告為靜態控制項，加入控制項。  
  
> [!NOTE]
>  可以在衍生類別中覆寫方法，如果開發人員想要啟用的方法，以處理其他控制項複製案例。 如需詳細資訊，請參閱注意事項繼承者注意事項 > 一節。  
  
 當新動態新增控制項時，才<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法會傳回控制項的新執行個體。 如果要加入的控制項是其他類型的伺服器控制項 （例如使用者控制項、 自訂控制項或 ASP.NET 控制項），控制項將會有已包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>由 Web 組件控制項集合的物件。 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法遇到<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項，它會傳回的新執行個體<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項包裝在其中的子控制項的新執行個體。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法會建立傳回控制項的新複本，它也會重設所有屬性的值設為預設值。 請注意，是否您想要保留可個人化屬性的值，並擁有其複製到新的控制項執行個體，您應該呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>以及方法。 最後一個步驟藉由實行<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法是呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>方法，以取得新的控制項識別碼。  
  
> [!NOTE]
>  方法會取得新複製的控制項識別碼，因為您不應該仰賴依據參考其原始的 id 加入至頁面的動態控制項 相反地，您應該參考方法所傳回的控制項的新執行個體。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>方法宣告為<see langword="virtual" />使開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，覆寫方法，並提供其他情況下，它可以在其中建立控制項的複本。 比方說，方法可以選擇性地接收做為輸入已經序列化至 XML 檔案的控制項。 方法無法還原序列化的 XML （如果有的話），並接著呼叫基底方法以處理現有的案例，並傳回的新執行個體<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控制項。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>依網站組態檔的指定建立一組轉換程式，並將它們加入至 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 屬性所參考的轉換程式集合。</summary>
        <returns>網站組態檔中指定的轉換程式集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>可以覆寫此方法，以新增應用程式可以使用的其他轉換。 例如，無法寫入方法從 Web 服務擷取一份可用的轉換程式。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理之所有控制項的集合。 這個類別無法被繼承。</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理之所有不同的 Web 組件控制項。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>這個方法會受到保護，而且密封的因為它是繼承自的類別為可見<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，但它不能覆寫。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 Web 組件應用程式所有可能的顯示模式集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有支援的顯示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立所有可能的顯示模式，不只是支援特定的頁面上的顯示模式的清單。 如需有關支援的顯示模式的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
 根據預設，Web 組件控制項集合會建立下列集合要使用 Web 組件頁面上的顯示模式：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 開發人員可以建立自訂的顯示模式，不論是否有隨附的自訂衍生自的區域<xref:System.Web.UI.WebControls.WebParts.WebZone>或<xref:System.Web.UI.WebControls.WebParts.ToolZone>類別。 若要建立自訂的顯示模式，您必須繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別，並將您的顯示模式做為支援的模式，在頁面上，您必須繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別並覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法。  
  
 當您使用新增的顯示模式時<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法，您應該加入它們要才會出現在任何使用者介面 (UI) 控制項的順序 (例如<xref:System.Web.UI.WebControls.ListBox>控制項)，為使用者提供可能的顯示模式的頁面上。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 在程式碼範例包含五個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   裝載其他控制項的網頁。  
  
-   使用者控制項位於<xref:System.Web.UI.WebControls.WebParts.WebPartZone>網頁上的區域，並可讓您輸入，並在標籤中顯示的文字。  
  
-   原始程式碼檔，其中包含兩個控制項。 其中一個是自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，以及其他是自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>来加入至頁面的預設顯示模式物件。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是網頁。 它包含兩個<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控制項，使用者控制項和自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 請注意`Register`在頁面頂端的指示詞參考的使用者控制項和編譯控制項的命名空間。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 此範例的第三個部分是輸入和顯示文字的使用者控制項。 它會使用<xref:System.Web.UI.WebControls.MultiView>控制項來建立多個檢視的 UI。 一個檢視會顯示`Button1`按鈕，另外一個則沒有。 請注意，在覆寫`OnPreRender`方法，將程式碼會檢查是否頁面目前為自訂的顯示模式，如果是的話，會顯示第一個使用者控制項，其中包含按鈕的檢視。 如果網頁不為自訂的顯示模式，例如，如果頁面是在瀏覽] 或 [設計模式中，會隱藏按鈕。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 此範例的第四個部分是兩個自訂類別的原始程式檔。 請注意，自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法，以及它會先呼叫基底方法，將所有的預設顯示模式，並將新增自訂的顯示模式。 自訂的顯示模式類別`InLineEditDisplayMode`，只要繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>管理員、 設定的顯示模式名稱的建構函式，並會覆寫一些基底屬性，以建立自訂的顯示特性。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要執行的程式碼範例，請瀏覽器頁面載入。 請注意，頁面目前是在瀏覽 模式中，與任何按鈕是可見的。 使用**顯示模式**下拉式清單控制項中，變更頁面，即可**內嵌編輯顯示**模式，並注意現在`Button1`按鈕會顯示在下方的使用者控制項。 新增一些文字，然後按一下按鈕來更新控制項。 請注意，若要瀏覽模式，會傳回頁面顯示，現在會顯示您所輸入的文字，因為頁面不會再將自訂的顯示模式中，會再次隱藏按鈕。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">逐步解說： 變更 Web 組件頁面上的顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得唯一值，做為動態連接的 ID。</summary>
        <returns>字串，包含連接的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法會產生一個 GUID 值，並將它轉換成字串，做為連接的唯一識別碼。 每次建立動態的連接時，會呼叫方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫這個方法在衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，以變更實作來產生唯一的識別碼。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">正在產生 ID 之控制項的 <see cref="T:System.Type" />。</param>
        <summary>產生動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的唯一 ID。</summary>
        <returns>字串，包含控制項的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項加入至網頁，它們可以是 （亦即在網頁標記中宣告的控制項） 的靜態或動態 （亦即它們會以程式設計方式加入）。 在任何情況其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項建立新的動態控制項，將新增至頁面上，它會呼叫這個方法，以產生唯一的識別碼。  
  
 方法是虛擬的讓開發人員可以覆寫它如果他們想要提供自訂的實作，以產生識別碼  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">字串，失敗控制項的 ID。 如果 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包含在失敗的作業中，則此 ID 為其子伺服器控制項的 ID。</param>
        <param name="originalTypeName">已失敗控制項之 <see cref="T:System.Type" /> 名稱的字串。 如果 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包含在失敗的作業中，則此型別名稱為其子伺服器控制項的型別名稱。</param>
        <param name="originalPath">包含至使用者控制項之路徑的字串，如果包含子使用者控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 在失敗的作業中時。</param>
        <param name="genericWebPartID">傳回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 之 ID 的字串，如果控制項型別包含在載入或建立控制項的失敗作業中時。</param>
        <param name="errorMessage">字串，包含要顯示在頁面上的錯誤訊息。</param>
        <summary>建立特殊控制項，當嘗試載入或建立動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項因特定理由失敗時，這個控制項會插入頁面並顯示給使用者。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />，插入頁面，以取代無法載入或建立的控制項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> Web 組件控制集嘗試載入或建立的動態執行個體時，會呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項和它因為某些原因失敗。 此方法會建立<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>物件，將錯誤訊息指派給它，並將它傳回。 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制項插入以取代無法的控制項和其錯誤訊息會顯示在頁面上。  
  
 您不能呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>直接從程式碼的方法。 不過，您可以繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，並擴充方法。 如需詳細資訊，請參閱繼承者一節的資訊。  
  
 使用者可以使用<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制項在網頁中大部分一般一樣<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要移除的錯誤訊息，他們可以關閉控制項，即可關閉動詞命令，此時將控制項加入至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>物件，如同任何其他已關閉的控制項。 如果使用者刪除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>也會從頁面刪除控制項，無法載入伺服器控制項。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您想要自訂會在傳回的資訊<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />您可以覆寫控制項，<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />方法，呼叫基底方法，將不同的值指派給基底方法，傳遞的參數，然後傳回產生的<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控制項。 比方說，如果您不想讓使用者看到<paramref name="originalPath" />（它會顯示使用者控制項的虛擬目錄路徑） 的值，當您呼叫基底方法，您可以傳遞空字串 ("") 為該參數。  
  
您也可以自訂的行為<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控制本身，藉由繼承自它。 例如，您可能想要覆寫其<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />或<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />屬性。</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回個人化物件，以包含目前網頁使用者的個人化資料。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含使用者的個人化資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>方法傳回的物件，包含並管理目前頁面的使用者的個人化設定。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會管理此物件。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Web 組件個人化概觀</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">非 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的伺服器控制項。</param>
        <summary>將非 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的伺服器控制項包裝在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 物件中，讓此控制項有 Web 組件功能。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，用來包裝 <paramref name="control" /> 並使其如同真正 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項作用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法是啟用伺服器控制項所沒有的主要機制<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，以取得相同的功能上<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，因此完全參與 Web 組件的應用程式。 使用此方法中，開發人員大幅擴展他們可以使用 Web 組件應用程式中的伺服器控制項數目，因為幾乎所有類型的伺服器控制項，可以使用標準 ASP.NET 控制項、 使用者控制項和自訂控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會使用這個方法在其他兩個案例中包裝伺服器控制項提供<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件。 當使用者新增至頁面使用伺服器控制項<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制項，如果匯入的控制項不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>呼叫方法。 此外，當伺服器控制項宣告中的持續性格式<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>網頁上的區域<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法會針對不是任何控制項呼叫<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 當您將伺服器控制項加入區域以程式設計的方式時，是使用一般的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法，以使用控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件，然後再呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，將控制項加入至集合的所有<xref:System.Web.UI.WebControls.WebParts.WebPart>在頁面上，所參考的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。 在`Button2_Click method`，則<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>呼叫方法來包裝<xref:System.Web.UI.WebControls.Calendar>用來控制<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>再將它新增至區域的物件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>可以覆寫此方法，以使用衍生<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />類別改為提供的 Web 組件的基底類別的控制項集合。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定自訂警告訊息，當使用者刪除控制項時，向使用者顯示這則訊息。</summary>
        <value>包含警告訊息文字的字串。 預設值為當地語系化的警告訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者刪除<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，通常會顯示預設警告訊息。 它會警告使用者，在刪除控制項的這個執行個體時，會永久刪除。 網頁開發人員可能會提供使用者得以加入至頁面控制項的新執行個體 (例如目錄<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，或透過一些程式設計的方式)，但是永久移除已刪除的控制項的目前執行個體。 如有需要，會顯示警告對話方塊中會包含要取消刪除動作，使用者 按鈕。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性可讓開發人員設定會對使用者顯示警告訊息。  
  
 如果頁面開發人員指派為空字串 ("") 會顯示於此屬性沒有警告訊息 對話方塊中的值，當使用者刪除<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性不會顯示在靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和伺服器控制項。 靜態控制項是伺服器控制項中已宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>Web 網頁標記中的區域。 這類控制項是靜態的因為它們不能刪除，所以刪除警告訊息永遠不會顯示在此情況下。 可由使用者關閉靜態控制項，但已關閉的控制項加入頁面目錄中，在其中它可以加入至頁面的使用者，而永遠無法復原刪除的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性以宣告方式和程式設計的方式。  
  
 有四個部分的程式碼範例：  
  
-   使用者控制項，可讓您變更網頁顯示模式。  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   Web 網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 在程式碼範例的第二個部分是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此範例會使用動態編譯的方法;因此沒有任何`Assembly`屬性中`Register`指示詞，這個網頁頂端的控制項。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 在程式碼範例的第三個部分是網頁。 此頁面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，以自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制宣告在區域中，以便使用者可以將它新增至頁面在執行階段。 請注意，可以從頁面刪除僅動態控制項 （以程式設計方式或從這類目錄加入至頁面的控制項）。 靜態控制項 (控制項中已宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>頁面標記中的區域) 可以關閉，但永遠不會刪除。 `<asp:webpartmanager>`項目宣告的自訂值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性使用`DeleteWarning`屬性。 `Button1_Click`方法會將指派到另一個自訂值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，您需要新增<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項加入網頁。 使用**顯示模式**下拉式清單控制項中，選取類別目錄的模式。 目錄出現時，請選取自訂控制項旁的核取方塊，按一下**新增**以將它新增至頁面上，然後按一下**關閉**返回頁面，即可瀏覽模式。 既然控制項為可見，您可以將它刪除。 使用**顯示模式**控制一次，請將頁面切換到設計模式中 （您無法刪除控制項頁面瀏覽模式時）。 按一下標頭中的動詞命令功能表 （箭號符號）<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，然後選取**刪除**。 您在設定的警告`DeleteWarning`屬性會出現。 按一下 **取消**。 現在按一下  按鈕**變更刪除的警告**，其中以程式設計方式變更的屬性值。 從控制項上的動詞命令功能表中選取**刪除**同樣地，並請注意，此時會出現另一個警告訊息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要刪除的伺服器控制項。</param>
        <summary>從網頁永久移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的動態執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法永久移除所代表的控制項`webPart`從頁面的參數。 不同於已關閉的控制，已新增到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，並可以加入上一步 頁面上，已刪除的控制項執行個體可以永遠不會加入至頁面。  
  
> [!NOTE]
>  所實作的 Web 組件控制項設定，可讓使用者刪除動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項取決於使用者並控制已加入至頁面的個人化範圍。 如果控制項加入網頁時在共用範圍中 （由使用者具有權限），然後控制項無法刪除個別的使用者當頁面位於使用者範圍。  
  
 只有動態控制項，才能刪除。 動態控制項都加入至頁面中，以程式設計方式或由使用者從目錄加入控制項。 靜態控制項加入以宣告方式中的標記或持續性格式的頁面。 由於宣告的標籤是永久存在於標記，可以永遠不會刪除靜態控制項，但可以關閉並重新開啟。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次**加入行事曆**按一下按鈕時，程式碼在事件處理常式會建立<xref:System.Web.UI.WebControls.Calendar>控制項，並將它新增至區域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件。 以程式設計方式加入控制項，因為它是動態的控制項，並因此會刪除。 當使用者按一下**刪除行事曆** 按鈕，程式碼可確保控制項存在，而且然後將它刪除藉由呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 組件控制項之網頁的配置變更時所使用的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>欄位會參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要控制項的執行個體。  
  
 包含 Web 組件的頁面控制項第一次載入時，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 當使用者想要變更頁面的配置將控制項移至不同的區域，或在目前的區域時，他們必須先切換頁面以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>（設計模式）。 在設計模式中，各種區域的使用者介面 (UI) 出現，而且使用者可以拖曳控制項，以變更配置。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單中，支援的顯示模式] 頁面上，在此情況下為 [瀏覽和設計。 請注意，在`Page_PreRender`方法中，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>。 如果是的話`Label1`會顯示，如果沒有的話，`Label1`會隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意頁面上的標籤會隱藏。 使用下拉式清單控制項，將頁面切換到設計模式。 請注意，因為中的程式碼`Page_PreRender`方法中，標籤現在會顯示。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要中斷連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</param>
        <summary>從控制項參與的任何連接中，移除正在關閉或刪除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法會在內部呼叫時的控制項在網頁上關閉或從頁面刪除設定的 Web 組件控制項。 在這類案例中，會呼叫方法來移除任何連線中的控制項，它牽涉到做為消費者或提供者。 如果控制項已移除從任何連線，此方法也會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法以結束所在的任何連線`webPart`是相關。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>呼叫方法時，它會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。 通常您可以取消這個事件，但兩種情況便無法取消。 一種情況發生在要求期間 頁面上，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>呼叫方法。 如果沒有現有連接，任何衝突<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>會叫用方法，以關閉其中一個衝突的連線，並在這個執行個體<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>，也無法予以取消事件，因為必須解決衝突。  
  
 在另一個案例，就會發生時<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項目前連接關閉或刪除。 在此情況下，因為控制項正在從移除頁面上，而終止，因此根據設計，不可能取消其連線需求<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>中斷結束連接的程序的事件。 如需詳細資訊，請參閱 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 使用兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，網頁可以可讓您藉由按一下按鈕，而另一個按鈕可讓您中斷連接控制項的控制項之間建立連線。 如果您的控制項時關閉此分頁為瀏覽模式中，且控制項連接時，覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法中斷連線已關閉的控制項、 結束連接，並顯示訊息。  
  
 在程式碼範例包含四個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   原始程式檔，其中包含自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   裝載控制項的網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二個部分是包含兩個自訂的原始程式碼檔案<xref:System.Web.UI.WebControls.WebParts.WebPart>將會連接的控制項和自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此範例會使用動態編譯，因此`Register`參考這些元件在網頁中的指示詞會據以宣告網頁的頂端。 如需示範編譯選項的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 在原始程式碼中，請注意繼承的控制項`MyWebPartManager`會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法。 這個方法會檢查在頁面中，以查看是否正在關閉的控制項參與連線，如果是的話，會呼叫每個連線<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法來結束連接。 這等同於在方法的基底實作<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 然後，覆寫的方法會藉由將訊息寫入網頁自訂基底實作。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 在程式碼範例的第三個部分是網頁。 請注意，最上方，它包含`Register`註冊使用者控制項，並具有動態編譯的組件的指示詞<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 頁面有兩種主要方法。 `Button1_Click`方法會建立控制項之間的連線時`Button2_Click`方法中斷連接控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 將頁面載入之後，請按一下**Connect**連接控制項的按鈕。 然後按一下 [動詞] 功能表中其中一個控制項 （控制項的標頭中的向下箭頭），並選取**關閉**從動詞命令功能表。 當您嘗試關閉的控制項時，覆寫的方法會呼叫、 連線就會結束，並將訊息寫入至頁面。 如果您想要重設頁面，即可還原關閉的控制項並嘗試使用其他選項，請按一下**重設使用者狀態**移除個人化資料，並還原網頁的原始狀態的連結。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，表示伺服器控制項之間的連接。</param>
        <summary>對網頁上連接的伺服器控制項，執行中斷連接的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法會執行完整的程序的結束之間的連線<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項，當您將它傳遞`connection`參數。  
  
 這個方法用來中斷連接控制項，當您將`<asp:connectionszone>`網頁，以管理連線時，提供使用者介面 (UI) 中的項目。 當頁面處於連線顯示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)，和目前的連線存在，使用者可以按一下按鈕，以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法來結束連接。  
  
 您也可以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，直接從程式碼，如果您想要中斷連接控制項，以程式設計的方式，以及無需將`<asp:connectionszone>`至頁面的項目。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 使用兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，網頁可以可讓您藉由按一下按鈕，而另一個按鈕可讓您中斷連接控制項的控制項之間建立連線。  
  
 在程式碼範例包含四個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   原始程式檔，其中包含自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   裝載控制項的網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二個部分是包含兩個自訂的原始程式碼檔<xref:System.Web.UI.WebControls.WebParts.WebPart>將連接的控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此範例會使用動態編譯，因此`Register`參考這些元件在網頁中的指示詞會據以宣告網頁的頂端。 如需示範編譯選項的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 在程式碼範例的第三個部分是網頁。 請注意，最上方，它包含`Register`註冊使用者控制項，並具有動態編譯的組件的指示詞<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 頁面有兩種主要方法。 `Button1_Click`方法會建立控制項之間的連線和`Button2_Click`方法中斷連接控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 將頁面載入之後，您可以按一下**Connect**連接控制項的按鈕。 如果您的文字方塊控制項中，輸入一些文字，然後按一下**Enter**  按鈕，文字將會顯示在連接的控制項 （它將不會顯示如果控制項已中斷連線）。 如果您按一下**中斷連線** 按鈕，控制項將會中斷連接。 您可以使用，以確認連線狀態的控制項**顯示模式**切換至頁面的下拉式清單控制項**Connect**模式。 之後，按一下 （由箭號表示） 的動詞命令功能表的其中一個控制項，標題列中，選取**Connect**項目。 連接 UI 會顯示;這是可用的因為沒有`<asp:connectionszone>`頁面中宣告的項目。 您也可以連接並中斷此 UI 的控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 是唯讀的。  
  
\-或- 
 <paramref name="connection" /> 已從 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 中斷連接。  
  
\-或- 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 是唯讀的。  
  
\-或- 
 <paramref name="connection" /> 已從 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中斷連接。</exception>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />方法，如果您想要變更中斷連線的預設實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控制項。 如果您覆寫方法，而且您只想要將某些實作新增至現有的方法，您可以呼叫基底方法，在執行自己的程式碼之前。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含 Web 組件控制項之網頁的現用顯示模式。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />，決定頁面的顯示模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含 Web 組件控制項的頁面一律是在其中數個可能的顯示模式。 如需有關顯示模式的詳細資訊，請參閱 < [Web 組件頁面顯示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會建立 Web 網頁的顯示模式。 使用基底<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會建立可用在包含 Web 組件控制項的頁面的數個標準的顯示模式物件。 這些標準的顯示模式中所述<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別概觀。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會管理使用 Web 組件控制項之網頁的顯示模式。 使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會在網頁上保留目前的顯示模式的參考。 您也可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，以將頁面切換至不同的顯示模式。 如需在使用 Web 組件控制項的頁面變更顯示模式的範例，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 管理顯示模式，過程<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也提供事件和顯示模式，例如相關的事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。 這些方法會提供一種機制，自訂頁面的行為，以及加入自訂的顯示模式。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性。 載入之後在瀏覽器中的，您可以使用靠近頁面底部的按鈕來切換顯示模式。 網頁載入時為預設的瀏覽模式。 如果您切換到設計模式，您可以將伺服器控制項從一個區域拖曳到另一個，或安排在一個區域中的兩個控制項。 如果您切換到編輯模式，您可以按一下其中一個伺服器的選取控制項的標頭中的動詞命令功能表**編輯**，並編輯使用提供的編輯使用者介面 (UI) 控制項。  
  
> [!NOTE]
>  在 Web 組件的應用程式的顯示模式間切換是很常見，而且要提供一致、 可重複使用的方式，若要這樣做的所有網頁包含 Web 組件控制項。 如範例的使用者控制項變更顯示模式，可以重複使用許多頁面上，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件不是其中一個支援的顯示模式。  
  
\-或- 
正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件已停用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">逐步解說： 變更 Web 組件頁面上的顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 組件頁面目前的顯示模式變更之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示模式是 Web 組件的應用程式中不可或缺的一部分。 當使用者切換至不同的顯示模式，在網頁上時，網頁通常需要非常不同的外觀，根據新的顯示模式的目的。 顯示模式已變更之後，您可能想要進行某些變更，在使用者介面 (UI)，例如隱藏或顯示特定的控制項，變更所選取的 UI 元素的外觀等等。  
  
> [!NOTE]
>  如需有關顯示模式的詳細資訊，請參閱 < [Web 組件頁面顯示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 如需有關如何取用事件的詳細資訊，請參閱[如何： 使用 Web Forms 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者按一下網頁上的動詞命令，而開始切換至不同顯示模式的程序之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示模式是 Web 組件的應用程式中不可或缺的一部分。 當使用者切換至不同的顯示模式，在網頁上時，網頁通常需要非常不同的外觀，根據新的顯示模式的目的。 使用者起始的動詞命令，即可變更至新的顯示模式的程序之後，您可能想要在使用者介面 (UI) 中進行某些變更，使用<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>屬性來判斷新的顯示模式是什麼，以及再變更各種 UI項目據此。 若要這樣做很有用的方式是覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>自訂 UI 的方法。  
  
> [!NOTE]
>  如需有關顯示模式的詳細資訊，請參閱 < [Web 組件頁面顯示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 如需有關如何取用事件的詳細資訊，請參閱[如何： 使用 Web Forms 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項關聯之所有顯示模式的唯讀集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含與 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控制項關聯之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性參考所有相關聯的顯示模式中，相較於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性，其參考只會使用目前的頁面上 （支援） 的顯示模式。  
  
 兩個提供的顯示模式中，瀏覽和設計，一律都支援頁面。 頁面有對應所需的特定顯示模式運作的區域類型時，才會支援其他三種顯示模式、 編輯、 目錄和連線。 例如，如果您的頁面不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域中，編輯顯示模式就會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性，但不是會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性。 程式碼會使用這個屬性，以填入具有所有可用的顯示模式 Web 組件控制項集合中的清單，甚至不是支援目前的頁面上。 在此情況下，類別目錄並連接的顯示模式不支援，因為其對應所需的區域不在網頁上。  
  
 其他三個顯示模式： 瀏覽、 設計和編輯-支援頁面。 編輯模式的支援，因為此頁面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域，同時瀏覽，並一律支援設計模式。  
  
 在瀏覽器頁面載入之後，您可以使用下拉式清單控制項，以切換到設計模式中，瀏覽模式的頁面，然後編輯模式。 您可以在編輯模式中，按一下下拉式動詞命令功能表中的其中一個伺服器控制項中，標頭，並選取**編輯**編輯控制項。 請注意，如果您選取**類別目錄**或是**Connect**在下拉式清單中，會產生錯誤頁面。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">逐步解說： 變更 Web 組件頁面上的顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上目前所有動態連接的集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含頁面上所有動態連接的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態的連接都是以程式設計的方式，而不是以靜態方式建立的連接。 靜態連接會建立在 Web Form 網頁的標記宣告。 動態連接被形成程式設計的方式，或使用連接使用者介面 (UI) 建立連線的使用者。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合，不過它是唯讀和您無法變更其內容，但是提供以程式設計方式存取每個動態連接物件。  
  
> [!NOTE]
>  若要執行常見的作業，例如連接或拔除<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，開發人員應該使用的公用方法上<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，例如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而不是嘗試直接修改連接中的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示使用者可用來編輯和修改伺服器控制項的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>欄位會參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要控制項的執行個體。  
  
 包含 Web 組件的頁面控制項第一次載入時，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 當使用者想要編輯或修改伺服器控制項時，它們必須先切換至頁面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>（編輯模式）。 第二，他們必須選取要編輯，請依序按一下 編輯動詞命令，在該控制項的標頭中的動詞命令功能表上的特定伺服器控制項。 在控制項處於編輯模式之後，編輯使用者介面 (UI) 會出現編輯選取的控制項。  
  
 若要啟用編輯模式，在頁面上的，頁面必須至少包含一個<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域包含一或多個提供的編輯控制項，例如<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>控制項或自訂的編輯控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單中的頁面上，在此情況下會瀏覽、 設計和編輯支援的顯示模式。 若要支援編輯，`<asp:EditorZone>`項目是在頁面中。 請注意，在`Page_PreRender`方法中，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>。 如果是的話`Label1`會顯示，如果沒有的話，`Label1`會隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意頁面上，標籤會隱藏起來。 若要切換至編輯模式頁面使用下拉式清單控制項。 請注意，因為中的程式碼`Page_PreRender`方法中，標籤現在會顯示。 按一下 **編輯**動詞命令功能表中的其中一個控制項，以啟用該特定控制項的編輯動詞命令。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，判斷在包含了 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的網頁上是否啟用用戶端指令碼。</summary>
        <value>布林值，指出用戶端指令碼是否可以在頁面上執行。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>屬性可讓開發人員若要停用用戶端指令碼。 您可能想要停用用戶端指令碼，基於安全考量，或以確保頁面上的所有使用者會都有類似的使用者經驗，即使他們使用不同的瀏覽器。  
  
 您可以停用用戶端指令碼，加上`EnableClientScript`屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在網頁上，如下列宣告式的程式碼行所示：  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外，開發人員可以排除這個屬性藉由繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別及設定預設值`false`。  
  
 Web 組件控制項集合會使用用戶端使用者介面 (UI) 和個人化功能，請提供一些用戶端指令碼。 如果您停用用戶端指令碼、 Web 組件控制項還能運作，但某些功能已停用。 若要將控制項拖曳到不同的區域功能已停用，以及呈現下拉式動詞命令功能表中 （動詞會改為會顯示為控制項的標題列中的連結） 的控制項的標題列中動詞命令的能力。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出網頁上是否允許佈景主題之使用。</summary>
        <value>布林值，指出佈景主題是否已啟用 所有情況下都是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會覆寫基底<xref:System.Web.UI.Control.EnableTheming%2A>屬性，以確保永遠會傳回的值`true`。 這是因為 Web 組件控制集需要使用佈景主題呈現網頁組件的控制項是控制項的子控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制以及構成網頁的使用者介面 (UI)。 比方說，佈景主題用來呈現的各種不同的區域，而中的區域，其中包括各種類型的控制項組件控制項 (繼承自控制項<xref:System.Web.UI.WebControls.WebParts.Part>類別)，使用者控制項、 ASP.NET 伺服器控制項，與自訂伺服器控制項。  
  
 雖然覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>屬性會實作為根據其基底屬性的讀取/寫入屬性，因為根據設計必須一律傳回的值，您無法設定屬性， `true`。 如果您嘗試設定屬性，<xref:System.NotSupportedException>擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">已嘗試設定屬性值。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項連接到另一個控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法完成連線的程序<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一個控制項的控制項。 它是對應項目來<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法可確保所參考的個人化物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是可修改，因為建立連接是本身的個人化的類型，這是必要條件。 方法則可確保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>物件不是`null`，以及最後會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性所參考的控制項是 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 有一個方法是呼叫基底方法，然後加入一些額外的自訂處理，或您可能想要完全自訂的整個程序完成控制項之間的連接。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成編輯 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法完成編輯程序<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 它是對應項目來<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法可確保所參考的個人化物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是可修改，這是必要的因為編輯控制項是需要個人化變更的程序。 方法則可確保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>物件不是`null`，以便在目前選取<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可以變更，但它會呼叫最後<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性所參考的控制項是 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 有一個方法是呼叫基底方法，然後加入一些額外的自訂處理，或您可能想要完全自訂 完成編輯控制項的整個程序。 比方說，在覆寫方法中，您可以先呼叫基底方法，並再加入一些程式碼，判斷所做的編輯變更和變更清單回到確認使用者的顯示。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定警告訊息的文字，當使用者嘗試從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項匯出敏感性狀態資料時，會顯示此警告訊息文字。</summary>
        <value>包含警告訊息的字串。 預設訊息為 .NET Framework 所提供的文化特性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者嘗試匯出敏感性狀態資料從<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並告訴他們的使用者在訊息方塊中，如果任何要匯出的資料來自已標記為機密的原始程式碼中的成員時，顯示一則警告訊息正在匯出敏感性資料，並提供機會，以取消匯出。 開發人員可以藉由設定項目將標示為機密的特定成員的資料`isSensitive`的參數`[Personalizable]`屬性設定為`true`成員上。 如需有關這個屬性和參數的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>類別。  
  
> [!IMPORTANT]
>  當您使用 Web 組件的匯出功能時，機密資料可能無法匯出到未經授權的使用者。 如需如何有效防止這種威脅的詳細資訊，請參閱[保護的 Web 組件頁面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每當使用者嘗試匯出時，會顯示預設訊息。 不過，藉由指派值給<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性，您可以提供自訂的警告訊息。  
  
   
  
## Examples  
 下列程式碼範例示範如何以宣告方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性。  
  
 以下網頁的程式碼會使用標準<xref:System.Web.UI.WebControls.BulletedList>控制項，並將它放在一個區域。 控制項將會以包裝<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段，這可讓它做為真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要表示將控制項設為可匯出，`ExportMode`屬性新增至`<asp:bulletedlist>`項目和屬性值設定為<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>，這表示該敏感性與非敏感性的資料可以匯出。 也請注意，在`<asp:webpartmanager>`項目，`ExportSensitiveDataWarning`屬性被指派自訂的值。  
  
 請注意，針對此程式碼範例才能運作，您必須在 Web.config 檔以啟用匯出 Web 組件描述檔案中新增的設定。 請確定您有與網頁相同的目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請務必`<webParts>`項目`enableExport`屬性設為`true`，如下列標記。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，按一下 （以向下箭號表示） 的動詞命令功能表中的控制項，其中包含連結的標題列。 動詞命令功能表中，選取**匯出**，並請注意，出現訊息方塊，這是使用自訂的警告。 如果您想要繼續匯出，請按一下**確定**，這可讓您儲存的 XML 描述檔本機複本與控制項相關的所有資料。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">控制項，將匯出其資料。</param>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />，將 <c>webPart</c> 的匯出資料寫入 XML 描述檔。</param>
        <summary>建立 XML 描述檔，其中包含伺服器控制項的狀態和屬性資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法會從各種不同的狀態和屬性資料組譯`webPart`到 XML 檔案。 資料包括控制項本身，包括其組件、 狀態資料和屬性資料的相關資訊。 起始匯出的使用者可以在本機電腦或網路上，以儲存到磁碟的 XML 檔案。 其他使用者可以描述的檔案匯入不同的網頁或網站，並套用至另一個執行個體的狀態和屬性資料`webPart`。 這提供快速且方便的機制，讓使用者能夠共用及重複使用伺服器控制項，其設定，並也提供開發人員一種控制項的外觀和行為的匯出和匯入的控制項。  
  
 屬性`webPart`預設不會匯出。 若要啟用匯出的屬性，您必須將它與標記`[Personalizable]`原始程式碼中的屬性。 您可以選擇性地標示為包含機密資料，藉由設定成可匯出的屬性`isSensitive`的參數`[Personalizable]`屬性設定為`true`。 根據預設，`isSensitive`是`false`。 開發人員可以將參數設定為`true`表示資料是敏感性資訊。  
  
 若要啟用`webPart`開發人員設定要匯出其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>屬性值設為<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>（包括所有可個人化和機密屬性），或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>的匯出除了機密屬性的所有項目.  
  
> [!IMPORTANT]
>  允許將資料從控制項、 匯出和其他控制項，將資料匯入的使用者需要一些安全性風險。 開發人員應該使用來保護機密資料，上面所討論的方法，以及如果他們想要避免完全公開資料的風險，則不應啟用匯出上`webPart`完全。 如需 Web 組件的安全性問題的詳細資訊，請參閱[保護的 Web 組件頁面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。  
  
\-或- 
 <paramref name="writer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所參考的控制項集合。  
  
\-或- 
<paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 屬性設為 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> 值，表示停用 <paramref name="webPart" /> 的匯出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保護 Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>覆寫成防止在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項上設定焦點，因為此控制項沒有使用者介面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>方法會覆寫基底<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>方法，並擲回例外狀況，如果呼叫端呼叫的方法。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項沒有 ui，而且絕不會對使用者顯示，它可以永遠不允許將本身的焦點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼叫端嘗試呼叫 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，但沒有 UI 的控制項不支援此動作。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">做為連接之消費者的伺服器控制項。</param>
        <summary>從做為 Web 組件連接之消費者的伺服器控制項中，擷取可做為連接點之所有 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 物件的集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />，包含消費者中的所有連接點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件連接一律會牽涉到兩個控制項，其中一個做為資料提供者，另一個做為資料的取用者。 每個控制項都必須有一或多個定義為連接點的方法。 如果消費者控制項，其連接點會<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>物件。 擷取取用者連接點是必要的步驟中建立 Web 組件連接。  
  
 取用者必須永遠有至少一個連接點，能夠建立連線。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法會檢查消費者控制項，並擷取其所有的連接點的集合。 如果<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項沒有連接點，方法會傳回空集合。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱主題[逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 網頁的宣告式標記包含`Register`使用者控制項和自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目以包含自訂控制項，並有`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法，將程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查，然後將新的連線新增至所參考的靜態連接集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。 請注意，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>會使用擷取的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法會傳遞至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以判斷是否可以建立兩個控制項之間的連線。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 您可以取得此程式碼和指示，編譯的範例區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會出現之後，請注意，連線已經存在的程式碼中包含`Page_Load`方法。 如果您在稍後的瀏覽器工作階段中返回此頁面，此靜態連接就會將已建立，且不需要重新建立每次頁面載入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 之執行個體的網頁。</param>
        <summary>擷取頁面上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項之目前執行個體的參考。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，參考頁面上控制項目前的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法會很有用的內容中您要擷取目前的參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 常見的案例，會發生這個是如果您要撰寫自訂控制項以何種的識別碼在開發期間無法得知<xref:System.Web.UI.WebControls.WebParts.WebPartManager>將可在其頁面上的控制項。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法是靜態的因此您可以直接而不需要的執行個體上呼叫它<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 某些控制項在 Web 組件控制項集合、 這類<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，具有<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>屬性，可擷取目前的參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因此，當使用這類控制項，您應該使用這個屬性來擷取的參照。  
  
 如果您的編碼的內容，您知道的 ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，例如撰寫的 Web 網頁內的內嵌程式碼，它是最簡單且最有效率的直接參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項使用其識別碼。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 此範例有兩個部分： 自訂伺服器控制項，以及裝載控制項的網頁。  
  
 自訂<xref:System.Web.UI.WebControls.Label>控制項會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法來擷取識別碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項目前的頁面，然後顯示該識別碼。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下列程式碼範例提供裝載中的控制項之 Web 網頁<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 在瀏覽器頁面載入之後，請注意，目前的識別碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會顯示自訂內<xref:System.Web.UI.WebControls.Label>控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">控制項，此方法傳回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 的值。</param>
        <summary>取得字串，包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 屬性的值。</summary>
        <returns>字串，包含 <paramref name="webPart" /> 之 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 的計算值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得的導出的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>屬性`webPart`。 當開發人員不指派值給<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，這個方法會產生做為標題顯示的值。 未命名的控制項的導出的值是由數字為字串，加上數字，指出目前的區域內的控制項的序列所組成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides">
          <para>若要變更預設顯示標題的計算方式，可以覆寫此方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在匯出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>當使用者嘗試匯出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項時，取得做為要求一部分的相對虛擬路徑和查詢字串。</summary>
        <returns>字串，包含相對虛擬路徑和查詢字串，這兩項一起形成匯出控制項的要求。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所傳回的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法是包含控制項、 網頁伺服器位置的相對虛擬路徑加上附加的查詢字串值，並形成匯出要求提交給伺服器。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法將字串編碼之前允許的要求來提交，以防範惡意的指令碼攻擊。  
  
> [!NOTE]
>  如需有關保護 Web 組件的應用程式的詳細資訊，請參閱[保護的 Web 組件頁面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">伺服器控制項，存在於 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 並在執行階段包裝成 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控制項。</param>
        <summary>取得包含伺服器控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控制項執行個體的參考。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，用來將 <paramref name="control" /> 包裝成子控制項。 如果 <paramref name="control" /> 不包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，則此方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情況下，有兩種類別的控制項，開發人員將會置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>參與 Web 組件的應用程式的區域：<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>基底類別和其他伺服器控制項，它可以是標準ASP.NET 控制項、 自訂控制項或使用者控制項。 當任何這些控制項置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>花費的功能區域，<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 A<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項本質上具有這項功能，但其他種類的伺服器控制項則否。 若要啟用做為其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>控制它們都放置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域中，ASP.NET 會將它們包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項。 因為<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項直接繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別，它會提供它的子控制項，則為 true 的 Web 組件功能。  
  
 通常在執行階段，網頁程式開發人員可能想要取得的參考<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含其中一個區域中的伺服器控制項的控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法可讓他們擷取參考<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法。 程式碼範例包含<xref:System.Web.UI.WebControls.Calendar>控制項內宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。 `Button1_Click`方法會先列印的 ID<xref:System.Web.UI.WebControls.Calendar>控制項標籤，然後再使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法來擷取參考<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包裝行事曆的控制項。 識別碼<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項，以及其子控制項的識別碼 (也就是<xref:System.Web.UI.WebControls.Calendar>控制項)，兩者會列印至第二個標籤。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">做為連接之提供者的伺服器控制項。</param>
        <summary>從做為 Web 組件連接之提供者的伺服器控制項中，擷取可做為連接點之所有 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 物件的集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />，包含提供者中的所有連接點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件連接一律會牽涉到兩個控制項，其中一個做為資料提供者，另一個做為資料的取用者。 每個控制項都必須有一或多個定義為連接點的方法。 如果提供者控制項，其連接點會<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>物件。  
  
 提供者必須永遠有至少一個連接點，能夠建立連線。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法會檢查提供者控制項，並擷取其所有的連接點的集合。 擷取提供者連接點是必要的步驟中建立 Web 組件連接。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 此範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 網頁的宣告式標記包含`Register`使用者控制項和自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目以包含自訂控制項，並有`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法，將程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查，然後將新的連線新增至所參考的靜態連接集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。 請注意，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>會使用擷取的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法會傳遞至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以判斷是否可以建立兩個控制項之間的連線。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 您可以取得此程式碼和指示，編譯的範例區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會出現之後，請注意，連線已經存在的程式碼中包含`Page_Load`方法。 如果您在稍後的瀏覽器工作階段中返回此頁面，此靜態連接就會將已建立，且不需要重新建立每次頁面載入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />，從正在匯入的 XML 描述檔讀取狀態和屬性資料。</param>
        <param name="errorMessage">
          <see cref="T:System.String" />，匯入期間發生錯誤時，顯示給使用者。</param>
        <summary>匯入 XML 描述檔，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的狀態和屬性資料，並將此資料套用至控制項。</summary>
        <returns>匯入的 XML 描述檔中參考的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (或包裝在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中的伺服器控制項，因此被視為 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法會匯入所建立的 XML 描述檔<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>伺服器控制項的方法。 它不是匯入之後，實際的伺服器控制項，但只包含有關控制項的狀態和屬性資料的說明檔案。 控制項和 description 檔案中參考的組件必須已經是使用者嘗試匯入描述檔案的伺服器上可用的。  
  
 若要啟用匯入控制項，開發人員必須新增<xref:System.Web.UI.WebControls.WebParts.CatalogZone>匯入將會啟用的頁面上的控制項。 在區域中，內<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必須加入控制項。 這個控制項提供的檔案 對話方塊中，可讓使用者瀏覽並找出要匯入描述檔案。  
  
 使用者尋找描述檔案，並開始匯入之後，會讀取描述檔案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法。 如果沒有任何錯誤，而且如果找不到組件和控制，要將伺服器控制項加入至目錄內<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制和 description 檔案中指定的各種屬性和狀態資料套用至控制項。 然後使用者可以選取控制項，並將它新增至頁面。  
  
> [!IMPORTANT]
>  像是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法有一些可能的安全性風險。 這牽涉到將資料匯入網站，因為惡意使用者可能嘗試插入描述檔案匯入的資料不正確或甚至是指令碼。 然後在頁面上，或在資料庫中，可能會出現不正確的資料，或插入的指令碼無法執行。 如需匯入描述檔案，以及避免這些風險的方式相關聯的潛在風險的概觀，請參閱 <<c0> [ 保護的 Web 組件頁面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> 無法讀取檔案。  
  
\-或- 
 <paramref name="reader" /> 需要顯示匯入錯誤訊息，但在檔案中找不到。  
  
\-或- 
 <paramref name="reader" /> 已到達檔案結尾，但找不到包含匯出之資料的 XML 項目。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保護 Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 類別的參考，用來結合和分離 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 類別中實際實作、但對控制項開發人員非常有用的一組方法。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 可以透過它來參考已區分成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各種方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性會公開的 Api 呼叫的一組<xref:System.Web.UI.WebControls.WebParts.WebPartManager>大部分用於擴充性案例的方法。  
  
 使用這些內部方法的設計的方式是透過存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性。 因為屬性已受到保護，您可以只存取它，並呼叫的方法，執行個體內<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>藉由繼承自類別<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。  
  
> [!NOTE]
>  這個屬性中的 IntelliSense 會隱藏[!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]。 不過，在 衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，您仍然可以存取的屬性和其各種成員。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項是否可以加入至頁面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件功能的一部分是彈性的能夠在執行階段時，將伺服器控制項加入至網頁。 有一些常見的案例所在之伺服器控制項 (它可以是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 自訂伺服器控制項、 使用者控制項或 ASP.NET 控制項) 可以加入。  
  
 在下列常見的情況下，Web 組件控制集嘗試將伺服器控制項加入至頁面，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>呼叫方法來授權它們：  
  
-   藉由宣告內的 Web 網頁標記中新增的伺服器控制項時<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域。  
  
-   當伺服器控制項是以程式設計方式新增至區域。  
  
-   當使用者匯入的伺服器控制項的 Web 組件類別目錄的控制項。  
  
-   當現有的伺服器控制項載入個人化資料存放區。  
  
-   若要新增的伺服器控制項時<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>以供目錄中的伺服器控制項的控制項。  
  
 在其中加入控制項，每個案例<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>呼叫方法來確定是否要加入的控制項，以便符合所有授權的準則。 當控制項已獲得授權時，它會新增通常因為它可以有沒有任何篩選的案例。 當控制項未獲授權時，Web 組件控制集可以回應有好幾種，視內容而定。 將未經授權的組件 （如果不需要通知使用者） 無法以無訊息方式到控制項組，它可以顯示錯誤訊息，或它可以加入的執行個體<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>類別做為預留位置。 這個預留位置物件不會顯示在頁面上，但會顯示在頁面原始碼，以表示未經授權的控制項已排除。  
  
 控制項是否獲得授權的行列式是授權篩選條件。 授權篩選條件是可讓開發人員從頁面排除不符合指定的準則的任何控制項的 Web 組件控制項集合中的功能。  
  
 若要建立篩選的案例，開發人員必須做兩件事。 首先，他們必須指派字串值 （值可以是任意），即可<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每個屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>學生打算在此案例中使用的控制項。 它們也可以指派值給這個屬性對於其他類型的不是伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，因為如果它們被放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域，以包裝此類控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段，以及此控制項繼承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性。  
  
 第二個的必要步驟來建立篩選的案例是為覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，或建立的事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。 在這些方法，開發人員可以檢查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性，以及如果此值會指出不應該授權控制項，開發人員確保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法會傳回值`false`。  
  
> [!NOTE]
>  如需程式碼範例和如何設定自訂的篩選案例中使用的描述<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，請參閱方法的多載的主題。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在檢查授權的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項。</param>
        <summary>執行會判斷控制項是否獲得授權可加入至頁面的初始步驟。</summary>
        <returns>指出 <paramref name="webPart" /> 是否可加入至頁面上的布林值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法會呼叫設定為檢查授權的 Web 組件控制項的初始方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 它接受`webPart`做為參數，並開始處理程序，最後會決定是否將控制項加入至頁面。 直接呼叫這個方法從程式碼時您必須判斷是否授權指定的控制項。  
  
 這個方法會執行初始工作，判斷控制項是否繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別，或者是<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項，且如果是的話，控制哪些類型的子項目包含。 若要完成授權工作，它會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法多載。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>從您的程式碼，以判斷控制項是否獲得授權加入至頁面的方法。  
  
 在程式碼範例有三個部分：  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>會覆寫的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。  
  
-   建立的篩選器的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   如何執行此程式碼範例的說明。  
  
 此程式碼範例會使用自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>多載方法，以提供的自訂處理<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性。 這個控制項的屬性值會檢查`admin`而且，如果值存在時，會授與該控制項。 如果控制項有不同的值，它未獲授權;不使用屬性值的控制項授權的因為它們都假設為無法篩選案例的一部分。  
  
 若要執行此程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此程式碼範例會使用動態編譯的方法。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 程式碼範例的第二個部分會建立可能可以排除控制項的篩選條件。 以下網頁包含三個中的 ASP.NET 伺服器控制項`<asp:webpartzone>`項目。 請注意，第一個和第二個控制項都有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性設定為不同的值，以及第三個未指派的屬性。 在執行階段，可以檢查此授權值和控制項可以加入至頁面上，如果篩選條件符合時，開發人員所設定的準則。 另外請注意，在`Page_Load`方法中，程式碼會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>方法，以判斷是否每個控制項已獲得授權，以及如果因此，它會設定每個控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 請注意，程式碼範例正常運作，您必須新增設定以啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 請確定您有與網頁相同的目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請務必`<webParts>`項目`enableExport`屬性設為`true`，如下列標記。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 在瀏覽器頁面載入之後，請注意，會顯示第一個控制項，因為它會比對的準則中覆寫的方法。 第二個控制項不會加入到頁面上，因為它會排除篩選器。 也加入第三個控制項，因為它並沒有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性集。 請注意，如果您按一下其中一個控制項的標題列中動詞命令功能表圖示時，他們可以同時匯出，因為其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>沒有指派屬性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>直接從程式碼會呼叫這個方法。 如果您想要取得更大控制權以程式設計方式在授權程序，您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />方法多載。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">正在檢查授權之控制項的 <see cref="T:System.Type" />。</param>
        <param name="path">正在授權之控制項的原始程式檔的相對應用程式路徑，若是使用者控制項。</param>
        <param name="authorizationFilter">指定給 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 屬性的任意字串值，用來授權控制項是否可以加入至頁面。</param>
        <param name="isShared">指出正在檢查授權的控制項是否為共用控制項，表示對應用程式的多數或所有使用者都是可見，並且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 屬性值設為 <see langword="true" />。</param>
        <summary>執行會判斷控制項是否獲得授權可加入至頁面的最終步驟。</summary>
        <returns>布林值，指出控制項是否獲得授權，可加入至頁面。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>多載方法會判斷控制項是否獲得授權加入至頁面的最後一個步驟執行。 此方法可確保`type`是有效的型別，而且`path`正在檢查之控制項是一個使用者控制項時，才會有值。 然後它會呼叫關鍵<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，這會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。  
  
   
  
## Examples  
 下列程式碼範例示範如何覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，以判斷控制項是否獲得授權加入至頁面。  
  
 第一個步驟是建立篩選器，可能可以排除控制項。 以下網頁包含三個中的 ASP.NET 伺服器控制項`<asp:webpartzone>`項目。 請注意，第一個和第二個控制項都有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性設定為不同的值，以及第三個未指派的屬性。 在執行階段，可以檢查此授權值和控制項可以加入至頁面上，如果篩選條件符合時，開發人員所設定的準則。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二個步驟為覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，並建立自訂授權篩選條件的處理。 請注意，程式碼會先檢查屬性是否有值，以便任何控制項不會指派<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性就會自動新增。 如果控制項有篩選，則程式碼會傳回`true`只有當篩選條件的值等於`admin`。 這會示範簡單的機制，您可以使用特定控制項顯示特定使用者，根據其角色。 本主題的範圍之外的完整範例，使用角色時，您可以使用相同的邏輯作為覆寫的方法，在此範例中，不同之處在於您可以檢查目前使用者是否符合授權篩選值的角色然後新增 僅對該使用者控制項。 這可讓您建立的網頁，其中有些使用者會看到所有的控制項，而其他使用者會看到選取的控制項。 這是如果您使用的角色檢查篩選條件的邏輯的可能外觀：  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此程式碼範例會使用動態編譯的方法。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 在瀏覽器頁面載入之後，請注意，會顯示第一個控制項，因為它會比對的準則中覆寫的方法。 第二個控制項不會加入到頁面上，因為其篩選值被排除。 新增第三個控制項，因為它並沒有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性集。 如果您變更屬性值，第二個控制項，來比對的第一個控制項，並再重新執行頁面上，也會加入第二個控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 是使用者控制項，但 <paramref name="path" /> 是 <see langword="null" /> 或空字串 ("")。  
  
\-或- 
 <paramref name="type" /> 不是使用者控制項，但 <paramref name="path" /> 有指定的值。</exception>
        <block subset="none" type="overrides">
          <para>可以覆寫此方法，藉由繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，如果您想要檢查授權時提供額外的處理。 您可能想要覆寫方法，檢查某些值<paramref name="authorizationFilter" />參數，並根據的值，傳回布林值，決定是否要在控制項加入至頁面。  
  
對於頁面開發人員也想要檢查授權篩選條件，並提供自訂處理，沒有執行此內嵌在.aspx 頁面，或在程式碼後置檔案中，而不需要可從任何類別繼承的選項。 您可以宣告替代的事件處理常式中的頁面<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法的<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項。 如需詳細資訊和範例，請參閱<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已執行個人化變更，並影響 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所控制的頁面層次個人化細節。</summary>
        <value>布林值，指出是已執行個人化變更。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>內部追蹤是否有任何它所管理的頁面層次個人化資料的屬性已變更。 個人化資料變更，當使用者執行各種不同的個人化動作，在頁面層級，例如新增或移除<xref:System.Web.UI.WebControls.WebParts.WebPart>連線或中斷連線移動控制項和其他動作以變更頁面的版面配置控制項的控制項。  
  
> [!NOTE]
>  使用者也可以執行控制層級，這表示它們進行個人化變更，到特定的控制項，在個人化，所做的變更只影響該控制項。 範例會編輯控制項，並變更其標題文字或它的背景色彩。 控制層級的個人化不會影響所追蹤的頁面層次個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，因此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>屬性值不會變更為`true`控制層級的個人化的時機。  
  
 雖然方法受到保護，而且呼叫端，無法直接存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性可以存取直接呼叫端，並傳回這個屬性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要載入之保存的狀態資料。</param>
        <summary>載入上一個頁面要求所儲存的控制項狀態資料，在後續要求中需要還原此控制項狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>方法會很有幫助還原應在頁面的回傳之間保存的屬性資料，即使<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>儲存已由個人化物件傳遞至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化資料，以使用於稍後的初始化過程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法會提供儲存的狀態資料的形式<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>物件。 載入 Web 組件控制項的個人化資料，以及執行其他初始化工作，最終會使用此資料。  
  
> [!NOTE]
>  由一連串的方法開始時，會呼叫這個方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法一開始會要求相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>物件，以提供個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 您無法直接從程式碼中呼叫這個方法。 您可以不過，直接呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法，而其本身會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法並傳回個人化資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法中衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 使用權限。</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 使用權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>這個屬性所傳回的物件型別還原序列化時，可在匯入期間。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 使用權限。</summary>
        <value>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 使用權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>匯入的所有項目但輸入還原序列化期間使用這個屬性所傳回的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">正在移動的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項。</param>
        <param name="zone">
          <c>webPart</c> 正在移至的目標 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">整數，表示 <c>webPart</c> 的索引，相對於 <c>zone</c> 中的其他控制項。</param>
        <summary>將 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項從某個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域移至另一個區域，或移至相同區域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法來移動`webPart`在相同區域中，或在不同的區域中的新位置。 您可以直接從程式碼，呼叫這個方法，它也會叫用時使用者會將控制項移到新位置，使用 Web 組件的使用者介面 (UI) 中的各種選項。  
  
 必須符合一些條件`webPart`可以移動，以及其中大部分由本主題的 [例外] 區域中所列的項目。 如果`webPart`不包含在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域不能將它移到區域的開始。  
  
 移動已符合條件後，發生下列動作順序`webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法會引發 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  `webPart` 會從其目前區域移除 （如有必要），並新增至其新的區域或其目前的區域中的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法會引發 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  `zoneIndex`的每個<xref:System.Web.UI.WebControls.WebParts.WebPart>在來源和目的地區域中的控制項重設為反映已移動的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，直接從程式碼，以移動<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項從一個區域到另一個。  
  
 在程式碼範例有三個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   裝載控制項的網頁。  
  
-   如何執行此程式碼範例的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式，以及使用者控制的運作方式的詳細資訊，請參閱 <<c0> [ 逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是網頁，其中包含兩個區域，其中每一個包含兩個伺服器控制項。 當使用者按一下**移動 web 組件**頁面上的按鈕中的程式碼`Button1_Click`方法將控制項從第一個區域移至第二個區域中的新位置。 請注意，程式碼第一次必須呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法來擷取<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包裝的物件`list1`控制項。 這是必要的因為第一個參數<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法需要<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，而`list1`是 ASP.NET 伺服器控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 在頁面載入之後，請按一下**移動 web 組件** 按鈕，並請注意，包含連結的控制項移到第二個區域中的中間位置。 此控制項的移動完成程式設計的方式，藉由呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法。 您也可以使用**顯示模式**下拉式清單控制項，將頁面切換到設計模式，並在設計模式中，您可以將控制項拖曳到不同的區域或其區域的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法也會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項來處理這類使用者起始移動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
\-或- 
 <paramref name="zone" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
\-或- 
<paramref name="webPart" /> 控制項的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 屬性所參考的區域是 <see langword="null" />，這表示 <paramref name="webPart" /> 目前不是包含在區域中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 或 <paramref name="zone" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> 小於零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件並叫用事件的處理常式 (如果有的話)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，當<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項正在加入至頁面的授權檢查。 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>呼叫方法時，它會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件和事件處理常式方法時，它會叫用處理常式。  
  
 授權程序<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項是一項重要 Web 組件功能。 每隔<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項加入至由區域<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項將會執行授權程序，以判斷是否可以加入控制項。 根據預設，Web 組件控制集所提供的任何篩選準則，以防止控制項新增至區域。 但是，控制項集合提供所需的開發人員建立自己的篩選準則的機制。 藉由使用這些機制，您可以建立自訂篩選案例。 比方說，您可以建立篩選，以便如果使用者是系統管理員角色中，某些控制項時將會新增至區域呈現網頁時，以及如果使用者是使用者角色，就不會加入這些控制項。  
  
 篩選控制項授權程序期間的機制會<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>上的屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>並<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>上的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 若要建立篩選的案例，有基本上有兩個工作。 首先，您指派字串<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每個屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>您想要篩選的控制項。 這些字串值可以是任意的但應該包含您想要篩選的準則。 比方說，如果您要指定的控制項新增至區域的只有當系統管理員使用者在檢視頁面上，那麼您可以指派字串值`admin`屬性。 然後您可以使用 ASP.NET 角色功能，並將您的網站上的所有使用者都加入至各種不同的角色，例如系統管理員、 管理員和使用者。 當頁面載入時，您篩選的程式碼會檢查使用者的角色，請比較正在檢查控制項上的授權篩選值，如果使用者是系統管理員角色中的 （舉例來說），您必須將控制項的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的值`admin`，可以新增控制項。  
  
 建立篩選的案例的第二個步驟是撰寫程式碼來檢查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值上<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並判斷是否要在加入至其區域之前，授權每個控制項。 有兩個選項可將此篩選的程式碼的位置。 第一個選項是網頁開發人員慣用的選項。 您可以建立方法以處理<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>直接在網頁伺服器指令碼，或程式碼分開置放檔案中的事件。 與事件關聯您的方法，藉由新增`OnAuthorizeWebPart`屬性的標記<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制在頁面中，如下列範例的標記程式碼所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 所有您的自訂方法只需要為每個 check<xref:System.Web.UI.WebControls.WebParts.WebPart>控制篩選準則，然後根據結果，布林值指派給<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>屬性<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>物件，表示是否<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可以新增。 範例 > 一節中的程式碼示範如何執行這項操作。  
  
 您的篩選程式碼的位置的第二個選項是繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，並覆寫方法，若要檢查篩選準則。 您可以覆寫以執行此兩種方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 雖然這兩種方法可以運作，但在大部分情況下最好是覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，因為它會提供您更以程式設計方式控制整個授權程序，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法會執行只有一個特定的工作也就是引發的事件和處理常式的核取。 自訂程式碼範例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定的自訂事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，以便處理常式可以提供自訂的篩選程式碼，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 此範例中會提供篩選的案例和授權的網頁開發人員的典型方式<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項加入至頁面。  
  
 在網頁上，注意`<asp:webpartmanager>`項目具有`OnAuthorizeWebPart`屬性指派給它的事件處理常式的名稱。 這個方法會檢查頁面上的控制項是否有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`admin`而且，如果是的話，會傳回`true`，這表示將會獲得授權並新增至頁面。  
  
> [!NOTE]
>  請注意，控制項沒有任何值，指派給<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性會加入，因為它們假設為無法篩選案例的一部分。 這會是篩選案例中常見的方法： 某些控制項進行篩選，和其他人不會因為它們都假設為可供所有使用者。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 使用者角色設定已超出本主題的範圍，因為此程式碼範例不會檢查在篩選中的使用者角色。 不過，篩選控制項，根據使用者角色的案例很可能是其中一種最常見的用法，此篩選的功能。 如果您有在您的網站上的角色，而且您想要檢查這個方法，以篩選控制項中的使用者角色，該方法會類似下列程式碼區塊 （相對於上述的程式碼範例不使用角色中更簡單的方法）。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件，以表示頁面及其控制項已載入，並且頁面上的連接已啟動，可以開始共用資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>網頁完成載入程序之後的事件。 方法可用來新增事件處理常式。  
  
 網頁程式開發人員可以加入，將自訂事件處理常式`OnConnectionsActivated`屬性設定為`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />方法中衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件，以表示頁面及其控制項已載入，並且可以開始啟動連接的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件，開發人員提供一種機制，以程式設計方式自訂 啟用連線處理程序。  
  
 網頁程式開發人員可以加入，將自訂事件處理常式`OnConnectionsActivating`屬性設定為`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />方法中衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含與變更之顯示模式關聯的事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以表示網頁上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項已完成從某個顯示模式切換至另一個顯示模式的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法在其基底表單只會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />方法。 比方說，變更後的顯示模式，可能會想要變更的使用者介面 (UI)，根據哪個顯示器模式包含在外觀中的項目<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />屬性。 或者，您可能想要隱藏特定的內容，或顯示特定的控制項。  
  
當您覆寫此方法時，您通常應該呼叫基底方法的覆寫的方法，最後一個步驟，讓您自訂的程式碼會率先執行並在上一次，引發事件指出模式變更為完整。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，包含與變更中顯示模式關聯的事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以表示網頁上的<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項正在進行從某個顯示模式切換至另一個顯示模式的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法在其基底表單只會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />方法。 比方說，因為會變更顯示模式，您可能想要檢查新的顯示模式將會 (使用<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />屬性) 和變更根據新的顯示模式將會有的使用者介面 (UI) 中的項目。 如果您有自訂的顯示模式時，您可能想要讓特定控制項顯示，如果自訂模式將會新的顯示模式。  
  
當您覆寫這個方法時，您通常應該呼叫基底方法的第一個步驟，在覆寫的方法，以便在引發事件來指出正在開始變更顯示模式。 然後，自訂程式碼可以進行變更的使用者介面 (UI) 中實際顯示新的 「 顯示 」 模式之前。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.Init" /> 事件，這是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項生命週期的第一個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法會呼叫基底方法，這會引發<xref:System.Web.UI.Control.Init>控制項，然後會執行數個準備步驟的詳細資訊，例如確保只有一個執行個體的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項在頁面上，並載入個人化資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">頁面上有另一個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，在網頁上呈現 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項之前會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>方法會呼叫基底方法，這會引發<xref:System.Web.UI.Control.PreRender>控制項，然後註冊的事件頁面，其中包含 Web 組件所需的數個用戶端指令碼控制。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，在剛選取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項或已清除其選取範圍之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件，這通常是開發人員可能要變更的使用者介面 (UI) 外觀的時間點。 例如，當新<xref:System.Web.UI.WebControls.WebParts.WebPart>選取控制項、 Web 組件控制集變更新選取的控制項的呈現。 會清除控制項的選取範圍之後，轉譯會回到正常。  
  
 使用者選取特定之後<xref:System.Web.UI.WebControls.WebParts.WebPart>進行編輯，控制<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>呼叫方法。 當使用者完成編輯控制項，並以結果，則會清除控制項的選取範圍，會關閉，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>一次呼叫方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>有數個選項的相關<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />事件，讓開發人員可以自訂變更選取的控制項後，就會發生的轉譯。 在宣告式的程式碼內<see langword="&lt;asp:webpartmanager&gt;" />您可以設定的項目<see langword="OnSelectedWebPartChanged" />屬性，然後將自訂方法的名稱指派給它。 在自訂的方法中中,，您可以修改所選控制項的呈現事件發生時。 另一個選項是繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫此方法。 第三個選項是自訂的呈現在區域層級;例如，您可以繼承自<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />類別，並覆寫其<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />方法，以自訂控制項選取和清除編輯程序期間呈現。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，在變更目前選取之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序中會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件，以變更它的程序中發生<xref:System.Web.UI.WebControls.WebParts.WebPart>目前已選取控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項使用這個方法和相關聯的事件，以提供取消處理程序在其中變更選取的控制項。 比方說，在呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法，也內<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法，以提供取消程序的方式。 如果使用者按一下 [取消] 上的動詞命令正在編輯的控制項，控制項不會再選取和編輯的任何變更不會儲存，因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法可讓您取消編輯的變更。  
  
> [!NOTE]
>  同樣地會期間的開始和結束連接的程序的方法呼叫的方法<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一個控制項，以便取消該程序的控制項。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>加上的事件`OnSelectedWebPartChanging`屬性設定為`<asp:webpartmanager>`中宣告式網頁標記中，並將自訂方法的名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">與控制項移除關聯的事件資料。</param>
        <summary>引發基底 <see cref="E:System.Web.UI.Control.Unload" /> 事件並從網頁中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項已加入至頁面之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法呼叫期間加入的程序<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或其他伺服器控制項加入至<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域) 至頁面。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>加上的事件`OnWebPartAdded`屬性設定為 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，在將 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的程序中發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>表示控制項正在加入的事件。 此方法也會提供取消加入程序的選項。 如果成功加入控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartAdding`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件，以表示控制項已從頁面移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件，以表示<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 （或其他伺服器或使用者控制項） 已成功關閉頁面上。  
  
 若要關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是指從頁面移除，讓它不會呈現，並也將它放在特別保留物件呼叫的頁面類別目錄。 頁面目錄中，對應至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，並維護參考至已關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>針對每個頁面的控制項。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項內的頁面上宣告<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用者可以將頁面切換成類別目錄的顯示模式，並將任何先前已關閉的控制項新增至頁面。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法提供的機會，開發人員建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。 網頁程式開發人員可以加入，將自訂事件處理常式`OnWebPartClosed`屬性設定為`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。 開發人員可能會在這個方法中執行的一項實用工作是將顯示已關閉的控制項取代的預留位置，使用工具提示，告知使用者如何將控制項新增至頁面的完成。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，從頁面正在移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的程序中會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件，以表示控制項是正在關閉，或從頁面移除。 此方法也會提供取消關閉程序的選項。 如果控制項已成功移除頁面上，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartClosinging`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，從頁面永久刪除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>刪除的程序期間呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或其他伺服器控制項加入至<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域) 從頁面。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>加上的事件`OnWebPartDeleted`屬性設定為 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，表示正在刪除動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或包含在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有動態<xref:System.Web.UI.WebControls.WebParts.WebPart>可刪除控制項，並刪除控制項時，控制項執行個體從頁面永久移除，且無法還原。 動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項是以程式設計的方式，加入或從 Web 組件目錄，而不是靜態控制項中宣告的 Web 網頁的標記。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件，以表示控制項會永久刪除從其區域。 此方法也會提供取消刪除的程序的機會。 如果控制項已成功刪除 頁面上，從<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartDeleting`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項已移至頁面上的不同位置之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件的最尾端<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，可確保任何程式碼隨即在事件處理常式執行之前，已完成移動控制項的程序。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>控制項移在其目前的區域，或另一個區域，而不論是否移動完成程式設計的方式或由使用者拖曳控制項時引發事件。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>加上的事件`OnWebPartMoved`屬性設定為 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，表示正在移動 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項或在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件，就會發生時<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項正在移動其區域內或另一個區域。 此方法也會提供取消移動程序的機會。 如果順利完成移動，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartMoving`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間已建立連接之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法會引發其相對應的事件，每一端的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法，以確保連線兩個控制項所需的步驟都要在事件處理常式中的任何程式碼執行之前完成。  
  
 方法可提供以程式設計方式控制的程序建立連線，以及相關聯的事件是一個方便的點，用來更新使用者介面 (UI)，或通知使用者已建立的連線。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>加上的事件`OnWebPartsConnected`屬性設定為 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，在建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或包含在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 的連接程序中發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，當兩個控制項嘗試建立連線時，就會發生。 此方法會提供取消連線嘗試的機會。 如果連線成功，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartsConnecting`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間的連接已結束之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法會引發其相對應的事件，每一端的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，它會執行結束兩個控制項之間連接的處理。  
  
 方法可讓您以程式設計方式控制結束連接的程序，以便開發人員可以通知使用者，對使用者介面 (UI) 中的變更，或應用程式進行其他變更。  
  
 網頁程式開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>加上的事件`OnWebPartsDisconnected`屬性設定為 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，表示正在結束 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 之連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，其發生於當兩個控制項都結束連接。 此方法會提供取消中斷連線的處理程序的機會。 如果成功移除的連線，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件會依循。  
  
 網頁程式開發人員可以提供自訂處理常式相關聯的事件加上`OnWebPartsDisconnecting`屬性設定為`<asp:webpartmanager>`Web 頁面上，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法，以自訂事件處理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含網頁個人化資料之物件的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含個人化資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性會提供方法來存取<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>頁面，以透過相關聯的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 您可以使用這個屬性，來存取各個成員的個人化物件。 例如，您可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法，才能切換網頁的個人化範圍，從共用使用者範圍中，反之亦然。 是否在頁面上，提供者用於個人化資料，以及其他即使啟用個人化，您也可以找出目前的頁面上，個人化範圍。  
  
 請注意，所參考資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是只有頁面層級的個人化資料，來追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 控制項專屬的個人化資料，例如可個人化屬性的值<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，不是屬於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性。  
  
> [!NOTE]
>  如需有關 Web 組件個人化的詳細資訊，請參閱 < [Web 組件個人化概觀](https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性以程式設計的方式。  
  
 下列網頁，讓使用者能夠進入編輯模式，若要編輯的特定層面<xref:System.Web.UI.WebControls.Calendar>控制項。 **切換範圍**按鈕切換到使用者或共用的個人化範圍的頁面。 **編輯模式**並**瀏覽模式**按鈕每個頁面切換到適當的顯示模式。 請注意，在`<script>`標記的方法，處理事件會使用下列兩個檔案區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性來存取基礎物件的實用的成員。 具體來說，這些方法會使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>透過存取物件上的屬性<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要執行程式碼範例，您還必須啟用一或多位使用者共用的範圍中的頁面個人化。 將項目內新增至 Web.config 檔案中，`<system.web>`區段，看起來像下列的標記。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 在瀏覽器頁面載入之後，請按一下**切換範圍** 按鈕，並請注意，頁面現在會顯示在共用範圍。 按一下 **編輯模式**若要變更顯示模式，按一下 指令動詞 功能表上可見的控制項，然後選取**編輯**從功能表。 請注意，這兩個編輯控制項的使用者介面 (UI) 會出現。 現在，請按一下**瀏覽模式**返回正常瀏覽。 如果頁面會顯示在共用的範圍內，按一下**切換範圍**一次，以確保使用者領域中的頁面。 接下來，請遵循相同的步驟，同樣地，編輯控制項，但請注意，現在在編輯 UI 中，<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>控制項不會出現。 這是因為當頁面位於共用的個人化範圍，僅適用於此控制項。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Web 組件個人化概觀</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項發出用戶端指令碼，用於各種個人化功能，例如在網頁上拖曳 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" />，接收控制項的內容，以寫入頁面。</param>
        <summary>覆寫成防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項呈現任何內容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制狀態資料，以便在未來的要求中，將資料還原至包含此控制項的網頁。</summary>
        <returns>
          <see cref="T:System.Object" />，用來包含儲存的控制項狀態資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>方法會將儲存頁面回傳，皆予以保存的屬性的狀態資料，即使<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所維護的自訂個人化狀態資料，當頁面重新載入時，讓這項資料也可以重新載入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>方法很重要，在個人化，過程中，因為它可讓未來的瀏覽器工作階段所儲存的個人化的使用者設定，並瀏覽至頁面。 方法會將儲存自訂個人化狀態資料，其中包含項目，如下所示： 動態<xref:System.Web.UI.WebControls.WebParts.WebPart>或已加入至頁面或從頁面; 已在頁面的移動的控制項與具有動態連接的伺服器控制項已建立或刪除。  
  
 您無法直接從程式碼中呼叫這個方法。 不過，您可以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法，而其本身呼叫此方法來儲存個人化資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫這個方法在衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別來自訂儲存個人化資料的程序。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項的參考，這個控制項目前選為要進行編輯或建立與另一個控制項的連接。</summary>
        <value>目前選為要編輯或建立連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性傳回的參考<xref:System.Web.UI.WebControls.WebParts.WebPart>或進行編輯或建立與另一個控制項的連接目前未選取其他伺服器控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項處理選取的控制項的程序提供數個實用的方法和事件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>只選取控制項之後，但進行任何變更之前，就會發生事件。 若要選取它之後執行控制項上的某些動作，請覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 例如，您可能要變更的控制項的外觀，已選取，但未變更，以視覺化方式強調選取的控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>只在選取的控制項已變更之後，就會發生事件。 若要變更後執行控制項上的某些動作，請覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>某個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的選取範圍已變更並移至網頁上的另一個控制項之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用於搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法，以變更選取的控制項的使用者介面 (UI)。 比方說，如果使用者切換到設計模式的頁面 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)，然後選取<xref:System.Web.UI.WebControls.WebParts.WebPart>控制的目的是將它拖曳到新位置，通常會藉由變更的色彩，例如變更選取之控制項的轉譯其框線或背景時選取它。  
  
> [!NOTE]
>  如需有關如何取用事件的詳細資訊，請參閱[如何： 使用 Web Forms 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在網頁上變更目前選取之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用於搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 頁面開發人員可以藉由新增在他們的程式碼中建立事件處理常式`OnSelectedWebPartChanging`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及將屬性的值設定為自訂方法的名稱將處理的事件。  
  
 開始或結束連接控制項之間，以及當開始和結束編輯控制項的程序期間，會引發這個事件。 如需詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>作為使用者的動作，以變更選取的控制項的直接結果，就會引發事件，可以取消事件。 不過，還有不能取消事件中的案例。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>刪除控制項時，<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 未使用者，而且它必須決定目前選取的控制項，以及何時變更不使用任何可能發生的中斷，選取範圍，讓它能完成的清除程序所有控制項。 因此，根據設計<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>方法無法取消在此案例中。 相關事件可取消，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>設定旗標，表示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化資料已經變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法會設定旗標，最後導致 Web 組件控制項設定為儲存更新的個人化資料中的 個人化元件。 如需詳細資訊，可能會導致變更追蹤的個人化資料的案例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>無法直接從您的程式碼呼叫方法，它不能覆寫，因為它供內部設定 Web 組件個人化功能的一部分的 Web 組件控制項。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>會呼叫此方法的衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。 這會很有用，如果您想要自訂的 Web 組件控制項的元件集，並因此需要控制設定個人化資料的旗標的程序的個人化項目。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">選取的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</param>
        <summary>將 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性值設為等於目前選取的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法呼叫期間的處理程序開頭或結尾指定的控制項編輯`webPart`參數，以及開頭或結尾包含連線`webPart`。  
  
 編輯和連接處理程序的開頭`webPart`是已選取要編輯，或輸入連接的控制項。  
  
 編輯和連接處理程序的結尾`null`傳遞至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法，會導致不會再選取目前選取的控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定空字串 ("")，不讓任何面板套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項。</summary>
        <value>空字串，防止面板套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>屬性會覆寫繼承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>屬性，以防止<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，也就是不可見的控制項，從使用面板。 屬性的實作可防止面板藉由一律傳回空字串指派`get`存取子，並一律在嘗試設定中的值是否擲回例外狀況`set`存取子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">已嘗試設定屬性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上定義為靜態連接之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 物件集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含頁面上的所有靜態連接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項來追蹤和管理頁面上的所有靜態連接。 靜態連接，相較於動態的連接，不需要每次呈現網頁時，加入至頁面。  
  
 這個屬性所參考的集合包含所有存在的頁面，無論它們是以程式設計方式建立或使用指定的靜態連接`<asp:webpartconnection>`在網頁標記中的項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 在程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和`<asp:webpartmanager>`項目。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只有網頁的部分範例。 您也必須取得範例-自訂使用者控制項和自訂控制項和介面的原始碼的前兩個部分的範例區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 該主題也說明選項編譯<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 在程式碼範例的第三個部分是網頁。 網頁的宣告式標記包含`Register`使用者控制項和自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目以包含自訂控制項，並有`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法，將程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查，然後將新的連線新增至所參考的靜態連接集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**Connect**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目，可讓您建立控制項之間的連線。 在連線模式中，按一下標題列中的向下箭號**郵遞區號**控制項來啟用它的動詞命令功能表中，然後按一下**Connect**。 連接使用者介面 (UI) 會出現之後，請注意，連線已經存在的程式碼中包含`Page_Load`方法。 如果您在稍後的瀏覽器工作階段中返回此頁面，此靜態連接就會將已建立，且不需要重新建立每次頁面載入。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得特定網頁上所有可用顯示模式的唯讀集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定網頁上可用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性包含只會在頁面上，指定的區域頁面上出現的控制項種類實際可用的顯示模式。  
  
> [!NOTE]
>  您可以停用的顯示模式，並停用的顯示模式時，它不會加入至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>集合，即使在支援該顯示模式的區域的對應型別是出現在頁面上。  
  
 一律支援瀏覽模式和設計模式。 可以變更顯示模式是編輯、 目錄和連接模式。 每一種顯示模式是特定類型的相關聯<xref:System.Web.UI.WebControls.WebParts.ToolZone>控制項。 它是該特殊類型的區域，會導致特定顯示模式，可以加入至所參考的集合在網頁上是否存在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 例如，如果網頁上包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>而非區域<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，然後編輯顯示模式是其中一個支援的模式，在該頁面上，但不是支援目錄顯示模式。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性與不同<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性，即在參考集合，其中包含所有目前可用的顯示模式<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，即使不是支援的特定頁面。  
  
   
  
## Examples  
 下列程式碼範例示範以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 程式碼會使用這個屬性來填入清單，只顯示可用的模式中目前的網頁。  
  
 有三個支援此頁面上顯示模式： 瀏覽、 設計和編輯。 前兩個永遠可用，以及編輯模式是用於此程式碼範例，因為此頁面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>控制項。 目錄和連接的顯示模式不會顯示，因為其對應的區域不在此頁面上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您可以使用下拉式清單控制項，以切換到設計模式中，瀏覽模式的頁面，然後編輯模式。 您可以在編輯模式中，按一下下拉式動詞命令功能表中的其中一個伺服器控制項中，標頭，並選取**編輯**編輯控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 組件的頁面顯示模式</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理的自訂個人化狀態資料是否已變更。</summary>
        <value>布林值，指出自訂個人化狀態資料是否已變更。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性可讓呼叫者以判斷是否個人化狀態資料受<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已變更。 當使用者將個人化頁面層級的詳細資訊，例如藉由變更頁面配置、 建立或刪除連線，且個人化資料新增或刪除控制項，已受到<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的變更。 這是受保護項目的值傳回到呼叫端傳遞方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>屬性，無法直接存取呼叫端。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性不會指出是否可個人化的屬性值或個別屬性，會影響個別的外觀<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項已變更。 控制層級的個人化個別追蹤每個控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性僅會指示是否個人化資料，在頁面層級並受<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已變更。  
  
 下列清單說明一些常見的執行個體的個人化，會導致<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性傳回的值`true`，這表示，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項有一些已變更的個人化資料：  
  
-   關閉靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>頁面上，控制項 （或伺服器或使用者控制項）。  
  
-   還原已關閉的靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>回到頁面從頁面類別目錄的控制項。  
  
-   在其區域或另一個區域，請移動任何控制項。  
  
-   從目錄加入控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項，或以程式設計方式加入控制項。  
  
-   建立兩個連線<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，以程式設計方式或使用連接使用者介面 (UI)。  
  
-   刪除兩個連線<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，以程式設計方式或使用連接 UI。  
  
 若要存取這個屬性值，您必須轉型<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項執行個體<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>介面，您可以再讀取<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>屬性值。  
  
   
  
## Examples  
 下列程式碼範例示範的簡易用法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性，以指出某些常見的網頁個人化執行個體且導致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>變更控制項的個人化資料。  
  
 在程式碼範例包含四個部分：  
  
-   可讓您變更使用者控制項上包含 Web 組件控制項的頁面顯示模式。  
  
-   包含兩個自訂的程式碼的原始程式檔<xref:System.Web.UI.WebControls.WebParts.WebPart>可以連接的控制項和介面。  
  
-   裝載的所有控制項的網頁。  
  
-   在程式碼範例的運作方式的說明。  
  
 在程式碼範例的第一個部分是變更顯示模式的使用者控制項。 您可以取得使用者控制項的原始程式碼範例區段的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 顯示模式，以及使用者控制的運作方式的相關資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是原始程式檔，以自訂控制項和介面。 請注意，`IZipCode`介面會公開一個方法，並為此方法實作在自訂`ZipCodeWebPart`控制項做為回呼方法以啟用`ZipCodeWebPart`做為連線案例中的提供者。 另一個控制項`WeatherWebPart`，在連接中控制可做為取用者，可以使用提供的特定介面`ZipCodeWebPart`。 在實際的應用程式，`WeatherWebPart`可以取用提供者，從個人化的郵遞區號值，然後將圖形化的天氣資訊提供給使用者。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確編譯它，然後將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您網站的 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 此程式碼範例會使用動態編譯;因此，請注意，`Register`僅包含在網頁頂端的此元件的指示詞`TagPrefix`並`Namespace`屬性，而不`Assembly`屬性。 如需示範如何編譯的逐步解說，請參閱 <<c0> [ 逐步解說： 開發和使用自訂 Web 伺服器控制項](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 在程式碼範例的第三個部分是網頁。 請注意，它包含兩個<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域中的，第一個包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 另外還有<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，其中包含標準<xref:System.Web.UI.WebControls.Calendar>使用者可以加入至網頁的控制項。 `<asp:connectionszone>`項目提供了連接 UI 控制項之間建立連線的使用者。 在 `Page_PreRender`方法，請注意，它會檢查是否已變更的個人化資料，而且如果是的話，會更新的文字`Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，嘗試建立一些會變更個人化資料本主題的 < 備註 > 一節所列的案例。 當您進行各種變更，當變更牽涉到追蹤的個人化案例之一<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，文字`Label1`控制項顯示，表示個人化資料已經變更。 例如，您可以：  
  
-   按一下控制項之間建立連線**連接 WebPart 控制項** 按鈕。  
  
-   使用**顯示模式**下拉式清單控制項的網頁切換至目錄的模式，並新增**我的行事曆**控制項，第二個<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
-   上一步 [] 頁面瀏覽模式中，按一下功能表的動詞命令 （標題列中的箭號顯示） 的變更**我的行事曆**控制項，然後選取**關閉**，關閉它，並將它新增至頁面目錄中。  
  
-   將頁面傳回至目錄模式，並新增**我的行事曆**回到頁面的控制項。  
  
-   使用**顯示模式**控制項加入頁面切換到設計模式，並拖曳至另一個區域，或在相同區域中的不同位置的其中一個或多個重新排列控制項的配置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">.NET web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>傳回之前已儲存且需要載入到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>方法，可讓 Web 組件控制項設為 直接存取受保護<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 呼叫這個方法時，它會儲存自訂個人化的資料受<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，以及先前儲存在永久資料存放區，以便稍後用於初始化程序。  
  
> [!NOTE]
>  在大部分情況下，頁面和控制項的開發人員程式碼不會不需要呼叫這個方法，因為它主要是由 Web 組件控制項擷取個人化資料的機制設定。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>讓開發人員會使用這個方法的其中一個案例是如果他們正在開發的自訂個人化架構，來取代其中一個所提供 Web 組件控制項集合。 在此情況下，開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法傳回的自訂實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件。 自訂<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件會呼叫實作<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />在適當的時間來載入自訂個人化資料的方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含所要儲存的狀態資料。</param>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理的自訂個人化狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法會實作<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>方法，可讓 Web 組件控制項設為 直接存取受保護<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 呼叫這個方法時，它會將儲存受管理的所有個人化的資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>永久資料存放區為 Web 組件應用程式設定的控制項。  
  
> [!NOTE]
>  在大部分情況下，頁面和控制項的開發人員程式碼不會不需要呼叫這個方法，因為它主要是由設定做為個人化的資料儲存機制的 Web 組件控制項。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員會使用這個方法的其中一個案例是如果他們正在開發的自訂個人化架構，來取代其中一個所提供 Web 組件控制項集合。 在此情況下，開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法傳回的自訂實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件。 自訂<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件會呼叫實作<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />在適當的時間，以儲存自訂個人化資料的方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將個人化狀態資料套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項，並呼叫基底方法，以啟用控制項檢視狀態資料之變更的追蹤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢視狀態資料變更會儲存在<xref:System.Web.UI.StateBag>物件，並可透過控制項的<xref:System.Web.UI.Control.ViewState%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得允許子控制項為可見的值。</summary>
        <value>布林值，指出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項及其子控制項是否為可見 所有情況下都是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會覆寫基底<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>屬性傳回的值一律`true`如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性。 即使<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項本身不見<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性必須設為`true`使其所有子控制項預設為可見。  
  
 如果您嘗試設定的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性，它一律產生錯誤，因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已覆寫基底屬性的行為，並防止任何值指派給屬性。  
  
 此屬性不是可繫結在視覺化設計工具，但可在執行階段繫結。 如需詳細資訊，請參閱<xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">嘗試指派值給此屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項已加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域之後發生，以表示控制項已成功加入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件可用於指出動態控制項 （控制項加入以程式設計的方式，而不是在網頁標記中所宣告） 已成功加入至區域。 搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法，事件會提供一種方式，來更新使用者介面 (UI)，或否則通知使用者已成功加入控制項的開發人員。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法之後將控制項新增至區域的程序已經開始。 此事件會提供完成之前取消程序的機會。 如果加入的程序成功，此事件之後緊接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。  
  
 網頁程式開發人員可以藉由新增事件中提供自訂處理常式`OnWebPartAdding`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 從頁面移除時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件表示，控制項已成功關閉，可能是由使用者或以程式設計的方式。 若要關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是指從頁面移除，讓它不會呈現，並也將它放在特別保留物件呼叫的頁面類別目錄。 頁面目錄中，對應至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，並維護參考至已關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>針對每個頁面的控制項。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項內的頁面上宣告<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用者可以將頁面切換至 類別目錄的顯示模式，並將任何先前已關閉的控制項新增至頁面。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法，它同時引發事件，並提供它的處理常式。  
  
 網頁程式開發人員可以加入，將自訂事件處理常式`OnWebPartClosed`屬性設定為`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從頁面移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>引發事件時<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法時<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項正在關閉控制項。 如果成功移除的控制項，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。  
  
 網頁程式開發人員可以提供自訂事件處理常式加`OnWebPartClosed`屬性設定為 <`asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法名稱。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>就會引發事件的直接結果的一個使用者結束<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，可以取消事件。 不過，還有不能取消事件中的案例。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>刪除控制項時，<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，非使用者。 及何時<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項正在呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法來關閉每個控制項，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>就會引發事件，事件無法取消 （依設計），因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>必須完成的清除工作所有區域的控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中已刪除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他伺服器控制項之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件可用於指出從某個區域已成功刪除動態控制項 （控制項加入以程式設計的方式，而不是在網頁標記中所宣告）。 搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法，事件會提供一種方式，來更新使用者介面 (UI)，或否則通知使用者已成功刪除控制項的開發人員。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項的執行個體從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域永久刪除的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法，刪除動態控制項 （一個以程式設計方式或由使用者透過 Web 組件的使用者介面已加入） 的過程。 事件會提供完成之前取消程序的機會。 如果順利完成刪除程序，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。  
  
 網頁程式開發人員可以藉由新增事件中提供自訂處理常式`OnWebPartDeleting`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項已移至網頁上的不同位置之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 （在 Web 網頁標記中宣告） 的靜態和動態控制項適用於此事件。 其相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法。 移動完成之後，就會引發事件，因為開發人員可以包含提供給使用者，某些驗證或某些其他動作的相關通知的事件處理常式。 若要新增事件處理常式，您可以加入`OnWebPartMoved`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法的名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移動 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域所包含之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他伺服器控制項的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>就會引發事件時<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項正在移動在其自己的區域，或另一個區域。 這可能會發生在使用者拖曳控制項，和以程式設計方式移動時。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法，且其提供完成之前取消移動程序的機會。 如果已完成的移動，且控制項放置在新位置，此事件後面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。  
  
 網頁程式開發人員可以建立自訂事件處理常式加`OnWebPartMoving`屬性設定為`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項所追蹤之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制集的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項以追蹤所有<xref:System.Web.UI.WebControls.WebParts.WebPart>內所包含的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>頁面上的區域。 集合是唯讀的雖然您可以存取個別<xref:System.Web.UI.WebControls.WebParts.WebPart>透過集合並進行變更，以程式設計方式控制。  
  
> [!NOTE]
>  可有<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項置於頁面上的外部<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域，會導致控制項沒有追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartManager>所參考或控制其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>集合。 不過，實在沒什麼理由使用<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項以外的區域，因為接著會失去其 Web 組件的功能，並做為一般的伺服器控制項。  
  
 任何類型的控制項可以放在區域中，自訂是否<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 標準的 ASP.NET 控制項、 使用者控制項或自訂伺服器控制項，可以視為<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項在執行階段。 控制項時，不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項放入<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域，在 ASP.NET 包裝控制項與執行階段<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件，使控制項可以如同真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 因此，藉由使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項可以追蹤的伺服器控制項，不論是否衍生自任何型別<xref:System.Web.UI.WebControls.WebParts.WebPart>類別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性以程式設計方式來存取個別<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 請注意，在網頁中，宣告式標記內`<asp:webpartzone>`有項目就是兩個標準的 ASP.NET 伺服器控制項。 雖然這些不是繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別，因為它們位於的區域，它們會以包裝<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件在執行階段，並因此將會包含在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。 您也可以加入自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 使用者控制項或自訂伺服器控制項在此區域中，並且會處理這些相同的方式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 請注意，程式碼範例正常運作，您必須新增設定以啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 請確定您有與網頁相同的目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請務必`<webParts>`項目`enableExport`屬性設為`true`，如下列標記。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 載入網頁瀏覽器中，如果您按一下後**WebPart 計數** 按鈕，程式碼會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性來傳回集合中的控制項數目。 如果您按一下**隱藏月曆標題** 按鈕，程式碼變更行事曆，使它只加上框線和標題不會呈現。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 之間建立特定連接之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法。 此事件很有用，因為您知道連線已完成之後，您可能想要通知之使用者的事實，或甚至變更頁面的使用者介面 (UI)。 例如，您可能想要顯示某些圖形的影像，以表示成功的連線兩個控制項，或顯示簡短訊息，並且變更網頁顯示模式返回瀏覽模式。  
  
 網頁程式開發人員可以藉由新增與這個事件中關聯的自訂事件處理常式`OnWebPartsConnected`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或位於 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 之間的連接程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法，並傳送信號已開始連線程序 （例如，使用者已選取的控制項並按一下連接動詞命令），但尚未完成。 這個事件會提供機會，以完成之前取消連接。 如果已成功完成連線，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。  
  
 網頁程式開發人員可以加入，將自訂事件處理常式`OnWebPartsConnecting`屬性設定為`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項之間的連接已結束之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法。 此事件很有用，因為您知道連接終止之後，您可能想要通知使用者、 執行某些清除動作，在程式碼，或在使用者介面 (UI) 中進行其他變更。  
  
 網頁程式開發人員可以藉由新增與這個事件中關聯的自訂事件處理常式`OnWebPartsDisConnected`屬性設定為`<asp:webpartmanager>`中項目 頁面上，以及指派給屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在結束先前連接之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的連接程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引發事件時<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法，且其發出信號因為使用者已按下中斷連線用的動詞命令，或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>否則呼叫方法。 這個事件會提供機會，以取消完成前結束連接的程序。 如果連線已成功地結束，這個事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。  
  
 網頁程式開發人員可以加入，將自訂事件處理常式`OnWebPartsDisconnecting`屬性設定為`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>直接結束連接的使用者動作的結果就會引發事件，可以取消事件。 不過，有幾個案例中無法取消事件。 第一個案例是，如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>刪除控制項時，<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 沒有使用者，和它也必須能夠終止的任何連接的控制項，而不需要任何可能發生的中斷連線，讓它能完成的清除和關閉程序所有控制項。 因此，根據設計<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法無法取消在此案例中。 相關事件可取消，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 第二個的案例，其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件無法取消時<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>呼叫方法時 （此頁面上，每個要求期間，例如呼叫），而且沒有某種類型的頁面上的現有連線中的衝突。 比方說，可能是使用者連線到控制項 y 的控制項 x，但共用的使用者連接控制項來控制 z，x 和 x 控制項尚不允許建立多個連接。 在此情況下，連接的個別使用者的設定值優先，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項解決衝突，藉由呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，並結束之間的連線 x 和 z 特定的使用者。 此中斷連線基本的設計中解決衝突，所以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件無法取消在此案例中。  
  
 第三個的案例，其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法無法取消時<xref:System.Web.UI.WebControls.WebParts.WebPart>或目前連接的伺服器控制項刪除或關閉。 因為控制項一定要從網頁中移除，就邏輯上也来移除其連線。 因此，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項叫用以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，進而引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，有的設計不是可能取消事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域之集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" />，參考 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項以追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>網頁上的區域。 請注意屬性並未參考所有類型的區域。它會參考衍生自的區域<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>類別，包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
 雖然屬性所參考的集合是唯讀的則您可以使用它來存取集合中的個別物件，並以程式設計方式處理這些。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性以程式設計方式來存取個別<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域控制項。 請注意，在宣告式 Web 網頁標記中，有兩個`<asp:webpartzone>`項目，每個都包含伺服器控制項。 在  `<script>`  頁面上，程式碼會使用區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性來存取個別的區域，列出所有區域識別碼，然後變更 第二個區域的背景色彩。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 請注意，程式碼範例正常運作，您必須新增設定以啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 請確定您有與網頁相同的目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請務必`<webParts>`項目`enableExport`屬性設為`true`，如下列標記。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 載入網頁瀏覽器中，如果您按一下後 **清單區域 Id**  按鈕，程式碼會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性，以列出集合中的所有區域的識別碼。 如果您按一下**變更區域背景色彩** 按鈕，程式碼變更第二個區域的背景色彩。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>