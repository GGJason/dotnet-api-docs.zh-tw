<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601302" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>作為 Web 組件控制項集合的中心類別，管理在網頁上發生的所有 Web 組件控制項、功能和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項做為中樞或控制項的中央 Web 組件的應用程式。 必須有一個-且-<xref:System.Web.UI.WebControls.WebParts.WebPartManager>使用 Web 組件控制項的每一頁上的控制項執行個體。 如同 Web 組件的應用程式層面，大部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項只適用於已驗證的使用者。 此外，它的功能適用於幾乎已完全位於繼承自的 Web 組件區域內的伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebZone>類別。 這些區域之外的頁面上的伺服器控制項可以有很少的 Web 組件功能或互動<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 在頁面上，Web 組件功能集線器<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項執行下表中所述的工作種類。  
  
|工作分類|控制項的功能|  
|-------------------|---------------------------|  
|追蹤 Web 組件控制項|會追蹤的許多不同種類的頁面上的控制項提供 Web 組件功能，包括<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 連線、 區域和其他項目。|  
|加入和移除 Web 組件控制項|提供方法來加入、 刪除和關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>頁面上的控制項。|  
|管理連接|建立控制項之間的連接，並且會監視連線，以及新增和移除它們的處理程序。|  
|個人化的控制項和網頁|可讓使用者在頁面上，將控制項移至不同的位置，並啟動外觀、 屬性和控制項的行為的使用者可以編輯的檢視。 會維護每個頁面上的特定使用者個人化設定。|  
|不同的網頁檢視之間切換|之間切換不同的特殊檢視的頁面上，以便使用者可以執行特定工作，例如變更頁面配置或編輯控制項。|  
|引發 Web 組件生命週期事件|定義引發並可讓開發人員處理的 Web 組件的控制項，例如當控制項所加入、 移動、 已連線，或已刪除的生命週期事件。|  
|啟用匯入和匯出的控制項|匯出包含的屬性狀態的 XML 資料流<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並可讓使用者匯入為了方便起見，個人化在其他網頁或網站中的複雜控制項中的檔案。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別具有大量的屬性。 與一致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>追蹤其他控制項的角色，它有一些參考 Web 組件控制項或其他特殊的 Web 組件物件的集合的屬性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性都是所使用的所有集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager>其追蹤和其他控制項管理工作。  
  
 屬性的另一個群組包含可自訂 Web 組件的應用程式中發生的特定案例中套用的警告。 這些包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會覆寫其基底的繼承屬性，許多 Web 伺服器控制項所使用的部分。 這些包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性。  
  
 最後，還有一組屬性可用來存取應用程式的目前狀態。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性會指出目前的顯示模式中的頁面。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>屬性會指出控制項是否可呈現用戶端指令碼，也就是相關的情況下，可能會有不同的功能的瀏覽器，或使用者指令碼已關閉。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性可用於參考包含數個重要的 Web 組件方法所使用的擴充性的情況下呼叫公用程式類別。 隱藏呼叫這些方法在個別的類別 (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>類別)，則<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別本身的應用程式開發介面簡化了。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性提供個人化物件會儲存使用者的個人化設定，並將保存到永久儲存區資料的存取權。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性可指出哪些<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項在頁面上的目前選取的使用者或應用程式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性會指出是否在自訂的個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項已變更。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項包含五個內建的顯示模式或網頁的檢視。 開發人員可以擴充此功能，例如延伸型別建立自訂的顯示模式<xref:System.Web.UI.WebControls.WebParts.WebZone>類別或<xref:System.Web.UI.WebControls.WebParts.ToolZone>類別。 使用者可以將頁面切換至不同的顯示模式，，前提是適當對應至指定的顯示模式的控制項類型會出現在頁面上。  
  
> [!NOTE]
>  所以，讓使用者可以切換成自訂的顯示模式，而不需要對應的區域在頁面上，以擴充此功能。 不過，預設行為是顯示模式會對應到區域。  
  
 標準顯示模式都由公用欄位在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。 下表摘要說明欄位，以及它們參考的顯示模式。 目前的顯示模式的頁面上，如先前所述，固定會參考在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，並可在特定的頁面上，指定的區域出現在頁面上，類型的顯示模式集合包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
|欄位|顯示模式的詳細資料|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|一般使用者檢視的網頁。預設值和最常見的顯示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|檢視使用者可以重新排列或刪除控制項，以變更頁面配置。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|變成可見的。 編輯的使用者介面 (UI) 的檢視使用者可以編輯的外觀、 內容和一般瀏覽模式中會顯示控制項的行為。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|變成可見的; 在目錄 UI 的檢視使用者可以從類別目錄中可用的控制項，將控制項加入頁面。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|變成可見的; 連接 UI 的檢視使用者可以連接、 管理或中斷連接控制項之間的連接。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會包含在 Web 組件頁面和控制項的生命週期中不可或缺的事件數目。 這些事件提供精確以程式設計方式控制 Web 組件控制項的行為。 大部分的方法與直接相關<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或放在其他伺服器或使用者控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域，讓它們可以表現<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項)。 不過，一些事件相關之頁面或頁面上的連接的狀態。 下表列出可用的事件，並摘要說明其用途。  
  
> [!NOTE]
>  在下表中的所有情況下，「 控制項 」 這個字是指<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項或任何伺服器控制項位於區域，且會包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在執行階段物件。  
  
|Event - 事件|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|控制項會加入至頁面，以便確認它已獲授權之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在頁面上的所有連線都已都啟動後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|啟用頁面上的所有連接處理程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|目前顯示模式的頁面已變更之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|變更頁面的顯示模式的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|已取消選取的控制項之後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|取消選取的控制項的處理程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|發生於控制項已新增至區域之後。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|將控制項加入至區域的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|發生於控制項已關閉 （從頁面移除） 之後。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|關閉控制項的處理程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|動態控制項 （一個以程式設計方式建立或新增從類別目錄） 的執行個體已永久刪除之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|刪除動態控制項的處理程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|發生於控制項移動其區域內，或另一個區域之後。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|移動控制項的處理程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|選取以參與連線的兩個控制項已建立連接之後，就會發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|連接兩個控制項的程序之前發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|連線已經中斷連接的兩個控制項之後發生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|中斷連接兩個控制項的程序之前發生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項有許多方法來管理 Web 組件頁面。 大型的一組方法，未列在此處，為的方法名稱的形式在*EventName*。 這些方法通常引發其相關聯的事件，並提供事件類型的處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>。 大部分的這些方法會覆寫的開發人員繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。 此外，網頁開發人員可以使用這些方法相關聯的事件提供自訂的處理常式。 例如，如果是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>網頁開發人員可以加入事件，`OnWebPartAdded`屬性`<asp:webpartmanager>`的標記網頁上，然後將指派的自訂方法的屬性名稱以提供自訂事件處理中的項目。 屬性對應於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法和事件處理最多的 Web 組件事件和其相關聯的方法可處理的這個基本模式。  
  
 此外，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項有特定的管理工作的方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (做為伺服器或使用者控制項和<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項)。 這些方法包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 另一組方法，被專門用於連接。 這包含方法，例如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>。  
  
 最後，某些<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法焦點放在個人化功能。 這些包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 如需其他詳細資訊<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法，可以透過存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性，請參閱文件<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>類別。  
  
   
  
## Examples  
 下列程式碼範例示範宣告式和以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 使用者控制項有下拉式清單控制項在頁面上，指定 Web 組件控制項出現在頁面上顯示可能的顯示模式。 在網頁上，此程式碼範例，這個使用者控制項宣告的正下方<xref:System.Web.UI.WebControls.WebParts.WebPartManager>網頁的標記中的項目，而且沒有`Register`指示詞來登錄此控制項的網頁頂端附近。 如需詳細資料會顯示此控制項中模式和原始碼的說明，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 網頁上的宣告式標記包含`Register`使用者控制項，並自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目來包含自訂控制項和`<asp:connectionszone>`項目。 這個頁面也包含一些內嵌程式碼，處理連接相關的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項等控制項，當您連接及中斷連接控制項，您可以看到此程式碼的效果。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 請注意，沒有名為介面`IZipCode`，並會實作這個介面中`ZipCodeWebPart`類別。 這個類別具有特殊的回呼方法，名為`ProvideIZipCode`做為提供者。 其他類型，名為`WeatherWebPart`，同時也會實作具有名為的特殊方法`GetIZipCode`，這可讓控制項做為其他控制項的取用者。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個程式碼範例會假設您有編譯成組件，來源和`Register`網頁中的指示詞參考的組件名稱。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接 UI 出現之後，請按一下**建立消費者連接**連結。 資料格會顯示具有下拉式清單控制項。 選取**天氣控制項**在下拉式清單中，然後按一下**連接**完成兩個控制項的連接。 按一下**關閉**，然後使用**顯示模式**下拉式清單，以返回一般瀏覽模式中的頁面。 您可以輸入的郵遞區號，和消費者控制項將使用您輸入的值來更新。 因為`ZipCode`屬性被標記為`Personalizable`在原始程式碼中，這個屬性值的屬性會保存跨瀏覽器工作階段，因此節省使用者輸入的值。 更趨精密完美的消費者控制項無法採取郵遞區號資訊、 查詢天氣資訊為基礎的程式碼，並顯示給使用者。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項用來擴充。 因為它是中央對 Web 組件的應用程式，當您想要擴充某些特定類型或控制 Web 組件控制項集合中，在許多情況下您必須也延伸讓<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，因為它是可能有部分的屬性或方法，才能讓 您的自訂類型在 Web 組件的應用程式的內容。 Web 組件參考文件 (請參閱<see cref="N:System.Web.UI.WebControls.WebParts" />)，討論如何擴充 Web 組件輸入時，經常必須完成，以擴充的項目提到<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，或將示範如何擴充程式碼範例中。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>建構函式會初始化所使用的數個重要變數<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 一項指派會直接影響所有的 Web 組件頁面是預設頁面的顯示模式設定為瀏覽模式的事實 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使網頁上目前非現用的所有連接成為現用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>頁面每個要求，以啟動之間的現有連接上呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>和位於其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域。 在某些情況下，如果沒有衝突的連接中啟動，此方法接著執行個體呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>以結束連接有問題的方法。 在中斷連線程序期間<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>就會引發事件。 通常開發人員可以取消此事件，在案例中，但這是衝突的連接，即無法取消，因為其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項需要解決衝突，才能完成啟用連線處理程序。 如需詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要加入至網頁或在頁面上開啟的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (或伺服器或使用者控制項)。</param>
        <param name="zone">
          <c>webPart</c> 正在加入至的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">整數，表示 <c>webPart</c> 在 <c>zone</c> 佔用的序號位置，相對於 <c>zone</c> 中的其他控制項。</param>
        <summary>為加入 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項至網頁，提供標準的程式設計方法。</summary>
        <returns>已加入至頁面的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法使用同時加入新的動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制頁面上，並重新開啟先前已關閉頁面的靜態或動態控制項。 若要加入新控制項呼叫方法時，確實建立一份中參考的控制項`webPart`參數。 複本的控制項，產生新的識別碼，所以開發人員應該參考<xref:System.Web.UI.WebControls.WebParts.WebPart>從要取得新的識別碼值的方法傳回的控制項。 當方法呼叫來重新開啟先前已關閉的控制項時，它會傳回所參考之控制項的直接參考`webPart`參數。  
  
> [!IMPORTANT]
>  您應該一律使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，而非<xref:System.Web.UI.ControlCollection.Add%2A>方法所參考的控制項集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType>屬性，將<xref:System.Web.UI.WebControls.WebParts.WebPart>到頁面上，以程式設計方式控制，因為使用<xref:System.Web.UI.ControlCollection.Add%2A>方法會擲回例外狀況。 若要加入的控制項不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (換句話說，將會包裝與伺服器控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段)，您應該先呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法來建立控制項，並接著呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，將控制項。 如需示範這種方法，請參閱 < 範例 > 一節。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法來以程式設計方式將伺服器控制項加入頁面。 網頁標記包含空白`<asp:webpartzone>`項目，和`<asp:webpartmanager>`項目。 第一次**新增行事曆**按一下按鈕時，程式碼在事件處理常式會建立<xref:System.Web.UI.WebControls.Calendar>控制，並將它加入做為區域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件、 呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="zone" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> 並未在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的區域集合中註冊。  
  
 \-或-  
  
 <paramref name="webPart" /> 已經在 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定的值小於零。<paramref name="zoneIndex" /></exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當呼叫 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法，以判斷 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項是否可以加入至頁面時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件會發生<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項新增至頁面。 有一些常見的案例，其中加入一個控制項的頁面。 如需這些的完整說明，請參閱 < 備註 > 一節<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。 當控制項加入時，必須檢查以查看是否其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性已設定且，若是如此，是否在控制項已獲授權加入至頁面。  
  
 開發人員可以建立事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，來提供篩選控制項。 如果控制項的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值不符合事件處理常式程式碼中的條件，控制項不會加入至頁面。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定的自訂事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，會自動覆寫預設<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。  
  
 中的程式碼`mgr1_AuthorizeWebPart`方法會檢查是否有其各自的頁面上的控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`user`而且，如果是的話，會傳回`true`，這表示，會獲得授權，會加入至頁面。 這是假設預設的方法可讓使用者在使用者個人化範圍中檢視網頁的控制項。 請注意，不過，在控制項的其中一個範例中有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`admin`。 開發人員可能會將此篩選條件置於特殊的控制項，其設計成系統管理使用者只能查看。 此控制項將會失敗期間的授權檢查<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，並不會顯示。 請注意沒有設定屬性的控制項; 也會顯示會假設它們不是篩選案例的一部分，因為其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>未設定的屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件的集合，這些物件可用於建立伺服器控制項之間的 Web 組件連接。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" />，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法來建立集合。 根據預設，它會從應用程式組態檔讀取可用的轉換程式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在建立連接的控制項。</param>
        <summary>啟動連接兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法存在的形成控制項之間的連線程序可以在不同的階段，讓開發人員更充分掌控連線程序能夠完成的。 此方法會執行一組初始的檢查，確保`webPart`處於其中一個連線可以合法形成的狀態。 如果`webPart`通過所有檢查時，它會接著設為目前選取的控制項 (請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性)，而且連接的程序可以繼續。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">頁面上目前的顯示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已關閉。  
  
 \-或-  
  
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的一部分。  
  
 -或-  
  
 <paramref name="webPart" /> 等於 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控制項。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 其中一個方法是將呼叫基底的方法，然後再加入一些其他的自訂處理;或者，您可能想要完全自訂啟動控制項之間的連接的程序。 例如，您可以確認特定的資料可建立連接之前。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要編輯的控制項。</param>
        <summary>啟動編輯 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法存在，因此編輯控制項的程序可以透過不同的階段，讓開發人員更充分掌控程序。 此方法會執行一組初始的檢查，確保`webPart`處於的狀態，進行編輯。 如果`webPart`通過所有檢查時，它會接著設為目前選取的控制項 (請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性)，可以繼續編輯程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">頁面上目前的顯示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已關閉。  
  
 \-或-  
  
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的一部分。  
  
 -或-  
  
 <paramref name="webPart" /> 等於 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控制項。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 組件控制項之頁面的預設顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>欄位參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態的物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要的控制項執行個體。  
  
 當包含 Web 組件的頁面控制項第一次載入時，它就會處於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 當使用者只需如同在一般的網頁瀏覽時，頁面會保留在瀏覽模式中。 如果使用者想要個人化的頁面配置、 控制項、 外觀或行為，它們必須將網頁切換成一種特殊的顯示模式可透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>欄位以程式設計的方式。 支援的顯示模式，在此情況下為 瀏覽和設計下拉式清單中填入的程式碼。 請注意，在`Page_PreRender`方法時，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>。 如果是這樣，`Label1`將會顯示，如果沒有的話，`Label1`將隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意，指出您是瀏覽模式在頁面上的標籤。 使用下拉式清單控制項，將頁面切換到設計模式。 請注意，因為中的程式碼`Page_PreRender`方法時，標籤現在會隱藏起來。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，以判斷這些控制項是否可以連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法用來判斷兩個<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可以連接。 方法通常做為條件式檢查之前呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法會檢查幾個連接可用以構成兩個控制項必須符合的條件。 下列清單摘要說明主要的準則進行連接。 如果都符合所有準則 （加上其他內部條件），則方法會傳回`true`，表示控制項可以連接：  
  
-   提供者和消費者控制項不能`null`，而且它們必須包含所參考的控制項集合中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
-   提供者和消費者不能相同的控制項。 換句話說<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項無法連線到本身。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>物件 （連接點為單位） 提供者和消費者不能是`null`。  
  
-   無法關閉的提供者和取用者 (沒有控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>屬性可以是`true`)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>連接點控制項的屬性必須符合的消費者和提供者的控制項類型。  
  
-   連接點皆必須啟用 (其<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>方法必須兩者都傳回`true`)。  
  
-   每一個連接點必須不嘗試以形成所指定者在它自己的更多連線<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>屬性。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>需要連接不相容的控制項物件 (transformer) 時，它無法`null`。 不過，如果控制項已經相容，必須是轉換程式`null`。  
  
-   轉換程式 （如果使用的話） 必須在中參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>集合。  
  
-   轉換程式 （如果使用的話） 必須有與相容的提供者和消費者，讓它可以將兩個控制項之間的資料轉換的介面。 第二個介面的消費者和提供者也必須相容。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">當兩個控制項連線時，提供資料給 <c>consumer</c> 的控制項。</param>
        <param name="providerConnectionPoint">讓 <c>provider</c> 參與連線的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">當兩個控制項連線時，從 <c>provider</c> 接收資料的控制項。</param>
        <param name="consumerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>consumer</c> 可以參與連線。</param>
        <summary>當提供者和消費者控制項有相容的介面，並且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件時，檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控制項是否可以連接。</summary>
        <returns>布林值，指出 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來連接`provider`和`consumer`時這兩個控制項具有相容的連接點類型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>不需要物件。 您可能想要使用這個方法來確認您可以在呼叫之前已連接兩個控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>建立的程式設計連線。  
  
 這個多載會使用相同的實作，做為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法多載，唯一的例外狀況，是這個多載不需要轉換程式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項`<asp:webpartmanager>`項目，並建立連線，使用某些事件處理程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 網頁上的宣告式標記包含`Register`使用者控制項，並自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目來包含自訂控制項和`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法時，程式碼會檢查是否連接才能進行而且，若是如此，定義提供者、 取用者，以及其各自的連接點，然後再將新的連接加入至靜態所參考的連接集合的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 它包含介面和兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，做為提供者和消費者另一個。 因為它們具有相容的連接點 (這兩種辨識`IZipCode`介面)，轉換程式不需要進行連接。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接使用者介面 (UI) 出現之後，請注意連接確認已建立的程式碼中包含`Page_Load`方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">當兩個控制項連線時，提供資料給 <c>consumer</c> 的控制項。</param>
        <param name="providerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>provider</c> 可以參與連線。</param>
        <param name="consumer">當兩個控制項連線時，從 <c>provider</c> 接收資料的控制項。</param>
        <param name="consumerConnectionPoint">做為回呼方法的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，讓 <c>consumer</c> 可以參與連線。</param>
        <param name="transformer">讓不相容的 <c>provider</c> 和 <c>consumer</c> 連線的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>檢查將參與連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，以判斷它們是否可以連接，並且使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 物件，來建立不相容消費者和提供者之間的連接。</summary>
        <returns>布林值，指出 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以建立連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來連接`provider`和`consumer`當兩個控制項有不相容的連接點類型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>需要物件時。 您可能想要使用這個方法來確認您可以在呼叫之前已連接兩個控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>建立的程式設計連線。  
  
 這個多載會使用相同的實作，做為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法多載，唯一的例外狀況，是這個多載都需要轉換程式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示從控制項目錄將伺服器控制項加入至網頁時所使用的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>欄位參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態的物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要的控制項執行個體。  
  
 當使用者想要將控制項加入頁面時，如果伺服器控制項的類別目錄功能時，它們可以將頁面切換至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>（目錄模式），並出現類別目錄的使用者介面 (UI)。 Web 組件類別目錄的 UI 由提供<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>區域控制項。 開發人員加入網頁中的這個區域，在設計階段，並再將伺服器控制項新增至區域，以便使用者可以在執行階段將這些控制項加入其頁面。 開發人員加入這些控制項之後，目錄模式會變成在頁面上支援的顯示模式，因為必要的控制項有啟用目錄的模式。  
  
 當使用者切換目錄模式、 區域和所有就會變得可見，加入伺服器控制項的頁面，而且使用者可以從類別目錄 頁面上，以新增或移除控制項的頁面中選取控制項。 控制項加入至頁面之後，會顯示一般瀏覽模式中，而在更新頁面。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單中的頁面上，在此情況下會瀏覽、 設計和類別目錄支援的顯示模式。 因為目錄模式可`<asp:CatalogZone>`項目和其子項目在網頁中的。 請注意，在`Page_PreRender`方法時，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>。 如果是這樣，`Label1`將會顯示，如果沒有的話，`Label1`將隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意頁面上的標籤為隱藏。 使用下拉式清單控制項，將頁面切換至目錄模式。 請注意，因為中的程式碼`Page_PreRender`方法，會立即顯示標籤。 您可以選取類別目錄中的控制項，並將它加入至其中一個頁面上的兩個區域。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>檢查提出要求之瀏覽器的功能，以及 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 屬性的值，以判斷是否要呈現用戶端指令碼。</summary>
        <returns>布林值，指出是否要呈現用戶端指令碼。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定警告，當使用者關閉連接中做為其他控制項之提供者的控制項時顯示此警告。</summary>
        <value>包含警告訊息的字串。 預設值為 .NET Framework 所提供的文化特性訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，通常會顯示任何訊息。 如需關閉控制項的意義的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法。  
  
 不過，當控制項已連線到另一個控制項，並做為資料到其他控制項的提供者，預設的警告訊息會顯示，當使用者嘗試關閉控制項。 訊息會告知使用者，提供者控制即將關閉，這表示可控制連接到此提供者取用者將不再有任何要取用的資料。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性可讓開發人員自訂顯示給使用者的警告訊息。  
  
 當使用者關閉時，如果網頁開發人員會指派給這個屬性空白或 null 字串值，會顯示任何警告訊息方塊<xref:System.Web.UI.WebControls.WebParts.WebPart>是提供者的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性對使用者顯示自訂的警告。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只網頁的部分範例。 您也需要自訂使用者控制項，上面所述的自訂控制項的原始程式碼。 從範例 > 一節的取得這兩項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 下列的網頁程式碼示範如何指派自訂警告訊息，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>屬性中的宣告式標記中`<asp:webpartmanager>`項目。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接使用者介面 (UI) 出現之後，請按一下**建立消費者連接**連結。 資料格會顯示具有下拉式清單控制項。 選取**天氣控制項**在下拉式清單中，按一下**連接**完成兩個控制項的連接。 按一下**關閉**，然後使用**顯示模式**下拉式清單，以返回一般瀏覽模式中的頁面。 最後，按一下 的動詞命令功能表**郵遞區號**控制 （此為提供者控制項在此情況下），然後選取**關閉**。 自訂訊息指派給您<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>顯示屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中正在關閉的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或伺服器控制項。</param>
        <summary>關閉 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，使其不會在網頁上呈現，但可重新開啟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法移除<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項，讓它不會呈現在網頁上原本包含它。 已關閉的控制項加入至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>物件，它會維護已關閉的控制項的參考，而且可讓要還原至頁面的控制項。 關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項仍然會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
 在關閉控制項是不同於刪除它。 已關閉的控制項屬性仍然可還原至 頁面上，但已刪除的控制項執行個體永久移除，絕對無法還原。 無論<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項 （在網頁標記中宣告） 的靜態或動態 （加入至頁面，以程式設計方式或由使用者從 Web 組件類別目錄），關閉並重新開啟頁面上。  
  
 一般而言，使用者就可以關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>按一下其動詞命令功能表並選取 關閉的動詞命令的控制項。 控制項也可以藉由直接呼叫關閉<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法，並將其傳遞的參考`webPart`。  
  
 在網頁上其中<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項已關閉，如果開發人員宣告`<asp:catalogzone>`項目，並在其中加入`<asp:pagecatalogpart>`項目，它會提供簡單的使用者介面 (UI) 頁面還原已關閉的控制項，在執行階段的使用者。 使用者可以將頁面切換成類別目錄的顯示模式，並已關閉的控制項將出現在頁面目錄內。 使用者可以選取 已關閉的控制項，並將它們加入至網頁上的任意位置想，和選取的控制項會還原至頁面，然後正常地呈現。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>呼叫方法時，便會產生多個事件： <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> （如果有多個控制項），和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>（如果沒有連接的控制項）。 通常開發人員可以取消這些事件，但在某些情況下就不可能取消這些服務。 如需詳細資訊，請參閱文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更頁面的顯示模式。  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   Web 網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 程式碼範例的第二個部分是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個範例會使用動態編譯的方法;因此沒有任何`Assembly`屬性`Register`對這個控制項頂端的網頁指示詞。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 程式碼範例的第三個部分是 Web 網頁。 此頁面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用 <`asp:pagecatalogpart>`宣告內的項目。 這是將包含的內容的封閉型<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，並且讓使用者能夠將它加入至網頁。 `Button1_Click`方法會直接呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法，關閉自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，不過使用者也可以關閉透過動詞命令功能表控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，請關閉自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>按一下控制項，標頭中的動詞命令功能表 （的箭頭符號），然後按一下控制項**關閉**。 現在將頁面變更為目錄模式選取**目錄**中**顯示模式**下拉式清單控制項。 頁面類別目錄會顯示關閉的控制項。 選取 已關閉的控制項旁的核取方塊，按一下**新增**以將它加入至頁面上，然後按一下**關閉**返回頁面，即可瀏覽模式。 控制項被還原頁面。 現在將它關閉，這次請再次按一下**關閉的 WebPart**  按鈕。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
 \-或-  
  
 <paramref name="webPart" /> 是共用控制項，並且已經被另一個使用者關閉。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用來顯示特別使用者介面 (UI) 的顯示模式，供使用者管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間的連接。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>欄位參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態的物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要的控制項執行個體。  
  
 當使用者想要管理之間的連接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制在網頁上，如果<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>已宣告區域在頁面上，它們可以將頁面切換成<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。 連接的顯示模式顯示特殊的 UI 來管理連接，其中包含連接或中斷控制項，並編輯現有連線的詳細資料的能力。  
  
 如果您想要提供使用者管理連接與 Web 組件控制項集合所提供的 UI 功能，您必須宣告`<asp:connectionszone>`在網頁標記中的項目。 不同於其他類型的項目<xref:System.Web.UI.WebControls.WebParts.WebZone>區域，您不需要將這個項目內的任何其他標記新增; 只要宣告項目本身。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
 程式碼範例包含三個部分：  
  
-   原始程式檔，其中包含介面和自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，可用以構成的連接。  
  
-   Web 網頁會提供 UI 的連接，並示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
-   如何執行此範例的說明。  
  
 程式碼範例的第一個部分是原始程式檔，其中包含介面和兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項的設計是讓它們可以連線。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個程式碼範例會使用動態編譯的方法。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 此範例的第二個部分是裝載自訂控制項的網頁。 在伺服器內`<script>`頁面上的標籤是數種方法，以填入頁面上可用的顯示模式下拉式清單。 使用者可以選取從下拉式清單，若要變更頁面的顯示模式。 其中一個可用的顯示模式，所以連接顯示模式`<asp:connectionszone>`在網頁標記中宣告的項目。 請注意，這個項目不包含任何其他子元素它的存在只為了啟用使用者的連接管理 UI。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式 會出現在此範例中在兩個地方。 首先，在`Page_Init`方法，連接顯示模式會加入到下拉式清單的顯示模式做為程式碼中參考的集合執行迴圈<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 第二個，`Page_PreRender`方法會檢查目前的顯示模式，在頁面上，而且如果目前的模式是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>，訊息會顯示在<xref:System.Web.UI.WebControls.Label>控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，按一下下拉式清單，然後選取 **連接**，將頁面切換成連接顯示模式。 請注意，會出現一則訊息，告訴您的頁面是在連接的顯示模式。 現在按一下其中一個的標題列中的動詞命令功能表 （箭號）<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，然後再按一下**連接**動詞命令功能表中。 UI 會顯示連線後，按一下連結以建立連接。 使用下拉式清單，連線會出現的 UI 中，請選取其他控制項將參與連線，並按一下**連接** 按鈕。 建立連線。 按一下**關閉**按鈕，然後再使用下拉式清單在頁面頂端的返回頁面，即可瀏覽顯示模式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上所有目前連接之集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性可提供存取目前的頁面上連接的資料集的方法。 集合本身是唯讀的而且開發人員想要管理特定的連接，從集合應使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>這類方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範宣告式和以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只網頁的部分範例。 您也需要自訂使用者控制項，上面所述的自訂控制項的原始程式碼。 從範例 > 一節的取得這兩項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 下列網頁程式碼示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性以程式設計方式來取得網頁上的目前連接的計數。 請注意，在`<script>`標記區段中，處理兩個事件的程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>屬性以取得計數。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 顯示連接的使用者介面 (UI) 之後，請按一下**建立消費者連接**連結。 資料格會顯示具有下拉式清單控制項。 選取**天氣控制項**在下拉式清單中，按一下**連接**完成兩個控制項的連接。 按一下**關閉**，然後使用**顯示模式**下拉式清單，以返回一般瀏覽模式中的頁面。 請注意，標籤現在會顯示連線的數目以及數目<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 如果您現在會傳回連接模式及中斷連接兩個控制項，當您返回瀏覽模式中，應該更新標籤的內容，而且應該沒有任何連接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在頁面上所有目前的 Web 組件連接不僅已建立，而且每個連接中的消費者和提供者控制項也已經開始共用資料之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在連線的生命週期，在頁面完成載入程序之後，就會發生此事件。 它也會發生之後<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件，表示只有該<xref:System.Web.UI.WebControls.WebParts.WebPart>或特定的連接中的伺服器控制項已成功連接。 案例中有多個連線，在頁面上，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>方法表示所有在網頁上的有效 Web 組件連線現在是使用中，以及是否可以共用資料。 了解所有連接都使用中，開發人員可以執行任意數目的工作，包括通知使用者狀態的所有連線時，通知處理和顯示來自提供者中，資料等等的消費者控制項。  
  
 此事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法，這個方法會引發事件，而且可讓開發人員建立自訂事件處理常式。  
  
 網頁開發人員可以建立自訂事件處理常式加入`OnConnectionsActivated`屬性`<asp:webpartmanager>`項目頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在網頁上啟動所有已建立之 Web 組件連接的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在連線的生命週期，會發生此事件一頁之前完成載入程序，因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>方法呼叫。 不同於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，這牽涉到特定連線之間<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>當頁面上，所有可能的連線已連接，而且即將啟動時，就會發生事件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，這會引發事件。 控制項開發人員想要擴充的類型可以加入至頁面的連線無法覆寫受保護<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，並啟用其他類型的連線。  
  
 網頁開發人員可以建立自訂事件處理常式加入`OnConnectionsActivating`屬性`<asp:webpartmanager>`項目頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控制項 (或能建立連接的其他伺服器控制項) 之間的連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法形成連接之間的任何兩個<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項。 之前呼叫這個方法，以建立連接時，您可能也想要呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>中條件的核取，以確保控制項符合的需求建立連接的方法。  
  
> [!NOTE]
>  它也可建立的不是兩個伺服器控制項之間的連接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 一般情況下，兩個控制項必須是自訂的伺服器控制項 (例如，從繼承的控制項<xref:System.Web.UI.WebControls.WebControl>或現有的 ASP.NET 伺服器控制項)，讓您無法新增必要的成員。 控制項也必須符合下列指定需求。  
  
 兩個控制項之間的連接案例的任何型別必須符合下列需求，就能夠連接：  
  
-   每個控制項位於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>（它並沒有為相同的區域） 的區域。  
  
-   提供者中的控制項連接 Web 組件控制項集合中實作時，會實作介面，做為公用的方法做為回呼，以提供者，並具有`ConnectionProvider`方法，將其識別為提供者連接上的中繼資料屬性點。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>擷取提供者連接點是虛擬的方法中，衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項不一定有使用相同的中繼資料屬性。  
  
-   在 Web 組件控制項集合中實作時，取用者控制項在連接中的也有特殊的方法，讓它取得的介面，公開提供者的回呼方法中的參考，而且取用者有`ConnectionConsumer`上的中繼資料屬性方法，將其識別為消費者連接點。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>擷取消費者連接點是虛擬的方法中，衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項不一定有使用相同的中繼資料屬性。  
  
-   回呼方法必須是相容、 中 （亦即消費者和提供者可以共用資料，直接） 提供者的回呼方法或開發人員所提供的介面，取用者可以使用的型別必須使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件從提供者將資料轉換成取用者可以使用的表單。  
  
    > [!IMPORTANT]
    >  當您不需要轉換程式時，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法多載。 當您需要轉換程式時，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法多載。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，其角色為提供資料給另一個連接的控制項。</param>
        <param name="providerConnectionPoint">方法，做為連接的回呼方法。 當 Web 組件控制集實作時，這是 <c>provider</c> 中標記著 <see langword="ConnectionProvider" /> 中繼資料屬性的公用方法。</param>
        <param name="consumer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項，其角色為從 <c>provider</c> 接收資料，然後處理或顯示此資料。</param>
        <param name="consumerConnectionPoint">與 <c>providerConnectionPoint</c> 連線的方法，以接收連線資料。 當 Web 組件控制集實作時，這是 <c>consumer</c> 中標記著 <see langword="ConnectionConsumer" /> 中繼資料屬性的公用方法。</param>
        <summary>只使用控制項的參考及其指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件，建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> (或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />) 控制項之間的連接。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含連接所需之提供者和消費者的各種相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載用來連接控制項，其連接點完全相容，它們可以連接不使用時<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件。 呼叫這個方法的多載時，它只會傳遞至另一個多載版本的方法，呼叫，並傳遞`null`參數需要<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>物件。  
  
 當您嘗試以程式設計方式連接兩個控制項時，您可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>條件檢查，以判斷是否可以直接連線控制項中的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法來以程式設計方式建立的連接。 若要執行範例所需的完整程式碼，請參閱 < 範例 > 一節的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 從該範例中，您需要使用者控制項，可讓您變更顯示模式，在頁面上，原始程式碼與原始碼的兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 網頁上裝載兩個的程式碼控制如下所示。 頁面會使用`Register`頂端指示詞來宣告的使用者控制項和自訂控制項。 自訂控制項中以宣告方式被`<asp:webpartzone>`項目。 處理的程式碼`Button1_Click`方法會建立使用控制項之間的連接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，請按一下**連接 web 組件控制項**按鈕以建立連接。 您可以在文字方塊中，輸入一些資料，然後按一下**輸入 5 位數郵遞區號**示範控制項已連接，，和在第一個控制項中輸入該資料會更新第二個按鈕。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的動態連接集合是唯讀。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，其角色為提供資料給另一個連接的控制項。</param>
        <param name="providerConnectionPoint">
          <c>provider</c> 中的公用方法，這個方法標記著 <see langword="ConnectionProvider" /> 中繼資料屬性，並作為連線的回呼方法。</param>
        <param name="consumer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，其角色為從 <c>provider</c> 或 <c>transformer</c> 接收資料，然後處理或顯示此資料。</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c> 中的公用方法，這個方法標記著 <see langword="ConnectionConsumer" /> 中繼資料屬性，並與 <c>providerConnectionPoint</c> 連線以接收連線資料。</param>
        <param name="transformer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，藉著將來自 <c>provider</c> 的資料轉換成 <c>consumer</c> 可以處理的格式，允許兩個控制項之間的連線。</param>
        <summary>使用控制項的參考、其指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 物件和 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 物件，建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> (或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />) 控制項之間的連接。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含連接所需之提供者、消費者和轉換程式的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載用來連接其連接點不相容時的控制項。 不相容的問題發生時`consumer`實作不同的介面比`provider`做為其連接點。 轉換程式會將資料轉換成可以辨識的型別`consumer`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">連接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中啟動。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中所包含並且由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控制項管理之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、伺服器或使用者控制項的集合。</summary>
        <value>
          <see cref="T:System.Web.UI.ControlCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項管理的所有控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>屬性未參考所參考的其他控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，例如各種區域控制項，<xref:System.Web.UI.WebControls.WebParts.EditorPart>或<xref:System.Web.UI.WebControls.WebParts.CatalogPart>控制項和其他項目。  
  
 這個屬性使用 Web 組件控制項集合，並在大部分的開發情況下它並不適用於從您的程式碼呼叫。 基於這個理由，雖然屬性是公用的它是隱藏的 IntelliSense。 開發人員想要存取的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>或管理的其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項應該使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要複製的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</param>
        <summary>為了將控制項加入至網頁，由 Web 組件控制集用來建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的複本。</summary>
        <returns>要加入至頁面的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不能呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>直接從程式碼的方法。 這個方法在內部呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，加入新的動態的程序的一部分<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項的頁面。 動態控制項加入至頁面以程式設計方式或透過 Web 組件的使用者介面 (UI)，例如將控制項加入從控制項，而不是直接在網頁標記中宣告的靜態控制項的類別目錄的使用者。  
  
> [!NOTE]
>  可以在衍生類別中覆寫方法，如果開發人員想要啟用方法，以處理其他控制項複製案例。 如需詳細資訊，請參閱注意事項繼承者注意事項 > 一節。  
  
 新的動態控制項加入時，如果它是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法會傳回控制項的新執行個體。 如果要加入的控制項是其他類型的伺服器控制項 （例如使用者控制項、 自訂控制項或 ASP.NET 控制項），控制項將會有已包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>由 Web 組件控制項集合的物件。 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法在遇到<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項，它會傳回的新執行個體<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項包裝在它的子控制項的新執行個體。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法會建立傳回控制項的新副本，它也會重設所有屬性的值設為預設值。 請注意，是否您想保留可個人化屬性的值，並讓它們複製到新的控制項執行個體，您應該呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>以及方法。 所執行的最後一個步驟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法是呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>方法，以取得新的控制項識別碼。  
  
> [!NOTE]
>  方法會取得已複製控制項的新識別碼，因為您不應依賴參考原始 id 加入至頁面的動態控制項 相反地，您應該參考之方法所傳回的控制項的新執行個體。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>方法宣告為<see langword="virtual" />以便開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，覆寫方法，並提供其他的案例，它可以建立複本的控制項。 例如，方法可以選擇性接收做為輸入已序列化成 XML 檔案的控制項。 方法無法還原序列化的 XML （如果有的話），並接著呼叫基底的方法來處理現有的案例，並傳回的新執行個體<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控制項。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>依網站組態檔的指定建立一組轉換程式，並將它們加入至 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 屬性所參考的轉換程式集合。</summary>
        <returns>網站組態檔中指定的轉換程式集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>若要加入其他轉換可由應用程式，可以覆寫這個方法。 例如，從 Web 服務擷取一份可用的轉換程式無法寫入的方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理之所有控制項的集合。 這個類別無法被繼承。</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理之所有不同的 Web 組件控制項。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>這個方法會受到保護，而且密封的因為它是繼承的類別為可見<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，但它不能覆寫。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 Web 組件應用程式所有可能的顯示模式集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有支援的顯示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立所有可能的顯示模式，不只是支援特定的頁面上的顯示模式清單。 如需有關支援的顯示模式的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
 根據預設，Web 組件控制項集合會建立下列設定中使用 Web 組件頁面上的顯示模式：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 開發人員可以建立自訂的顯示模式，不論有無隨附的自訂衍生自的區域<xref:System.Web.UI.WebControls.WebParts.WebZone>或<xref:System.Web.UI.WebControls.WebParts.ToolZone>類別。 若要建立自訂的顯示模式，您必須繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別，並將您的顯示模式為支援的模式下，在頁面上，您必須繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別並覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法。  
  
 當您新增的顯示模式使用<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法，您應該以新增您想要顯示的任何使用者介面 (UI) 控制項的順序 (例如<xref:System.Web.UI.WebControls.ListBox>控制項)，提供給使用者的可能顯示模式在頁面上。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 程式碼範例包含五個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   裝載其他控制項的網頁。  
  
-   使用者控制項位於<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域在網頁上，並可讓您輸入並顯示在標籤中的文字。  
  
-   原始程式碼檔，其中包含兩個控制項。 其中一個是自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，以及其他會自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>来加入至頁面的預設顯示模式物件。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是網頁。 它包含兩個<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控制項，使用者控制項和自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 請注意`Register`在頁面頂端的指示詞參考的使用者控制項和編譯控制項的命名空間。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 此範例的第三個部分是輸入和顯示文字的使用者控制項。 它會使用<xref:System.Web.UI.WebControls.MultiView>控制項來建立多個 UI 的檢視。 一個檢視隨即出現，並`Button1`按鈕，另一個則沒有。 請注意，在覆寫`OnPreRender`方法，該程式碼會檢查是否頁面目前為自訂的顯示模式，如果是的話，會顯示使用者控制項，其中包含按鈕的第一個檢視。 如果頁面未處於自訂顯示模式，例如，如果頁面是在瀏覽或設計模式中，則會隱藏按鈕。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 此範例的第四個部分是兩個自訂類別的原始程式檔。 請注意，自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法，以及它會先呼叫基底方法，將所有的預設顯示模式，並將自訂的顯示模式。 自訂顯示模式類別`InLineEditDisplayMode`，只是繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>、 建構函式，在設定的顯示模式的名稱，並覆寫的數字的基底的屬性，以建立自訂的顯示特性。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要執行的程式碼範例，請載入瀏覽器中。 請注意頁面正在瀏覽模式中，而且沒有按鈕會顯示。 使用**顯示模式**下拉式清單控制項中，變更頁面以**內嵌編輯顯示**模式中，並注意現在`Button1`按鈕會顯示在較低的使用者控制項。 加入一些文字，然後按一下按鈕來更新控制。 請注意，頁面顯示會傳回到瀏覽模式中，現在會顯示您輸入的文字，因為頁面不再是自訂的顯示模式中，會再次隱藏按鈕。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得唯一值，做為動態連接的 ID。</summary>
        <returns>字串，包含連接的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法會產生 GUID 值，並將它轉換為字串做為連接的唯一識別碼。 每次建立動態的連接時，會呼叫方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫這個方法在衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別若要變更的實作來產生唯一的識別碼。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">正在產生 ID 之控制項的 <see cref="T:System.Type" />。</param>
        <summary>產生動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的唯一 ID。</summary>
        <returns>字串，包含控制項的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項會加入至網頁，則其可以是 （亦即在網頁標記中宣告控制項） 的靜態或動態 （亦即會以程式設計方式加入）。 在任何情況下其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項建立新的動態控制項，可將加入至頁面上，它會呼叫這個方法，以產生唯一識別碼。  
  
 此方法，讓開發人員可以覆寫它如果他們想要提供自訂實作產生識別碼是虛擬  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">字串，失敗控制項的 ID。 如果 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包含在失敗的作業中，則此 ID 為其子伺服器控制項的 ID。</param>
        <param name="originalTypeName">已失敗控制項之 <see cref="T:System.Type" /> 名稱的字串。 如果 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包含在失敗的作業中，則此型別名稱為其子伺服器控制項的型別名稱。</param>
        <param name="originalPath">包含至使用者控制項之路徑的字串，如果包含子使用者控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 在失敗的作業中時。</param>
        <param name="genericWebPartID">傳回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 之 ID 的字串，如果控制項型別包含在載入或建立控制項的失敗作業中時。</param>
        <param name="errorMessage">字串，包含要顯示在頁面上的錯誤訊息。</param>
        <summary>建立特殊控制項，當嘗試載入或建立動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項因特定理由失敗時，這個控制項會插入頁面並顯示給使用者。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />，插入頁面，以取代無法載入或建立的控制項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>呼叫方法時，Web 組件控制項載入或建立的動態執行個體的設定嘗試<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項及其原因而失敗。 此方法會建立<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>物件，錯誤訊息給它，然後將它傳回。 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>取代失敗，此控制項插入控制項，而且其錯誤訊息會顯示頁面上。  
  
 您不能呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>直接從程式碼的方法。 不過，您可以繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別和擴充方法。 如需詳細資訊，請參閱繼承者注意事項 > 一節的資訊。  
  
 使用者可以使用<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制在網頁中很像它們一般<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要移除的錯誤訊息，他們可以關閉控制項，即可關閉動詞命令，此時將控制項加入至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>物件，像任何其他已關閉的控制項。 如果使用者刪除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制項，無法載入伺服器控制項也會從頁面刪除。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您想要自訂的資訊中傳回<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控制項，可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />方法，呼叫基底方法將不同的值指派給基底的方法，傳遞的參數，然後傳回結果<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控制項。 比方說，如果您不想讓使用者看到<paramref name="originalPath" />值 （這會顯示在使用者控制項的虛擬目錄路徑），當您呼叫基底方法，您可以傳遞空字串 ("") 為該參數。  
  
 您也可以自訂的行為<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控制本身，繼承自它。 例如，您可能想要覆寫其<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />或<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />屬性。</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回個人化物件，以包含目前網頁使用者的個人化資料。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含使用者的個人化資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>方法會傳回包含和管理使用者的個人化設定目前的頁面物件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項管理此物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">非 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的伺服器控制項。</param>
        <summary>將非 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的伺服器控制項包裝在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 物件中，讓此控制項有 Web 組件功能。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，用來包裝 <paramref name="control" /> 並使其如同真正 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項作用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法是啟用的不是伺服器控制項的主要機制<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項與相同的功能上採取<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，因此完全參與 Web 組件的應用程式。 使用此方法，開發人員大幅展開他們可以使用 Web 組件的應用程式中的伺服器控制項的數目，因為幾乎所有類型的伺服器控制項-可以使用標準 ASP.NET 控制項、 使用者控制項，以及自訂控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會使用這個方法在兩個其他情況下將伺服器控制項提供<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件。 當使用者將伺服器控制項加入頁面使用<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制，如果匯入的控制項不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法呼叫。 此外，當伺服器控制項宣告中的持續性格式<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域在網頁上，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法針對不是任何控制項呼叫<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 當您將伺服器控制項加入區域以程式設計的方式時，是使用一般的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法，以使用控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件，然後再呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，以將控制項加入的所有集合<xref:System.Web.UI.WebControls.WebParts.WebPart>在頁面上，所參考的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。 在`Button2_Click method`、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>呼叫方法來包裝<xref:System.Web.UI.WebControls.Calendar>用來控制<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>才能將它新增到區域的物件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會覆寫使用衍生<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />類別改為使用 Web 組件提供基底類別的控制項集合。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定自訂警告訊息，當使用者刪除控制項時，向使用者顯示這則訊息。</summary>
        <value>包含警告訊息文字的字串。 預設值為當地語系化的警告訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者刪除<xref:System.Web.UI.WebControls.WebParts.WebPart>控制時，通常會顯示預設的警告訊息。 它會警告使用者，在刪除控制項的這個執行個體時，會永久刪除。 網頁開發人員可能會提供一種方式，將控制項的新執行個體加入至頁面的使用者 (例如的類別目錄<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，或透過一些程式設計的方式)，但是永久移除已刪除的控制項的目前執行個體。 如有需要，會顯示警告對話方塊中包含要取消刪除動作，使用者 按鈕。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性可讓開發人員若要設定顯示給使用者的警告訊息。  
  
 如果網頁開發人員會指派為空字串 ("") 會顯示於此屬性沒有警告訊息 對話方塊的值，當使用者刪除<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性不會顯示在靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和伺服器控制項。 靜態控制項是伺服器控制項中已宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>網頁標記中的區域。 這類控制項都是靜態的因為它們無法刪除，如此一來，刪除警告訊息永遠不會顯示在此情況下。 靜態控制項可以關閉的使用者，但已關閉的控制項加入至頁面目錄，在其中它可以加入至網頁的使用者，而永遠無法復原刪除的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性以宣告方式和程式設計的方式。  
  
 有四個部分的程式碼範例：  
  
-   使用者控制項，可讓您變更頁面的顯示模式。  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   Web 網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 程式碼範例的第二個部分是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個範例會使用動態編譯的方法;因此沒有任何`Assembly`屬性`Register`對這個控制項頂端的網頁指示詞。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 程式碼範例的第三個部分是 Web 網頁。 此頁面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用的自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項中所宣告該區域，以便讓使用者可以將它加入頁面在執行階段。 請注意，可以從頁面刪除僅動態控制項 （以程式設計方式或從這類目錄加入至網頁的控制項）。 靜態控制項 (控制項中已宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域在頁面標記中的) 可以關閉，但永遠不會刪除。 `<asp:webpartmanager>`項目宣告的自訂值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性使用`DeleteWarning`屬性。 `Button1_Click`方法會將指派到另一個自訂值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，您需要加入<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項加入網頁。 使用**顯示模式**下拉式清單控制項中，選取類別目錄的模式。 目錄出現時，請選取自訂控制項旁的核取方塊，按一下**新增**以將它加入至頁面上，然後按一下**關閉**返回頁面，即可瀏覽模式。 既然控制項為可見，您可以將它刪除。 使用**顯示模式**控制項一次，將頁面切換到設計模式 （您無法刪除控制項頁面瀏覽模式時）。 按一下標頭中的動詞命令功能表 （的箭頭符號）<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，然後選取**刪除**。 您在設定的警告`DeleteWarning`屬性隨即顯示。 按一下**取消**。 現在按一下 標示為按鈕**變更刪除警告**，以程式設計方式變更的屬性值。 從控制項上的動詞命令功能表，選取**刪除**一次，並請注意，此時會出現警告訊息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要刪除的伺服器控制項。</param>
        <summary>從網頁永久移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的動態執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法永久移除所代表的控制項`webPart`頁中的參數。 不同於已關閉的控制項，其新增到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，並可以再加入頁面上，刪除的控制項執行個體可以永遠不會加入至網頁。  
  
> [!NOTE]
>  由 Web 組件控制項實作設定，可讓使用者刪除動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制取決於使用者和控制項加入至頁面已個人化範圍。 如果控制項已加入共用的範圍頁面時 （所具有的權限的使用者），然後控制項無法刪除由個別使用者頁面時使用者領域中。  
  
 只有動態控制項，才能刪除。 動態控制項已加入至頁面，以程式設計方式或從目錄中加入控制項的使用者。 靜態控制項加入至以宣告方式中的標記或持續性格式的頁面。 因為永遠出現在標記中的宣告式標記，靜態控制項可以永遠不會刪除，但可以關閉並重新開啟。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次**新增行事曆**按一下按鈕時，程式碼在事件處理常式會建立<xref:System.Web.UI.WebControls.Calendar>控制，並將它加入做為區域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件。 以程式設計方式加入控制項，因為它是動態的控制項，並因此被刪除。 當使用者按一下**刪除行事曆**按鈕時，程式碼可確保控制項確認存在，然後再刪除它，藉由呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 組件控制項之網頁的配置變更時所使用的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>欄位參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態的物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要的控制項執行個體。  
  
 當包含 Web 組件的頁面控制項第一次載入時，它就會處於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 當使用者想要變更頁面的版面配置將控制項移到不同的區域，或在目前的區域內時，他們必須先將頁面切換至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>（設計模式）。 在設計模式中，使用者介面 (UI) 的各種不同的區域出現，而且使用者可以拖曳控制項，以變更版面配置。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單的頁面上，在此情況下為 瀏覽和設計支援的顯示模式。 請注意，在`Page_PreRender`方法時，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>。 如果是這樣，`Label1`將會顯示，如果沒有的話，`Label1`將隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意頁面上的標籤為隱藏。 使用下拉式清單控制項，將頁面切換到設計模式。 請注意，因為中的程式碼`Page_PreRender`方法，會立即顯示標籤。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要中斷連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</param>
        <summary>從控制項參與的任何連接中，移除正在關閉或刪除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法會在內部呼叫時控制項在頁面上關閉，或從頁面刪除設定的 Web 組件控制項。 在這類案例中，被呼叫方法來移除任何連線涉及為取用者或提供者。 如果從任何連線中移除控制項，這個方法也會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法來中止所在的任何連接`webPart`牽涉到。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>呼叫方法時，便會產生<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。 通常這個事件可以取消，但在兩個情況下即無法取消。 其中一種情況發生在要求期間 頁面上，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>方法呼叫。 如果沒有現有的連線，衝突<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法會被叫用以關閉其中一個衝突的連接，而且在這個執行個體<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件無法取消，因為必須解決衝突。  
  
 在另一個案例，就會發生時<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項目前連接關閉或刪除。 在此情況下，因為控制項正在移除頁面中，終止，因此依設計不可能取消其連線需求<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>中斷結束連接的程序的事件。 如需詳細資訊，請參閱 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 使用兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，網頁可以可讓您按一下按鈕，而另一個按鈕可讓您中斷連線之控制項的控制項之間建立連線。 如果您關閉其中一個控制項在頁面的瀏覽模式的控制項已連接，覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法中斷連接已關閉的控制項，會結束連線，並顯示訊息。  
  
 程式碼範例包含四個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   包含自訂的原始程式檔<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   裝載控制項的網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二個部分是包含兩個自訂的原始程式碼檔<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項所要連接和自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個範例會使用動態編譯，所以`Register`據以宣告指示詞參考這些元件在網頁中的網頁的頂端。 如需示範編譯選項的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 在原始程式碼中，請注意繼承的控制項`MyWebPartManager`會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法。 這個方法會檢查在頁面中，查看是否正在關閉控制參與連接而且，如果是的話，會呼叫每個連接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法來結束連接。 這等同於在方法的基底實作<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 覆寫的方法然後自訂基底實作，透過將訊息寫入頁面。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 程式碼範例的第三個部分是 Web 網頁。 請注意，最上方，它包含`Register`註冊的使用者控制項，並具有動態編譯的組件的指示詞<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 頁面具有兩種主要方法。 `Button1_Click`方法建立控制項之間的連接時`Button2_Click`方法中斷連接控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 將頁面載入之後，請按一下**連接**連接控制項的按鈕。 然後按一下動詞命令功能表中的控制項 （控制項的標頭中的向下箭頭），並選取**關閉**從動詞命令功能表。 當您嘗試關閉控制項時，覆寫的方法會呼叫、 連線就會結束，並將訊息寫入至頁面。 如果您想要重設頁面，即可還原已關閉的控制項並嘗試使用其他選項，請按一下**重設使用者狀態**移除個人化資料和還原頁面的原始狀態的連結。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，表示伺服器控制項之間的連接。</param>
        <summary>對網頁上連接的伺服器控制項，執行中斷連接的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法會執行完整的程序的結束之間的連線<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項，當您將傳遞`connection`參數。  
  
 這個方法用來中斷連接控制項，當您將`<asp:connectionszone>`網頁上，以管理連線時，提供使用者介面 (UI) 中的項目。 當頁面處於連接的顯示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)，且目前的連線存在，使用者可以按一下按鈕，以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法來結束連接。  
  
 您也可以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，直接從程式碼，如果您想要中斷連接控制項，以程式設計的方式，而不需要新增`<asp:connectionszone>`至頁面的項目。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 使用兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，網頁可以可讓您按一下按鈕，而另一個按鈕可讓您中斷連線之控制項的控制項之間建立連線。  
  
 程式碼範例包含四個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   包含自訂的原始程式檔<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   裝載控制項的網頁。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二個部分是包含兩個自訂的原始程式碼檔<xref:System.Web.UI.WebControls.WebParts.WebPart>將連接的控制項。 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個範例會使用動態編譯，所以`Register`據以宣告指示詞參考這些元件在網頁中的網頁的頂端。 如需示範編譯選項的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 程式碼範例的第三個部分是 Web 網頁。 請注意，最上方，它包含`Register`登錄使用者控制項，並具有動態編譯的組件的指示詞<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 頁面具有兩種主要方法。 `Button1_Click`方法建立控制項之間的連接和`Button2_Click`方法中斷連接控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 將頁面載入之後，您可以按一下**連接**連接控制項的按鈕。 如果您輸入一些文字的文字方塊控制項中，然後再按一下**Enter**按鈕時，文字會顯示在連接的控制項 （它可能不會顯示如果控制項已中斷連線）。 如果您按一下**中斷連線** 按鈕，控制項將會中斷連接。 您可以使用，以驗證控制項的連接狀態**顯示模式**切換到頁面的下拉式清單控制項**連接**模式。 之後，請按一下 （由箭號表示） 的動詞命令功能表控制項，其中的標題列中，選取**連接**項目。 顯示連接 UI;它是可用的因為沒有`<asp:connectionszone>`頁面中宣告的項目。 您也可以連接，並中斷此 UI 控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 是唯讀的。  
  
 \-或-  
  
 <paramref name="connection" /> 已從 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 中斷連接。  
  
 \-或-  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 是唯讀的。  
  
 \-或-  
  
 <paramref name="connection" /> 已從 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中斷連接。</exception>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />方法，如果您想要變更中斷連線的預設實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控制項。 如果您不要覆寫方法中，您只想要將某些實作加入至現有的方法，您可以呼叫基底方法，在執行自己的程式碼之前。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含 Web 組件控制項之網頁的現用顯示模式。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />，決定頁面的顯示模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含 Web 組件控制項的頁面一律是其中幾個可能的顯示模式。 如需有關顯示模式的詳細資訊，請參閱[Web 組件頁面顯示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會建立網頁的顯示模式。 使用基底<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項建立可以用在包含 Web 組件控制項的頁面的數個標準顯示模式物件。 這些標準顯示模式中有描述<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>類別概觀。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會管理使用 Web 組件控制項之網頁的顯示模式。 使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項在頁面上保留目前的顯示模式的參考。 您也可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性，以將頁面切換至不同的顯示模式。 如需在使用 Web 組件控制項的網頁變更顯示模式的範例，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 管理顯示模式，一部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項也會提供事件和顯示模式，例如相關的事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。 這些方法會提供一個機制，自訂網頁的行為，以及加入自訂的顯示模式。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性。 之後載入網頁瀏覽器中的，您可以使用靠近頁面底部的按鈕，切換顯示模式。 頁面位於瀏覽模式，根據預設，在載入時。 如果您切換到設計模式，您可以將伺服器控制項從一個區域拖曳到另一個，或排列一個區域內的兩個控制項。 如果您切換至編輯模式，您可以按一下其中一種伺服器控制項，選取的標頭中的動詞命令功能表**編輯**，並編輯使用提供編輯使用者介面 (UI) 控制項。  
  
> [!NOTE]
>  在 Web 組件的應用程式的顯示模式間切換是很常見，因此，您可以提供一致、 可重複使用的方式，若要這樣做的所有網頁包含 Web 組件控制項。 變更顯示模式，使用者控制項的範例可以在許多頁面上重複使用，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件不是其中一個支援的顯示模式。  
  
 \-或-  
  
 正在指定給屬性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件已停用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 組件頁面目前的顯示模式變更之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示模式是 Web 組件的應用程式中不可或缺的一部分。 當使用者切換至不同的顯示模式，在網頁上時，網頁通常會非常不同的外觀，根據新的顯示模式的用途。 顯示模式已變更之後，您可能想要讓特定變更在使用者介面 (UI)，例如隱藏或顯示特定控制項，變更所選取的 UI 元素的外觀，並以此類推。  
  
> [!NOTE]
>  如需有關顯示模式的詳細資訊，請參閱[Web 組件頁面顯示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 如需有關如何使用事件的詳細資訊，請參閱[How to： 使用 Web Form 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者按一下網頁上的動詞命令，而開始切換至不同顯示模式的程序之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示模式是 Web 組件的應用程式中不可或缺的一部分。 當使用者切換至不同的顯示模式，在網頁上時，網頁通常會非常不同的外觀，根據新的顯示模式的用途。 使用者起始的動詞命令，即可變更至新的顯示模式程序之後，您可能想要變更某些使用者介面 (UI) 中使用<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>屬性來判斷新的顯示模式是什麼，，然後變更 各種 UI項目據此。 若要這樣做的實用方式是覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>自訂 UI 的方法。  
  
> [!NOTE]
>  如需有關顯示模式的詳細資訊，請參閱[Web 組件頁面顯示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 如需有關如何使用事件的詳細資訊，請參閱[How to： 使用 Web Form 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項關聯之所有顯示模式的唯讀集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含與 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控制項關聯之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性參考所有相關聯的顯示模式中，相較於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性，即在參考只會使用 （支援） 目前頁面上的顯示模式。  
  
 兩個提供的顯示模式中，瀏覽與設計中，一律支援在頁面上。 頁面具有區域所需的特定顯示模式運作的對應型別時，才會支援其他三種顯示模式、 編輯、 目錄及連線。 例如，如果您的頁面不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域，編輯顯示模式將會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性，但不是會出現在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性。 程式碼會使用這個屬性來填入清單所有可用的顯示模式 Web 組件控制項集合中，甚至不支援目前的頁面上。 在此情況下，類別目錄，而且連線的顯示不支援的模式，因為對應的必要區域不在頁面上。  
  
 其他三個顯示模式： 支援在頁面上瀏覽、 設計和編輯。 編輯支援模式，因為此頁面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域，瀏覽時，一律會支援設計模式。  
  
 在瀏覽器頁面載入之後，您可以使用下拉式清單控制項切換到設計模式，將頁面從瀏覽模式，然後編輯模式。 您可以在編輯模式中，按一下下拉式清單動詞命令功能表中的伺服器控制項的其中一個標頭，並選取**編輯**，編輯控制項。 請注意，如果您選取**目錄**或**連接**在下拉式清單中，會產生錯誤頁面。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上目前所有動態連接的集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含頁面上所有動態連接的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態的連接都是以程式設計的方式，而非以靜態方式建立的連接。 藉由在 Web Form 網頁標記中宣告它們可以建立靜態連接。 以程式設計的方式，或由使用者建立連接，使用連接的使用者介面 (UI) 的格式動態連接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合中，雖然它是唯讀的您無法變更其內容，但是提供以程式設計方式存取每個動態連接物件。  
  
> [!NOTE]
>  若要執行一般作業，例如連線或中斷連線<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項開發人員應該使用的公用方法上<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，例如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而不需要嘗試直接修改連線中的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示使用者可用來編輯和修改伺服器控制項的顯示模式。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>欄位參考自訂<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>建立和所包含的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因為這是靜態的物件，您可以參考它直接透過<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，而不需要的控制項執行個體。  
  
 當包含 Web 組件的頁面控制項第一次載入時，它就會處於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（瀏覽模式） 的預設值。 當使用者想要編輯或修改伺服器控制項時，他們必須先將頁面切換至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>（編輯模式）。 第二，他們都必須選取特定的伺服器控制項，以編輯，請按一下該控制項的標頭中的動詞命令功能表上的編輯動詞命令。 控制項處於編輯模式之後，編輯的使用者介面 (UI) 會出現編輯選取的控制項。  
  
 若要啟用編輯模式，在頁面上的，頁面必須至少包含一個<xref:System.Web.UI.WebControls.WebParts.EditorZone>區域，其中包含一或多個提供編輯控制項，例如<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>控制項或自訂的編輯控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>欄位以程式設計的方式。 程式碼會填入下拉式清單的頁面上，在此情況下會瀏覽、 設計和編輯支援的顯示模式。 若要支援編輯，`<asp:EditorZone>`項目是在的頁面。 請注意，在`Page_PreRender`方法時，程式碼會檢查是否目前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>屬性設定為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>。 如果是這樣，`Label1`將會顯示，如果沒有的話，`Label1`將隱藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您就預設的瀏覽模式。 請注意，隱藏的頁面上的標籤。 若要將頁面切換至編輯模式，使用下拉式清單控制項。 請注意，因為中的程式碼`Page_PreRender`方法，會立即顯示標籤。 按一下**編輯**在其中一個控制項，以啟用該特定控制項的編輯動詞命令功能表中的動詞命令。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，判斷在包含了 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的網頁上是否啟用用戶端指令碼。</summary>
        <value>布林值，指出用戶端指令碼是否可以在頁面上執行。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>屬性可讓開發人員若要停用用戶端指令碼。 您可能想要停用用戶端指令碼，基於安全性目的，或確保所有頁面的使用者會都有類似的使用者經驗，即使它們使用不同的瀏覽器。  
  
 您可以停用用戶端指令碼加入`EnableClientScript`屬性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在網頁上，如下列宣告式的程式碼行所示：  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外，開發人員能夠排除這個屬性透過繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別及設定預設值給`false`。  
  
 Web 組件控制項集合會使用用戶端指令碼來提供一些用戶端使用者介面 (UI) 和個人化功能。 如果您停用用戶端指令碼、 Web 組件控制項還能運作，但會停用某些功能。 將控制項拖曳到不同區域的能力已停用，以及呈現下拉式動詞命令功能表中控制項的標題列 （動詞命令會顯示為控制項的標題列中的連結） 中的動詞命令的能力。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出網頁上是否允許佈景主題之使用。</summary>
        <value>布林值，指出佈景主題是否已啟用 所有情況下都是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Control 覆寫基底<xref:System.Web.UI.Control.EnableTheming%2A>屬性，以確保一律會傳回值的`true`。 這是因為 Web 組件控制項集合需要呈現 Web 組件的佈景主題的使用控制項的子控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，形成網頁的使用者介面 (UI)。 比方說，佈景主題以用來呈現不同的區域，和位於區域，其中包括各種類型的控制項組件的控制項 (繼承自控制項<xref:System.Web.UI.WebControls.WebParts.Part>類別)，使用者控制項、 ASP.NET 伺服器控制項和自訂的伺服器控制項。  
  
 雖然覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>屬性會實作為其基底屬性根據讀/寫屬性，您無法設定屬性，因為根據設計一律會傳回值為`true`。 如果您嘗試設定屬性，<xref:System.NotSupportedException>擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">已嘗試設定屬性值。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項連接到另一個控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法完成連接的程序<xref:System.Web.UI.WebControls.WebParts.WebPart>為其他控制項的控制項。 它是對應項目來<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法可確保所參考的個人化物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是可修改，而這是必要的因為建立連接是本身的個人化的類型。 方法接著確定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>物件不是`null`，最後會呼叫和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性所參考的控制項是 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 其中一個方法會呼叫基底方法，然後加入一些其他的自訂處理，或您可能想要完全自訂的整個程序完成控制項之間的連接。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成編輯 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法完成編輯程序<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 它是對應項目來<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法可確保所參考的個人化物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是可修改，而這是必要的因為編輯控制項是需要個人化變更的程序。 方法接著確定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>物件不是`null`，以便在目前選取<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可能會變更，而且它會呼叫最後<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性所參考的控制項是 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>開發人員需要擴充<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項可能會想要覆寫這個方法在衍生類別中的。 其中一個方法會呼叫基底方法，然後加入一些其他的自訂處理，或您可能想要完全自訂完成編輯控制項的整個程序。 比方說，在覆寫方法中，您無法先呼叫基底方法，並將決定所做的編輯變更一些程式碼，並顯示給終端使用者是確認回變更的清單。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定警告訊息的文字，當使用者嘗試從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項匯出敏感性狀態資料時，會顯示此警告訊息文字。</summary>
        <value>包含警告訊息的字串。 預設訊息為 .NET Framework 所提供的文化特性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者嘗試將敏感的狀態資料從匯出<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，如果任何要匯出的資料來自已標示為機密的原始程式碼中的成員，告訴他們在訊息方塊中，使用者顯示警告訊息正在匯出敏感性資料，並提供取消匯出的機會。 開發人員可以藉由設定項目將標示為機密的特定成員的資料`isSensitive`參數`[Personalizable]`屬性`true`成員上。 如需有關這個屬性和參數的詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>類別。  
  
> [!IMPORTANT]
>  當您使用 Web 組件的匯出功能時，未經授權的使用者可以可能匯出敏感性資料。 如需有關如何防範這項威脅的詳細資訊，請參閱[保護 Web 組件頁面](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每當使用者嘗試匯出時，會顯示預設訊息。 不過，透過指派值給<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性，您可以提供自訂的警告訊息。  
  
   
  
## Examples  
 下列程式碼範例示範如何宣告式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>屬性。  
  
 在下列網頁的程式碼會使用標準<xref:System.Web.UI.WebControls.BulletedList>控制，並將它放在區域中。 控制項將會包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段，可讓它成為 true<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 將控制項設為可匯出、`ExportMode`屬性加入至`<asp:bulletedlist>`項目和屬性值設定為<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>，可以匯出敏感性及非機密資料的表示。 也請注意，在`<asp:webpartmanager>`項目，`ExportSensitiveDataWarning`屬性被指派自訂的值。  
  
 請注意，工作的程式碼範例，您必須在 Web.config 檔案，以啟用匯出 Web 組件描述檔中加入的設定。 確定您具有網頁上的相同目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請確定沒有`<webParts>`具有項目`enableExport`屬性設為`true`，在下列標記中。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，請包含連結控制項的標題列中按一下 （以向下箭號表示） 的動詞命令功能表。 在 [動作] 功能表中，選取**匯出**，並請注意，訊息方塊隨即出現，並自訂警告。 如果您想要繼續匯出，請按一下**確定**，這樣能讓您儲存的 XML 描述檔案的本機副本與控制項相關的所有資料。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">控制項，將匯出其資料。</param>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />，將 <c>webPart</c> 的匯出資料寫入 XML 描述檔。</param>
        <summary>建立 XML 描述檔，其中包含伺服器控制項的狀態和屬性資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法組合的各種狀態及屬性資料是從`webPart`成 XML 檔案。 資料包括控制項本身，包括其組件、 狀態資料和屬性資料的相關資訊。 起始匯出的使用者可以將 XML 檔案儲存至磁碟，本機電腦或網路上。 其他使用者可以描述檔案匯入到不同的網頁或網站，並套用至不同的執行個體的狀態和屬性資料`webPart`。 這提供快速且方便的機制，來共用及重複使用的伺服器控制項，其設定的使用者，它也提供方法來控制的外觀和行為的匯出和匯入控制項開發人員。  
  
 屬性上的`webPart`預設不會匯出。 若要啟用匯出的屬性，您必須將它與標記`[Personalizable]`的原始程式碼中的屬性。 您也可以選擇性地將標示成可匯出的屬性，為包含機密資料，藉由設定`isSensitive`參數`[Personalizable]`屬性`true`。 根據預設，`isSensitive`是`false`。 開發人員可以將參數設定為`true`表示資料是敏感性資訊。  
  
 若要啟用`webPart`開發人員設定要匯出其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>屬性值設為  <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> （包括所有可個人化和機密屬性），或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>，匯出機密屬性以外的所有內容.  
  
> [!IMPORTANT]
>  允許使用者將資料從控制項，匯出和匯入資料到其他控制項，需要一些安全性風險。 開發人員應使用來保護機密資料，上面所討論的方法，而且如果他們想要避免完全公開資料的風險，則不應啟用匯出上`webPart`完全。 如需 Web 組件的安全性問題的詳細資訊，請參閱[保護 Web 組件頁面](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="writer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所參考的控制項集合。  
  
 \-或-  
  
 <paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 屬性設為 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> 值，表示停用 <paramref name="webPart" /> 的匯出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>覆寫成防止在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項上設定焦點，因為此控制項沒有使用者介面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>方法會覆寫基底<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>方法，並擲回例外狀況，如果呼叫端呼叫的方法。 因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>、 控制項沒有 ui 而且永遠不會對使用者顯示其永遠不會讓焦點設在本身。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼叫端嘗試呼叫 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，但沒有 UI 的控制項不支援此動作。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">做為連接之消費者的伺服器控制項。</param>
        <summary>從做為 Web 組件連接之消費者的伺服器控制項中，擷取可做為連接點之所有 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 物件的集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />，包含消費者中的所有連接點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件連接一定牽涉到兩個控制項，其中一個做為資料提供者，另一個做為資料的取用者。 每個控制項都必須有一或多個定義為連接點的方法。 若為取用者控制項，其連接點是<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>物件。 擷取的消費者連接點是建立 Web 組件連接的必要步驟。  
  
 取用者永遠必須至少一個連接點，若要能夠建立連接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法會檢查取用者控制項，並擷取其所有的連接點的集合。 如果<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項沒有的連接點，方法會傳回空集合。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需有關顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 網頁上的宣告式標記包含`Register`使用者控制項，並自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目來包含自訂控制項和`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法時，程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查並再加入新的連接所參考的靜態連接的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。 請注意，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>物件，擷取使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法接著會傳遞給<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以判斷是否可以建立兩個控制項之間的連接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 您可以取得此程式碼，以及用於編譯，從範例 > 一節的指示<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接使用者介面 (UI) 出現之後，請注意連接確認已建立的程式碼中包含`Page_Load`方法。 如果您在更新版本的瀏覽器工作階段中傳回此頁面，此靜態連接將會建立，且不需要重新建立每次載入頁面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 之執行個體的網頁。</param>
        <summary>擷取頁面上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項之目前執行個體的參考。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，參考頁面上控制項目前的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法很有用的內容中您要擷取目前參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 這會在其中發生的常見案例是如果您要撰寫的自訂控制項，哪些的識別碼在開發期間不知道<xref:System.Web.UI.WebControls.WebParts.WebPartManager>將會在其 頁面上的控制項。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法是靜態的因此您可以呼叫它直接而不需要的執行個體<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 控制項集合，例如 Web 組件中的某些控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，具有<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>可以擷取目前參考的屬性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 因此，當使用這類控制項，您應該使用這個屬性來擷取的參照。  
  
 如果您在撰寫程式碼的內容，其中您知道的識別碼中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，例如撰寫程式碼內嵌在網頁，它是最簡單且最有效率的直接參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項使用其識別碼。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 這個範例有兩個部分： 自訂伺服器控制項，以及裝載控制項的網頁。  
  
 自訂<xref:System.Web.UI.WebControls.Label>控制使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法來擷取的識別碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項目前的頁面，然後顯示該識別碼。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下列程式碼範例提供裝載控制項中的網頁<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 在瀏覽器頁面載入之後，請注意，目前的識別碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項顯示內自訂<xref:System.Web.UI.WebControls.Label>控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">控制項，此方法傳回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 的值。</param>
        <summary>取得字串，包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 屬性的值。</summary>
        <returns>字串，包含 <paramref name="webPart" /> 之 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 的計算值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得的導出的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>屬性`webPart`。 當開發人員不指派值給<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，這個方法會產生為標題顯示的值。 未命名控制項的導出的值為字串，加上數字，指出控制項的順序，在目前區域中的數字所組成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides">
          <para>若要變更預設顯示標題的計算方式，可以覆寫這個方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在匯出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>當使用者嘗試匯出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項時，取得做為要求一部分的相對虛擬路徑和查詢字串。</summary>
        <returns>字串，包含相對虛擬路徑和查詢字串，這兩項一起形成匯出控制項的要求。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所傳回的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法，包含控制項、 網頁伺服器位置的相對虛擬路徑，以及附加的查詢字串值可形成匯出要求提交給伺服器。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法將字串編碼之前允許送出，以防止惡意指令碼攻擊的要求。  
  
> [!NOTE]
>  如需保護 Web 組件的應用程式的詳細資訊，請參閱[保護 Web 組件頁面](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">伺服器控制項，存在於 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 並在執行階段包裝成 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控制項。</param>
        <summary>取得包含伺服器控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控制項執行個體的參考。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，用來將 <paramref name="control" /> 包裝成子控制項。 如果 <paramref name="control" /> 不包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，則此方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情況下，有兩種類別的控制項開發人員置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>參與 Web 組件的應用程式的區域：<xref:System.Web.UI.WebControls.WebParts.WebPart>繼承的控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>基底類別和其他伺服器控制項，可以是標準ASP.NET 控制項、 自訂控制項或使用者控制項。 當任何這些控制項置於<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>花費之功能區域，<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 A<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項有本質上這項功能，但其他伺服器控制項的類型不相符。 若要讓其他伺服器控制項做為<xref:System.Web.UI.WebControls.WebParts.WebPart>控制它們被放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域，ASP.NET 會將它們包裝與<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項。 因為<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項直接繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別，它會提供它的子控制項，則為 true 的 Web 組件功能。  
  
 通常在執行階段，網頁開發人員可能會想要取得的參考<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含其中一個區域中的伺服器控制項的控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法可讓他們能夠擷取的參照<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法。 程式碼範例包含<xref:System.Web.UI.WebControls.Calendar>控制項內宣告<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。 `Button1_Click`方法第一次會列印 ID<xref:System.Web.UI.WebControls.Calendar>控制項標籤，然後再使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法來擷取的參照<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包裝行事曆控制項。 識別碼<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項，以及它的子控制項的 ID (也就是<xref:System.Web.UI.WebControls.Calendar>控制項)，兩者會列印第二個標籤。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">做為連接之提供者的伺服器控制項。</param>
        <summary>從做為 Web 組件連接之提供者的伺服器控制項中，擷取可做為連接點之所有 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 物件的集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />，包含提供者中的所有連接點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件連接一定牽涉到兩個控制項，其中一個做為資料提供者，另一個做為資料的取用者。 每個控制項都必須有一或多個定義為連接點的方法。 如果提供者的控制項，其連接點系統會<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>物件。  
  
 提供者必須永遠有至少一個連接點，若要能夠建立連接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法會檢查提供者控制項，並擷取其所有的連接點的集合。 擷取提供者連接點是建立 Web 組件連接的必要步驟。  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 此範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 網頁上的宣告式標記包含`Register`使用者控制項，並自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目來包含自訂控制項和`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法時，程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查並再加入新的連接所參考的靜態連接的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。 請注意，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>物件，擷取使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法接著會傳遞給<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以判斷是否可以建立兩個控制項之間的連接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 此範例的第三個部分是控制項的原始程式碼。 您可以取得此程式碼，以及用於編譯，從範例 > 一節的指示<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接使用者介面 (UI) 出現之後，請注意連接確認已建立的程式碼中包含`Page_Load`方法。 如果您在更新版本的瀏覽器工作階段中傳回此頁面，此靜態連接將會建立，且不需要重新建立每次載入頁面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />，從正在匯入的 XML 描述檔讀取狀態和屬性資料。</param>
        <param name="errorMessage">
          <see cref="T:System.String" />，匯入期間發生錯誤時，顯示給使用者。</param>
        <summary>匯入 XML 描述檔，其中包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的狀態和屬性資料，並將此資料套用至控制項。</summary>
        <returns>匯入的 XML 描述檔中參考的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (或包裝在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中的伺服器控制項，因此被視為 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法匯入所建立的 XML 描述檔案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>伺服器控制項的方法。 它不是實際的伺服器控制項所匯入，而只包含有關控制項的狀態和屬性資料的描述檔案。 控制項和 description 檔案中參考組件必須已經是使用者嘗試匯入描述檔案伺服器上可用的。  
  
 若要啟用匯入一個控制項，開發人員必須將<xref:System.Web.UI.WebControls.WebParts.CatalogZone>匯入將會啟用的頁面上的控制項。 區域內<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必須加入控制項。 這個控制項提供檔案對話方塊，可讓使用者瀏覽並尋找要匯入的說明檔案。  
  
 描述檔案的使用者尋找說明檔案，並開始匯入之後，所讀取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法。 如果沒有任何錯誤，而且如果找到的組件和控制，要將伺服器控制項加入至內目錄<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制項，以及指定 description 檔案中的各種屬性和狀態資料套用至控制項。 使用者可以選取控制項，並將它加入至頁面。  
  
> [!IMPORTANT]
>  像<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法有一些潛在安全性風險。 因為它牽涉到將資料匯入的網站，惡意使用者可以嘗試將不正確的資料或甚至是指令碼插入 description 檔案匯入。 然後在頁面上，或在資料庫中，可能會顯示不正確的資料或插入的指令碼無法執行。 如需匯入描述檔案，以及避免發生這些風險的方式與相關聯的潛在風險的概觀，請參閱[保護 Web 組件頁面](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> 無法讀取檔案。  
  
 \-或-  
  
 <paramref name="reader" /> 需要顯示匯入錯誤訊息，但在檔案中找不到。  
  
 \-或-  
  
 <paramref name="reader" /> 已到達檔案結尾，但找不到包含匯出之資料的 XML 項目。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 類別的參考，用來結合和分離 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 類別中實際實作、但對控制項開發人員非常有用的一組方法。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 可以透過它來參考已區分成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各種方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性會公開成一組呼叫 Api<xref:System.Web.UI.WebControls.WebParts.WebPartManager>大部分用於擴充性的情況下的方法。  
  
 使用這些內部方法的設計的方式是透過存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>屬性。 因為屬性已受到保護，您只能存取權限和呼叫的方法，執行個體內<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>類別繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別。  
  
> [!NOTE]
>  這個屬性隱藏的中的 IntelliSense [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]。 不過，在衍生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，您仍然可以存取的屬性和其不同的成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項是否可以加入至頁面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 組件功能部分是彈性的將伺服器控制項加入至網頁中，在執行階段的能力。 有一些常見的案例中提供伺服器控制項 (它可以是自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 自訂伺服器控制項，使用者控制項或 ASP.NET 控制項) 加入。  
  
 在下列的一般狀況下，Web 組件會控制組嘗試將伺服器控制項加入至網頁，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>呼叫方法以授權他們：  
  
-   藉由宣告內的網頁標記中加入伺服器控制項時<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域。  
  
-   當伺服器控制項是以程式設計方式新增至區域。  
  
-   當使用者匯入伺服器控制項的控制項的 Web 組件類別目錄。  
  
-   當現有的伺服器控制項是從個人化資料存放區中載入。  
  
-   當伺服器控制項加入<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>以供目錄中的伺服器控制項的控制項。  
  
 在其中加入控制項，每個案例<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>呼叫方法來確定是否要加入的控制項，以便符合所有授權的準則。 當控制項已獲得授權時，將其加入通常因為它可以有沒有任何篩選的案例。 當控制項未獲授權時，Web 組件控制項集合可以回應數種方式，視內容而定。 控制項集合可能會以無訊息模式失敗將未經授權的組件 （如果不需要通知使用者有），它可以顯示錯誤訊息，或它可以將執行個體<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>類別做為預留位置。 此預留位置物件不會顯示在頁面上，但會顯示在頁面原始碼，以表示未經授權的控制項已排除。  
  
 控制是否已獲授權的行列式是授權篩選條件。 授權篩選條件是可讓開發人員從頁面排除不符合指定的準則的任何控制項的 Web 組件控制項集合中的功能。  
  
 若要建立篩選案例，開發人員必須執行兩件事。 首先，它們必須指定字串值 （值可以是任意） 至<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每個屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>它們打算在案例中使用的控制項。 它們也可以指派值給這個屬性的其他類型的伺服器控制項不<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，因為如果它們被放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域，以包裝此類控制項<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制項在執行階段，以及此控制項的繼承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性。  
  
 第二個必要步驟，建立篩選的案例是為覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，或建立的事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。 開發人員可以在這些方法中，檢查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性，以及如果此值會指出不應該授權控制項，開發人員確保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法會傳回值`false`。  
  
> [!NOTE]
>  程式碼範例，以及如何設定自訂的篩選案例使用的描述<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，請參閱方法的多載的主題。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在檢查授權的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項。</param>
        <summary>執行會判斷控制項是否獲得授權可加入至頁面的初始步驟。</summary>
        <returns>指出 <paramref name="webPart" /> 是否可加入至頁面上的布林值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法是呼叫要檢查的授權設定的 Web 組件控制項的初始方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 它可接受`webPart`做為參數，並開始才是最終決定控制項是否會加入至網頁的處理序。 直接呼叫這個方法從程式碼時，您必須判斷是否授權指定的控制項。  
  
 這個方法會決定控制項是否會繼承的初始工作執行<xref:System.Web.UI.WebControls.WebParts.WebPart>類別或<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制，而且如果是這樣，何種類型的子控制項，它包含。 若要完成工作的授權，它會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法多載。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>從您的程式碼，以判斷是否授權控制項加入至頁面的方法。  
  
 程式碼範例包含三個部分：  
  
-   自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>會覆寫控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。  
  
-   建立的篩選條件的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
-   如何執行此程式碼範例的說明。  
  
 這個程式碼範例會使用自訂<xref:System.Web.UI.WebControls.WebParts.WebPartManager>會覆寫控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>多載方法，以提供自訂處理<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性。 這個控制項的屬性值會檢查`admin`而且，如果值存在，即表示授權控制項。 如果控制項具有不同的值，它未獲授權。不使用屬性值的控制項授權的因為它們假設為篩選案例的一部分。  
  
 若要執行此程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個程式碼範例會使用動態編譯方法。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 程式碼範例的第二個部分會建立篩選器，可能可以排除控制項。 在下列網頁包含三個中的 ASP.NET 伺服器控制項`<asp:webpartzone>`項目。 請注意，第一個和第二個控制項都有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性設定為不同的值，和第三個未指派給屬性。 在執行階段，能夠檢查這個授權值和控制項可以加入至頁面，如果篩選條件符合時，開發人員所設定的準則。 也請注意在`Page_Load`方法]、 [程式碼會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>方法，以判斷是否每個控制項已獲得授權，然後如果因此，它會設定每個控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 請注意，工作的程式碼範例，您必須新增設定，若要啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 確定您具有網頁上的相同目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請確定沒有`<webParts>`具有項目`enableExport`屬性設為`true`，在下列標記中。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 載入瀏覽器中的之後，請注意，會顯示第一個控制項，因為它會比對的準則中覆寫的方法。 第二個控制項不會加入至頁面，因為它篩選所排除的。 也加入第三個控制項，因為它並沒有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性集。 請注意，如果您按一下標題列的其中一個控制項中的動詞命令功能表圖示時，他們可以同時匯出，因為其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>沒有指派屬性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>直接從程式碼會呼叫這個方法。 如果您想要取得大於以程式設計方式控制授權程序，您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />方法多載。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">正在檢查授權之控制項的 <see cref="T:System.Type" />。</param>
        <param name="path">正在授權之控制項的原始程式檔的相對應用程式路徑，若是使用者控制項。</param>
        <param name="authorizationFilter">指定給 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控制項之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 屬性的任意字串值，用來授權控制項是否可以加入至頁面。</param>
        <param name="isShared">指出正在檢查授權的控制項是否為共用控制項，表示對應用程式的多數或所有使用者都是可見，並且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 屬性值設為 <see langword="true" />。</param>
        <summary>執行會判斷控制項是否獲得授權可加入至頁面的最終步驟。</summary>
        <returns>布林值，指出控制項是否獲得授權，可加入至頁面。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>多載方法會判斷是否授權控制項加入至頁面的最後一個步驟執行。 此方法可確保`type`是有效的類型，而`path`正在檢查的控制項是一個使用者控制項時，才會有值。 然後它會呼叫的重大<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，這會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。  
  
   
  
## Examples  
 下列程式碼範例示範如何覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，以判斷是否授權控制項加入至頁面。  
  
 第一個步驟是建立篩選器，可能可以排除控制項。 在下列網頁包含三個中的 ASP.NET 伺服器控制項`<asp:webpartzone>`項目。 請注意，第一個和第二個控制項都有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性設定為不同的值，和第三個未指派給屬性。 在執行階段，能夠檢查這個授權值和控制項可以加入至頁面，如果篩選條件符合時，開發人員所設定的準則。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二個步驟就是覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，並建立自訂授權篩選條件的處理。 請注意，程式碼會先檢查屬性是否有值，以便任何控制，不會指派<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性會自動加入。 如果控制項有篩選，則程式碼會傳回`true`才篩選值等於`admin`。 這將示範一個簡單的機制，您可以使用特定的控制項，顯示特定使用者，根據其角色。 超出本主題的範圍使用角色的完整範例時，您可以使用相同的邏輯當做覆寫的方法，在此程式碼範例中，只不過您無法檢查目前使用者是否在符合授權篩選值的角色然後再加入控制項，僅對該使用者。 這會讓您建立的頁面，其中有些使用者會看到所有控制項，而其他使用者將會都看到選取的控制項。 這是使用角色時檢查篩選條件的邏輯的可能外觀：  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個程式碼範例會使用動態編譯方法。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 載入瀏覽器中的之後，請注意，會顯示第一個控制項，因為它會比對的準則中覆寫的方法。 第二個控制項不會加入至網頁，因為其篩選值被排除。 加入第三個控制項，因為它並沒有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性集。 如果您變更屬性值，第二個控制項來比對的第一個控制項，並再重新執行頁面上，也會加入第二個控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 是使用者控制項，但 <paramref name="path" /> 是 <see langword="null" /> 或空字串 ("")。  
  
 \-或-  
  
 <paramref name="type" /> 不是使用者控制項，但 <paramref name="path" /> 有指定的值。</exception>
        <block subset="none" type="overrides">
          <para>這個方法會覆寫繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別，如果您想要檢查授權時提供額外的處理。 您可能想要覆寫簽入特定值的方法<paramref name="authorizationFilter" />參數，並根據值，傳回布林值，決定是否要在控制項加入至頁面。  
  
 對於網頁開發人員也想要授權篩選條件檢查，並提供自訂處理，沒有執行此內嵌在.aspx 頁面，或在程式碼後置檔案中，而不必從任何類別繼承的選項。 您可以宣告替代的事件處理常式中的頁面<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項。 如需詳細資訊和範例，請參閱<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已執行個人化變更，並影響 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所控制的頁面層次個人化細節。</summary>
        <value>布林值，指出是已執行個人化變更。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>內部追蹤是否有任何它所管理的頁面層級個人化資料的屬性已變更。 個人化資料變更時的使用者執行各種不同的個人化動作，在頁面層級，例如加入或移除<xref:System.Web.UI.WebControls.WebParts.WebPart>連線或中斷連線的控制項，變更頁面的版面配置，藉由移動控制項和其他動作的控制項。  
  
> [!NOTE]
>  使用者也可以執行控制層級，這表示它們進行個人化變更，到特定控制項，在個人化，所做的變更只影響該控制項。 範例會編輯控制項，並變更其標題文字或它的背景色彩。 控制層級個人化不會影響所追蹤的頁面層級個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，所以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>屬性值不會變更為`true`控制層級個人化就會發生。  
  
 雖然方法受到保護，而且呼叫端，無法直接存取<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>直接的呼叫端，才能存取內容，並傳回這個屬性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要載入之保存的狀態資料。</param>
        <summary>載入上一個頁面要求所儲存的控制項狀態資料，在後續要求中需要還原此控制項狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>方法會很有幫助還原應在頁面的回傳保存的屬性資料即使<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>儲存已由個人化物件傳遞至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化資料，以使用於稍後的初始化過程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法提供儲存的狀態資料的形式<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>物件。 將 Web 組件控制項載入個人化資料，以及執行其他初始設定工作，最終會使用此資料。  
  
> [!NOTE]
>  方法的序列，開始時呼叫這個方法是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法一開始會要求相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>要個人化資料提供給物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 您無法直接從您的程式碼呼叫此方法。 您可以不過，直接呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法，而其本身會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法並傳回個人化資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />中衍生方法<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 使用權限。</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 使用權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>這個屬性所傳回的物件用於匯入期間類型還原序列化。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 使用權限。</summary>
        <value>取得 <see cref="T:System.Security.PermissionSet" /> 物件，該物件僅允許 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 使用權限和 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 使用權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>匯入所有項目除了輸入還原序列化期間使用這個屬性所傳回的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">正在移動的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項。</param>
        <param name="zone">
          <c>webPart</c> 正在移至的目標 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">整數，表示 <c>webPart</c> 的索引，相對於 <c>zone</c> 中的其他控制項。</param>
        <summary>將 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項從某個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域移至另一個區域，或移至相同區域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法來移動`webPart`到新位置位於相同區域中，或在不同區域中。 您可以直接從程式碼，呼叫這個方法，它也會叫用時，使用者將控制項移到新位置，使用 Web 組件的使用者介面 (UI) 中的各種選項。  
  
 之前必須符合一些條件`webPart`可以移動，和其中大部分以本主題中的例外狀況 > 一節中所列的項目。 如果`webPart`並未包含在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域不能將它移到區域的開始。  
  
 下列動作順序已符合這些條件之後，就會移動`webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法會引發 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  `webPart` 移除從其目前的區域 （如有必要），並加入至其新的區域或其目前區域中的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法會引發 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  `zoneIndex`的每個<xref:System.Web.UI.WebControls.WebParts.WebPart>來源和目的地的區域中的控制項重設為反映已移動的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，直接從程式碼，以移動<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一個區域的控制項。  
  
 程式碼範例包含三個部分：  
  
-   變更顯示模式的使用者控制項。  
  
-   裝載控制項的網頁。  
  
-   如何執行此程式碼範例的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 如需顯示模式和使用者控制項的運作方式的詳細資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是包含兩個區域，其中每一個都包含兩個伺服器控制項 Web 網頁。 當使用者按一下**移動 WebPart**在頁面上中的程式碼的按鈕`Button1_Click`方法將控制項從第一個區域移至第二個區域中的新位置。 請注意，程式碼第一次必須呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法來擷取<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包裝物件`list1`控制項。 這是必要的因為第一個參數<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法需要<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，而`list1`是 ASP.NET 伺服器控制項。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 在頁面載入之後，請按一下**移動 WebPart**  按鈕，並請注意，包含連結控制項移到第二個區域中的中間位置。 此控制項的移動作業透過以程式設計方式呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法。 您也可以使用**顯示模式**下拉式清單控制項，將頁面切換到設計模式，並在設計模式中，您可以將控制項拖曳到不同的區域或其區域的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法也會呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項來處理這類使用者起始移動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
 \-或-  
  
 <paramref name="zone" /> 不包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控制項的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
 \-或-  
  
 <paramref name="webPart" /> 控制項的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 屬性所參考的區域是 <see langword="null" />，這表示 <paramref name="webPart" /> 目前不是包含在區域中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 或 <paramref name="zone" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> 小於零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />，包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件並叫用事件的處理常式 (如果有的話)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法透過呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，當<xref:System.Web.UI.WebControls.WebParts.WebPart>授權，以加入至頁面選取控制項。 當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>呼叫方法時，便會產生<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件和事件處理常式方法時，它會叫用處理常式。  
  
 授權程序<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項是一個重要的 Web 組件功能。 每個<xref:System.Web.UI.WebControls.WebParts.WebPart>或加入至依區域的伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項將會執行授權程序，以判斷是否可以加入控制項。 根據預設，Web 組件控制項集合不提供任何篩選準則，以避免將控制項加入至區域。 但控制項集合並提供所需的開發人員建立自己的篩選條件的機制。 藉由使用這些機制，您可以建立自訂的篩選案例。 比方說，您可以建立篩選，以便使用者是系統管理員角色中，如果特定的控制項，會加入至區域時轉譯頁面時，如果使用者是使用者角色中，將不會加入這些控制項。  
  
 篩選控制項授權程序期間的機制是<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 若要建立篩選的案例，有本質上這兩個工作。 首先，您指派字串<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每個屬性<xref:System.Web.UI.WebControls.WebParts.WebPart>您想要篩選的控制項。 這些字串值可以是任意的但應該包含您想要篩選的準則。 例如，如果您要指定的控制項来新增至區域的只有當系統管理員使用者檢視頁面上，則您可能會指定的字串值`admin`屬性。 您無法使用 ASP.NET 角色功能，然後將您的站台的所有使用者都加入至不同的角色，例如系統管理員、 管理員和使用者。 當網頁載入時，您篩選程式碼會檢查使用者的角色，請比較檢查，在控制項上的授權篩選值，且使用者是系統管理員角色中的 （例如），而您必須設定控制項的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的值`admin`，無法加入控制項。  
  
 建立篩選案例的第二個步驟是撰寫程式碼來檢查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值上<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，並判斷是否要在加入其區域之前，授權的每個控制項。 有兩種方式來放置這個篩選程式碼的位置。 第一個選項是針對網頁開發人員慣用的選項。 您可以建立方法以處理<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>直接在網頁伺服器指令碼，或程式碼分隔檔案中的事件。 與事件關聯您的方法，藉由新增`OnAuthorizeWebPart`屬性的標記<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項在頁面中，如下列範例的標記程式碼所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 所有您的自訂方法需要為每個 check<xref:System.Web.UI.WebControls.WebParts.WebPart>控制篩選準則，然後根據結果，布林值指派給<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>屬性<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>物件，表示是否<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項都可以是加入。 範例 > 一節中的程式碼會示範如何執行這項操作。  
  
 放置您篩選程式碼的第二個選項是繼承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別，並覆寫檢查篩選準則的方法。 您可以覆寫以執行此兩種方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 雖然可行哪一種方法，在大部分情況下最好是覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，因為它為您提供更大以程式設計方式控制整個授權程序，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法會執行一個特定的工作也就是引發事件和處理常式的核取。 在自訂程式碼範例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別會覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定的自訂事件處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，以便處理常式能夠提供用於自訂篩選程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 這個範例會提供篩選的案例和授權的網頁開發人員的典型方式<xref:System.Web.UI.WebControls.WebParts.WebPart>將控制項加入至頁面。  
  
 在網頁上，注意`<asp:webpartmanager>`項目具有`OnAuthorizeWebPart`屬性指派給它的事件處理常式的名稱。 這個方法會檢查是否有其各自的頁面上的控制項<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性值設定為`admin`而且，如果是的話，會傳回`true`，這表示，會獲得授權，會加入至頁面。  
  
> [!NOTE]
>  請注意，控制項沒有任何值指派給<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>屬性加入，因為會假設它們不是篩選案例的一部分。 這是常見的方法是篩選案例中： 某些控制項進行篩選，和其他項目不會因為它們都假設為可供所有使用者。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 設定使用者角色已超出本主題的範圍，因為此程式碼範例不會檢查在篩選中的使用者角色。 不過，篩選控制項，根據使用者角色的案例很可能是其中一個最常見的用途，此篩選的功能之一。 如果您有角色上您的網站，而且您想要檢查這個方法，以篩選控制項中的使用者角色，方法就會類似下列程式碼區塊 （相對於上述的程式碼範例不使用角色中更簡單的方法）。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件，以表示頁面及其控制項已載入，並且頁面上的連接已啟動，可以開始共用資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>頁面完成載入程序之後的事件。 此方法會提供加入事件處理常式的方式。  
  
 網頁開發人員可以加入，將自訂事件處理常式`OnConnectionsActivated`屬性`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />中衍生方法<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件，以表示頁面及其控制項已載入，並且可以開始啟動連接的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件，開發人員提供一種機制，以程式設計方式自訂 啟用連線處理程序。  
  
 網頁開發人員可以加入，將自訂事件處理常式`OnConnectionsActivating`屬性`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />中衍生方法<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含與變更之顯示模式關聯的事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以表示網頁上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項已完成從某個顯示模式切換至另一個顯示模式的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>其基底中的方法會形成只會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />方法。 例如，變更後的顯示模式，可能會想要變更使用者介面 (UI)，根據哪個顯示器中包含模式的外觀中的項目<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />屬性。 或者，您可能想要隱藏特定內容，或顯示特定的控制項。  
  
 當您覆寫此方法時，您通常應該呼叫基底的方法覆寫的方法，最後一個步驟，讓自訂程式碼會先執行，並引發事件，指出模式變更為完整。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，包含與變更中顯示模式關聯的事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以表示網頁上的<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項正在進行從某個顯示模式切換至另一個顯示模式的程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>其基底中的方法會形成只會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />方法。 比方說，會顯示模式已變更，您可能想要檢查新的顯示模式將會 (使用<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />屬性) 並在使用者介面 (UI)，根據新的顯示模式將會進行一些變更。 如果您有自訂的顯示模式，您可能想要顯示特定的控制項，如果自訂模式即將成為新的顯示模式。  
  
 當您覆寫這個方法時，您通常應該呼叫基底方法的第一個步驟，在覆寫的方法，如此就會引發事件指出正在開始變更顯示模式。 然後，自訂程式碼可以進行變更使用者介面 (UI) 中新的顯示模式實際上不會顯示之前。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.Init" /> 事件，這是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項生命週期的第一個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法會呼叫基底方法，這會引發<xref:System.Web.UI.Control.Init>事件的控制項，然後再執行數個預備步驟的詳細資訊，例如確保只有一個執行個體<xref:System.Web.UI.WebControls.WebParts.WebPartManager>在頁面上，控制及載入個人化資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">頁面上有另一個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，在網頁上呈現 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項之前會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>方法會呼叫基底方法，這會引發<xref:System.Web.UI.Control.PreRender>控制項，然後暫存器的事件數個頁面，其中包含 Web 組件所需的用戶端指令碼控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，在剛選取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項或已清除其選取範圍之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件，通常是在開發人員可能會想要變更的使用者介面 (UI) 外觀的時間點。 例如，當新<xref:System.Web.UI.WebControls.WebParts.WebPart>選取控制項，Web 組件控制項設定變更新選取的控制項的呈現。 會清除控制項的選取範圍之後，轉譯會恢復正常。  
  
 使用者選取特定之後<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項進行編輯，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法呼叫。 當使用者完成編輯控制項，並以結果，會清除控制項的選取範圍，就會關閉它，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>再次呼叫方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>有幾個選項相關<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />事件，可讓開發人員自訂轉譯的變更所選的控制項後，就會發生。 宣告式程式碼中，內<see langword="&lt;asp:webpartmanager&gt;" />項目，您可以設定<see langword="OnSelectedWebPartChanged" />屬性，並指派給它的自訂方法的名稱。 在自訂的方法中，您可以修改所選控制項的呈現事件發生時。 另一個選項是繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫此方法。 第三個選項是以自訂轉譯在區域層級;例如，您可以繼承自<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />類別，並覆寫其<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />方法，以自訂控制項選取和編輯程序期間已清除的呈現。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，在變更目前選取之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的程序中會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>變更它的程序期間發生的事件<xref:System.Web.UI.WebControls.WebParts.WebPart>目前選取控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項會使用這個方法和相關聯的事件，以提供取消處理程序在其中變更所選的控制項的機會。 方法內的呼叫，例如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法，並也在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法，以提供方法來取消處理程序。 如果使用者按一下 [取消] 5d; 上的動詞命令正在編輯的控制項，再選取控制項和編輯的任何變更不會儲存，因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法可讓以取消編輯的變更。  
  
> [!NOTE]
>  同樣地方法的開頭和結尾連接的程序期間呼叫該方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項為其他控制項，以便取消該程序。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件加`OnSelectedWebPartChanging`屬性`<asp:webpartmanager>`宣告式網頁標記中，並將指派給屬性的自訂方法的名稱中的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">與控制項移除關聯的事件資料。</param>
        <summary>引發基底 <see cref="E:System.Web.UI.Control.Unload" /> 事件並從網頁中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項已加入至頁面之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>新增的程序期間會呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或加入至其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域) 的頁面。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件加`OnWebPartAdded`屬性加入 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，在將 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的程序中發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>表示控制項正在加入事件。 此方法也會提供取消加入程序的選項。 如果控制項已成功新增，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartAdding`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件，以表示控制項已從頁面移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件，表示<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 （或其他伺服器或使用者控制項） 已成功關閉頁面上。  
  
 若要關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是指從頁面移除，而不轉譯時，也將它放在特殊持有物件稱為頁面類別目錄。 頁面目錄中，對應至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，維護參考至已關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>每一頁的控制項。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>宣告內的頁面上的控制項<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用者可以將頁面切換成類別目錄的顯示模式，並將任何先前已關閉的控制項加入至網頁。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法提供機會讓開發人員建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。 網頁開發人員可以加入，將自訂事件處理常式`OnWebPartClosed`屬性`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。 開發人員可能會在這個方法中執行的一個有用工作用來顯示關閉的控制項取代的預留位置，完成與工具提示，告知使用者如何將控制項加入至網頁。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，從頁面正在移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的程序中會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件，代表控制項正在關閉或移除頁面。 此方法也會提供取消關閉處理序的選項。 如果控制項已成功移除頁面上，從<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartClosinging`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，從頁面永久刪除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>的刪除程序期間會呼叫方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項 (或加入至其他伺服器控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域) 的頁面。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件加`OnWebPartDeleted`屬性加入 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，表示正在刪除動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或包含在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項可以被刪除，並刪除控制項時，控制項執行個體從頁面時，會永久移除，且無法還原。 動態<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項是以程式設計的方式，加入或從 Web 組件類別目錄中，而不是靜態控制項中宣告的 Web 網頁的標記。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>表示控制項會永久刪除從其區域事件。 此方法也會提供取消刪除的程序的機會。 如果控制項已成功刪除頁面上，從<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartDeleting`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項已移至頁面上的不同位置之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件的結尾處<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，可確保移動控制項的處理程序會完成之前的任何程式碼在事件處理常式的執行。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>控制項移其目前的區域中，或另一個區域，而不論是否移動是以程式設計方式或由使用者拖曳控制項時引發事件。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件加`OnWebPartMoved`屬性加入 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，表示正在移動 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項或在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件發生時<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他伺服器控制項正在移動其區域內，或另一個區域。 此方法也會提供取消移動程序的機會。 如果順利完成移動，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartMoving`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間已建立連接之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法就會引發對應的事件的結尾處<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法，可確保連接兩個控制項所需的步驟都完成之後，事件處理常式中的任何程式碼執行之前。  
  
 此方法會提供以程式設計方式控制建立連接的程序和相關聯的事件是一個方便的點要更新的使用者介面 (UI)，或告知使用者已建立連線。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件加`OnWebPartsConnected`屬性加入 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，在建立兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或包含在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 的連接程序中發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，當兩個控制項嘗試建立連接時，就會發生此事件。 此方法提供有機會取消正在嘗試連接。 如果連接成功，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartsConnecting`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項之間的連接已結束之後會發生這個事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法就會引發對應的事件的結尾處<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，它會執行的終止兩個控制項之間的連線程序。  
  
 此方法提供結束連接的程序以程式設計方式控制，讓開發人員可以通知使用者，變更使用者介面 (UI)，或對應用程式進行其他變更。  
  
 網頁開發人員可以建立的自訂處理常式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件加`OnWebPartsDisconnected`屬性加入 <`asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，表示正在結束 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 之連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法會引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>兩個控制項都結束連接時，就會發生的事件。 此方法會提供取消中斷連線程序的機會。 如果成功移除連接，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件會依循。  
  
 網頁開發人員可以提供的自訂處理常式相關聯的事件加`OnWebPartsDisconnecting`屬性`<asp:webpartmanager>`等網頁，然後將自訂的方法名稱指派給屬性的項目。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當開發人員建立衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別可以覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />自訂事件處理方法。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含網頁個人化資料之物件的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含個人化資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性可用來存取<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>逐頁檢視相關聯的物件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 您可以使用這個屬性，存取個人化物件的各種不同的成員。 例如，您可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法切換網頁的個人化範圍從共用的使用者領域，反之亦然。 是否在哪一個提供者用於個人化資料，以及其他的頁面上，甚至啟用個人化，您也可以找出目前個人化範圍的頁面。  
  
 請注意，所參考的資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性是只有頁面層級個人化資料所追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。 控制項特定個人化資料，例如可個人化屬性的值<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是屬於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性。  
  
> [!NOTE]
>  如需有關 Web 組件個人化的詳細資訊，請參閱[Web 組件個人化概觀](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性以程式設計的方式。  
  
 在下列網頁可讓使用者進入編輯模式，若要編輯的特定層面<xref:System.Web.UI.WebControls.Calendar>控制項。 **切換範圍**按鈕切換至使用者或共用個人化範圍的頁面。 **編輯模式**和**瀏覽模式** 按鈕會分別將頁面切換成適當的顯示模式。 請注意，在`<script>`標記處理的事件使用的方法的兩個檔案的區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性來存取基礎物件的實用的成員。 具體來說，這些方法使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>透過存取的物件上屬性<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要執行程式碼範例，您也必須啟用一或多位使用者個人化在共用範圍的頁面。 在 Web.config 檔案中，加入一個項目`<system.web>`區段，看起來像下列的標記。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 在瀏覽器頁面載入之後，請按一下**切換範圍**按鈕，並請注意，頁面現在會顯示在共用範圍。 按一下**編輯模式**若要變更顯示模式，請按一下上可見的控制項，動詞命令功能表，然後選取**編輯**從功能表。 請注意，會出現兩個編輯控制項的使用者介面 (UI)。 現在按一下**瀏覽模式**返回正常瀏覽。 如果頁面會顯示在共用的範圍內，按一下**切換範圍**再次以確保使用者領域中的頁面。 接下來，請遵循相同的步驟，編輯控制項，但在編輯的 UI 中，請注意，現在<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>控制項不會出現。 這是因為共用個人化範圍頁面時，只適用於此控制項。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項發出用戶端指令碼，用於各種個人化功能，例如在網頁上拖曳 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" />，接收控制項的內容，以寫入頁面。</param>
        <summary>覆寫成防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項呈現任何內容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制狀態資料，以便在未來的要求中，將資料還原至包含此控制項的網頁。</summary>
        <returns>
          <see cref="T:System.Object" />，用來包含儲存的控制項狀態資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>方法將儲存的狀態應保存在頁面回傳的內容資料，即使<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所維護的自訂個人化狀態資料，當頁面重新載入時，讓這項資料也可以重新載入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>方法很重要進行個人化，因為它可讓個人化的使用者設定儲存為未來的瀏覽器工作階段，並瀏覽至頁面。 方法會將儲存自訂的個人化狀態資料，其中包含項目，如下所示： 動態<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項加入頁面或從刪除頁面; 已移動頁面的控制項並具有動態連接已建立或刪除。  
  
 您無法直接從您的程式碼呼叫此方法。 不過，您可以呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法，而其本身呼叫此方法來儲存個人化資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員可以覆寫這個方法在衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別來自訂儲存個人化資料的程序。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項的參考，這個控制項目前選為要進行編輯或建立與另一個控制項的連接。</summary>
        <value>目前選為要編輯或建立連接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>屬性會傳回參考<xref:System.Web.UI.WebControls.WebParts.WebPart>或目前未選取進行編輯或建立連接與另一個控制項的其他伺服器控制項。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項提供數種有用的方法和事件的處理程序的選取控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>只選取控制項之後，但進行任何變更之前，就會發生事件。 若要執行某些控制項上的動作之後加以選取，請覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 比方說，您可能想要變更的控制項選取但未變更，以視覺化方式強調選取的控制項的外觀。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>之後已變更選取的控制項，就會發生事件。 若要變更後執行某些控制項上的動作，請覆寫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>某個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項的選取範圍已變更並移至網頁上的另一個控制項之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用於搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法，以變更選取的控制項的使用者介面 (UI)。 比方說，如果使用者切換到設計模式的頁面 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)，然後選取<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項目的，是將它拖曳到新位置，通常會藉由變更色彩，例如變更的呈現方式選取的控制項，其框線或背景時選取它。  
  
> [!NOTE]
>  如需有關如何使用事件的詳細資訊，請參閱[How to： 使用 Web Form 應用程式中的事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在網頁上變更目前選取之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用於搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 網頁開發人員可以建立程式碼中的事件處理常式加`OnSelectedWebPartChanging`屬性`<asp:webpartmanager>` 頁面上，並將屬性的值設定為自訂的方法名稱中的項目即將處理此事件。  
  
 開始或結束連接控制項之間，以及當開始和結束的編輯控制項的程序期間，會引發這個事件。 如需詳細資訊，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>直接結果的變更所選的控制項的使用者動作，就會引發事件，可以取消事件。 不過，是無法取消事件中的案例。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>就在刪除控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 不使用者，而且它必須決定目前選取的控制項，以及何時變更選取範圍沒有任何中斷的機會，讓它能完成的清理程序所有控制項。 因此，根據設計<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>方法無法在此案例中取消。 相關事件可取消，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>設定旗標，表示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化資料已經變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法會設定旗標，最終導致 Web 組件控制項設定為將更新的個人化資料儲存中的 個人化元件。 如需詳細資訊，可能會導致個人化資料所追蹤的變更之案例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>無法直接從您的程式碼呼叫方法，它無法覆寫，因為它供內部 Web 組件控制項設定為 Web 組件個人化功能的一部分。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>呼叫此方法由衍生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別。 這會是很有用，如果您想要自訂的個人化的 Web 組件控制項的元件集，並因此需要控制設定個人化資料的旗標的程序。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">選取的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</param>
        <summary>將 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 屬性值設為等於目前選取的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>開頭或結尾所指定的控制項編輯的處理序期間會呼叫方法`webPart`參數，且開頭或結尾包含連線的`webPart`。  
  
 編輯和連接處理程序的開頭`webPart`是已選取要編輯，或輸入連接的控制。  
  
 編輯和連接處理程序的結尾`null`傳遞至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法，會導致取消選取目前選取的控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定空字串 ("")，不讓任何面板套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項。</summary>
        <value>空字串，防止面板套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>屬性會覆寫繼承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>屬性可防止<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，這是不可見的控制項，從使用面板。 屬性的實作可防止面板指派由一律會傳回空字串從`get`存取子，並一律在嘗試設定中的值是否擲回例外狀況`set`存取子。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">已嘗試設定屬性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上定義為靜態連接之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 物件集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含頁面上的所有靜態連接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性供<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項來追蹤和管理頁面上的所有靜態連接。 靜態連接，相較於動態的連接，不必每次在呈現的頁面加入至網頁。  
  
 這個屬性所參考的集合包含所有存在的頁面，是否會在建立以程式設計方式或使用指定的靜態連接`<asp:webpartconnection>`在網頁標記中的項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更 Web 組件頁面上的顯示模式。  
  
-   原始程式碼檔，其中包含兩個自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項和自訂的介面。  
  
-   包含兩個自訂的網頁<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項並`<asp:webpartmanager>`項目。  
  
-   此範例在瀏覽器中的運作方式的說明。  
  
 下列程式碼包含只網頁的部分範例。 您也要取得範例-自訂使用者控制項及原始程式碼的自訂控制項和介面-前兩個部分的範例 > 一節從<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 該主題也說明您的選項來編譯<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。  
  
 程式碼範例的第三個部分是 Web 網頁。 網頁的宣告式標記包含`Register`使用者控制項，並自訂控制項的指示詞。 沒有`<asp:webpartmanager>`項目，`<asp:webpartzone>`項目來包含自訂控制項和`<asp:connectionszone>`項目。 請注意，在`Page_Load`方法時，程式碼是否連線已經存在，而且，如果沒有，請定義提供者、 取用者，以及其各自的連接點，會檢查並再加入新的連接所參考的靜態連接的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>屬性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 您已載入網頁瀏覽器中之後，請按一下**顯示模式**下拉式清單控制項，然後選取**連接**切換頁面，即可連接模式。 連接模式使用`<asp:connectionszone>`項目可讓您建立控制項之間的連接。 在連接模式中，按一下標題列中的向下箭號**郵遞區號**啟動其動詞命令功能表中，控制項，然後按一下**連接**。 連接使用者介面 (UI) 出現之後，請注意連接確認已建立的程式碼中包含`Page_Load`方法。 如果您在更新版本的瀏覽器工作階段中傳回此頁面，此靜態連接將會建立，且不需要重新建立每次載入頁面。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得特定網頁上所有可用顯示模式的唯讀集合。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定網頁上可用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 物件集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性包含僅會在頁面上，指定區域在頁面上出現的控制項種類實際可用的顯示模式。  
  
> [!NOTE]
>  顯示模式可以停用，並停用的顯示模式時，它不會加入至<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>集合，即使對應支援顯示模式的區域類型存在於頁面上。  
  
 一律支援瀏覽模式和設計模式。 可以改變的顯示模式是編輯、 目錄和連接模式。 每一種顯示模式都與特定類型的<xref:System.Web.UI.WebControls.WebParts.ToolZone>控制項。 它是特別具型別會造成特定的顯示模式来加入至所參考的集合在網頁上區域的存在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 例如，如果網頁包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>而非區域<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，然後編輯顯示模式是其中一個支援的模式，在該頁面上，但是不支援類別目錄的顯示模式。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性不同於<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>屬性，即在參考集合，其中包含所有目前可用的顯示模式<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，即使不是支援的特定頁面。  
  
   
  
## Examples  
 下列程式碼範例示範如何以程式設計方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>屬性。 程式碼會使用這個屬性來填入清單，只顯示可用的模式在目前的網頁。  
  
 有三個支援此頁面上顯示模式： 瀏覽、 設計和編輯。 前兩個一律可用，以及編輯模式是用於此程式碼範例，因為此頁面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>控制項。 類別目錄和連線的顯示模式不會顯示，因為其對應的區域不在此頁面上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 在瀏覽器頁面載入之後，您可以使用下拉式清單控制項切換到設計模式，將頁面從瀏覽模式，然後編輯模式。 您可以在編輯模式中，按一下下拉式清單動詞命令功能表中的伺服器控制項的其中一個標頭，並選取**編輯**，編輯控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理的自訂個人化狀態資料是否已變更。</summary>
        <value>布林值，指出自訂個人化狀態資料是否已變更。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性可讓呼叫端若要判斷是否個人化狀態由管理的資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已變更。 當使用者個人化頁面層級的詳細資訊，例如藉由變更頁面配置、 建立或刪除連接，並由加入或刪除控制項，管理個人化資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的變更。 這是受保護的值傳回呼叫端傳遞方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>屬性，無法直接存取的呼叫端。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性不會指出是否可個人化的屬性值或個別的屬性會影響個別的外觀<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，已經變更。 控制層級個人化個別追蹤每個控制項。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性只會指出是否個人化資料，在頁面層級且受<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已變更。  
  
 下列清單將描述一些常見的執行個體的個人化，可能導致<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性傳回的值`true`，這表示，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項有某些變更個人化資料：  
  
-   關閉靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>頁面上，控制項 （或伺服器或使用者控制項）。  
  
-   還原已關閉的靜態<xref:System.Web.UI.WebControls.WebParts.WebPart>回到頁面從頁面類別目錄的控制項。  
  
-   在其區域內，或另一個區域，請移動任何控制項。  
  
-   將控制項加入從目錄<xref:System.Web.UI.WebControls.WebParts.WebPart>或伺服器控制項，或以程式設計方式加入控制項。  
  
-   建立兩個連接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，以程式設計方式或使用連接的使用者介面 (UI)。  
  
-   刪除兩個連接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，以程式設計方式或使用連接 UI。  
  
 若要存取這個屬性值，您必須轉換<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項執行個體<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>介面; 您可以再讀取<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>屬性值。  
  
   
  
## Examples  
 下列程式碼範例示範簡單的使用方式的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>屬性，以表示某些常見的網頁個人化執行個體且導致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>變更控制項的個人化資料。  
  
 程式碼範例包含四個部分：  
  
-   使用者控制項，可讓您變更包含 Web 組件控制項的頁面上的顯示模式。  
  
-   包含兩個自訂的程式碼的原始程式檔<xref:System.Web.UI.WebControls.WebParts.WebPart>可連接控制項和介面。  
  
-   裝載的所有控制項的網頁。  
  
-   程式碼範例的運作方式的說明。  
  
 程式碼範例的第一個部分是使用者控制項變更顯示模式。 您可以從範例 > 一節的取得使用者控制項的原始程式碼<xref:System.Web.UI.WebControls.WebParts.WebPartManager>類別概觀。 顯示模式和使用者控制項的運作方式的相關資訊，請參閱[逐步解說： 變更 Web 組件頁面上顯示的模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此範例的第二個部分是原始程式檔，以自訂控制項和介面。 請注意，`IZipCode`介面會公開一種方法，並為此方法實作中自訂`ZipCodeWebPart`控制項做為回呼方法以啟用`ZipCodeWebPart`做為連接案例中的提供者。 另一個控制項`WeatherWebPart`，做為取用者控制連接; 它可以使用所提供的特定介面`ZipCodeWebPart`。 在實際應用，`WeatherWebPart`無法使用個人化的郵遞區號值從提供者，然後再提供圖形化的氣象資訊給使用者。  
  
 若要執行程式碼範例，您必須編譯這個原始程式碼。 您可以明確地進行編譯，並將產生的組件放在您的網站的 Bin 資料夾或全域組件快取。 或者，您可以將原始程式碼放在您的網站 App_Code 資料夾中，這樣就會在執行階段進行動態編譯。 這個程式碼範例會使用動態編譯。因此，請注意，`Register`頂端網頁上的此元件的指示詞只能包含`TagPrefix`和`Namespace`屬性，而不`Assembly`屬性。 如需示範如何編譯的逐步解說，請參閱[逐步解說： 開發和使用自訂 Web 伺服器控制項](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 程式碼範例的第三個部分是 Web 網頁。 請注意，它包含兩個<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域，其中包含兩個自訂的第一個<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 另外還有<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，其中包含標準<xref:System.Web.UI.WebControls.Calendar>使用者可以將頁面加入的控制項。 `<asp:connectionszone>`項目會提供 UI，讓使用者能夠建立控制項之間的連接的連接。 在`Page_PreRender`方法，請注意，若要查看是否已變更個人化資料，而且如果是，它會檢查更新的文字`Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 在瀏覽器頁面載入之後，嘗試建立一些會變更個人化資料本主題的 < 備註 > 一節所列的案例。 當您進行各種變更時變更涉及所追蹤的個人化案例的其中一個,<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，文字`Label1`控制項顯示，指出已變更個人化資料。 例如，您可以：  
  
-   按一下控制項之間建立連線**連接 web 組件控制項** 按鈕。  
  
-   使用**顯示模式**下拉式清單控制項以將頁面切換至目錄的模式，並加入**我的行事曆**第二個控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
-   變更頁面回瀏覽模式中，按一下功能表的動詞命令 （顯示在標題列中的箭頭符號） 的**我的行事曆**控制項，然後選取**關閉**關閉它，並將其加入至頁面類別目錄。  
  
-   將網頁傳回給目錄的模式，並加入**我的行事曆**回到頁面的控制項。  
  
-   使用**顯示模式**控制，將頁面切換到設計模式，並拖曳其中一個或多個檔案至另一個區域，或相同區域中的不同位置，重新排列控制項的配置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，其中包含要載入的狀態資料。</param>
        <summary>傳回之前已儲存且需要載入到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的自訂個人化狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是實作<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>方法，它提供的 Web 組件控制項設定為直接存取受保護的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 呼叫這個方法時，它會儲存自訂的個人化的資料受<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項，而且先前儲存在永久的資料存放區初始化程序中稍後使用。  
  
> [!NOTE]
>  在大部分情況下，頁面和控制項的開發人員程式碼不會不需要呼叫這個方法，因為主要是由 Web 組件控制項設定為擷取個人化資料的機制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>讓開發人員會使用這個方法的其中一個情況是如果他們正在開發一個自訂的個人化架構，以用來取代一個由提供 Web 組件控制項集合。 在這種情況下，開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法傳回的自訂實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件。 自訂<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件會呼叫的實作<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />在適當的時間載入自訂的個人化資料的方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含所要儲存的狀態資料。</param>
        <summary>儲存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項所管理的自訂個人化狀態資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法是實作<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>方法，它提供的 Web 組件控制項設定為直接存取受保護的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 呼叫這個方法時，它會將儲存所管理的所有個人化的資料<xref:System.Web.UI.WebControls.WebParts.WebPartManager>Web 組件的應用程式設定的永久資料儲存區的控制項。  
  
> [!NOTE]
>  在大部分情況下，頁面和控制項的開發人員程式碼不會不需要呼叫這個方法，因為主要是由 Web 組件控制項設定為儲存個人化資料的機制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開發人員會使用這個方法的其中一個情況是如果他們正在開發一個自訂的個人化架構，以用來取代一個由提供 Web 組件控制項集合。 在這種情況下，開發人員無法繼承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />類別並覆寫<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法傳回的自訂實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件。 自訂<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />物件會呼叫的實作<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />在適當的時間來儲存自訂的個人化資料的方法。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將個人化狀態資料套用至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項，並呼叫基底方法，以啟用控制項檢視狀態資料之變更的追蹤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢視狀態資料變更會儲存在<xref:System.Web.UI.StateBag>物件，並可透過控制項的存取<xref:System.Web.UI.Control.ViewState%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得允許子控制項為可見的值。</summary>
        <value>布林值，指出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項及其子控制項是否為可見 所有情況下都是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Control 覆寫基底<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>屬性一律會傳回值為`true`如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性。 即使<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項本身不可見，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性必須設為`true`使其所有子控制項都都預設為可見。  
  
 如果您嘗試設定的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>屬性，它一定會產生錯誤因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項已覆寫基底屬性行為，並防止任何值指派給屬性。  
  
 這個屬性不是在視覺化設計工具，可繫結，但可在執行階段繫結。 如需詳細資訊，請參閱<xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">嘗試指派值給此屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項已加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域之後發生，以表示控制項已成功加入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件可用於指出動態控制項 （以程式設計的方式，加入，而不是在網頁標記中所宣告的控制項） 是否已成功新增至區域。 搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法，這個事件提供開發人員一種方式更新使用者介面 (UI) 或否則通知使用者已成功加入控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項加入至 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>開始新增控制項至區域的程序之後的方法。 此事件會提供完成之前取消此程序的機會。 如果成功加入程序，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。  
  
 網頁開發人員可以提供事件的自訂處理常式加`OnWebPartAdding`屬性`<asp:webpartmanager>`項目 頁面上，指定給該屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 從頁面移除時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件表示，控制項已經成功地關閉，依使用者或以程式設計的方式。 若要關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是指從頁面移除，而不轉譯時，也將它放在特殊持有物件稱為頁面類別目錄。 頁面目錄中，對應至<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制項，維護參考至已關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>每一頁的控制項。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>宣告內的頁面上的控制項<xref:System.Web.UI.WebControls.WebParts.CatalogZone>區域，使用者可以將頁面切換至目錄的顯示模式，並將任何先前已關閉的控制項加入至頁面。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法，這個方法會引發事件，而且提供的處理常式。  
  
 網頁開發人員可以加入，將自訂事件處理常式`OnWebPartClosed`屬性`<asp:webpartmanager>`項目 頁面上，然後將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從頁面移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法時<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項正在關閉控制。 如果成功移除控制項，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。  
  
 網頁開發人員可以提供自訂事件處理常式加入`OnWebPartClosed`屬性加入 <`asp:webpartmanager>`項目 頁面上，指定給該屬性的自訂方法名稱。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>就會引發事件的直接結果的使用者關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，可以取消事件。 不過，是無法取消事件中的案例。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>就在刪除控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項，不是使用者。 與時機<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項正在呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法，關閉每個控制項，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>就會引發事件，事件無法取消 （符合設計），因為<xref:System.Web.UI.WebControls.WebParts.WebPartManager>必須完成的清除工作所有區域的控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域中已刪除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他伺服器控制項之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件可用於指出動態控制項 （以程式設計的方式，加入，而不是在網頁標記中所宣告的控制項） 是否已成功刪除從區域。 搭配<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法，這個事件會提供一種方式，來更新使用者介面 (UI) 或否則通知使用者已成功刪除控制項的開發人員。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將動態 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他伺服器控制項的執行個體從 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域永久刪除的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法，刪除動態控制項 （一個以程式設計方式或透過 Web 組件的使用者介面的使用者已加入） 的過程。 事件會提供完成之前取消此程序的機會。 如果順利完成刪除程序，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。  
  
 網頁開發人員可以提供事件的自訂處理常式加`OnWebPartDeleting`屬性`<asp:webpartmanager>`項目 頁面上，指定給該屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項已移至網頁上的不同位置之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 （在網頁標記中宣告） 的靜態和動態控制項適用於此事件。 相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法。 移動完成之後，就會引發事件，因為開發人員可以包含提供給使用者、 驗證或執行其他動作的相關通知的事件處理常式。 若要加入事件處理常式，您可以加入`OnWebPartMoved`屬性`<asp:webpartmanager>`元素在頁面上，並指派給屬性的自訂方法的名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移動 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 區域所包含之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他伺服器控制項的程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>就會引發事件時<xref:System.Web.UI.WebControls.WebParts.WebPart>或它自己的區域內，或另一個區域，移動其他伺服器控制項。 當使用者拖曳控制項，及以程式設計方式移動時，也可能會發生。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法，這個方法，並提供完成之前取消移動程序的機會。 如果已完成的移動，並放在新位置的控制項，此事件後面是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。  
  
 網頁開發人員可以建立自訂事件處理常式加入`OnWebPartMoving`屬性`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項所追蹤之所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控制項的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制集的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性供<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項以追蹤所有<xref:System.Web.UI.WebControls.WebParts.WebPart>內所包含的控制項<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>網頁的區域。 集合是唯讀的雖然您可以存取個別<xref:System.Web.UI.WebControls.WebParts.WebPart>以程式設計方式控制透過它們集合並變更。  
  
> [!NOTE]
>  很可能有<xref:System.Web.UI.WebControls.WebParts.WebPart>之外的頁面上的控制項置於<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域使用，這會導致控制項沒有追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartManager>所參考或控制其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>集合。 不過，沒有什麼道理使用<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項區域外,，因為它然後失去其 Web 組件的功能，並做為一般的伺服器控制項。  
  
 任何類型的控制項，可放置在區域中，是否自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 標準的 ASP.NET 控制項、 使用者控制項或自訂伺服器控制項，可用來當做<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項在執行階段。 控制項時，不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項放入<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域，在 ASP.NET 包裝的控制項的執行階段<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件，使控制項可以如同真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 因此，藉由<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項可以追蹤任何類型的伺服器控制項，不論是否衍生自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性以程式設計方式來存取個別<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項。 請注意，在網頁的宣告式標記內`<asp:webpartzone>`有項目是兩個標準的 ASP.NET 伺服器控制項。 雖然這些不會繼承自<xref:System.Web.UI.WebControls.WebParts.WebPart>類別，因為它們是將各加上方區域中<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>物件在執行階段，並因此將會包含在所參考的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性。 您也可以加入自訂<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 使用者控制項或自訂伺服器控制中的這個區域中，並且會處理這些相同的方式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 請注意，工作的程式碼範例，您必須新增設定，若要啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 確定您具有網頁上的相同目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請確定沒有`<webParts>`具有項目`enableExport`屬性設為`true`，在下列標記中。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 您載入網頁瀏覽器中，如果您按一下之後**WebPart 計數**按鈕時，程式碼會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>屬性集合中傳回控制項的計數。 如果您按一下**隱藏日曆標題**按鈕時，程式碼會變更行事曆，讓它只會以框線和標題不會呈現。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或伺服器或使用者控制項) 之間建立特定連接之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法。 此事件很有用，因為您知道連接完成之後，您可能想要通知使用者的事實，或甚至變更頁面的使用者介面 (UI)。 例如，您可能想要顯示特定圖形影像，表示成功連接兩個控制項，或顯示簡短訊息，然後將頁面顯示模式變更回瀏覽模式。  
  
 網頁開發人員可以關聯的自訂事件處理常式與此事件加入`OnWebPartsConnected`屬性`<asp:webpartmanager>`項目頁面上，指定給該屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在建立 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控制項 (或位於 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域中的伺服器或使用者控制項) 之間的連接程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法，以及它會通知已開始連線程序 （例如，使用者已選取的控制項並按一下連接的動詞命令），但尚未完成。 這個事件會提供完成之前取消連線的機會。 如果已成功完成連線，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。  
  
 網頁開發人員可以加入，將自訂事件處理常式`OnWebPartsConnecting`屬性`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>兩個 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項之間的連接已結束之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件相關聯<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法。 此事件很有用，因為您知道連接終止之後，您可能想要通知使用者、 在程式碼中，執行某些清除動作，或在使用者介面 (UI) 中進行其他變更。  
  
 網頁開發人員可以關聯的自訂事件處理常式與此事件加入`OnWebPartsDisConnected`屬性`<asp:webpartmanager>`項目頁面上，指定給該屬性的自訂方法名稱。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在結束先前連接之 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或伺服器控制項的連接程序中發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>就會引發事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法，並發出訊號事實使用者已按一下中斷連線動詞或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>否則呼叫方法。 這個事件會提供取消處理程序完成之前結束連接的機會。 如果連接就會順利結束，此事件後面接著<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。  
  
 網頁開發人員可以加入，將自訂事件處理常式`OnWebPartsDisconnecting`屬性`<asp:webpartmanager>`項目，並將自訂的方法名稱指派給屬性。  
  
 通常，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>直接結束連接的使用者動作的結果就會引發事件，可以取消事件。 不過，有幾個案例中不能取消事件。 第一個案例是，如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>就在刪除控制項<xref:System.Web.UI.WebControls.WebParts.WebPart>它所包含的控制項必須全部關閉，否則它們會被遺棄。 在此情況下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制關閉<xref:System.Web.UI.WebControls.WebParts.WebPart>控制項、 不使用者，和它也必須能夠終止的任何連接控制項沒有任何可能發生的中斷連線，讓它能完成的清除和關閉程序所有控制項。 因此，根據設計<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法無法在此案例中取消。 相關事件可取消，請參閱<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 中的第二個案例<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>無法取消事件時<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>呼叫方法時 （這稱為期間每個要求頁面時，例如），並沒有某種類型的頁面上的現有連線中的衝突。 比方說，可能是使用者連線到控制項 y 的控制項 x，但共用的使用者控制項來控制 z，x 連接和控制 x 尚不允許建立多個連接。 在此情況下，個別使用者的連線設定的優先順序，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項解決衝突，藉由呼叫<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法和結束之間的連線 x 和 z 特定的使用者。 這個中斷連線基本的設計來解決衝突，所以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>無法在此案例中取消事件。  
  
 第三個的案例，其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法無法取消時<xref:System.Web.UI.WebControls.WebParts.WebPart>或目前連接的伺服器控制項刪除或已關閉。 因為控制項一定會從網頁中移除，所以邏輯上也来移除其連線。 因此，當<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項叫用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，進而引發<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，根據設計有不是可能取消事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域之集合的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" />，參考 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 區域的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性供<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項以追蹤<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>網頁上的區域。 請注意屬性並未參考所有類型的區域。它會參考衍生自的區域<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>類別，包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>區域。  
  
 雖然屬性所參考的集合是唯讀，但您可以使用它來存取集合中的個別物件和程式設計方式使用它們。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性以程式設計方式來存取個別<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>區域控制項。 請注意，在宣告式 Web 網頁標記中，有兩個`<asp:webpartzone>`項目，每個都包含伺服器控制項。 在`<script>`頁面時，程式碼使用區段<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>屬性來存取個別的區域，列出所有區域 Id，然後變更 第二個區域的背景色彩。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 請注意，工作的程式碼範例，您必須新增設定，若要啟用匯出 Web 組件描述檔案的 Web.config 檔案中。 確定您具有網頁上的相同目錄中的 Web.config 檔案，此程式碼範例。 內`<system.web>`區段中，請確定沒有`<webParts>`具有項目`enableExport`屬性設為`true`，在下列標記中。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 您載入網頁瀏覽器中，如果您按一下之後**清單區域 Id**按鈕時，程式碼會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>列出的所有區域集合中的 Id 屬性。 如果您按一下**變更區域的背景色彩**按鈕時，程式碼變更第二個區域的背景色彩。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>