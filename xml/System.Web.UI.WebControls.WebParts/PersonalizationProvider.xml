<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="54103b25251ca76be386820236610217228c9efe" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46693832" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>實作個人化提供者的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是定義為個人化提供者的必要的功能的抽象基底類別。 個人化提供者載入和儲存個人化資料，代表<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>執行個體。  
  
 基底類別定義一些方法; 的標準的行為只有在特別處理基礎資料存放區的方法會標記為抽象的。 這可讓開發人員撰寫自訂提供者互動的特定資料存放區中，而不必重新實作所使用的標準功能<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>類別。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>您可以從衍生<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />，並提供 只有這個類別中定義的抽象方法的實作。 抽象方法處理，特別是儲存及載入資料的實體資料存放區中，與資料存放區管理。 自訂提供者必須能夠管理個人化資訊的方式，可區別<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />來自<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />資料。 此外，提供者必須區隔個人化資料，由頁面以及應用程式。  
  
實作<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />緊密結合的實作<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />因為一些個人化提供者方法傳回的執行個體<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-衍生的類別。 為了簡化開發自訂的提供者<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />基底類別包含的個人化的邏輯和序列化/還原序列化邏輯，會使用直接的預設實作<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />類別。 如此一來，撰寫自訂的提供者，專門用來與不同的資料存放區的工作只會要求下列的抽象方法的實作： 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -此方法必須要能夠計算提供的查詢參數的資料庫中的個人化資料列數目。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -指定的路徑和使用者名稱，這個方法會載入兩個二進位大型物件 (Blob) 從資料庫： 一個用於共用的資料，一個用於使用者資料的 BLOB。 如果您提供的使用者名稱和路徑，則您不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項來存取可提供使用者名稱/路徑資訊的頁面資訊。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> -指定的路徑和使用者名稱，則這個方法會刪除資料庫中對應的資料列。 如果您提供的使用者名稱和路徑，則您不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項來存取可提供使用者名稱/路徑資訊的頁面資訊。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -指定的路徑和使用者名稱，這個方法會儲存到資料庫所提供的 BLOB。 如果您提供的使用者名稱和路徑，則您不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制項來存取可提供使用者名稱/路徑資訊的頁面資訊。  
  
在所有這些方法中，如果只有提供路徑，則表示要對頁面共用個人化資料。 如果路徑以及使用者名稱傳遞至方法時，頁面的使用者個人化資料應該在發生作用。 若是<see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />，應該一律載入指定的路徑的共用的資料，並選擇性地路徑的使用者個人化資料也載入如果使用者名稱不是<see langword="null" />。  
  
所有其他抽象的方法是只有在系統管理應用程式，並不會使用 Web 組件基礎結構在執行階段。 如需的個人化提供者實作的範例，請參閱<see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />類別。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="http://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 組件頁面</related>
    <related type="Article" href="http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Web 組件個人化概觀</related>
    <related type="Article" href="http://msdn.microsoft.com/library/a88d2bd5-4932-4ec1-b176-7d7da45f85d9">逐步解說： 實作使用者控制的 Web 組件個人化</related>
    <related type="Article" href="http://msdn.microsoft.com/library/7885563f-7bbe-45a0-b5e2-c6bf1bc2deaa">Web 組件個人化</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為這是抽象類別的建構函式時，您必須覆寫這個方法，以建立繼承自這個類別的類別的執行個體。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得或設定為提供者設定的應用程式名稱。</summary>
        <value>為個人化提供者設定的應用程式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在組態檔中使用未指定應用程式名稱[（ASP.NET 設定結構描述） webParts 之 personalization 的 providers 項目](http://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195)屬性，值<xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>屬性使用。  
  
> [!CAUTION]
>  因為所提供的所有要求都使用單一的預設個人化提供者執行個體<xref:System.Web.HttpApplication>物件，您可以有多個要求同時執行，每個嘗試設定<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>屬性值。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>屬性不是安全執行緒的多個寫入，以及變更<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>屬性值可能會導致非預期的行為，應用程式的多個使用者。 建議您避免程式碼，讓使用者設定<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>屬性才。 設定<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>屬性可能是必要項，例如，在管理多個應用程式的個人化資料的系統管理應用程式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 物件清單，表示 Web 組件控制集使用的一組已知能力。</summary>
        <returns>
          <see cref="T:System.Collections.IList" />，表示 Web 組件控制集使用的一組已知能力。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，這個方法會傳回包含兩個功能的清單：<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>。 這些是可以在定義的預設功能[（ASP.NET 設定結構描述） webParts 之 personalization 的 authorization 項目](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)內的項目[(ASP.NET webParts 的 personalization 項目設定結構描述）](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)項目[webParts 項目 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)組態區段。 如果您選擇實作的自訂個人化基礎結構，您可以覆寫這個方法，並定義您自己的授權相關的使用者功能集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資訊。</param>
        <param name="loadedState">個人化狀態資訊。</param>
        <summary>決定初始個人化範圍應當是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 還是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 範圍。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，指出目前的個人化範圍是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 還是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會判斷是否應為目前的領域<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>或是<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，參考<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制及個人化狀態已經載入從稍早在個人化生命週期中的資訊。 這項資訊由<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>後續的個人化相關工作的執行個體。  
  
 下列規則用來決定個人化範圍：  
  
-   範圍一開始假設為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果目前正在執行的使用者帳戶未經過驗證，則範圍會設定為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果目前正在執行的使用者帳戶的驗證，則會在優先順序中進行其他處理：  
  
    -   如果網頁為回傳模式，頁面要求就會包含來自先前呈現頁面的範圍資訊。 如果該範圍的資訊指出<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>使用範圍，則範圍會評估為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
    -   如果目前正在執行的頁面必須從另一個頁面傳送給它的控制項 (例如，如果將控制轉移的原因呼叫<xref:System.Web.HttpServerUtility.Transfer%2A>方法; 請注意，這個特定的檢查不會發生跨網頁公佈)，如果先前執行網頁有<xref:System.Web.UI.WebControls.WebParts.WebPartManager>執行個體，範圍設定的值為`Personalization.Scope`屬性從先前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>執行個體。  
  
    -   如果不符合上述準則，則範圍評估為值<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>目前的屬性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項。  
  
 在進行先前的評估之後，，和範圍評估為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>範圍，就會發生下列處理：  
  
-   如果目前正在執行的使用者帳戶具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，範圍仍然設為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果目前正在執行的使用者帳戶並沒有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，則範圍會重設為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果所有先前的範圍內評估結果為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>，此結果會儲存為目前正在執行的頁面上的隱藏欄位。 這是藉此頁面可以重新執行後續的回傳期間範圍內評估的機制。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">與 <paramref name="webPartManager" /> 關聯的頁面為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資訊。</param>
        <summary>傳回包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 執行個體的字典，表示目前執行之使用者帳戶的個人化相關能力。</summary>
        <returns>如果使用者帳戶已驗證，則為包含零或多個 <see cref="T:System.Collections.IDictionary" /> 執行個體的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />；如果執行使用者帳戶未經驗證，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會使用中的資訊[（ASP.NET 設定結構描述） webParts 之 personalization 的 authorization 項目](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)內的項目[個人化項目為webParts （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)項目[webParts 項目 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)組態區段，在 Machine.config 或 Web.config 檔案以判斷使用者的授權功能。  
  
 在字典中的功能將會隸屬<xref:System.Collections.IList>所傳回的物件<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A>方法，目前包括<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">與 <paramref name="webPartManager" /> 關聯的頁面為 <see langword="null" />。  
  
\-或- 
與網頁關聯的要求為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，含有要查詢的個人化資訊。 這個值不能是 <see langword="null" />。</param>
        <param name="query">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />，含有查詢。 這個值可以是 <see langword="null" />。</param>
        <param name="pageIndex">查詢的起始位置。</param>
        <param name="pageSize">要傳回的資料錄數。</param>
        <param name="totalRecords">可用的資料錄總數。</param>
        <summary>在衍生類別中覆寫時，根據範圍和特定查詢參數，傳回包含零或多個 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 衍生物件的集合。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />，含有零或多個 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 衍生物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是查詢的個人化資料的系統管理方法的抽象定義。 衍生的實作應該遵循以下所述的邏輯。  
  
 傳回的項目組受到`pageIndex`並`pageSize`參數，其中`pageSize`設定要傳回的記錄數目和`pageIndex`設定要傳回的記錄。 比方說，`pageIndex`為 0， `pageSize` 25 個會傳回前 25 個相符項目，雖然`pageIndex`為 1 和`pageSize`25 個會傳回出現 26 50。 如果您想要擷取所有可用的記錄，設定`pageIndex`為 0 並`pageSize`至<xref:System.Int32.MaxValue>。  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-會依字母順序傳回衍生的物件，並將其排序依據的組合他們<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A>和<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A>屬性值，同時以遞增順序。  
  
 此方法會查詢萬用字元的字元傳遞至基礎資料存放區。 目前相依於每個提供者如何處理字元，例如星號 （*）、 百分比符號 （%） 或底線 (_) 萬用字元的支援。  
  
 一般來說，針對 SQL 相容的資料存放區，您可以執行萬用字元搜尋部分的路徑包含萬用字元，不會出現在開頭、 結尾或搜尋字串中的文字中間<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性。 例如，若要尋找開頭為"~/vdir，「 所有路徑<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性會設定為"~/vdir%」。  
  
 同樣地，部分的使用者名稱的萬用字元搜尋可能會出現在任何時間點的文字字串中的萬用字元<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性。 例如，若要尋找所有的使用者名稱開頭的"John"，<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>參數會看起來像"John %"。  
  
 適用於下列的查詢條件約束：  
  
-   如果只有`scope`提供，並`query`是`null`上的所有屬性或`query`傳回`null`或預設值，則比對所指定的所有記錄`scope`參數會傳回。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性不是`null`，傳回的記錄也會比對的篩選根據的路徑<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性不是`null`，傳回的記錄也會篩選根據的使用者名稱符合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性不等於<xref:System.DateTime.MaxValue>，則傳回的記錄也會篩選為傳回與非作用中使用者相關聯的記錄。 比較包含記錄所在<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>屬性小於或等於<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性。  
  
 請注意，這個方法不會驗證查詢參數的組合。 比方說，程式碼可以要求一組共用範圍中的特定使用者名稱相關聯的個人化狀態記錄。 因為使用者名稱不是共用的資訊與相關聯，則傳回的集合會是空白。  
  
 有可能會傳回空集合的參數組合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 結合的範圍<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 範圍中的任何或所有的值組合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，含有要查詢的個人化資訊。 這個值不能是 <see langword="null" />。</param>
        <param name="query">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />，含有查詢。 這個值可以是 <see langword="null" />。</param>
        <summary>在衍生類別中覆寫時，會傳回特定範圍內存在的基礎資料存放區中的資料列數目。</summary>
        <returns>基礎資料存放區中針對特定 <paramref name="scope" /> 參數而存在的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是抽象的定義，管理方法來擷取個人化資料的計數。 衍生的實作應該遵循以下所述的邏輯。  
  
 此方法會查詢萬用字元的字元傳遞至基礎資料存放區。 目前相依於每個提供者如何處理字元，例如星號 （*）、 百分比符號 （%） 或底線 (_) 萬用字元的支援。  
  
 一般來說，針對 SQL 相容的資料存放區，您可以執行萬用字元搜尋部分的路徑包含萬用字元，不會出現在開頭、 結尾或搜尋字串中的文字中間<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性。 例如，若要尋找開頭為"~/vdir，「 所有路徑<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性會設定為"~/vdir%」。  
  
 同樣地，部分的使用者名稱的萬用字元搜尋可能會出現在任何時間點的文字字串中的萬用字元<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性。 例如，若要尋找所有的使用者名稱開頭的"John"，<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>參數會看起來像"John %"。  
  
 適用於下列的查詢條件約束：  
  
-   如果只有`scope`提供，並`query`是`null`上的所有屬性或`query`傳回`null`或預設值，則比對所指定的所有記錄`scope`參數會計算。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性不是`null`的計數的記錄也會比對的篩選根據的路徑<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性不是`null`的計數的記錄也會篩選根據的使用者名稱符合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>屬性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性不等於<xref:System.DateTime.MaxValue>，然後計算的記錄也會篩選為傳回與非作用中使用者相關聯的記錄。 比較包含記錄所在<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>屬性小於或等於<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性。  
  
 請注意，這個方法不會驗證查詢參數的組合。 比方說，程式碼可以要求在共用的範圍內的特定使用者名稱與相關聯的個人化狀態記錄的計數。 使用者名稱不是共用的資訊與相關聯的因為傳回的計數會是零。  
  
 有可能會傳回非零計數的參數組合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 結合的範圍<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>屬性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 範圍中的任何或所有的值組合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資料。</param>
        <param name="path">用做擷取金鑰之個人化資訊的路徑。</param>
        <param name="userName">用做擷取金鑰之個人化資訊的使用者名稱。</param>
        <param name="sharedDataBlob">
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 範圍的傳回資料。</param>
        <param name="userDataBlob">
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 範圍的傳回資料。</param>
        <summary>在衍生類別中覆寫時，會載入基礎資料存放區中未經處理的個人化資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>並實作這個方法應該使用`webPartManager`， `path`，和`username`參數做為擷取索引鍵。 不論資料的方式儲存在資料存放區 （某些資料存放區可能會執行某種類型的智慧型存放裝置），必須傳回資料的個人化成為組封裝的兩個陣列中的位元組。 傳回的資料必須符合下列規則：  
  
-   資料<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>範圍必須一律會傳回在`sharedDataBlob`參數。  
  
-   根據索引鍵值<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>中傳回資料`userDataBlob`參數。 為非`null`值`userName`參數會指示<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>也應該擷取資料。  
  
 個人化提供者衍生自<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>並實作這個方法可以最佳化其資料存放區之間的互動擷取所有的個人化資料，在一個往返，而不是擷取<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>中兩個資料分隔來回行程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資料。</param>
        <param name="ignoreCurrentUser">
          <see cref="T:System.Boolean" />，指出是否應該將使用者名稱傳遞給個人化提供者。</param>
        <summary>從基礎資料存放區載入未經處理的資料，並將該資料轉換成 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> 物件。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含個人化資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法時所使用的主要進入點<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>載入個人化資料的類別。 預設實作會從基礎資料存放區載入未經處理資料 （功能在衍生的提供者中實作），然後將轉換成的未經處理資料<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>執行個體。  
  
 如果`ignoreCurrentUser`參數是`true`，沒有使用者名稱傳遞給<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A>方法。 個人化提供者可以選擇將此內容解譯成有意義的唯一的個人化狀態與<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>範圍應該從基礎資料存放區中擷取。  
  
 當<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>方法正在執行時，它會呼叫<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>方法，而且有三種類型的狀態是正在載入可能會發生的還原序列化錯誤。 當這些特定的錯誤發生時，擲回任何例外狀況，而改為 [健康情況監視] 功能所記錄的錯誤事件 (如需健全狀況監視，以及存取它所建立的記錄資訊，請參閱[ASP.NET 健康監視概觀](http://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). 下列的三種案例會讓還原序列化錯誤事件寫入記錄檔：  
  
-   還原序列化會使用字串的屬性類型的失敗的嘗試<xref:System.ComponentModel.TypeConverter>。  
  
-   若要還原序列化使用二進位序列化的屬性類型的失敗的嘗試。  
  
-   若要還原序列化的屬性類型，因為無法建立類型的執行個體嘗試失敗。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">與 <paramref name="webPartManager" /> 關聯的頁面為 <see langword="null" />。  
  
\-或- 
與網頁關聯的要求為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資料。</param>
        <param name="path">用做資料存放區金鑰之個人化資訊的路徑。</param>
        <param name="userName">用做資料存放區金鑰之個人化資訊的使用者名稱。</param>
        <summary>在衍生類別中覆寫時，會刪除基礎資料存放區中未經處理的個人化資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>並實作這個方法應該使用`webPartManager`， `path`，和`userName`參數做為儲存體金鑰。 衍生的實作必須修改資料存放區，以便提供的儲存體金鑰的個人化資料實際上會被刪除。 這是由衍生的實作，決定如何它們實際完成這項作業。  
  
 在衍生的個人化提供者必須能夠區分每個頁面為基礎的個人化資料。 此外，針對指定的頁面狀態，個人化提供者必須能夠區分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>範圍資料。 如果為非`null`提供使用者名稱，則重設作業套用至<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>範圍; 否則重設作業適用於<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>範圍。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資料。</param>
        <summary>將個人化資料重設至基礎資料存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法時所使用的主要進入點<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>重設個人化資料的類別。 預設實作會使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制項來決定要重設資料的路徑和使用者名稱。 預設實作則會呼叫<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartManager" /> 沒有與網頁相關聯。  
  
\-或- 
網頁沒有與進行中 <see cref="T:System.Web.HttpRequest" /> 相關聯。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">要重設之個人化資訊的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 這個值不能是 <see langword="null" />。</param>
        <param name="paths">要刪除之個人化資訊的路徑。</param>
        <param name="usernames">要刪除之個人化資訊的使用者名稱。</param>
        <summary>在衍生類別中覆寫時，會根據指定的參數，刪除基礎資料存放區中的個人化狀態。</summary>
        <returns>刪除的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是刪除個人化資料的系統管理方法的抽象定義。 衍生的實作應該遵循以下所述的邏輯。  
  
 這個方法不支援任何萬用字元搜尋。 如果個人化提供者會公開交易感知的資料存放區的資料，這個方法應該視為單一不可部分完成交易來執行其作業。  
  
 允許參數的下列組合：  
  
-   `scope`參數設定，而所有其他參數會設定為`null`。 這個組合會刪除所指定的個人化範圍相關聯的所有 Web 組件個人化資料`scope`。  
  
-   `scope`參數設定，而`paths`參數包含至少一個值。 這個組合會刪除指定的路徑或路徑所指定的個人化範圍中的所有 Web 組件個人化資料`scope`。  
  
-   `scope`參數設定為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，則`paths`參數會設定，且包含只有一個值，而`usernames`參數包含至少一個值。 這個組合會刪除所有的使用者個人化 Web 組件中所包含的使用者相關聯的指定路徑的資料`usernames`。  
  
-   `scope`參數設定為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，則`paths`參數設為`null`，和`usernames`參數包含至少一個值。 這個組合會刪除所有的每一使用者個人化 Web 組件的資料，在中所包含的使用者相關聯的所有路徑之間`usernames`。  
  
 任何其他的參數值組合無效，而且將會擲回<xref:System.ArgumentException>例外狀況。 具體而言，不允許下列兩種組合：  
  
-   `usernames`不能提供參數時`scope`設定為<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   `paths`參數不能包含多個項目時`usernames`參數不是`null`。  
  
 任何`paths`和`usernames`包含於各自陣列的參數值必須符合以下驗證規則。 如果任何驗證規則失敗時的參數陣列中，任何成員<xref:System.ArgumentException>擲回例外狀況。 驗證規則如下：  
  
-   `null` 不允許值。  
  
-   空字串 ("") 不允許。 參數應該修剪之前執行的檢查，空字串。  
  
-   `usernames`參數不能包含逗號 （，）。  
  
-   長度`paths`參數不能大於 256 個字元的 SQL database。  
  
-   長度`usernames`參數不能大於 256 個字元的 SQL database。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要刪除之個人化資料的路徑。 這個值可以為 <see langword="null" />，但是不能為空字串 ("")。</param>
        <param name="userInactiveSinceDate">日期，表示網站使用者上次變更個人化資料的時間。</param>
        <summary>在衍生類別中覆寫時，會根據指定的參數，刪除基礎資料存放區中的 Web 組件個人化資料。</summary>
        <returns>從基礎資料存放區刪除的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是刪除個人化資料的系統管理方法的抽象定義。 請注意，這個方法只會影響使用者的個人化資料和不共用的資料。  
  
 衍生的實作應該遵循以下所述的邏輯：  
  
-   `path`參數不能包含萬用字元。  
  
-   如果提供者會公開交易感知的資料存放區的資料，這個方法應在單一不可部分完成交易中執行其作業。  
  
-   如果`path`參數為非`null`，然後與相關聯的唯一的每一使用者個人化資料錄`path`將被刪除。  
  
-   只有每位使用者個人化資料錄會被視為非使用中所示的日期後的使用者相關聯`userInactiveSinceDate`參數會被刪除。 具體來說，記錄<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>小於或等於<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>會被刪除。  
  
-   如果未提供這兩個參數，則會刪除符合這兩個條件約束的記錄。  
  
-   `path`參數可以是`null`。  
  
-   `path`參數不可以是空的字串。 它應該修剪之前執行這項檢查。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> 屬性不能是 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，管理個人化資料。</param>
        <param name="path">用做資料存放區金鑰之個人化資訊的路徑。</param>
        <param name="userName">用做金鑰之個人化資訊的使用者名稱。</param>
        <param name="dataBlob">要儲存的資料位元組陣列。</param>
        <summary>在衍生類別中覆寫時，會將未經處理的個人化資料儲存至基礎資料存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是方法的將未經處理的個人化資料儲存至基礎資料存放區所使用的抽象定義。  
  
 在衍生的實作應該使用`webPartManager`， `path`，和`userName`參數做為儲存體金鑰。 在衍生的個人化提供者必須能夠區分每個頁面為基礎的個人化資料。 此外，針對指定的頁面狀態，提供者必須能夠區分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>範圍。 如果非`null`提供使用者名稱，則`dataBlob`參數處於<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>範圍; 否則`dataBlob`參數會假設為在<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>範圍。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含要儲存的個人化資料。</param>
        <summary>將個人化資料儲存至資料存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法時所使用的主要進入點<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>類別來儲存個人化資料。  
  
 這個方法的預設實作會使用的內部實作的方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>封裝的個人化資料的位元組陣列。 如果此封裝的結果建立空的位元組陣列 （因為任何個人化資料，造成屬性擷取），預設實作會呼叫<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。 否則，預設實作會呼叫<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">儲存的 <paramref name="state" /> 物件與 <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> 方法傳回的 <paramref name="state" /> 物件型別不同。</exception>
      </Docs>
    </Member>
  </Members>
</Type>