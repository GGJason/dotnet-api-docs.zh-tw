<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5038b89f27dd627e6fd9b09bf7edd124c4e3944a" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48626706" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供基底類別，以便指定在執行階段時的動態行為。 這個類別必須是繼承類別，您無法直接將其執行個體化。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject`類別可讓您定義可以在動態物件上執行哪些作業，以及如何執行這些作業。 例如，您可以定義當您嘗試取得或設定物件屬性、 呼叫方法，或執行標準的數學運算，例如加法和乘法時，會發生什麼事。  
  
 這個類別可以是很有用，如果您想要建立之程式庫更方便的通訊協定。 例如，如果您的程式庫的使用者必須使用下列語法： `Scriptobj.SetProperty("Count", 1)`，您可以讓您能夠使用更簡單的語法，例如`scriptobj.Count = 1`。  
  
 您無法直接建立的執行個體`DynamicObject`類別。 若要實作的動態行為，您可能想要繼承`DynamicObject`類別並覆寫所需的方法。 例如，如果您需要的設定和取得屬性的唯一作業，您可以覆寫只<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法。  
  
 在 C# 中，來啟用從衍生類別的執行個體的動態行為`DynamicObject`類別，您必須使用`dynamic`關鍵字。 如需詳細資訊，請參閱[使用動態類型](~/docs/csharp/programming-guide/types/using-type-dynamic.md)。  
  
 在 Visual Basic 中的晚期繫結支援動態作業。 如需詳細資訊，請參閱 <<c0> [ 早期和晚期繫結](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)。  
  
 下列程式碼範例示範如何建立衍生自類別的執行個體`DynamicObject`類別。  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 您也可以將您自己的成員加入衍生自類別`DynamicObject`類別。 如果您的類別定義屬性，並且也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法中，動態語言執行階段 (DLR) 會先使用語言繫結器來尋找靜態定義的類別中的屬性。 如果沒有這類屬性，會呼叫 DLR<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法。  
  
 `DynamicObject`類別會實作 DLR 介面<xref:System.Dynamic.IDynamicMetaObjectProvider>，這可讓您共用的執行個體`DynamicObject`支援 DLR 互通性模型的語言之間的類別。 例如，您可以在其中建立的執行個體`DynamicObject`類別在 C# 中，並再將它傳遞給 IronPython 函式。 如需詳細資訊，請參閱 < [Dynamic Language Runtime 概觀](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)。  
  
> [!NOTE]
>  如果您有一個簡單的案例，您需要的物件，但是，只能新增和移除成員，在執行階段，不需要定義特定的作業，而且不會不有靜態成員，使用<xref:System.Dynamic.ExpandoObject>類別。  
>   
>  如果您有更進階的案例，您要定義參與互通性通訊協定，或您要管理快取的 DLR 快速動態分派動態物件的方式，建立您自己實作<xref:System.Dynamic.IDynamicMetaObjectProvider>介面。  
  
   
  
## Examples  
 假設您想要提供替代語法來存取值在字典中，也因此的書寫`sampleDictionary["Text"] = "Sample text"`(`sampleDictionary("Text") = "Sample text"` Visual Basic 中)，您可以撰寫`sampleDictionary.Text = "Sample text"`。 此外，您想要區分大小寫，此語法以便`sampleDictionary.Text`相當於`sampleDictionary.text`。  
  
 下列程式碼範例示範`DynamicDictionary`類別，衍生自`DynamicObject`類別。 `DynamicDictionary`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)`在 Visual Basic 中) 來儲存索引鍵 / 值組，並覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以支援新的語法。 它也提供`Count`包含屬性，其中顯示多少動態屬性字典。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 如需其他範例，請參閱 <<c0> [ 建立包裝函式與 DynamicObject](http://go.microsoft.com/fwlink/?LinkId=169008) C# 常見問題集部落格上。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>讓衍生型別得以初始化 <see cref="T:System.Dynamic.DynamicObject" /> 型別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法直接建立的執行個體<xref:System.Dynamic.DynamicObject>類別。 若要實作動態行為，您必須繼承自<xref:System.Dynamic.DynamicObject>類別並覆寫所需的方法。  
  
 在 C# 中，來啟用從衍生類別的執行個體的動態行為<xref:System.Dynamic.DynamicObject>類別，您必須使用`dynamic`關鍵字。 如需詳細資訊，請參閱[使用動態類型](~/docs/csharp/programming-guide/types/using-type-dynamic.md)。  
  
 在 Visual Basic 中的晚期繫結支援動態作業。 如需詳細資訊，請參閱 <<c0> [ 早期和晚期繫結](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立衍生自的類別的執行個體<xref:System.Dynamic.DynamicObject>類別。  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回所有動態成員名稱的列舉型別。</summary>
        <returns>包含動態成員名稱的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法有偵錯之用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">運算式，表示分派給動態虛擬方法的 <see cref="T:System.Dynamic.DynamicMetaObject" />。</param>
        <summary>提供分派給動態虛擬方法的 <see cref="T:System.Dynamic.DynamicMetaObject" />。 此物件可以封裝在另一個 <see cref="T:System.Dynamic.DynamicMetaObject" /> 內部，以提供個別動作的自訂行為。 這個方法支援語言實作者適用的動態語言執行階段基礎結構，但不建議直接在程式碼中使用。</summary>
        <returns>
          <see cref="T:System.Dynamic.DynamicMetaObject" /> 型別的物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供二進位運算的相關資訊。 <c>binder.Operation</c> 屬性會傳回 <see cref="T:System.Linq.Expressions.ExpressionType" /> 物件。 例如，對於 <c>sum = first + second</c> 陳述式 (其中 <c>first</c> 和 <c>second</c> 衍生自 <see langword="DynamicObject" /> 類別)，<c>binder.Operation</c> 會傳回 <c>ExpressionType.Add</c>。</param>
        <param name="arg">二進位運算的右運算元。 例如，對於 <c>sum = first + second</c> 陳述式 (其中 <c>first</c> 和 <c>second</c> 衍生自 <see langword="DynamicObject" /> 類別)，<c>arg</c> 等於 <c>second</c>。</param>
        <param name="result">二進位運算的結果。</param>
        <summary>提供二進位運算的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定加法和乘法這類運算的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定的二進位運算應該如何執行動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 當您有二元運算，例如加法或乘法，則會呼叫這個方法。 例如，如果<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A>會覆寫方法，它陳述式之類的自動叫用`sum = first + second`或是`multiply = first*second`，其中`first`衍生自`DynamicObject`類別。  
  
 您可以使用，以取得二元作業類型的相關資訊`Operation`屬性`binder`參數。  
  
 如果您的動態物件只適用於 C# 和 Visual Basic`binder.Operation`屬性可以從下列值之一<xref:System.Linq.Expressions.ExpressionType>列舉型別。 不過，如果您在 IronPython 或 IronRuby 等其他語言，您可以有其他值。
  
|值|描述|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|不含溢位檢查，數值運算元的加法運算。|`a + b`|`a + b`|  
|`AddAssign`|不含溢位檢查，數值運算元的加法複合指派運算。|`a += b`|不支援。|  
|`And`|位元`AND`作業。|`a & b`|`a And b`|  
|`AndAssign`|位元`AND`複合指派運算。|`a &= b`|不支援。|  
|`Divide`|算術除法運算。|`a / b`|`a / b`|  
|`DivideAssign`|算術除法複合指派運算。|`a /= b`|不支援。|  
|`ExclusiveOr`|位元`XOR`作業。|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|位元`XOR`複合指派運算。|`a ^= b`|不支援。|  
|`GreaterThan`|「 大於 」 比較。|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|「 大於或等於 」 比較。|`a >= b`|不支援。|  
|`LeftShift`|位元左移運算。|`a << b`|`a << b`|  
|`LeftShiftAssign`|位元左移複合指派運算。|`a <<= b`|不支援。|  
|`LessThan`|「 小於 」 比較。|`a < b`|`a < b`|  
|`LessThanOrEqual`|「 小於或等於 」 比較。|`a <= b`|不支援。|  
|`Modulo`|算術餘數運算。|`a % b`|`a Mod b`|  
|`ModuloAssign`|算術餘數複合指派運算。|`a %= b`|不支援。|  
|`Multiply`|不含溢位檢查，數值運算元的乘法運算。|`a * b`|`a * b`|  
|`MultiplyAssign`|不含溢位檢查，數值運算元的乘法複合指派運算。|`a *= b`|不支援。|  
|`NotEqual`|不是相等比較。|`a != b`|`a <> b`|  
|`Or`|位元或邏輯`OR`作業。|`a &#124; b`|`a Or b`|  
|`OrAssign`|位元或邏輯`OR`複合指派。|`a &#124;= b`|不支援。|  
|`Power`|引發到乘冪的數字的數學運算。|不支援。|`a ^ b`|  
|`RightShift`|位元的向右移位作業。|`a >> b`|`a >> b`|  
|`RightShiftAssign`|位元右移複合指派運算。|`a >>= b`|不支援。|  
|`Subtract`|不含溢位檢查，數值運算元的減法運算。|`a - b`|`a - b`|  
|`SubtractAssign`|不含溢位檢查，數值運算元的減法複合指派運算。|`a -= b`|不支援。|  
  
> [!NOTE]
>  若要實作`OrElse`(`a || b`) 和`AndAlso`(`a && b`) 在 C# 中的動態物件的作業，您可以同時實作<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A>方法和<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A>方法。  
>   
>  `OrElse`作業組成一元`IsTrue`作業和二元`Or`作業。 `Or`只有當使用者執行作業的結果`IsTrue`作業`false`。  
>   
>  `AndAlso`作業組成一元`IsFalse`作業和二元`And`作業。 `And`只有當使用者執行作業的結果`IsFalse`作業`false`。  
  
   
  
## Examples  
 假設您需要的資料結構來儲存文字和數字表示的數字，而且您想要定義基本的數學運算，例如加法和減法，這類資料。  
  
 下列程式碼範例示範`DynamicNumber`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicNumber` 覆寫<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A>方法，以啟用數學運算。 它也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用存取項目。  
  
 在此範例中，支援唯一的加法和減法運算。 如果您嘗試寫入之類的陳述式`resultNumber = firstNumber*secondNumber`，執行階段例外狀況。  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供轉換作業的相關資訊。 <c>binder.Type</c> 屬性提供物件必須轉換成的目標類型。 例如，對於 C# 中的 <c>(String)sampleObject</c> (Visual Basic 中的 <c>CType(sampleObject, Type)</c>) 陳述式 (其中 <c>sampleObject</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別執行個體)，<c>binder.Type</c> 會傳回 <see cref="T:System.String" /> 類型。 <c>binder.Explicit</c> 屬性提供發生之轉換類型的資訊。 如果是明確轉換則會傳回 <see langword="true" />，如果是隱含轉換則會傳回 <see langword="false" />。</param>
        <param name="result">型別轉換作業的結果。</param>
        <summary>提供型別轉換作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定物件型別轉換作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定的型別轉換應該如何執行動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 在 C# 中，如果這個方法會覆寫時，它會自動叫用就是明確或隱含轉換，如下列程式碼範例所示。  
  
 在 Visual Basic 中，支援明確的轉換。 如果您覆寫這個方法，它可以使用呼叫<xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A>或<xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A>函式。  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 假設您需要的資料結構來儲存文字和數字表示的數字，而且您想要定義轉換此資料結構的字串與整數。  
  
 下列程式碼範例示範`DynamicNumber`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicNumber` 覆寫<xref:System.Dynamic.DynamicObject.TryConvert%2A>方法來啟用類型轉換。 它也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用存取資料的項目。  
  
 在此範例中，支援只用於字串和整數的轉換。 如果您嘗試將物件轉換成任何其他類型，則會擲回執行階段例外狀況。  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供初始設定作業的相關資訊。</param>
        <param name="args">在初始設定期間傳遞給物件的引數。 例如，對於 <c>new SampleType(100)</c> 運算 (其中 <c>SampleType</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類型)，<c>args[0]</c> 等於 100。</param>
        <param name="result">初始設定的結果。</param>
        <summary>提供作業的實作，這些作業會初始化動態物件的新執行個體。 這個方法並不適用於 C# 或 Visual Basic。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫這個方法，以指定初始化動態物件的新執行個體的方式。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 C# 和 Visual Basic 編譯器永遠不會發出程式碼以使用這個方法，因為它們不支援第一級型別。 此方法適用於使用下列語法： 支援的動態物件初始設定的語言`dynamic new`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">提供刪除的相關資訊。</param>
        <param name="indexes">要刪除的索引。</param>
        <summary>提供依索引刪除物件之作業的實作。 這個方法並不適用於 C# 或 Visual Basic。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何刪除具有指定的索引的值。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 C# 和 Visual Basic 編譯器永遠不會發出程式碼以使用這個方法，因為它們並不支援此類作業。 此方法適用於支援語法，例如，藉由索引刪除物件的語言`del sampleObject[1,2]`在 Python 中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">提供刪除的相關資訊。</param>
        <summary>提供刪除物件成員之作業的實作。 這個方法並不適用於 C# 或 Visual Basic。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何刪除物件成員。 這個方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 C# 和 Visual Basic 編譯器永遠不會發出程式碼以使用這個方法，因為它們並不支援此類作業。 此方法適用於刪除成員，例如支援語法的語言`del sampleObject.SampleMember`在 Python 中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供作業的相關資訊。</param>
        <param name="indexes">用於作業的索引。 例如，對於 C# 中的 <c>sampleObject[3]</c> (Visual Basic 中的 <c>sampleObject(3)</c>) 運算 (其中 <c>sampleObject</c> 衍生自 <see langword="DynamicObject" /> 類別)，<c>indexes[0]</c> 等於 3。</param>
        <param name="result">索引作業的結果。</param>
        <summary>提供依索引取得值之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定索引作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大部分情況下，會擲回執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫這個方法，以指定如何依索引取得值，應該執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大部分情況下，會擲回執行階段例外狀況)。  
  
 如果這個方法會覆寫時，它會自動叫用作業，例如當`sampleObject[3]`C# 中或`sampleObject(3)`Visual Basic、 where`sampleObject`衍生自<xref:System.Dynamic.DynamicObject>類別。  
  
   
  
## Examples  
 假設您想要建立的物件的屬性可以存取由名稱這類`Property0`， `Property1`，依此類推，或索引，以便，例如`sampleObject.Property0`相當於`sampleObject[0]`在 C# 或`sampleObject(0)`Visual Basic 中。  
  
 下列程式碼範例示範`SampleDynamicObject`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `SampleDynamicObject`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)` Visual Basic 中) 來儲存索引鍵 / 值組。 `SampleDynamicObject` 覆寫<xref:System.Dynamic.DynamicObject.TrySetIndex%2A>和<xref:System.Dynamic.DynamicObject.TryGetIndex%2A>可依索引存取的方法。 它會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用存取以屬性名稱。  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供已呼叫動態作業之物件的相關資訊。 <c>binder.Name</c> 屬性會提供在其中執行動態作業之成員的名稱。 例如，對於 <c>Console.WriteLine(sampleObject.SampleProperty)</c> 陳述式 (其中 <c>sampleObject</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別執行個體)，<c>binder.Name</c> 會傳回 "SampleProperty"。 <c>binder.IgnoreCase</c> 屬性會指定成員名稱是否區分大小寫。</param>
        <param name="result">取得作業的結果。 例如，如果是針對屬性呼叫這個方法，您可以將屬性值指派給 <c>result</c>。</param>
        <summary>提供取得成員值之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定取得屬性值這類作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大部分情況下，會擲回執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何取得成員值的作業執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大部分情況下，會擲回執行階段例外狀況)。  
  
 當您有類似的陳述式時，會呼叫這個方法`Console.WriteLine(sampleObject.SampleProperty)`，其中`sampleObject`是衍生自類別的執行個體<xref:System.Dynamic.DynamicObject>類別。  
  
 您也可以將您自己的成員加入衍生自類別`DynamicObject`類別。 如果您的類別定義屬性，並且也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法中，動態語言執行階段 (DLR) 會先使用語言繫結器來尋找靜態定義的類別中的屬性。 如果沒有這類屬性，會呼叫 DLR<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法。  
  
   
  
## Examples  
 假設您想要提供替代語法來存取值在字典中，也因此的書寫`sampleDictionary["Text"] = "Sample text"`(`sampleDictionary("Text") = "Sample text"` Visual Basic 中)，您可以撰寫`sampleDictionary.Text = "Sample text"`。 此外，此語法必須區分大小寫，以便`sampleDictionary.Text`相當於`sampleDictionary.text`。  
  
 下列程式碼範例示範`DynamicDictionary`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicDictionary`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)`在 Visual Basic 中) 來儲存索引鍵 / 值組，並覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以支援新的語法。 它也提供`Count`包含屬性，其中顯示多少動態屬性字典。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供叫用作業的相關資訊。</param>
        <param name="args">在叫用作業期間傳遞給物件的引數。 例如，對於 <c>sampleObject(100)</c> 作業 (其中<c>sampleObject</c> 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別)，<c>args[0]</c> 等於 100。</param>
        <param name="result">物件引動過程的結果。</param>
        <summary>提供叫用物件之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定叫用物件或委派這類作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 在大多數情況下，會擲回語言特有執行階段例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何叫用物件的作業執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大部分情況下，會擲回執行階段例外狀況)。  
  
 如果這個方法會覆寫時，它會自動叫用作業，例如當`sampleObject(100)`，其中`sampleObject`衍生自<xref:System.Dynamic.DynamicObject>類別。  
  
 在 C# 中，但在 Visual Basic 中不支援叫用物件的作業。 Visual Basic 編譯器永遠不會發出程式碼，請使用這個方法，而 Visual Basic 語言不支援下列語法： `sampleObject(100)`。  
  
   
  
## Examples  
 假設您需要的資料結構，來儲存文字和數字表示的數字。 您想要能夠個別指定每個屬性的值並能夠初始化的單一陳述式中的所有屬性。  
  
 下列程式碼範例示範`DynamicNumber`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicNumber` 覆寫<xref:System.Dynamic.DynamicObject.TryInvoke%2A>方法，以啟用一次初始化的所有屬性。 它也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用個別的物件屬性的存取權。  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供動態作業的相關資訊。 <c>binder.Name</c> 屬性會提供在其中執行動態作業之成員的名稱。 例如，對於 <c>sampleObject.SampleMethod(100)</c> 陳述式 (其中 <c>sampleObject</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別執行個體)，<c>binder.Name</c> 會傳回 "SampleMethod"。 <c>binder.IgnoreCase</c> 屬性會指定成員名稱是否區分大小寫。</param>
        <param name="args">在叫用作業期間傳遞給物件成員的引數。 例如，對於 <c>sampleObject.SampleMethod(100)</c> 陳述式 (其中 <c>sampleObject</c> 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別)，<c>args [0]</c> 等於 100。</param>
        <param name="result">成員引動過程的結果。</param>
        <summary>提供叫用成員之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定呼叫方法這類作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何叫用該物件成員的作業執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 如果這個方法會覆寫時，它會自動叫用時執行的作業，例如`sampleObject.SampleMethod(100)`，其中`sampleObject`衍生自`DynamicObject`類別。  
  
 您也可以將您自己的方法加入類別衍生自<xref:System.Dynamic.DynamicObject>類別。 例如，如果您覆寫<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A>方法，動態分派系統首先會嘗試判斷指定的方法是否存在於類別。 如果找不到方法，它會使用<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A>實作。  
  
 此方法不支援`ref`和`out`參數。 中的所有參數`args`陣列傳值方式傳遞。  
  
   
  
## Examples  
 假設您想要提供替代語法來存取值在字典中，也因此的書寫`sampleDictionary["Text"] = "Sample text"`(`sampleDictionary("Text") = "Sample text"` Visual Basic 中)，您可以撰寫`sampleDictionary.Text = "Sample text"`。 此外，您會想要能夠呼叫此字典上的所有標準字典方法。  
  
 下列程式碼範例示範`DynamicDictionary`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicDictionary`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)` Visual Basic 中) 來儲存索引鍵 / 值組。 它會覆寫<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A>方法，以支援的方法<xref:System.Collections.Generic.Dictionary%602>類別並覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以支援新的語法。 它也提供`Print`方法，它會列印出所有字典索引鍵和值。  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">提供作業的相關資訊。</param>
        <param name="indexes">用於作業的索引。 例如，對於 C# 中的 <c>sampleObject[3] = 10</c> (Visual Basic 中的 <c>sampleObject(3) = 10</c>) 運算 (其中 <c>sampleObject</c> 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別)，<c>indexes[0]</c> 等於 3。</param>
        <param name="value">要設定給具有所指定索引之物件的值。 例如，對於 C# 中的 <c>sampleObject[3] = 10</c> (Visual Basic 中的 <c>sampleObject(3) = 10</c>) 運算 (其中 <c>sampleObject</c> 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別)，「值」<c></c>等於 10。</param>
        <summary>提供依索引設定值之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定依指定之索引存取物件之作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 在大多數情況下，會擲回語言特有執行階段例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何依索引存取物件的作業執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 如果這個方法會覆寫時，它會自動叫用作業，例如當`sampleObject[3] = 10`C# 中或`sampleObject(3) = 10`Visual Basic、 where`sampleObject`衍生自<xref:System.Dynamic.DynamicObject>類別。  
  
   
  
## Examples  
 假設您想要建立的物件的屬性可以存取由名稱這類`Property0`， `Property1`，依此類推，或索引，以便，例如`sampleObject.Property0`相當於`sampleObject[0]`在 C# 或`sampleObject(0)`Visual Basic 中。  
  
 下列程式碼範例示範`SampleDynamicObject`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `SampleDynamicObject`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)` Visual Basic 中) 來儲存索引鍵 / 值組。 `SampleDynamicObject` 覆寫<xref:System.Dynamic.DynamicObject.TrySetIndex%2A>和<xref:System.Dynamic.DynamicObject.TryGetIndex%2A>可依索引存取的方法。 它會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用存取以屬性名稱。  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">提供已呼叫動態作業之物件的相關資訊。 <c>binder.Name</c> 屬性會提供獲得指派該值之成員的名稱。 例如，對於 <c>sampleObject.SampleProperty = "Test"</c> 陳述式 (其中 <c>sampleObject</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別執行個體)，<c>binder.Name</c> 會傳回 "SampleProperty"。 <c>binder.IgnoreCase</c> 屬性會指定成員名稱是否區分大小寫。</param>
        <param name="value">要設定給成員的值。 例如，對於 <c>sampleObject.SampleProperty = "Test"</c> (其中 <c>sampleObject</c> 是衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別執行個體)，<c>value</c> 會傳回 "Test"。</param>
        <summary>提供設定成員值之作業的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定設定屬性值這類作業的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫此方法，以指定應該如何將值設定為成員的作業執行的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 當您有類似的陳述式時，會呼叫這個方法`sampleObject.SampleProperty = "Test"`，其中`sampleObject`是衍生自類別的執行個體<xref:System.Dynamic.DynamicObject>類別。  
  
 您也可以將您自己的成員加入衍生自類別`DynamicObject`類別。 如果您的類別定義屬性，並且也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法中，動態語言執行階段 (DLR) 會先使用語言繫結器來尋找靜態定義的類別中的屬性。 如果沒有這類屬性，會呼叫 DLR<xref:System.Dynamic.DynamicObject.TrySetMember%2A>方法。  
  
   
  
## Examples  
 假設您想要提供替代語法來存取值在字典中，也因此的書寫`sampleDictionary["Text"] = "Sample text"`(`sampleDictionary("Text") = "Sample text"` Visual Basic 中)，您可以撰寫`sampleDictionary.Text = "Sample text"`。 此外，此語法必須區分大小寫，以便`sampleDictionary.Text`相當於`sampleDictionary.text`。  
  
 下列程式碼範例示範`DynamicDictionary`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicDictionary`類別包含的物件`Dictionary<string, object>`型別 (`Dictionary(Of String, Object)`在 Visual Basic 中) 來儲存索引鍵 / 值組，並覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以支援新的語法。 它也提供`Count`包含屬性，其中顯示多少動態屬性字典。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">提供一元運算的相關資訊。 <c>binder.Operation</c> 屬性會傳回 <see cref="T:System.Linq.Expressions.ExpressionType" /> 物件。 例如，對於 <c>negativeNumber = -number</c> 陳述式 (其中 <c>number</c> 衍生自 <see langword="DynamicObject" /> 類別)，<c>binder.Operation</c> 會傳回 "Negate"。</param>
        <param name="result">一元運算的結果。</param>
        <summary>提供一元運算的實作。 衍生自 <see cref="T:System.Dynamic.DynamicObject" /> 類別的類別可以覆寫這個方法，以指定負號、遞增或遞減這類運算的動態行為。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" />。 如果這個方法傳回 <see langword="false" />，語言的執行階段繫結器會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Dynamic.DynamicObject>類別可以覆寫這個方法，以指定如何應該執行一元運算的動態物件。 方法不覆寫時，執行階段繫結器的語言會決定行為。 (在大多數情況下，將會擲回特定語言的執行階段例外狀況)。  
  
 當您有一元運算，例如負號、 遞增或遞減，會呼叫這個方法。 例如，如果<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A>會覆寫方法，這個方法會自動叫用陳述式之類`negativeNumber = -number`，其中`number`衍生自<xref:System.Dynamic.DynamicObject>類別。  
  
 您可以使用，以取得一元作業的類型的相關資訊`Operation`屬性`binder`參數。  
  
 如果您的動態物件只適用於 C# 和 Visual Basic`binder.Operation`屬性可以從下列值之一<xref:System.Linq.Expressions.ExpressionType>列舉型別。 不過，如果您在 IronPython 或 IronRuby 等其他語言，您可以有其他值。
  
|值|描述|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|一元遞減運算。|`a--`|不支援。|  
|`Increment`|一元遞增運算。|`a++`|不支援。|  
|`Negate`|算術負運算。|`-a`|`-a`|  
|`Not`|邏輯否定。|`!a`|`Not a`|  
|`OnesComplement`|的補數。|`~a`|不支援。|  
|`IsFalse`|False 條件的值。|`a && b`|不支援。|  
|`IsTrue`|則為 true 的條件值。|`a &#124;&#124; b`|不支援。|  
|`UnaryPlus`|一元加號。|`+a`|`+a`|  
  
> [!NOTE]
>  若要實作`OrElse`(`a || b`) 和`AndAlso`(`a && b`) 在 C# 中的動態物件的作業，您可以同時實作<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A>方法和<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A>方法。  
>   
>  `OrElse`作業組成一元`IsTrue`作業和二元`Or`作業。 `Or`只有當使用者執行作業的結果`IsTrue`作業`false`。  
>   
>  `AndAlso`作業組成一元`IsFalse`作業和二元`And`作業。 `And`只有當使用者執行作業的結果`IsFalse`作業`false`。  
  
   
  
## Examples  
 假設您需要的資料結構來儲存文字和數字表示的數字，而且您想要定義這類資料的算術負運算。  
  
 下列程式碼範例示範`DynamicNumber`類別，衍生自<xref:System.Dynamic.DynamicObject>類別。 `DynamicNumber` 覆寫<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A>方法，以啟用數學的否定運算。 也會覆寫<xref:System.Dynamic.DynamicObject.TrySetMember%2A>和<xref:System.Dynamic.DynamicObject.TryGetMember%2A>方法，以啟用存取項目。  
  
 在此範例中，支援只數學的否定運算。 如果您嘗試寫入之類的陳述式`negativeNumber = +number`，則執行階段發生例外狀況。  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>