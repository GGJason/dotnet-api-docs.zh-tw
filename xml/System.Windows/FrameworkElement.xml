<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6a283083305e47932ae5e8c05635ec875cb3930" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52735679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>為 Windows Presentation Foundation (WPF) 項目提供一組 WPF 架構層級的屬性、事件和方法。 這個類別代表所提供的 WPF 架構層級實作，此實作建置在由 <see cref="T:System.Windows.UIElement" /> 所定義的 WPF 核心層級 API 之上。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 是 WPF 架構層級項目類別以及 WPF 核心層級的集合之間的連接點<xref:System.Windows.UIElement>展示服務。 如需有關這些概念的詳細資訊，請參閱 < [WPF 架構](~/docs/framework/wpf/advanced/wpf-architecture.md)。  
  
 <xref:System.Windows.FrameworkElement> 擴充<xref:System.Windows.UIElement>並新增下列功能：  
  
-   **版面配置系統定義**:<xref:System.Windows.FrameworkElement>提供特定的 WPF 架構層級實作特定方法中的虛擬成員所定義的<xref:System.Windows.UIElement>。 最值得注意的是，<xref:System.Windows.FrameworkElement>密封特定 WPF 核心層級的版面配置覆寫，並改為提供 WPF 架構層級對等項目，衍生類別應該覆寫。 例如，<xref:System.Windows.FrameworkElement>標誌<xref:System.Windows.UIElement.ArrangeCore%2A>提供，但<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。 這些變更會反映在 WPF 架構層級沒有完整的版面配置系統可呈現任何就地<xref:System.Windows.FrameworkElement>衍生的類別。 在 WPF 核心層級的特定成員，將結構一般[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]配置方案已備妥，但未定義的版面配置系統實際的引擎。 如需詳細資訊，請參閱[配置](~/docs/framework/wpf/advanced/layout.md)。  
  
-   **邏輯樹狀結構：** 一般[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]程式設計模型以在元素樹狀結構通常表示。 讓您表示的項目樹狀結構，為邏輯樹狀結構中，並隨附支援，如在標記中定義該樹狀結構在實作<xref:System.Windows.FrameworkElement>層級。 請注意，不過<xref:System.Windows.FrameworkElement>刻意不會定義內容的模型，並將保留該衍生類別的責任。 如需詳細資訊，請參閱 [WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
-   **物件存留期事件：** 通常是很有幫助 初始化項目時 （稱為建構函式） 或當項目是第一次載入邏輯樹狀結構。 <xref:System.Windows.FrameworkElement> 定義數個事件與物件存留期，為包含項目，例如新增更多的子元素的程式碼後置作業提供有用的勾點。 如需詳細資訊，請參閱 <<c0> [ 物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
-   **資料繫結和動態資源參考的支援：** 藉由資料繫結和資源的屬性層級支援<xref:System.Windows.DependencyProperty>類別，並在屬性系統，但能夠解析的成員值做為預存<xref:System.Windows.Expression>（基礎資料繫結和動態資源的程式設計建構） 由實作<xref:System.Windows.FrameworkElement>。 如需詳細資訊，請參閱 <<c0> [ 資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)並[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   **樣式：** <xref:System.Windows.FrameworkElement>定義<xref:System.Windows.FrameworkElement.Style%2A>屬性。 不過，<xref:System.Windows.FrameworkElement>尚未定義支援範本，或支援的裝飾項目。 這些功能導入的控制項類別這類<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
-   **更多的動畫支援：** 某些動畫支援已定義在 WPF 核心層級，但<xref:System.Windows.FrameworkElement>延伸此程式碼藉由實作<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>和相關的成員。  
  
 可以從類別階層架構中，看出許多[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]類別衍生自<xref:System.Windows.FrameworkElement>，直接或透過中繼基底類別，例如<xref:System.Windows.Controls.Panel>或<xref:System.Windows.Controls.Control>。  
  
 如果您想要使用<xref:System.Windows.FrameworkElement>做為基底類別，您可能想要先檢查現有的衍生的類別。 <xref:System.Windows.FrameworkElement> 支援許多基本案例，但因為缺乏一些令人期待的 「 項目 」，因為您用來建立的建置區塊的功能[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]在[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 比方說，<xref:System.Windows.FrameworkElement>並未定義任何真實的內容模型;<xref:System.Windows.FrameworkElement>基底類別並未定義此屬性，可以建立如[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]子項目。 特別是，您可能想要看看<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkElement" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呈現此項目的高度。</summary>
        <value>項目的高度，做為[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 內的值。 預設值是 0 (零)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是根據其他高度輸入和版面配置系統的導出的值。 值，由配置系統本身根據實際轉譯階段，並可能因此會落後稍有設定的值屬性的這類<xref:System.Windows.FrameworkElement.Height%2A>所輸入變更的基礎。  
  
 因為<xref:System.Windows.FrameworkElement.ActualHeight%2A>是計算的值，您應該注意可能是多個，或是設定報告的累加式變更為其各種作業的結果由配置系統。 配置系統可能會計算子項目所需的測量空間、父項目的條件約束，依此類推。  
  
 雖然您無法設定這個屬性從[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>其樣式中的值。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會顯示各種高度屬性。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呈現此項目的寬度。</summary>
        <value>項目的寬度，做為[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 內的值。 預設值是 0 (零)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是根據其他寬度輸入和版面配置系統的導出的值。 值，由配置系統本身根據實際轉譯階段，並可能因此會落後稍有設定的值屬性的這類<xref:System.Windows.FrameworkElement.Width%2A>所輸入變更的基礎。  
  
 因為<xref:System.Windows.FrameworkElement.ActualWidth%2A>是計算的值，您應該注意可能是多個，或是設定報告的累加式變更為其各種作業的結果由配置系統。 配置系統可能會計算子項目所需的測量空間、父項目的條件約束，依此類推。  
  
 雖然您無法設定這個屬性從[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>其樣式中的值。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會顯示各種寬度屬性。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要加入的子項目。</param>
        <summary>將所提供的物件加入至此項目的邏輯樹狀結構。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法實作的物件，表示項目的邏輯子項目的集合。 子項目集合的集合維護可能會在屬性 getter 或 setter，類別處理的 Changed 事件，建構函式，或將集合型別本身內完成。  
  
 針對控制項作者，操作邏輯樹狀結構，在此層級不是建議的作法，除非使用的基底控制項類別的內容模型都適用於您控制的案例。 層級的子類別化，請考慮<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 這些類別提供特定的強制執行的邏輯樹狀結構子項目，透過專用的內容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。 如需有關如何使用<xref:System.Windows.FrameworkElement.LogicalChildren%2A>並<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 如果當邏輯樹狀結構會進行逐一查看另一個處理序一次呼叫，則可能會擲回例外狀況。  
  
   
  
## Examples  
 下列範例會實作`Child`自訂屬性<xref:System.Windows.FrameworkElement>執行它自己的視覺分層實作。 屬性 setter 經過設計，如果值變更時，從邏輯樹狀結構，以及特定類別的視覺集合移除的舊值。 快取的屬性值時，，然後新增至邏輯樹狀結構和自訂的視覺集合的值。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如有必要，則建置目前範本的視覺化樹狀，並傳回值，指出此呼叫是否已重建視覺化樹狀。</summary>
        <returns>如果視覺項目已加入樹狀結構，則為 <see langword="true" />；否則傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以呼叫這個方法，以保證元素的視覺化樹狀結構已完成。 這項確認步驟可能需要的程式碼會檢查樹狀結構中的子項目。 在應用程式，呼叫的典型的項目邏輯<xref:System.Windows.FrameworkElement.ApplyTemplate%2A>並非必要，因為範本會在適當的時間點的項目在其存留期自動套用。  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> 每個量值上呼叫傳遞由 WPF 架構層級配置系統。  
  
 <xref:System.Windows.FrameworkElement> 在衍生的類別可以使用<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>的情況下，明確地呼叫這個方法後，或由配置系統通知的類別處理常式。 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 會呼叫後範本完全產生，並附加至邏輯樹狀結構。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父系內這個項目應該用來排列本身和其子系的最終區域。</param>
        <summary>實作 <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (在 <see cref="T:System.Windows.UIElement" /> 內定義為 Virtual)，並密封實作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是密封格式。 若要覆寫您自訂的項目，特別是針對項目配置的排列傳遞中的邏輯您<xref:System.Windows.FrameworkElement>衍生的類別必須覆寫<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">父系內這個項目應該用來排列本身和其子系的最終區域。</param>
        <summary>在衍生類別中覆寫時，放置子項目，並且判斷 <see cref="T:System.Windows.FrameworkElement" /> 衍生類別的大小。</summary>
        <returns>使用的實際大小。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>想要自訂版面配置處理的排列傳遞的控制項作者應該覆寫這個方法。 實作模式應該呼叫<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />的每個可見的子元素和傳遞最終想要為每個子項目的大小<paramref name="finalRect" />參數。 父項目應該呼叫<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上每個子系，否則為子項目將無法呈現。  
  
許多衍生的類別會提供這個方法的實作。 重要的方法包括： <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />，<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />和<see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />。</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動這個項目的初始化處理序 (Process)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您正在調整它們的方式，尚未公開 （expose） 或連接到任何項目樹狀結構的項目，您可以在個別的項目上呼叫這個方法。 比方說，您可能已建立新<xref:System.Windows.FrameworkElement>，但不是尚未將它附加到任何邏輯樹狀結構。 或者，您的項目所在其內的子項目邏輯樹狀結構可能未連線至視窗或應用程式頁面。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>實作這個方法，以提供特殊處理，您的項目初始化期間載入程序的項目之前會發生。  
  
您的實作應該呼叫基底實作，因為基底 （預設值） 的實作會設定一些內部的旗標，以追蹤的初始化。 一個可能的實作是使用這個方法來攔截，到您自己尚未啟用的建構函式的私用類別初始化常式。  
  
基底實作會擲回例外狀況，如果<see cref="M:System.Windows.FrameworkElement.BeginInit" />呼叫一次以上相同的項目之前<see cref="M:System.Windows.FrameworkElement.EndInit" />所呼叫。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始提供之腳本中包含的動作順序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <summary>開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或是<xref:System.Windows.Media.Animation.BeginStoryboard>項目在標記中，然後將這些稱為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 大部分的控制層面的<xref:System.Windows.Media.Animation.Storyboard>可以解決會在標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當動畫到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須具備的分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
   
  
## Examples  
 下列範例會擷取<xref:System.Windows.Media.Animation.Storyboard>從 [資源]，然後執行，<xref:System.Windows.Media.Animation.Storyboard>內部事件時處理的類別。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <param name="handoffBehavior">列舉型別的值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</param>
        <summary>使用若屬性已經顯示動畫時應發生之情形的指定選項，開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或是<xref:System.Windows.Media.Animation.BeginStoryboard>項目在標記中，然後將這些稱為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 大部分的控制層面的<xref:System.Windows.Media.Animation.Storyboard>可以解決會在標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當動畫到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須具備的分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
 遞移式行為可將指定的屬性為<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用 Compose HandoffBehavior  
 當您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性，以使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>先前該屬性相關聯的物件會繼續耗用系統資源，計時系統會執行不會自動移除時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`作為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>從時鐘清單，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>的子系時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時要呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  回收物件時，其時鐘也會中斷連接，並進行記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
   
  
## Examples  
 下列範例會擷取<xref:System.Windows.Media.Animation.Storyboard>從 [資源]，然後執行，<xref:System.Windows.Media.Animation.Storyboard>內部事件時處理的類別。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <param name="handoffBehavior">列舉型別的值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</param>
        <param name="isControllable">宣告在動畫啟動後，是否可以控制 (暫停) 該動畫。</param>
        <summary>使用控制啟動後之動畫的指定狀態，開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或是<xref:System.Windows.Media.Animation.BeginStoryboard>項目在標記中，然後將這些稱為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 大部分的控制層面的<xref:System.Windows.Media.Animation.Storyboard>可以解決會在標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當動畫到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須具備的分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
 遞移式行為可將指定的屬性為<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用 Compose HandoffBehavior  
 當您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性，以使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>先前該屬性相關聯的物件會繼續耗用系統資源，計時系統會執行不會自動移除時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`作為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>從時鐘清單，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>的子系時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時要呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  回收物件時，其時鐘也會中斷連接，並進行記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>可用於驗證之物件的多個屬性的值。 例如，假設應用程式會提示使用者輸入的地址，並接著會填入型別的物件`Address`，其中具有屬性`Street`， `City`， `ZipCode`，和`Country`，值的使用者提供。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。 比方說，<xref:System.Windows.Controls.ValidationRule>可以確保郵遞區號是有效的地址的國家/地區。  
  
 項目子系繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例會是一部分的應用程式，會檢查使用者是否已設定為相同值的兩個物件的屬性。 第一個範例會建立兩個<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至不同的資料來源。 <xref:System.Windows.Controls.StackPanel>已經<xref:System.Windows.Data.BindingGroup>包含<xref:System.Windows.Controls.ValidationRule>檢查兩個字串是否相等。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 下列範例所示<xref:System.Windows.Controls.ValidationRule>，先前的範例使用。  在 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法覆寫，此範例會取得每個來源物件<xref:System.Windows.Data.BindingGroup>並檢查物件的屬性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 若要叫用<xref:System.Windows.Controls.ValidationRule>，呼叫<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>方法。  下列範例會呼叫<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>按鈕的 click 事件發生時。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在內含此項目的任何可捲動區域內，嘗試將此項目帶入檢視。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在內含此項目的任何可捲動區域內，嘗試將此項目帶入檢視。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>源自目前的項目中的事件。 會引發這個事件，以便它可以藉由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似的類別。 預期的行為是，事件由父項目，標示為已處理事件資料，在處理事件的來源帶入檢視的邏輯內嵌在透過<xref:System.Windows.Controls.ScrollViewer>控制項。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件或<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法傳輸相關的成功或失敗，以外，這個事件通常是標示為在處理的成功的任何資訊。 失敗可能包含項目設定，如的原因<xref:System.Windows.UIElement.Visibility%2A>以外的某些值<xref:System.Windows.Visibility.Visible>。  
  
 如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 會成為可見。  
  
 藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上包含的項目中任何父系可捲動區域。 如果這個項目不包含在可捲動區域<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但是不會有任何作用因為沒有任何事件接聽程式。  
  
   
  
## Examples  
 下列範例會實作應用程式瀏覽事件，每當回應的處理常式[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]正在瀏覽至包含片段。 在名為片段[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]遵循雜湊符號 （#），並實作的行為會導致要捲動進入檢視框架內的項目。 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 和<xref:System.Windows.FrameworkElement.RequestBringIntoView>要求在範例中，捲動行為。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">指定同樣應帶入檢視的項目大小。</param>
        <summary>在內含此項目的任何可捲動區域內，嘗試將此項目所提供的區域大小帶入檢視。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>源自目前的項目中的事件。 會引發這個事件，以便它可以藉由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似的類別。 預期的行為是，事件由父項目，標示為已處理事件資料，在處理事件的來源帶入檢視的邏輯內嵌在透過<xref:System.Windows.Controls.ScrollViewer>控制項。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件或<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法傳輸相關的成功或失敗，以外，這個事件通常是標示為在處理的成功的任何資訊。 失敗可能包含項目設定，如的原因<xref:System.Windows.UIElement.Visibility%2A>以外的某些值<xref:System.Windows.Visibility.Visible>。  
  
 如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 會成為可見。  
  
 藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上包含的項目中任何父系可捲動區域。 如果這個項目不包含在可捲動區域<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但是不會有任何作用因為沒有任何事件接聽程式。  
  
   
  
## Examples  
 下列範例會在受條件約束的捲動區域中有大型的圖形。 頁面上的按鈕有捲動檢視來大量圖形的特定區域的處理常式。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定透過操作功能表項目的 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要求操作功能表時應該出現的操作功能表項目。</summary>
        <value>指派給這個項目的操作功能表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生類別，然後就技術上來說可能<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性。 不過，這會建立令人混淆的內容功能表經驗的使用者，並不建議這種做法。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在項目上的任何內容功能表正要關閉之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要隱藏關閉快顯功能表，事件處理常式應將其標記為已處理。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考事件的基礎服務的定義：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkElement>，會公開基礎服務事件不會對應<xref:System.Windows.FrameworkElement.ContextMenuClosing>識別項，您可以使用它作為觸發程序)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生類別，但<xref:System.Windows.FrameworkElement.ContextMenuClosing>事件就不會引發由操作功能表直接。 相反地，會引發事件，從 「 擁有 」 做為屬性的內容功能表，並只會在使用者嘗試關閉 UI 中的操作功能表時所引發的項目。 但是它有可能<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性 （巢狀的內容功能表）。 在此情況下<xref:System.Windows.Controls.ContextMenu>實際上未擁有巢狀<xref:System.Windows.Controls.ContextMenu>及可能引發事件，與在巢狀的內容功能表中的事件來源。  
  
 <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Closed>)，但<xref:System.Windows.Controls.ContextMenu.Closed>事件不會提供您取消的使用者動作的機會。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目上的任何內容功能表開啟時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手動開啟操作功能表，為已處理的事件處理常式時，應該標示相關的事件。 否則，現有的值<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性會用來自動開啟操作功能表。 標記處理的事件會有效地取消的預設動作，並可能是重設的值有機會<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。 不過，還有您應該要注意的時間問題。 為了完全取代透過操作功能表<xref:System.Windows.FrameworkElement.ContextMenuOpening>處理常式中，初始的操作功能表不能為 null 或空白。 或者，您可能需要處理的事件，然後以手動方式開啟新的操作功能表。 如需詳細資訊，請參閱 <<c0> [ 如何： 處理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考基礎附加的事件：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkElement>，會公開基礎服務事件不會對應<xref:System.Windows.FrameworkElement.ContextMenuOpening>識別項，您可以在觸發程序中使用它)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生類別，但不是會從內容功能表中開啟做為來源引發此事件。 從 「 擁有 」 做為屬性的內容功能表，並只會在使用者嘗試在 UI 中，開啟操作功能表時所引發的項目，會引發事件。 可能<xref:System.Windows.Controls.ContextMenu>本身能夠<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，但您應該避免這種情況 (如需詳細資訊，請參閱<xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Opened>)，但<xref:System.Windows.Controls.ContextMenu.Opened>將不提供取消的使用者動作的機會。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定滑鼠指標在此元素上方時所顯示的游標。</summary>
        <value>要顯示的游標。 預設值依這個相依性屬性定義為 <see langword="null" />。 不過，執行階段的實際預設值會受各種因素影響。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中設定這個屬性時， [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，則[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。 提供的字串應該評估為<xref:System.Windows.Input.CursorType>值。 如需詳細資訊，請參閱<xref:System.Windows.Input.Cursor>。  
  
 這個屬性所建立的資料指標是否將，或當滑鼠指標位於此項目上方時，不會顯示主要取決於值<xref:System.Windows.FrameworkElement.ForceCursor%2A>屬性。 此外，事件相關的考量，例如使用中的拖放、 滑鼠捕捉、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性中的值。  
  
 若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。  
  
 `null`預設實際上會判斷實際的資料指標的值此處延後和應從別處取得。 如果看到不含以程式設計方式從任何來源的值時，預設資料指標，是以視覺化方式超過[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]應用程式是在箭號。 不過，暫時性的資料指標變更不會設定為<xref:System.Windows.FrameworkElement.Cursor%2A>時它們會透過傳遞的項目值。 <xref:System.Windows.FrameworkElement.Cursor%2A>屬性會唯一報表非 null 值在實際設於何處，例如透過程式碼或樣式的情況下。 每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.UIElement.QueryCursor>事件。 事件反昇和路由中的任何項目有機會處理事件，並設定透過此事件的引數的資料指標的值。 這是產生在大部分情況下以視覺化方式明顯的資料指標的機制。 如果<xref:System.Windows.UIElement.QueryCursor>處理常式傳回一個資料指標結果，則事件處理，而且引數中已變更的值優先於 windows 7<xref:System.Windows.FrameworkElement.Cursor%2A>屬性，在任何層級，除非<xref:System.Windows.FrameworkElement.ForceCursor%2A>設定。  
  
 您如果不建立自訂游標，通常有設定此屬性的靜態屬性值<xref:System.Windows.Input.Cursors>類別。 設定<xref:System.Windows.FrameworkElement.Cursor%2A>在程式碼需要下列其中之一：  
  
-   呼叫<xref:System.Windows.Input.Cursor>建構函式來取得<xref:System.Windows.Input.Cursor>執行個體。 這兩個簽章<xref:System.Windows.Input.Cursor>建構函式使用資料流或檔案，您要建立的預期<xref:System.Windows.Input.Cursor>自訂的資料指標的物件。  
  
-   使用<xref:System.Windows.Input.CursorConverter>類別和其<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>方法，以指定的資料指標<xref:System.Windows.Input.CursorType>，或可評估為字串<xref:System.Windows.Input.CursorType>，並轉換回到<xref:System.Windows.Input.Cursor>。  
  
 設定<xref:System.Windows.Input.Cursor>在部分信任中不會啟用為某個自訂值。 如需有關自訂的資料指標的詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例示範如何刻意設定資料指標圖形。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目在參與資料繫結時的資料內容。</summary>
        <value>用做為資料內容的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，繫結，例如路徑的資料來源的相關資訊。  
  
 資料內容可以會直接設定為.NET 物件，以評估該物件的屬性繫結。 或者，您可以設定資料內容<xref:System.Windows.Data.DataSourceProvider>物件。  
  
 這個相依性屬性繼承的屬性值。 如果有子項目，而不需要的其他值<xref:System.Windows.FrameworkElement.DataContext%2A>透過本機值或樣式，來建立，則屬性系統會設定這個值為<xref:System.Windows.FrameworkElement.DataContext%2A>指派此值最接近的父項目的值。  
  
 或者，您可以使用下列屬性之一<xref:System.Windows.Data.Binding>類別來明確指定繫結來源：
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  如需詳細資訊，請參閱 <<c0> [ 如何： 指定繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在 XAML 中，<xref:System.Windows.FrameworkElement.DataContext%2A>通常會設定為<xref:System.Windows.Data.Binding>宣告。 您可以使用屬性元素語法或屬性語法。 屬性語法會顯示在此頁面上的範例。 您也可以使用程式碼來設定<xref:System.Windows.FrameworkElement.DataContext%2A>。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> 是可繫結為 dbtype_iunknown 其中一個內容可能會繫結到另一個屬性。 不過，如果您繫結至<xref:System.Windows.FrameworkElement.DataContext%2A>，請小心不要建立循環的繫結參考 (不會繫結<xref:System.Windows.FrameworkElement.DataContext%2A>本身，這很可能會由於屬性值繼承的情況進行<xref:System.Windows.FrameworkElement.DataContext%2A>屬性)。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 直接內嵌的物件，用做為父項目中的任何繫結的資料內容。 一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>衍生的類別。 或者，可能會在這裡，放適用於繫結的任何物件類型的未經處理資料實際稍後定義的繫結。  
  
 *bindingUsage*  
 評估為不適當的資料內容繫結使用方式。 如需詳細資訊，請參閱[Binding 標記延伸模組](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 下列其中之一： [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)或是[ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)。 指的定義為資源中之物件的未經處理資料時，會使用這種使用方式。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 從所要求之物件的索引鍵識別碼<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例說明如何將資料內容處理程式碼繫結，並提供定義的繫結屬性的特定值的資訊。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個項目的資料內容變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需資料內容和資料繫結的說明，請參閱 <<c0> [ 資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  當<xref:System.Windows.FrameworkElement.DataContext%2A>項目變更時，可能會受影響這個項目上的所有資料繫結屬性。 這適用於所有項目都會邏輯樹狀結構中目前項目的子項目繼承的資料內容，以及目前的項目本身。 所有這類現有的繫結必須重新解譯新<xref:System.Windows.FrameworkElement.DataContext%2A>並會重新評估繫結結果。 資料繫結引擎不具決定性的這些困擾，相對於引發順序<xref:System.Windows.FrameworkElement.DataContextChanged>事件。 事件之後，或以任何混合，可以會在事件中之前, 發生的重新評估。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.DataContext" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可在使用或定義佈景主題樣式時，用來參考這個控制項之樣式的索引鍵。</summary>
        <value>樣式索引鍵。 若要當做佈景主題樣式查閱一部分正常運作，這個值必須是要加上樣式之控制項的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性通常是透過其直接屬性存取子的任何未設定。 相反地，您會覆寫這個相依性屬性的型別特定中繼資料每次您建立新<xref:System.Windows.FrameworkElement>衍生的類別。 當您衍生的控制項時，呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>針對方法<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>內控制項的靜態建構函式的識別碼，衍生類別 （或對等的類別初始化）。  
  
 控制項通常會覆寫它自己的型別，這個屬性的預設值，但在某些情況下也可以使用基底類型存在佈景主題字典中的樣式。 如果基底控制項的 [控制項] 範本完全定義該衍生的視覺表示法，而且衍生的型別公開 （expose） 任何其他成員不需要額外的項目控制項範本的一部分，這是控制項的只有實用。  
  
 如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>屬性設`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例說明的 < 備註 > 所述的相依性屬性中繼資料覆寫使用量。 此程式碼會定義自訂控制項類別`NumericUpDown`適用於從專用的控制項程式庫組件。 詳述的靜態建構函式參考一些私用的初始化函式時，註冊類別處理常式 (另一個常見的控制項子類別化案例; 請參閱[路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md))，最後覆寫<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>上的相依性屬性中繼資料`NumericUpDown`類別。 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 預期的索引鍵，也就是用來查閱某些任意的非樣式控制項的樣式的佈景主題樣式系統的慣例，一律會傳回它自己的類型。 完整的範例也會定義該金鑰; 所參考的實際控制項的佈景主題樣式請參閱[NumericUpDown 自訂控制項，具有佈景主題和 UI 自動化支援範例](https://go.microsoft.com/fwlink/?LinkID=160025)。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  此範例的完整原始程式碼位於 GitHub 兩者[ C# ](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary)並[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary)。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">具有佈景主題和 UI 自動化支援範例的 NumericUpDown 自訂控制項</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>表示項目的初始設定程序已完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.FrameworkElement.BeginInit%2A>先前已呼叫，基底實作會引發<xref:System.Windows.FrameworkElement.Initialized>事件。 否則，如果<xref:System.Windows.FrameworkElement.BeginInit%2A>，不會呼叫或可能不是決定是否<xref:System.Windows.FrameworkElement.BeginInit%2A>呼叫，則會<xref:System.Windows.FrameworkElement.Initialized>就不會引發，並改為擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">呼叫 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 時，沒有在項目上先呼叫 <see cref="M:System.Windows.FrameworkElement.BeginInit" />。</exception>
        <block subset="none" type="overrides">
          <para>實作這個方法，以提供您的項目初始化期間載入程序的項目時應該發生的特殊處理。  
  
您的實作應該呼叫基底實作，因為基底 （預設值） 的實作會設定一些內部的旗標，以追蹤的初始化。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求之項目的名稱。</param>
        <summary>尋找具有所提供之識別項名稱的項目。</summary>
        <returns>要求的項目。 如果找不到相符的項目，這可能會是 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果項目具有子項目，這些子元素會遞迴地搜尋所有要求的具名項目。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> 可在目前的項目名稱範圍內操作。 如需詳細資訊，請參閱 < [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">X:name 屬性</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">所要求資源的索引鍵識別項。</param>
        <summary>以指定的索引鍵搜尋資源，如果找不到要求的資源時會擲回例外狀況。</summary>
        <returns>要求的資源。 如果找不到含有所提供索引鍵的資源，便會擲回例外狀況。 在擲回例外狀況時，可能也會傳回 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。 如果您不想處理的呼叫會造成例外狀況<xref:System.Windows.FrameworkElement.FindResource%2A>，呼叫<xref:System.Windows.FrameworkElement.TryFindResource%2A>改。 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 傳回`null`當要求的資源無法找到，且不擲回例外狀況。  
  
 如果呼叫的項目上找不到資源，邏輯樹狀結構中的父項目是搜尋的下一步，應用程式，則佈景主題，然後最後系統資源。 這項查閱方法等同於在標記中的動態資源參考所要求資源如果樹狀結構搜尋的方式。 如需有關資源查閱的詳細資訊，請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 一般而言，您立即轉換<xref:System.Windows.FrameworkElement.FindResource%2A>值傳回至屬性的型別，您可以使用傳回的資源值設定。  
  
 資源索引鍵不一定是字串。 比方說，樣式的佈景主題層級的控制項索引鍵，<xref:System.Type>的控制項，以及應用程式或頁面的樣式的控制項通常會使用這個相同的金鑰慣例。 如需詳細資訊，請參閱 <<c0> [ 設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)或是[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
   
  
## Examples  
 下列範例會取得一個具名的資源，並將它轉換成適當的型別來填滿屬性。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到 <paramref name="resourceKey" />，<see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件的事件處理常式也不存在。  
  
-或- 
 找不到 <paramref name="resourceKey" />，而且 <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> 屬性是 <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件中的 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定文字和其他 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 項目在控制其配置的任何父項目中的流向。</summary>
        <value>文字和其他 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 項目在其父項目中的流向，以列舉值表示。 預設值是 <see cref="F:System.Windows.FlowDirection.LeftToRight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性屬性的使用方式設定<xref:System.Windows.FrameworkElement.FlowDirection%2A>這個項目上。 因為設定的屬性值繼承<xref:System.Windows.FrameworkElement.FlowDirection%2A>可能可以設定項目上<xref:System.Windows.FrameworkElement.FlowDirection%2A>上未設定的所有子項目<xref:System.Windows.FrameworkElement.FlowDirection%2A>在本機或透過其他方式，例如樣式。  
  
 這個屬性未自動設定做為一部分的任何應用程式的文化特性資訊，因為項目可能包含不一定是要遵守的文化特性資訊所隱含的一般流程方向的內容。 如需有關全球化考量的詳細資訊，請參閱[WPF 的全球化](~/docs/framework/wpf/advanced/globalization-for-wpf.md)。  
  
 此屬性具有已定義[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]屬性存取子，因此它可作為相依性屬性。 不過，它也會註冊為附加，因此它也可以當作附加屬性。 附加的註冊是主要是讓屬性值繼承支援，但屬性也可用來當做真正的附加屬性。 附加的屬性使用方式，才會相關，如果您想要設定文字方向的物件具有<xref:System.Windows.FrameworkElement>父元素中會執行配置時，不是本身<xref:System.Windows.FrameworkElement>，而且已沒有更直接定義`FlowDirection`屬性。 (某些流程這類文件類別<xref:System.Windows.Documents.Block>並<xref:System.Windows.Documents.Inline>定義自己的`FlowDirection`，這個屬性也可以設定文字方向。 屬性值再由讀取最終內容主機而不需要附加的屬性使用方式。）  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個屬性也可以設定不是類別上<xref:System.Windows.FrameworkElement>衍生類別，由下列[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]附加屬性使用方式：  
  
 `<` *物件* `FrameworkElement.` **FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 這個屬性是相依性屬性和附加的屬性;請參閱 < 備註 >。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定屬性，這個屬性可自訂外觀、效果或其他樣式特性，以在這個項目捕捉到鍵盤焦點時套用至項目。</summary>
        <value>要在取得焦點時套用的樣式。 相依性屬性中所宣告的預設值是空的靜態 <see cref="T:System.Windows.Style" />。 不過，執行階段的有效值通常是 (但不一定總是) 佈景主題支援為控制項所提供的樣式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會影響視覺外觀，但不會報告<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>中繼資料中。 這是因為視覺外觀變更事件驅動，隨時可能不適用且因此通常不應該報告中繼資料中的任何視覺效果] 或 [版面配置資訊。  
  
 就概念而言，套用至控制項的焦點視覺行為應該保持一致控制項。 若要只變更焦點視覺化樣式，當您在撰寫整個佈景主題，是最合理的方式，來強制執行一致性。 設定這個屬性上個別控制項的樣式，而不是屬於佈景主題不是預定的使用方式，此屬性，因為它可能會導致令人困惑的使用者體驗，關於鍵盤焦點。 如果您打算是刻意不一致整個佈景主題的控制項特定行為，更好的方法是使用觸發程序在樣式中個別輸入的狀態屬性，這類<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做並不會的方式以視覺化方式會影響任何現有的焦點視覺化樣式。 如需有關的設計用意<xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>及替代專注屬性，請參閱 <<c2> [ 設定在控制項和 FocusVisualStyle 焦點的樣式](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式索引鍵。 索引鍵參考中的現有資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性元素語法是技術上可行，但不是建議使用。 請參閱[內嵌樣式和範本](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示此 <see cref="T:System.Windows.FrameworkElement" /> 是否應強制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 呈現游標，如 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 屬性所宣告。</summary>
        <value>如果游標位於此項目上方時，強制游標展示使用目前游標的 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 設定 (包括在所有子項目上) 則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您將這個屬性設定為`true`您將會覆寫的子項目所建立的資料指標喜好設定。 因此一般應用程式這麼做[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能會造成混淆使用者，特別是如果子元素正嘗試將指定資料指標。 設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>在控制項的子類別化或複合 （compositing） 的情況下更適合。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會強制資料指標的值。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要從中取得繫結的目標 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>傳回 <see cref="T:System.Windows.Data.BindingExpression" />，代表指定屬性的繫結。</summary>
        <returns>如果目標屬性具有使用中的繫結，則為 <see cref="T:System.Windows.Data.BindingExpression" />；否則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢查傳回值的`null`是一種技術，可用來判斷屬性是否具有使用中的繫結。  
  
 這個方法是其實只是為了方便起見包裝<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>方法。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> 將目前的執行個體傳遞並`dp`參數來<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">要為其傳回 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 的項目。</param>
        <summary>取得所指定 <see cref="T:System.Windows.DependencyObject" /> 的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加屬性值。</summary>
        <returns>要求的流程方向，作為列舉值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的主要目的是支援的附加的屬性語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定其父項目中排列的流程方向。 若要取得值，在目前<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">視覺呈現的項目部分大小。</param>
        <summary>傳回裁剪遮罩的幾何。 如果配置系統嘗試排列大於可用顯示空間的項目，則會套用這個遮罩。</summary>
        <returns>裁剪幾何。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 邊界將被減去`layoutSlotSize`版面配置系統行為的一部分。  
  
 傳回的 null 參考，表示會發生任何裁剪。 預設實作永遠會傳回`null`時<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。 這個方法會覆寫 <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>。 <xref:System.Windows.FrameworkElement>實作會使用<xref:System.Windows.FrameworkElement.MaxHeight%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>其計算中。 數個類別的子<xref:System.Windows.FrameworkElement>覆寫這個方法一次。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>會覆寫以一律傳回`null`因為裝飾項通常是刻意一般範圍外。 <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> 並<xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType>會傳回`null`如果<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>預設實作永遠會傳回<see langword="null" />時<see cref="P:System.Windows.UIElement.ClipToBounds" />是<see langword="false" />。 覆寫通常都是保留這項行為，但有例外狀況，根據關聯性和衍生的類別和其版面配置邏輯，而不是基底類別的用途。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">要尋找的子項目名稱。</param>
        <summary>傳回具現化 <see cref="T:System.Windows.Controls.ControlTemplate" /> 視覺化樹狀結構中的具名項目。</summary>
        <returns>要求的項目。 如果所要求名稱的項目不存在，則可能為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的範本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]有獨立的名稱範圍。 這是因為範本是重複使用，並在範本中定義的任何名稱不能是唯一的當每個控制項的多個執行個體具現化其範本。 呼叫<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>方法，以傳回來自範本之後它會具現化, 物件的參考。 您無法使用<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>方法來尋找範本中的項目，因為<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>作用中的多個一般範圍，以及之間沒有連線<xref:System.Windows.Controls.ControlTemplate>類別本身和具現化的範本，一旦套用。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 提供這個方法相同的功能。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 已受到保護而不是公用，並使用正確名稱範圍，使其得以存取項目] 和 [尋找名為其內的項目內的範本考量。 使用<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>當您需要取得其父控制項之外的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果沒有視覺父代，則傳回這個項目的替代邏輯父代。</summary>
        <returns>每當這個方法的 WPF 架構層級實作具有非視覺父連線時，傳回 <see langword="null" /> 以外的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫 <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>。 預設值<xref:System.Windows.FrameworkElement>實作會傳回預期單一視覺化父項目，也就是相同的結果，以取得<xref:System.Windows.FrameworkElement.Parent%2A>值。 在衍生的類別實作可能會傳回替代的父代關聯性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">集合中要求的子項目之以零為起始的索引。</param>
        <summary>覆寫 <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />，並從子項目集合傳回指定索引處的子系。</summary>
        <returns>要求的子項目。 這應該不會傳回 <see langword="null" />；如果提供的索引超出範圍，則會擲回例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Windows.FrameworkElement>實作中，唯一有效的索引為零。 內容模型的<xref:System.Windows.FrameworkElement.GetVisualChild%2A>支援零個或一個子項目，不是集合。  
  
   
  
## Examples  
 下列範例示範如何自訂裝飾項會使用所宣告的值<xref:System.Windows.Media.VisualCollection>，它會維護其多個視覺子系。 這些值會透過覆寫的報告<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此實作僅適用於不會維護任何更具描述性的視覺子項目集合的項目。 沒有這類集合的任何項目必須覆寫這個方法，並將索引對應至對等的索引，該項目支援子項目集合中。 索引，範圍從 0 到<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />（減一） 應該會傳回有效的項目; 任何其他索引應該擲回例外狀況超出範圍。 範例中的項目型別支援子集合，且會覆寫<see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />若要傳回多個可能的子項<see cref="T:System.Windows.Controls.Panel" />。  
  
中的預設實作<see cref="T:System.Windows.FrameworkElement" />是假設只能有一個視覺子系。 針對傳遞任何值<paramref name="index" />非零的例外狀況擲回的原因。 數個常見的項目，例如裝飾項目、 裝飾項或具有特定的呈現的項目覆寫<see cref="T:System.Windows.FrameworkElement" />實作 （從中繼的基底類別實作）。 某些實作仍強制執行一個視覺子系，而有些則可讓集合。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的建議高度。</summary>
        <value>項目的高度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值是 <see cref="F:System.Double.NaN" />。 這個值必須等於或大於 0.0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> 其中三個可寫入屬性位於<xref:System.Windows.FrameworkElement>指定高度資訊。 其他兩種方式<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果沒有之間有衝突，這些值，實際高度判斷的應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後，如果在範圍中，內<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 如果此項目是某個其他項目內的子項目，然後將此屬性設為值其實只是建議的值。 版面配置系統，以及特定配置的邏輯父項目會使用值為非繫結輸入版面配置程序。 實際上<xref:System.Windows.FrameworkElement>幾乎都是其他; 的子項目設定時，即使<xref:System.Windows.FrameworkElement.Height%2A>上<xref:System.Windows.Window>。 (如<xref:System.Windows.Window>，會使用值，當基礎的應用程式模型會建立基本的轉譯假設建立 Hwnd 裝載的應用程式。)  
  
 除了為可接受<xref:System.Double>值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 這是您在程式碼中指定自動調整大小行為的方式。 在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您將值設定為字串"Auto"（不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填滿可用的高度。 不過請注意，特定的控制項通常會提供透過其將會停用自動調整大小行為，除非它是特別重新啟用的預設佈景主題樣式的預設值。  
  
 這個屬性傳回的值一定是與任何已設定為它的值相同。 相較之下，windows 7<xref:System.Windows.FrameworkElement.ActualHeight%2A>而有所不同。 這種情形是以靜態方式配置拒絕建議的大小，基於某些原因，因為或立刻顯示。 版面配置系統本身會在相對於屬性系統的組以非同步方式運作<xref:System.Windows.FrameworkElement.Height%2A>和可能處理該特定尚未調整大小屬性變更。  
  
 值的限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值，則會擲回執行階段例外狀況。  
  
 驗證檢查，除了沒有不具決定性的上限值，用於繫結<xref:System.Windows.FrameworkElement.Height%2A>，會由配置系統強制執行 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=nameWithType>但小於<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果您超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿設定<xref:System.Windows.FrameworkElement.Height%2A>大幅超過大小上限的任何可能的視覺顯示，或者您可能會超過此不具決定性的上限值。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 如需上限資訊，請參閱＜備註＞。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
 **Auto**  
 啟用自動調整大小行為。 請參閱＜備註＞。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Height" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至此元素在父項元素 (例如面板或項目控制項) 中組成時的水平對齊特性。</summary>
        <value>此水平對齊方式設定作為列舉值。 預設值為 <see cref="F:System.Windows.HorizontalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.Width%2A>項目上明確設定屬性，這些測量結果在配置期間會較高優先，並將取消設定的一般效果<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>至<xref:System.Windows.HorizontalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]屬性存取子是相依性屬性。 這個特定的相依性屬性很頻繁已設定不同的子類別化之項目，特別是控制項在其明顯的 「 預設 」 值。 這通常發生於兩種方式之一： 相依性屬性重新加以註冊特定的子類別，但具有不同的中繼資料，設定其預設值;或以不同的方式設定該相依性屬性值的預設樣式套用。 比方說，明顯 「 預設 」 的<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>for<xref:System.Windows.Controls.Label>控制項將會是<xref:System.Windows.HorizontalAlignment.Left>，即使<xref:System.Windows.Controls.Label>繼承<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>直接從<xref:System.Windows.FrameworkElement>。 這是因為該值重設的預設樣式內<xref:System.Windows.Controls.Label>，樣式的控制項範本內。  
  
 <xref:System.Windows.Controls.Canvas> 不會使用<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>當您在撰寫版面配置，因為<xref:System.Windows.Controls.Canvas>根據絕對位置。  
  
 當繼承<xref:System.Windows.Controls.Label>或衍生類別，<xref:System.Windows.Controls.Label>重新定義此相依性屬性的預設值<xref:System.Windows.HorizontalAlignment.Left>。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定屬性值繼承的範圍限制、資源索引鍵查閱，以及 RelativeSource FindAncestor 查閱。</summary>
        <value>列舉值。 預設值為 <see cref="F:System.Windows.InheritanceBehavior.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目中的特定界限樹狀組<xref:System.Windows.FrameworkElement.InheritanceBehavior%2A>刻意限制的繼承行為，來檢查應用程式資源，或防止 RelativeSource FindAncestor 查閱查詢目前的項目強制資源查閱範圍或任何進一步。 當使用繫結時，就會發生 RelativeSource FindAncestor 查閱<xref:System.Windows.Data.RelativeSource>具有其<xref:System.Windows.Data.RelativeSource.Mode%2A>屬性設定為<xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType>值。  
  
 若要讓您設定此屬性的衍生的類別，您應該這麼做在靜態建構函式或其他初始化常式中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個 <see cref="T:System.Windows.FrameworkElement" /> 初始化時發生。 這個事件符合 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 屬性值從 <see langword="false" /> (或未定義) 變更為 <see langword="true" /> 的案例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件時引發<xref:System.Windows.FrameworkElement.EndInit%2A>或<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>方法受到呼叫。 這兩種方法的呼叫可以有來自應用程式程式碼，或透過[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]處理器的行為時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理頁面。  
  
 您是否選擇處理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取決於您的需求。 如果您不需要讀取項目屬性，想要重設屬性，而且不需要任何版面配置的資訊，<xref:System.Windows.FrameworkElement.Initialized>可能要採取更好的事件。 如果您需要的項目，可供使用，所有屬性，而且您會設定屬性，可能會重設配置，<xref:System.Windows.FrameworkElement.Loaded>可能要採取更好的事件。 如果您的處理常式會由配置系統來表示需要新的版面配置階段解譯的任何屬性重設，則是小心重新進入。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>上如果您不確定哪些屬性可能需要新的版面配置屬性的值傳遞，在變更時。)  
  
 如需序列的物件事件<xref:System.Windows.FrameworkElement>，也針對幾個相關應用程式和項目類別，會看到[物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定此 <see cref="T:System.Windows.FrameworkElement" /> 使用的輸入內容。</summary>
        <value>輸入範圍，可修改替代輸入法之輸入的解譯方式。 預設值為 <see langword="null" /> (採用預設的命令處理方式)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個相依性屬性繼承的屬性值。 如果有子項目，而不需要的其他值<xref:System.Windows.FrameworkElement.InputScope%2A>透過本機值或樣式，來建立，則屬性系統會設定這個值為<xref:System.Windows.FrameworkElement.InputScope%2A>指派此值最接近的祖系項目的值。  
  
 雖然[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法用法列為和語法上允許，設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]不常見。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.InputScope" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出在由 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 處理器處理期間，或是明確地呼叫 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 方法時，是否已初始化這個項目。</summary>
        <value>如果對於每個先前提及的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 處理或方法呼叫將項目初始化，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性也可能`true`如果此項目具有移動邏輯樹狀結構內，使它有新的父項目，並且因此變成一次重新載入。  
  
 此屬性相當實用，如果您也使用<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>。 載入邏輯樹狀結構中的項目[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器可確保系統能夠進行初始化。 不在邏輯樹狀結構中的項目都初始化時<xref:System.Windows.FrameworkElement.EndInit%2A>呼叫。 任何特定處理缺少<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>，會發生這只要建構函式會傳回初始化的結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此項目是否已載入以供展示。</summary>
        <value>如果目前項目是附加至項目樹狀結構則為 <see langword="true" />，如果項目從未附加至已載入的項目樹狀結構則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從新的建構<xref:System.Windows.FrameworkElement>，此屬性一開始`false`，且會維持`true`設為之後`true`，即使之後移除元素從已連線的邏輯樹狀結構的程式碼。 `true` 狀態是由一般的展示邏輯時設定項目載入至展示引擎。  
  
 一般而言，載入的項目會轉譯，但並非全部<xref:System.Windows.FrameworkElement>衍生的類別中有一份簡報和其他屬性，例如<xref:System.Windows.UIElement.Visibility%2A>可能會影響呈現。  
  
   
  
## Examples  
 下列範例會實作兩個處理常式： 一個處理<xref:System.Windows.FrameworkElement.Loaded>事件的根項目，因此它是特定的頁面根項目，載入，因為這是事件的重要性。 其他處理常式會攔截到的使用者控制項，並呼叫<xref:System.Windows.FrameworkElement.IsLoaded%2A>，以確保根項目會載入完整。 這兩個處理常式呼叫相同的函式 （未顯示），將會填入新資料的子項目。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至項目的當地語系化/全球化語言資訊。</summary>
        <value>這個項目的語言資訊。 預設值是 <see cref="T:System.Windows.Markup.XmlLanguage" /> 及其設定為字串 "en-US" 的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字串格式會遵循 RFC 3066 標準。 例如，美國英文是"EN-US"。 如需有關值和格式的詳細資訊，請參閱<xref:System.Windows.Markup.XmlLanguage>。  
  
 這個相依性屬性繼承的屬性值。 如果有子項目，而不需要的其他值<xref:System.Windows.FrameworkElement.Language%2A>建立透過本機值或樣式，屬性系統會將值設為可<xref:System.Windows.FrameworkElement.Language%2A>指派此值最接近的祖系項目的值。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 定義的一般意義`xml:lang`屬性。 <xref:System.Windows.FrameworkElement.Language%2A> 基本上會公開這個屬性為相依性屬性的意義。 <xref:System.Windows.FrameworkElement.Language%2A> 可以以程式設計的方式，調整，而且可以參與平行的方式的屬性系統值繼承如何`xml:lang`屬性可以繼承中的子系項目範圍[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]。 如果您設定<xref:System.Windows.FrameworkElement.Language%2A>，此值會變成`xml:lang`並覆寫任何先前的值。 如需詳細資訊，請參閱 < [xml: lang 處理中 XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Language" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應在執行配置時，套用在這個項目圖形轉換。</summary>
        <value>這個項目應使用的轉換。 預設值為 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相對於<xref:System.Windows.UIElement.RenderTransform%2A>，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>會影響版面配置的結果。  
  
 設定轉換，可提供縮放和旋轉的強大的功能。 不過，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>會忽略<xref:System.Windows.Media.TranslateTransform>作業。 這是因為子元素的版面配置系統行為<xref:System.Windows.FrameworkElement>自動更正任何位移的位置插入版面配置的縮放或旋轉項目和父項目的的座標系統。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 可能會導致不佳的應用程式效能，如果您不需要完整檢查由配置系統的案例中叫用的。 當您套用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>要<xref:System.Windows.Controls.Panel.Children%2A>的集合<xref:System.Windows.Controls.Panel>觸發配置系統的新階段，強制所有螢幕上要能重新測量和重新排列物件。 如果您要更新的完整應用程式[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]，這項功能可能會完全您的需要。 不過，如果您不需要完整的版面配置階段，使用<xref:System.Windows.UIElement.RenderTransform%2A>屬性，它不會叫用配置系統，並因此，通常是較好的選擇，在此案例。  
  
 範例案例，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>很有用的包括： 旋轉項目，例如功能表元件從水平改成垂直，反之亦然，調整元素 （拉近） 焦點，提供編輯行為，依此類推。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例示範如何套用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>的項目。 此範例會建立的執行個體<xref:System.Windows.Controls.Button>並將它裝載在父<xref:System.Windows.Controls.Grid>。 它也會使用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>屬性，將套用<xref:System.Windows.Media.RotateTransform>至<xref:System.Windows.Controls.Button>。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">2d 轉換範例</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目已配置版面、呈現以及可以互動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> 通常的最後一個事件中引發的項目初始化順序。 它將會引發這個事件之後<xref:System.Windows.FrameworkElement.Initialized>。 您是否選擇處理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取決於您的需求。 如果您不需要讀取項目屬性，想要重設屬性，而且不需要任何版面配置的資訊，<xref:System.Windows.FrameworkElement.Initialized>可能要採取更好的事件。 如果您需要的項目，可供使用，所有屬性，而且您會設定屬性，可能會重設配置，<xref:System.Windows.FrameworkElement.Loaded>可能要採取更好的事件。 如果您的處理常式會由配置系統來表示需要新的版面配置階段解譯的任何屬性重設，則是小心重新進入。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>上如果您不確定哪些屬性可能需要新的版面配置屬性的值傳遞，在變更時。)  
  
 如需序列的物件事件<xref:System.Windows.FrameworkElement>，也針對幾個相關應用程式和項目類別，會看到[物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 直接路由的事件不會遵循路由，它們才會處理在相同的項目，其引發。 直接路由的事件支援其他路由的事件的行為： 它們支援的可存取的處理常式集合，且可用來當做<xref:System.Windows.EventTrigger>樣式。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同時會引發因為使用者起始系統佈景主題變更控制項上。 佈景主題變更會導致控制項範本以及包含視覺化樹狀結構，這樣又會卸載並重新載入整個控制項失效。 因此<xref:System.Windows.FrameworkElement.Loaded>無法假設發生只有當頁面是第一次載入透過 巡覽至頁面。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.Loaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>為此項目的邏輯子項目取得列舉值。</summary>
        <value>此項目之邏輯子項目的列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 可讓您逐一查看子項目。 這是適用於項目可能沒有定義、 專用的集合，但仍會包含一個以上的子項目，特別是<xref:System.Windows.FrameworkContentElement>子項目。  
  
 如需有關如何使用<xref:System.Windows.FrameworkElement.LogicalChildren%2A>並<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array 標記延伸</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的外邊界。</summary>
        <value>提供項目的邊界值。 預設值為其所有屬性皆等於 0 (零) 的 <see cref="T:System.Windows.Thickness" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 邊界是這個項目和其他版面配置建立時將會是相鄰的項目之間的間距[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 共用項目可能會對等項目 （例如其他項目通用的父控制項的集合中），或也可能是這個項目的父代。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> 已設定為<xref:System.Windows.Thickness>結構，而不是數字邊界可設定對稱性。 <xref:System.Windows.Thickness>結構本身支援字串類型轉換，好讓您可以指定非對稱<xref:System.Windows.FrameworkElement.Margin%2A>在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]也屬性語法。  
  
 非零的邊界適用於外部項目配置的空間<xref:System.Windows.FrameworkElement.ActualWidth%2A>和<xref:System.Windows.FrameworkElement.ActualHeight%2A>。  
  
 邊界的加總的同層級項目中的版面配置。比方說，兩者皆擁有 30 的邊界設定相鄰型 edge 的兩個相鄰項目會有 60 個兩者之間的空間。  
  
 具有邊界設定的項目將不會通常限制的指定大小<xref:System.Windows.FrameworkElement.Margin%2A>配置的矩形空間不是已夠大，邊界，再加上項目的內容區域。 計算配置時，將會改為限制的項目內容的區域。 邊界會受限於的唯一情況也是內容已被限制，一直到零。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *left、 頂端、 右下*  
 數字值介於 0 和<xref:System.Double.PositiveInfinity>會指定四個可能的維度屬性的<xref:System.Windows.Thickness>結構。  
  
 屬性使用方式也會接受縮寫對稱和邏輯的方式提供的順序套用的值。 比方說，`Margin="20"`會解譯成表示<xref:System.Windows.Thickness>具有設定為 20 的所有屬性。 `Margin="20,50"` 將被解譯成表示<xref:System.Windows.Thickness>與<xref:System.Windows.Thickness.Left%2A>並<xref:System.Windows.Thickness.Right%2A>設定為 20，和<xref:System.Windows.Thickness.Top%2A>和<xref:System.Windows.Thickness.Bottom%2A>設為 50。  
  
 預設單位<xref:System.Windows.Thickness>量值是[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]。 您也可以藉由附加單位類型字串來指定其他單位`cm`， `in`，或`pt`任何量值。  
  
 數字值依現狀[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]屬性不需要指定小數位數 （0 是可以接受的不需要提供為 0.0)。 如需詳細資訊[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>。  
  
 *thicknessReference*  
 將現有的物件參考<xref:System.Windows.Thickness>。 這可能是`}`、 a 或`}`參考。 如需詳細資訊[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Margin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素的最大高度限制。</summary>
        <value>項目的最大高度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值是 <see cref="F:System.Double.PositiveInfinity" />。 這個值可以是等於或大於 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性上<xref:System.Windows.FrameworkElement>指定高度資訊。 其他兩種方式<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.Height%2A>。  如果這些值之間沒有衝突，這是第一次應用程式的實際高度判斷順序<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後每一個位於範圍中，如果<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值的限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 相同<xref:System.Double>套用範圍限制的屬性值一節中所述，不同之處在於您必須使用[X:static 標記延伸](~/docs/framework/xaml-services/x-static-markup-extension.md)如果您需要明確地設定這個值為<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素的最大寬度限制。</summary>
        <value>項目的最大寬度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值是 <see cref="F:System.Double.PositiveInfinity" />。 這個值可以是等於或大於 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性上<xref:System.Windows.FrameworkElement>指定寬度的資訊。 其他兩種方式<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.Width%2A>。 如果這些值之間沒有衝突，實際寬度判斷的應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後每一個位於範圍中，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值的限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值，則會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 相同<xref:System.Double>套用範圍限制的屬性值一節中所述，不同之處在於您必須使用[X:static 標記延伸](~/docs/framework/xaml-services/x-static-markup-extension.md)來設定這個值為<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父項目可以提供給子項目使用的大小。</param>
        <summary>為 <see cref="T:System.Windows.FrameworkElement" /> 實作基本的測量傳遞配置系統行為。</summary>
        <returns>這個項目在配置中需要的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>連接 WPF 核心層級和 WPF 架構層級配置量值實作。 <xref:System.Windows.FrameworkElement>實作密封方法。 若要調整的任何項目，WPF 架構層級為基礎的量值傳遞版面配置行為，請覆寫<xref:System.Windows.FrameworkElement.MeasureOverride%2A>改。 若要調整的測量行程，刻意不會在 WPF 架構層級上建置或使用項目的版面配置行為<xref:System.Windows.FrameworkElement>，覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">此項目可提供給子項目使用的大小。 此值可以指定為無限大，表示項目會隨著可用的內容而改變大小。</param>
        <summary>在衍生類別中被覆寫時，測量子項目所需之配置的大小，以及決定 <see cref="T:System.Windows.FrameworkElement" /> 衍生類別的大小。</summary>
        <returns>大小，此項目會依據其計算子項目的大小結果，決定配置時所需的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫<xref:System.Windows.FrameworkElement.MeasureOverride%2A>若要實作自訂的版面配置調整大小行為，您的項目，因為它所參與[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]版面配置系統。 您的實作應該執行下列作業：  
  
1.  逐一查看您的項目特定版面配置，呼叫的一部分的子系集合<xref:System.Windows.UIElement.Measure%2A>每個子項目上。  
  
2.  立即取得<xref:System.Windows.UIElement.DesiredSize%2A>子系上 (這設定為屬性之後<xref:System.Windows.UIElement.Measure%2A>稱為)。  
  
3.  計算根據測量子項目的父代的網路所需的大小。  
  
 傳回值<xref:System.Windows.FrameworkElement.MeasureOverride%2A>應的項目本身所需大小，就會變成目前的項目之父元素的輸入量值。 頁面的根項目為止，這個相同的程序會持續進行版面配置系統。  
  
 在此過程中，子元素可能會傳回較大<xref:System.Windows.UIElement.DesiredSize%2A>大小比初始`availableSize`來表示子項目想更多空間。 這可能會處理您自己的實作中藉由引進可捲動區域，由父代調整控制項大小，藉由建立某種方式的堆疊順序或任何數目的測量或排列內容的解決方案。  
  
> [!IMPORTANT]
>  項目應該呼叫<xref:System.Windows.UIElement.Measure%2A>在此過程中每個子系，否則子項目將不會正確大小或排列。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>下列非編譯程式碼會示範這項實作模式。  <c>VisualChildren</c>代表您自己的項目應該定義的子系的可列舉集合屬性。 屬性可以命名任何項目。 <c>VisualChildren</c>是預留位置名稱，此範例中，以利<c>VisualChildren</c>不是[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]所提供[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]或部分的命名模式...  
  
[！ 的程式碼 csharp[CorePseudocode #FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [！ 的程式碼 vb[CorePseudocode #FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素的最小高度限制。</summary>
        <value>項目的最小高度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<see cref="F:System.Double.PositiveInfinity" /> 和 <see cref="F:System.Double.NaN" /> 都無效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性上<xref:System.Windows.FrameworkElement>指定高度資訊。  其他兩種方式<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果這些值之間沒有衝突，這是第一次應用程式的實際高度判斷順序<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後每一個位於範圍中，如果<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值的限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值，則會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 相同<xref:System.Double>套用屬性值一節中所述的範圍限制。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.MinHeight" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素的最小寬度限制。</summary>
        <value>項目的最小寬度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<see cref="F:System.Double.PositiveInfinity" /> 和 <see cref="F:System.Double.NaN" /> 則無效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性上<xref:System.Windows.FrameworkElement>指定寬度的資訊。  其他兩種方式<xref:System.Windows.FrameworkElement.Width%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果這些值之間沒有衝突，實際寬度判斷的應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後每一個位於範圍中，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值的限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值，則會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 相同<xref:System.Double>套用屬性值一節中所述的範圍限制。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.MinWidth" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">要移動焦點的方向，以列舉型別 (Enumeration) 的值表示。</param>
        <summary>以所提供的周遊方向，將鍵盤焦點從這個項目移到其他項目。</summary>
        <returns>若成功移動焦點則傳回 <see langword="true" />，若所指定之方向的目標項目不存在，或無法成為鍵盤導向，則傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作會覆寫<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType>並密封方法。  
  
   
  
## Examples  
 下列範例會實作處理數種可能的按鈕輸入處理常式。 每個按鈕表示可能發生<xref:System.Windows.Input.FocusNavigationDirection>。 處理常式會追蹤目前的鍵盤焦點和呼叫的項目<xref:System.Windows.FrameworkElement.MoveFocus%2A>該項目，指定適當<xref:System.Windows.Input.FocusNavigationDirection>初始化為<xref:System.Windows.Input.TraversalRequest>類型提供的參數。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的識別名稱。 此名稱提供參考，以便程式碼後置 (例如事件處理常式程式碼) 可以在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 處理器處理期間建構標記項目之後參考此項目。</summary>
        <value>項目的名稱。 預設為空字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的用法是指定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]做為屬性標記的項目名稱。  
  
 這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 名稱必須是唯一的名稱範圍內。 如需詳細資訊，請參閱 < [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 取得<xref:System.Windows.FrameworkElement.Name%2A>如果您要建立項目中的程式碼並不常見。 如果您沒有適當的參考程式碼中，您可以直接呼叫方法和項目上的屬性參考，而且通常不會需要<xref:System.Windows.FrameworkElement.Name%2A>。 這個例外狀況是如果<xref:System.Windows.FrameworkElement.Name%2A>字串具有某些多載意義，例如它是否可顯示該名稱在[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼後置如果原始<xref:System.Windows.FrameworkElement.Name%2A>從標記已設定，也不建議，並載入之後變更的屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]不會變更原始的物件參考。 只有在剖析期間明確建立基礎的名稱範圍時，會建立物件參考。 您必須特別呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>來進行有效變更<xref:System.Windows.FrameworkElement.Name%2A>已載入元素的屬性。  
  
 一個值得注意案例設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼是很重要時，才能註冊名稱，將分鏡腳本的項目執行，以便在執行階段參考它們。 您可以註冊的名稱之前，可能也需要具現化，並將指派<xref:System.Windows.NameScope>執行個體。 請參閱 < 範例 > 一節中，或是[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼具有有限的應用程式，但取得項目<xref:System.Windows.FrameworkElement.Name%2A>是更常見的。 一個特定案例中，這是您的應用程式是否支援頁面重新載入至應用程式，而執行的階段程式碼不一定是程式碼後置定義該頁面的瀏覽模型。 公用程式方法<xref:System.Windows.FrameworkElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkElement>，可以找到任何項目<xref:System.Windows.FrameworkElement.Name%2A>該項目邏輯樹狀結構中搜尋必要的樹狀目錄中以遞迴方式。 或者您可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，也會採用<xref:System.Windows.FrameworkElement.Name%2A>做為引數的字串。  
  
 常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>比方說) 實作介面<xref:System.Windows.Markup.INameScope>。 這個介面的實作應該強制執行的名稱是模稜兩可在其範圍內。 定義這個介面的根項目也定義名稱範圍行為界限的所有相關[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]。  
  
 <xref:System.Windows.FrameworkElement.Name%2A>屬性也可做為其他處理序的識別碼。 比方說， [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] automation 模型會使用<xref:System.Windows.FrameworkElement.Name%2A>為用戶端和提供者的 AutomationId。  
  
 所用的字串值<xref:System.Windows.FrameworkElement.Name%2A>有一些限制，如基礎所加諸[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)所定義[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]規格。 最值得注意的是，<xref:System.Windows.FrameworkElement.Name%2A>必須以字母或底線字元 (_) 開頭，而且必須包含字母、 數字或底線。 如需詳細資訊，請參閱 < [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> 是其中一個非常少無法變成動畫的相依性屬性 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>是`true`中繼資料中)，因為名稱本身是針對動畫很重要。 資料繫結<xref:System.Windows.FrameworkElement.Name%2A>技術上可行，但是一個非常常見的案例，因為資料繫結<xref:System.Windows.FrameworkElement.Name%2A>無法提供屬性的主要用途： 為程式碼後置中提供識別碼的連接點。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.NameProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 下列範例會設定<xref:System.Windows.FrameworkElement.Name%2A>屬性中的程式碼，然後註冊到新建立的 名稱<xref:System.Windows.NameScope>藉由呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>。 如下圖所示的技巧是使用分鏡腳本，以動畫顯示的需求，因為分鏡腳本必須由目標<xref:System.Windows.FrameworkElement.Name%2A>，並不能設為目標的物件參考。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Name" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中被覆寫時，每當應用程式程式碼或內部處理序呼叫 <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> 時一都會叫用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。  
  
 範本是區段的項目已完成的視覺化樹狀結構的 Template 屬性是來自<xref:System.Windows.Style>套用項目。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>衍生的類別<see cref="T:System.Windows.FrameworkElement" />可以使用這個方法為通知的各種可能的案例： 
-您可以呼叫您自己的建置項目視覺化樹狀結構的其餘部分的程式碼的實作。  
  
-您可以執行已套用至範本，例如取得來自範本的具名項目參考的視覺化樹狀結構所依賴的程式碼。  
  
-您可以導入才有意義存在於範本位於視覺樹狀結構完成後的服務。  
  
-您可以設定狀態和屬性的範本內會相依於其他因素的項目。 比方說，屬性值可能只會設定為可探索藉由得知的父項目，或當特定衍生類別會使用常見的範本。  
  
實作者應該一律呼叫之前其自己實作的基底實作。 <see cref="T:System.Windows.FrameworkElement" /> 本身具有沒有預設值可能會實作中，但中介類別。  
  
 <see cref="T:System.Windows.Controls.Control" /> 提供類似的覆寫， <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當未處理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 如果在繼承的中繼類別已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。 一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 如果在繼承的中繼類別已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。 一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件到達其路由中的這個項目時，便會叫用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於在某些其他 * 基底的項目，所公開的方法<xref:System.Windows.FrameworkElement.OnGotFocus%2A>沒有預設實作。 具體來說，它已關閉，就會覆寫基底元素的下一步 層級中的 null 實作的實作<xref:System.Windows.UIElement.OnGotFocus%2A>。 叫用時，<xref:System.Windows.FrameworkElement.OnGotFocus%2A>在目前的項目，因為鍵盤焦點從事件的起源的情況下此項目上設定適當的焦點行為。 <xref:System.Windows.FrameworkElement.OnGotFocus%2A>處理常式不會標記為已處理，即使當焦點設定為目前的項目之事件引數。 如果事件的來源是在樹狀目錄中 （不是目前項目） 的另一個項目，這個處理常式沒有任何作用。  
  
 您可以覆寫此方法，以變更預設的焦點行為，在您的項目，但請注意，變更焦點行為，如此一來可能會更好可藉由不允許 完全可設定焦點的項目 (請參閱<xref:System.Windows.UIElement.Focusable%2A>)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您想要將事件引數中處理標記，您應留意其他項目樹狀結構中的父元素中的事件處理的結果。 因為這個處理常式是事件反昇的路由，將焦點設定至目前<paramref name="sender" />每個事件引數可能不適當。 焦點，可能需要進入任一個複合的子項目或父項目，根據某些控制項的複合。 因此將焦點事件標示為已處理，才建議整個事件透過路由的視覺化樹狀結構是撰寫您所撰寫之控制項的一部分。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.FrameworkElement.Initialized" /> 事件。 每當 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 在內部設為 <see langword="true" /> 便會叫用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此特定 * 方法並不是類別處理常式攔截。 或其不完全遵循既定[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上 * 方法慣例相符的事件可能會隱藏透過覆寫這個方法並不會呼叫基底實作。  
  
 請注意，<xref:System.Windows.FrameworkElement.IsInitialized%2A>屬性是唯讀的因此您無法設定<xref:System.Windows.FrameworkElement.IsInitialized%2A>來強制初始化行為。 設定初始設定狀態要進行只有[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]framework。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虛擬方法的預設實作會引發事件，如先前所述。 覆寫應呼叫基底實作以保留此行為。 如果您無法呼叫基底實作，不只將您不會引發<see cref="E:System.Windows.FrameworkElement.Initialized" />事件，通常預計的<see cref="T:System.Windows.FrameworkElement" />衍生類別，但您也會隱藏兩個重要樣式和佈景主題樣式初始化作業藉由這個基底實作。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件資料，描述已變更的屬性，以及舊值和新值。</param>
        <summary>每當這個 <see cref="T:System.Windows.FrameworkElement" /> 上任何相依性屬性的有效值已更新時叫用。 已變更的特定相依性屬性會在引數參數中報告。 覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是要用於偵測一般的屬性變更或失效。 它改為適用於一般失效模式修改如果已知廣泛分類屬性的特定資訊。  
  
 這個方法是可能被叫用次數物件的存留期間。 因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。 不過，您會使用這個方法如果<xref:System.Windows.FrameworkElement>包含大量的值相互關聯的相依性屬性，或者如果它包含邏輯，例如轉譯行為，必須重新執行的許多相關的屬性失效的情況。  
  
 請注意，有同名`OnPropertyChanged`方法具有不同的簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別上。 該`OnPropertyChanged`用於資料物件的通知，而且是合約的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>務必呼叫基底實作中，在實作中的第一個作業。 如果沒有這樣做會大幅停用整個[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統中，這會導致報告不正確的值。 特定<see cref="T:System.Windows.FrameworkElement" />實作也會負責維護適當的狀態，針對各種會影響顯示的使用者介面的屬性。 這些包括讓失效的變更樣式在適當的時間為基礎的視覺化樹狀結構。</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">變更所涉及之舊和新大小的詳細資料。</param>
        <summary>使用指定的資訊作為最終事件資料的一部分，引發 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>。 如果您呼叫這個方法則會重設<xref:System.Windows.FrameworkElement.ActualWidth%2A>屬性，<xref:System.Windows.FrameworkElement.ActualHeight%2A>中提供的引數，變更的屬性，或兩者，根據為指定的項目，並且您總是會引發此事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>不會覆寫這個方法的典型版面配置案例。 版面配置系統會刻意非同步的方式，以確保所有可能的配置排列，並說明量值的情況下運作。 版面配置系統覆寫方法<see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />和<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />通常已足夠完成任何必要的配置的自訂。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> 會公開為虛擬機器。 您可以覆寫<see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />更正執行階段行為的變更與輸入事件結合控制項的例外狀況的撰寫回應可能會提供不正確的版面配置資訊。  
  
您可能仍會覆寫 （受保護但並未密封） 衍生類別中的，這個方法。 請務必呼叫基底實作，以保留先前所述，行為，除非您有非常特定的理由，停用預設 WPF 架構層級轉譯行為。 無法引發<see cref="E:System.Windows.FrameworkElement.SizeChanged" />事件將會產生非標準的版面配置行為，如果使用標準的 WPF 架構層級的版面配置系統實作。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">舊樣式。</param>
        <param name="newStyle">新樣式。</param>
        <summary>在這個項目上使用的樣式變更時叫用，如此將使配置失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法有設定資訊的樣式變更條件的內部旗標的預設實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您應該通常不必覆寫這個方法。 任何變更牽涉到量值為樣式或排列變更已經會觸發另一個轉譯週期，假設的典型實作<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />，或預設值。 覆寫<see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />可能適合如果您<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />實作刻意將最佳化，或支援部分更新，但仍然會想要更直接將變更套用至樣式。 (部分更新會嘗試避免多個累加呼叫<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />和<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上任何子項目)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當未處理的 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 如果在繼承的中繼類別已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。 一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 如果在繼承的中繼類別已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。 一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">舊的父項目。 可能是 <see langword="null" />，表示項目之前沒有視覺父項目。</param>
        <summary>在視覺化樹狀中這個項目的父項目變更時叫用。 覆寫 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視覺化樹狀結構是有別於邏輯樹狀結構，因為後者省略不 （例如集合），以視覺化的方式，呈現的項目，並展開其主題和樣式複合 （compositing） 根據某些項目。 如需詳細資訊，請參閱 [WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個虛擬方法的預設實作會查詢以取得新的父項、 引發各種初始化事件，及設定內部的旗標，初始化狀態的相關<see cref="T:System.Windows.FrameworkElement" />視情況。 最後，它會呼叫後續的基底實作，做為宣告所<see cref="T:System.Windows.UIElement" />，接著呼叫其基底<see cref="T:System.Windows.Media.Visual" />。 請務必呼叫基底實作，以保留此行為，否則宣告為另一個元素的子系時，這個項目的項目樹狀結構行為可能無法如預期般運作。  
  
設定現有的少數[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]類別會覆寫這個方法，例如： <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />， <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />。 最常見的案例是強制執行新的父系必須是特定類型。 這可能涉及新的父項失敗的型別測試的一些方式時擲回例外狀況。 此案例中的特製化的版本存在於清單項目和功能表項目，其中沒有意義的任何父代之外 visual 擁有適當的集合，來儲存它們的實作。 請注意，這種情況下不一定會引發例外狀況，因為可能會依賴 「 一般 」 父母不屬於暫時的項目重設父代的設計工具案例。  
  
這個方法也會覆寫中特定項目，它們通常是根項目，例如<see cref="T:System.Windows.Window" />。 另一種情況是明顯的根目錄中的項目標記，但其中的項目自動產生更高的基礎結構已編譯的邏輯樹狀結構中 (例如<see cref="T:System.Windows.Controls.Page" />)。 <see cref="T:System.Windows.Window" />和<see cref="T:System.Windows.Controls.Page" />實作刻意密封方法。</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定此元素的樣式屬性是否來自佈景主題樣式的值。</summary>
        <value>如果這個項目不會使用佈景主題樣式，所有從樣式產生的屬性都來自本機應用程式樣式，且佈景主題樣式屬性不會套用，則為 <see langword="true" />。 如果應用程式樣式先套用，然後針對不是在應用程式樣式中具體設定的屬性套用佈景主題樣式則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。  
  
> [!IMPORTANT]
>  如果您設定<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>至`true`控制，您將會隱藏的佈景主題樣式所提供的預設控制項範本。 該控制項範本通常會包含內容的主講人和其他複合的項目，提供基本[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]功能和控制項的視覺效果。 如果您想要繼續支援相同的功能，做為預設佈景主題樣式的控制項，您必須提供替代樣式與複寫相同的結構的控制項範本。 如需詳細資訊，請參閱[控制項撰寫概觀](~/docs/framework/wpf/controls/control-authoring-overview.md)。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個項目的邏輯父項目。</summary>
        <value>此項目的邏輯父代。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> 可能是`null`中的項目已具現化，而未附加到任何最終會連接到的頁面層級的根項目中或應用程式物件的邏輯樹狀結構的情況。  
  
 請注意，根據您的應用程式的功能，有可能變更邏輯父項目保留這個屬性的值並不會反映該變更。 您通常應該取得的值之前您需要它。  
  
 請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)邏輯樹狀結構周遊的詳細資訊和案例，使用<xref:System.Windows.FrameworkElement.Parent%2A>適當探索是這項技術的父項目。  
  
 屬性引擎有可能重新計算之元素的所有屬性值時，它會重設父代，因為有些屬性繼承邏輯樹狀結構的值。 <xref:System.Windows.FrameworkElement.DataContext%2A>套用的項目會重設父代時，也可以變更繫結。  
  
 變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。  
  
 使用的最常見的案例<xref:System.Windows.FrameworkElement.Parent%2A>屬性是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkElement>從父代的屬性值。 如需範本，<xref:System.Windows.FrameworkElement.Parent%2A>範本的最終會`null`。 取得略過此點，並將延伸至邏輯樹狀結構的範本會實際套用，請使用<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。  
  
 請注意這個屬性不會報告從邏輯樹狀結構父項的變化的案例中的視覺化樹狀結構父代。 視覺化樹狀結構父代不是一般的應用程式的情況下通常特別重要，但可能會針對某些視覺層級的情況下所需的父項目。 請參閱 <xref:System.Windows.Media.VisualTreeHelper>。  
  
   
  
## Examples  
 下列範例會顯示項目的父代，會檢查，然後再使用從父代的屬性值來比對的子系項目上設定屬性的程式碼。 在此情況下，這些是會影響轉譯大小的屬性。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">報告變更的子項目。</param>
        <summary>在 <see cref="T:System.Windows.FrameworkElement" /> 的特定子類別中支援累加配置實作。 <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> 會在子項目使得屬性失效時叫用，該屬性在中繼資料內已標記，會在配置期間影響父代的測量或排列傳遞。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目有子項目某些屬性已失效，及屬性已標記為<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>或<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>屬性中繼資料，在註冊期間，這個方法會叫用。 方法引動過程會告知哪個特定子項目必須重新測量，如果這個項目支援部分的版面配置的 （累加） 更新的父項目。  
  
 根據預設，<xref:System.Windows.FrameworkElement>不支援累加配置，然後在<xref:System.Windows.FrameworkElement>類別此方法有沒有預設的實作。 覆寫此方法時，可能需要的案例並不常見，因為它需要您修改預設的版面配置系統行為。  
  
 範例實作的狀況可能是類別是否有可能的子項目，明顯比 WPF 架構層級配置系統更嚴格的型別限制。 由於這些自訂項目，屬性變更可能會刻意延後當您實作一些自訂的版面配置行為。 比方說，量值/排列方法覆寫，嘗試最佳化的子項目會呈現階段，可能會延後，特定類型的變更通常會導致另一個版面配置階段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">應用於決定預期焦點變更的方向。</param>
        <summary>決定下一個項目，該項目會針對所提供的焦點移動方向，接收相對於此項目的焦點，但是不會實際移動焦點。</summary>
        <returns>如果焦點實際上有周遊時，焦點會移動到的下一個項目。 如果無法依所提供的方向相對於此項目移動焦點，則可能傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 是沒有實際移動焦點的相關的方法。  
  
   
  
## Examples  
 下列範例會實作處理數種可能的按鈕輸入，表示可能發生的每個按鈕處理常式<xref:System.Windows.Input.FocusNavigationDirection>。 處理常式會追蹤目前的鍵盤焦點和呼叫的項目<xref:System.Windows.FrameworkElement.PredictFocus%2A>該項目，並指定適當<xref:System.Windows.Input.FocusNavigationDirection>初始化為<xref:System.Windows.Input.TraversalRequest>類型提供的參數。 而不需要移動的項目，做為<xref:System.Windows.FrameworkElement.MoveFocus%2A>一樣，這個處理常式會變更的視覺效果進行預測的焦點目的地實體的維度。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定下列其中一個方向：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 這些方向對 <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 而言不是合法的 (但對 <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 而言是合法的)。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要用於指定之「名稱-物件」對應的名稱。</param>
        <param name="scopedElement">對應的物件。</param>
        <summary>提供可簡化對 <see cref="T:System.Windows.NameScope" /> 註冊方法之存取的存取子 (Accessor)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是很便利的方法呼叫<xref:System.Windows.NameScope.RegisterName%2A>。 實作會檢查後續的父項目，直到它找到適用<xref:System.Windows.NameScope>實作中，找到所尋找的項目，實作<xref:System.Windows.Markup.INameScope>。 如需有關命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>才能正確地將連結的應用程式程式碼中建立時的動畫分鏡腳本。 這是因為其中一個索引鍵屬性，分鏡腳本表現<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，使用執行階段名稱查閱，而不是能夠將目標項目的參考。 這是，則為 true，即使該元素是由參考從程式碼存取。 如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要移除的項目。</param>
        <summary>從這個項目的邏輯樹狀中移除提供的物件。 <see cref="T:System.Windows.FrameworkElement" /> 更新受影響的邏輯樹狀結構父指標，以便與刪除保持同步。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法實作的物件，表示項目的邏輯子項的集合。 這可能會在屬性 getter 或 setter 的類別處理常式中完成`Changed`事件、 建構函式，或在集合中的類型本身。  
  
 針對控制項作者，操作邏輯樹狀結構，在此層級不是建議的作法，除非提供基底控制項類別的內容模型沒有適當。 層級的子類別化，請考慮<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 這些類別提供特定的強制執行，透過專用的邏輯子系的內容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。  
  
   
  
## Examples  
 下列範例會實作`Child`自訂屬性<xref:System.Windows.FrameworkElement>執行它自己的視覺分層實作。 屬性的 setter 經過設計，如果值變更時，從邏輯樹狀結構，以及特定類別的視覺集合移除的舊值。 會快取的值，並再新增標準 WPF 架構層級邏輯樹狀結構和自訂的視覺集合的值。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在這個項目上呼叫 <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> 時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件表示至父代<xref:System.Windows.Controls.ScrollViewer>（或衍生類別中） 所引發的項目<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件應顯示出來的可捲動區域內。 <xref:System.Windows.Controls.ScrollViewer>接著會將標示<xref:System.Windows.FrameworkElement.RequestBringIntoView>為已處理，所使用之事件的類別處理的事件。 一般而言<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件的資料應該不會標示為已處理的未控制的捲動區域，任何類別或任何執行個體處理常式，因為這樣會干擾呼叫的項目，目的是<xref:System.Windows.FrameworkElement.BringIntoView%2A>。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定在本機定義的資源字典。</summary>
        <value>目前在本機定義的資源字典，其中每項資源都可以使用索引鍵存取。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，和通常是在針對任何個別的頁面或應用程式的根項目。 放置在此層級的資源字典可讓您更輕鬆地尋找從個別的子頁面中的項目 （或從任何頁面上，在應用程式的情況下）。 在大部分的應用程式案例中，我們建議樣式定義為物件項目內的資源字典中，或定義為外部的資源，以便讓整個樣式資源可彼此獨立 （這種方法有助於個別設計工具團隊的職責區隔需要加以編輯的實體檔案的開發人員責任）。  
  
 請注意，這個屬性會傳回該項目內直接宣告的資源字典。 這是不同於實際資源查閱程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中定義的資源。  
  
 資源也可以從集合中的程式碼所參考，但請注意，在建立資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]絕對無法供存取直到之後<xref:System.Windows.FrameworkElement.Loaded>宣告字典項目引發。 以非同步方式並不會剖析資源的事實上，甚至<xref:System.Windows.FrameworkElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義資源。 基於這個理由，您應該通常只能存取[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義為一部分的執行階段程式碼，或透過其他的資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。 當您透過程式碼存取資源時，這基本上等於是從進行參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除或使用程式碼來查詢集合內的資源所需的方法。 <xref:System.Windows.FrameworkElement.Resources%2A>屬性是可為支援的案例是完全取代的項目是一個新的或不同的資源集合<xref:System.Windows.ResourceDictionary>。  
  
 請注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的語法不包括的項目<xref:System.Windows.ResourceDictionary>。 這是隱含的集合語法; 的範例代表集合項目的標記就可以省略。 改為指定為項目加入至集合的項目。 如需有關隱含集合並[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，請參閱 < [XAML 語法詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 一種情況其中<xref:System.Windows.ResourceDictionary>仍然明確指定為項目才不會導入合併的字典，在此情況下通常的任何子項目<xref:System.Windows.ResourceDictionary>。 如需詳細資訊，請參閱 <<c0> [ 合併的資源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一或多個物件項目，其中每個定義的資源。 每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>必須有唯一的值[X:key 指示詞](~/docs/framework/xaml-services/x-key-directive.md)，從擷取的值時做為唯一的索引鍵<xref:System.Windows.ResourceDictionary>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">X:key 屬性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將繫結附加至指定相依性屬性的這個項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">識別要建立繫結的目的屬性。</param>
        <param name="path">用於繫結之屬性的來源屬性名稱或路徑。</param>
        <summary>根據提供給資料來源做為路徑限定性條件的來源屬性名稱，將繫結附加至這個項目。</summary>
        <returns>記錄繫結的條件。 這個傳回值對錯誤檢查很有用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是很便利的方法呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>根據所提供`path`參數。 此簽章會更方便，如果您要建立簡單的預設繫結項目。 如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或是<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。  
  
   
  
## Examples  
 下列範例會設定使用特定路徑的繫結。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">識別應該要建立繫結的屬性。</param>
        <param name="binding">代表資料繫結的詳細規格。</param>
        <summary>根據提供的繫結物件，將繫結附加至這個項目。</summary>
        <returns>記錄繫結的條件。 這個傳回值對錯誤檢查很有用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是很便利的方法呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">指定流程方向的項目。</param>
        <param name="value">指定方向的列舉值。</param>
        <summary>設定所提供項目的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加屬性值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的屬性語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定其父項目中排列的流程方向。 在目前設定的值<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">資源繫結到的屬性。</param>
        <param name="name">資源名稱。</param>
        <summary>搜尋具有指定名稱的資源，並針對指定的屬性建立該資源的資源參考。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資源參考是使用類似[DynamicResource 標記延伸](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)標記中。 資源參考會建立內部運算式提供在執行階段延後基準上所指定屬性的值。 每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該將 <see cref="P:System.Windows.FrameworkElement.Resources" /> 屬性的內容序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.Windows.FrameworkElement.Resources" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`只要至少一個索引鍵的資源正在本機<xref:System.Windows.FrameworkElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該將 <see cref="P:System.Windows.FrameworkElement.Style" /> 屬性的內容序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.Windows.FrameworkElement.Style" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.Style>本機設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該將 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 屬性的內容序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`true`如果<xref:System.Windows.FrameworkElement.Triggers%2A>屬性在本機設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 或 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 屬性變更值時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，它們才會處理在相同的項目，其引發。 直接路由的事件支援其他路由的事件的行為： 它們支援的可存取的處理常式集合，且可用來當做<xref:System.Windows.EventTrigger>樣式。  
  
 版面配置系統會讀取屬性內<xref:System.Windows.SizeChangedEventArgs>此事件，以判斷是否應該在報告的大小變更視為重要的引數類別。 這可讓版面配置系統或您的特定控制項版面配置實作，以避免強制版面配置變更，因為舊的和新的高度或寬度值之間以視覺化方式無法察覺的差異。 無法察覺的差異可能是因為浮點資料類型的捨入或相同結果的計算。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>來源值因與此項目繫結的任何現有屬性變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個項目呈現時要使用的樣式。</summary>
        <value>如有，則為項目已套用的非預設樣式。 否則為 <see langword="null" />。 預設建構 <see cref="T:System.Windows.FrameworkElement" /> 的預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制項，通常是預設樣式控制項的佈景主題，從所提供或來自樣式通常由套用至該類型的控制項在網頁或應用程式層級 （隱含樣式） 的資源目前的樣式。 這個屬性不會設定或傳回預設 （主題） 樣式，但會傳回隱含樣式或項目做的明確樣式。 在隱含或明確樣式中，指定做為資源或在本機定義的樣式並不重要。  
  
 設定樣式有一些限制。 您可以重設整個<xref:System.Windows.FrameworkElement.Style%2A>屬性，以新<xref:System.Windows.Style>在任何時間，這會強制配置重新撰寫。 不過，一旦該樣式會放在使用中所載入的項目，<xref:System.Windows.Style>應視為密封。 嘗試變更使用中樣式的任何個別的屬性 (例如集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。 標記中定義的樣式會被視為正在使用中，只要載入資源字典中的 （如資源），或包含在頁面載入 （適用於內嵌樣式）。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> 是相依性屬性具有特殊的優先順序。 本機設定樣式通常會在運作的最高的優先順序屬性系統中。 如果<xref:System.Windows.FrameworkElement.Style%2A>為 null，在屬性系統會檢查隱含樣式中指定該類型的本機或應用程式資源的載入期間。 如果樣式是仍為 null，這個步驟之後，就顯示用途的動作樣式通常是來自預設 （主題） 樣式中不會傳回預設樣式<xref:System.Windows.FrameworkElement.Style%2A>屬性值。 請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)或是[樣式和範本化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式索引鍵。 索引鍵參考中的現有資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性元素語法是技術上可行，但不是建議用於大部分案例。 請參閱[內嵌樣式和範本](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例會定義資源字典中的樣式。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Style" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求之環境屬性 (Ambient Property) 的名稱。</param>
        <summary>如需這個成員的描述，請參閱 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>如果 <paramref name="propertyName" /> 可用則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.FrameworkElement> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可以用來儲存關於此元素自訂資訊的任意物件值。</summary>
        <value>所要的值。 此屬性沒有預設值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性相當於其他 Microsoft 程式撰寫模型，例如 Visual Basic 應用程式或 Windows Form 中的標記屬性。 <xref:System.Windows.FrameworkElement.Tag%2A> 要提供的預先存在的屬性位置，您可以在其中儲存有關任何一些基本的自訂資訊<xref:System.Windows.FrameworkElement>而不需要您的子類別的項目。  
  
 因為這個屬性會採用一個物件，您必須使用屬性的項目使用方式，若要設定<xref:System.Windows.FrameworkElement.Tag%2A>到具有已知與內建的類型轉換器，例如字串的物件以外的任何項目中 XAML 屬性。 使用此方法的物件通常不是標準的 WPF 命名空間內，而且因此可能需要外部的命名空間的命名空間對應，就會用作 XAML 項目。 如需詳細資訊，請參閱 < [XAML 命名空間和命名空間對應 WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)並[XAML 和自訂類別，如 WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.TagProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Tag" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個項目上的任何屬性繫結的目標值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。 這通常表示有問題的繫結是雙向繫結的繫結的相依性屬性 affirms，先前的屬性值無效現在根據任何驗證或快取的屬性或資料來源所支援的配置。  
  
 使用事件資料的<xref:System.Windows.FrameworkElement.TargetUpdated>事件，以判斷特定的屬性，報告的目標值更新。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個項目的範本父代參考。 若此項目不是透過範本建立，則這個屬性不相關。</summary>
        <value>項目其<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />造成要建立此項目。 這個值通常是<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 通常是`null`會在您的應用程式標記或程式碼中建立的物件。 這是因為您建立這些物件直接，不是透過範本。 物件參考取得逐步邏輯樹狀結構，從根或一般名稱的參考，不是來自範本。  
  
 情況<xref:System.Windows.FrameworkElement.TemplatedParent%2A>可能無法`null`包括點擊測試特定低階的輸入事件，逐一查看與視覺化樹狀結構的事件處理等作業<xref:System.Windows.Media.VisualTreeHelper>，或使用列舉值，這可能會傳回來源的項目從範本。 另一種情況是如果您特別呼叫<xref:System.Windows.FrameworkTemplate.FindName%2A>對現有<xref:System.Windows.FrameworkTemplate>和會使用傳回的物件。  
  
 範本是範本的內容會一次建立的實際共用的物件。 因此，如果您取得的項目，是來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。 若要連接這類範本參考頁面的邏輯樹狀結構，您應該會看到<xref:System.Windows.FrameworkElement.TemplatedParent%2A>值，並繼續瀏覽所需的項目樹狀結構。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定工具提示物件，該物件會為[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中的這個項目而顯示。</summary>
        <value>工具提示物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性的值屬於類型<xref:System.Windows.Controls.ToolTip>，則該值是將用於工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值為任何其他類型的則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。 如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>。 服務類別會提供可用來進一步自訂的附加的屬性<xref:System.Windows.Controls.ToolTip>。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 成為的顯示文字的字串<xref:System.Windows.FrameworkElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 提供物件項目表單，應該做的內容中的某些物件<xref:System.Windows.FrameworkElement>。 通常這會是<xref:System.Windows.FrameworkElement>或其他項目所建立的版面配置複合<xref:System.Windows.FrameworkElement.ToolTip%2A>，最後會包含在複合 （compositing） 內的文字內容。 這項用法中<xref:System.Windows.Controls.ToolTip>會建立項目會隱含地從剖析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>屬性。  
  
 <`ToolTip` .../>  
 請參閱 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.Controls.ToolTip>中的程式碼，然後設定<xref:System.Windows.FrameworkElement.ToolTip%2A>屬性上的<xref:System.Windows.Controls.Primitives.StatusBar>控制項。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在項目上的任何工具提示正要關閉之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 標示<xref:System.Windows.FrameworkElement.ToolTipClosing>為已處理的事件不會取消關閉工具提示。 關閉工具提示完成後會顯示工具提示，只會在使用者與 UI 互動的回應。  
  
 此事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用從服務不會公開為服務層級事件的新增/移除事件方法的實作。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>任何元素的工具提示開啟時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止工具提示出現在 UI 中，您的處理常式，如<xref:System.Windows.FrameworkElement.ToolTipOpening>可以將標記<xref:System.Windows.Controls.ToolTipEventArgs>處理的事件資料。 否則，會顯示工具提示，使用值<xref:System.Windows.FrameworkElement.ToolTip%2A>做為工具提示內容的屬性。 另一個可能的情況是您可以撰寫會重設的值的處理常式<xref:System.Windows.FrameworkElement.ToolTip%2A>是事件來源，會顯示工具提示時之前, 的項目屬性。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> 若將不會產生值<xref:System.Windows.FrameworkElement.ToolTip%2A>是`null`或其他未設定。 不要刻意設定<xref:System.Windows.FrameworkElement.ToolTip%2A>至`null`tooltip 為開啟，或開啟; 這不會關閉工具提示的影響，會改為建立在 UI 中的非預期的視覺成品時。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用從服務不會公開為服務層級事件的新增/移除事件方法的實作。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.ToolTip" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得直接在這個項目或子項目中建立的觸發程序集合。</summary>
        <value>
          <see cref="T:System.Windows.Trigger" /> 物件的強類型集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此屬性只在設定[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]透過集合語法所示，或存取的集合物件，使用其不同的方法，例如 Add。 要存取的集合物件本身的屬性是唯讀，該集合本身是讀寫。 屬性只存在於根項目;嘗試找到它，或將它設定其他位置，將會導致擲回例外狀況。  
  
 這個屬性不會啟用檢查觸發程序，這個項目上的使用中的樣式的一部分。 此外，它只會報告解譯為常值加入至集合，在標記或程式碼中的觸發程序的集合。 項目通常不會有這類現有的預設值的項目 (透過範本執行個體);它是更常見會改為在樣式中建立的複合控制項所來自的觸發程序。  
  
 就行為 (並嘗試建立的作用是來自哪個項目宣告<xref:System.Windows.FrameworkElement.Triggers%2A>集合)，觸發條件和觸發程序的效果可能在這個項目上，或可能在其子項目邏輯樹狀結構中。 請注意，如果您使用存留期事件，例如<xref:System.Windows.FrameworkElement.Loaded>若要取得此集合，子元素的觸發程序可能還無法完全載入，並會在執行階段會確實比較小的集合。  
  
 請注意，建立項目上的觸發程序的集合只支援<xref:System.Windows.EventTrigger>，沒有屬性觸發程序 (<xref:System.Windows.Trigger>)。 如果您需要屬性觸發程序，您必須放在樣式或範本內，並再指派該樣式或範本的項目是直接透過<xref:System.Windows.FrameworkElement.Style%2A>屬性，或間接透過隱含樣式參考。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreTriggers*  
 一或多個定義<xref:System.Windows.EventTrigger>項目。 每個這類觸發程序必須包含有效的分鏡腳本動作和參考。 請注意，這個集合只能建立在頁面的根項目。 如需詳細資訊，請參閱[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的索引鍵識別項。</param>
        <summary>以指定的索引鍵搜尋資源；如果找到，則傳回該資源。</summary>
        <returns>找到的資源，如果找不到具有所提供之 <paramref name="key" /> 的資源，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果呼叫的項目上找不到資源，透過邏輯樹狀結構向上搜尋父資源樹狀目錄，在樹狀結構的相同方式來搜尋的若資源所要求機碼在執行階段。 此方法會傳回`null`只有當資源樹狀目錄中，每個現有的條件，在樹狀結構的任何地方不在於該索引鍵的任何資源，<xref:System.Windows.FrameworkElement.TryFindResource%2A>呼叫。  
  
 通常您會立即傳回值轉換成您嘗試使用傳回的資源值設定屬性的型別。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A>方法有類似的行為不同之處在於它會擲回例外狀況，如果未不傳回提供的索引鍵的任何資源。  
  
   
  
## Examples  
 下列範例會實作為按鈕處理常式，其中按鈕被按下設定其資源所定義的筆刷的背景取得藉由呼叫<xref:System.Windows.FrameworkElement.TryFindResource%2A>本身。 這會逐步引導項目樹狀結構，並尋找資源 (資源本身中定義[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]並不會顯示)。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目從已載入項目的項目樹狀結構中移除時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，它們才會處理在相同的項目，其引發。 直接路由的事件支援其他路由的事件的行為： 它們支援的可存取的處理常式集合，且可用來當做<xref:System.Windows.EventTrigger>樣式。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同時會引發因為使用者起始系統佈景主題變更控制項上。 佈景主題變更會導致控制項範本以及包含視覺化樹狀結構，這樣又會卸載並重新載入整個控制項失效。 因此<xref:System.Windows.FrameworkElement.Unloaded>無法假設只發生在導覽離開該頁面。  
  
 請注意，<xref:System.Windows.FrameworkElement.Unloaded>應用程式開始進行關閉之後，不會引發事件。 由所定義的條件時，就會發生應用程式關閉<xref:System.Windows.Application.ShutdownMode%2A>屬性，就會發生。 如果您將清除程式碼中的處理常式<xref:System.Windows.FrameworkElement.Unloaded>事件，例如 mongoadminusername<xref:System.Windows.Window>或<xref:System.Windows.Controls.UserControl>，它可能不會呼叫如預期般運作。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkElement.Unloaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要從目前範圍中移除的「名稱-物件」配對名稱。</param>
        <summary>簡化對 <see cref="T:System.Windows.NameScope" /> 取消註冊方法的存取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您只會要取消註冊名稱，如果您想要重新註冊該相同名稱的另一個項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新將預設樣式套用至目前 <see cref="T:System.Windows.FrameworkElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出配置進位是否應該在配置期間套用到這個項目的大小和位置。</summary>
        <value>如果套用配置進位，則為 <see langword="true" />否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>項目的屬性是`true`，會計算期間的所有非整數像素值<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>階段會捨入到整個像素值。  
  
 這個屬性會繼承子項目。  
  
> [!NOTE]
>  您應該設定<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>至`true`根項目上。 版面配置系統會將父座標; 中的子系座標因此，如果父座標不像素界限上，子座標也不像素界限上。 如果<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>不是根目錄上設定，設定<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>上的子系，以取得您想要的效果。  
  
 繪製像素界限上的 物件排除時，所產生的消除鋸齒邊緣落在裝置像素半透明邊緣。 下圖顯示落在裝置像素的單一像素寬度列的輸出。 在左側的列未使用版面配置進位，而且是消除鋸齒。 在右側的一行中，會使用版面配置進位。  
  
 ![反&#45;相較於單一像素列的別名線。](~/add/media/pixelsnaplinecompare.PNG "相較於單一像素列的消除鋸齒線條。")  
  
 當您使用版面配置進位，<xref:System.Windows.GridUnitType.Star>調整大小、 版面配置系統會建立小型的變化中的資料行或資料列的度量，以避免呈現子像素。 例如，如果方格具有 3 個資料行每個大小的 100 總寬度<xref:System.Windows.GridUnitType.Star>，而不是建立三個資料行的 33.3 相等的寬度，版面配置系統會建立 2 個資料行的寬度為 33，34 的寬度的另一個。  
  
> [!NOTE]
>  在.NET 4.6 中已變更版面配置進位，以減少含邊界之控制項中的裁剪功能的執行個體。 根據預設，如果您的目標 Framework 是.NET Framework 4.6 或更高版本，會啟用此功能。 以舊版 framework 為目標的應用程式可以選擇在新的行為加入 app.config 檔案中的下列設定：`<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>`設定才會生效，在.NET Framework 4.6 上執行應用程式。  
  
   
  
## Examples  
 下列範例示範的效果，<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>屬性有單一的像素寬度該行。 左邊的行號不會使用版面配置進位，並在右邊的列可讓您使用版面配置進位。 如果您緩時變調整視窗大小，可以看到差異捨入可讓該配置。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至此項目在父項目 (例如面板或項目控制項) 中組成時的垂直對齊特性。</summary>
        <value>垂直對齊設定。 預設值為 <see cref="F:System.Windows.VerticalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.Height%2A>並<xref:System.Windows.FrameworkElement.Width%2A>項目上明確設定屬性，這些測量結果採取優先於版面配置] 和 [取消設定此屬性的規則的效果<xref:System.Windows.VerticalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]屬性存取子是相依性屬性。 這個特定的相依性屬性很頻繁已設定不同的衍生項目類別，特別是控制項在其明顯的 「 預設 」 值。 這通常發生於兩種方式之一： 相依性屬性重新加以註冊特定的衍生類別中，但具有不同的中繼資料，設定其預設值;或以不同的方式設定該相依性屬性值的預設樣式套用。 比方說，明顯 「 預設 」 的<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>for<xref:System.Windows.Controls.ComboBoxItem>控制項將會是<xref:System.Windows.VerticalAlignment.Center>，即使<xref:System.Windows.Controls.ComboBoxItem>繼承<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>直接從<xref:System.Windows.FrameworkElement>。 這是因為該值重設的預設樣式內<xref:System.Windows.Controls.ComboBoxItem>，樣式的控制項範本內。  
  
 <xref:System.Windows.Controls.Canvas> 不會使用<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>當您在撰寫版面配置，因為<xref:System.Windows.Controls.Canvas>根據絕對位置。  
  
 當繼承<xref:System.Windows.Controls.ComboBoxItem>或任何衍生類別，<xref:System.Windows.Controls.ComboBoxItem>重新定義預設值，這個屬性是<xref:System.Windows.VerticalAlignment.Center>。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個項目內的視覺化子項目數。</summary>
        <value>這個項目的視覺化子項目數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>實作<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>一律會傳回零或一次。 維護視覺子系集合，其中可能會超過一個的類別必須覆寫這個屬性和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 這個屬性通常會用來判斷目前的子集合，基於實作版面配置覆寫的上限 (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>， <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>)。  
  
   
  
## Examples  
 下列範例示範如何自訂裝飾項會使用所宣告的值<xref:System.Windows.Media.VisualCollection>它會維護其多個視覺子系，並報告這些值的覆寫透過<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您的類別支援多個視覺子系，子項目集合中，覆寫這個屬性，該集合中傳回的項目計數。 即使集合物件本身會傳回計數，您必須這麼做。 在 WPF 架構層級的項目配置邏輯會假設所有項目，會傳回有效的計數，透過其<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />屬性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素的寬度。</summary>
        <value>項目的寬度 (以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 為單位)。 預設值是 <see cref="F:System.Double.NaN" />。 這個值必須等於或大於 0.0。 如需上限資訊，請參閱＜備註＞。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性上<xref:System.Windows.FrameworkElement>指定寬度的資訊。  其他兩種方式<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果這些值之間沒有衝突，實際寬度判斷的應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能被接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後每一個位於範圍中，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 這個屬性傳回的值一定是與任何已設定為它的值相同。 相較之下，windows 7<xref:System.Windows.FrameworkElement.ActualWidth%2A>而有所不同。 版面配置可能已基於某些原因拒絕建議的大小。 此外，配置系統本身以非同步方式運作的屬性系統集相對<xref:System.Windows.FrameworkElement.Width%2A>和可能處理該特定尚未調整大小屬性變更。  
  
 除了為可接受<xref:System.Double>值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 這是您指定自動調整大小行為的方式。 在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您將值設定為字串"Auto"（不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填滿可用的寬度。 不過請注意，特定的控制項通常會提供將會停用自動調整大小行為，除非它是特別重新啟用其預設樣式中的預設值。  
  
 驗證檢查，除了沒有不具決定性的上限值，用於繫結<xref:System.Windows.FrameworkElement.Width%2A>，會由配置系統強制執行 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=nameWithType>但小於<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果您超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿設定<xref:System.Windows.FrameworkElement.Width%2A>大幅超過大小上限的任何可能的視覺顯示，或者您可能會超過此不具決定性的上限值。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 如需上限資訊，請參閱＜備註＞。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確包含小數位數。 執行個體的值`1`是可以接受的。  
  
 *qualifiedDouble*  
 A*雙*值，如上所述，後面接著一個的下列單位宣告字串： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
 `Auto`  
 啟用自動調整大小行為。 請參閱＜備註＞。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkElement.Width" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>