<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37e7aed83bb8605e1fc6521bbaffa487694de176" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461196" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a WPF framework-level set of properties, events, and methods for Windows Presentation Foundation (WPF) elements. This class represents the provided WPF framework-level implementation that is built on the WPF core-level APIs that are defined by <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 是 WPF 架構層級項目類別以及的 WPF 核心層級設定之間的連接點<xref:System.Windows.UIElement>展示服務。 如需有關這些概念的詳細資訊，請參閱[WPF 架構](~/docs/framework/wpf/advanced/wpf-architecture.md)。  
  
 <xref:System.Windows.FrameworkElement> 擴充<xref:System.Windows.UIElement>並加入下列功能：  
  
-   **版面配置系統定義**:<xref:System.Windows.FrameworkElement>提供特定方法中的虛擬成員所定義的特定 WPF 架構層級實作<xref:System.Windows.UIElement>。 最值得注意的是，<xref:System.Windows.FrameworkElement>密封特定 WPF 核心層級配置覆寫，並改為提供 WPF 架構層級對等項目，衍生類別應該改為覆寫。 例如，<xref:System.Windows.FrameworkElement>標誌<xref:System.Windows.UIElement.ArrangeCore%2A>但提供<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。 這些變更反映在 WPF 架構層級為完整配置系統中沒有可呈現任何位置的事實<xref:System.Windows.FrameworkElement>衍生的類別。 在 WPF 核心層級，特定的成員，將結構一般[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]根據的配置方案的位置，但未定義的版面配置系統實際引擎。 如需詳細資訊，請參閱[配置](~/docs/framework/wpf/advanced/layout.md)。  
  
-   **邏輯樹狀結構：** 一般[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]程式設計模型通常表示在樹狀目錄中的項目。 表示邏輯樹狀結構的項目樹狀結構和隨附支援針對在標記中定義該樹狀結構在實作支援<xref:System.Windows.FrameworkElement>層級。 請注意，不過<xref:System.Windows.FrameworkElement>刻意未定義內容的模型，並會保留該衍生類別的責任。 如需詳細資訊，請參閱 [WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
-   **物件存留期的事件：** 通常是很有幫助 初始化項目時 （稱為建構函式），或項目時先載入到邏輯樹狀結構。 <xref:System.Windows.FrameworkElement> 定義數個事件物件存留期與相關，提供有用的攔截程序牽涉到項目，例如新增更多的子元素的程式碼後置作業。 如需詳細資訊，請參閱[物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
-   **支援資料繫結和動態資源參考：** 屬性層級的支援資料繫結和資源實作由<xref:System.Windows.DependencyProperty>類別和屬性系統，但能夠解析的成員值卻儲存為<xref:System.Windows.Expression>（做為資料繫結和動態資源的程式設計建構） 由實作<xref:System.Windows.FrameworkElement>。 如需詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)和[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   **樣式：** <xref:System.Windows.FrameworkElement>定義<xref:System.Windows.FrameworkElement.Style%2A>屬性。 不過，<xref:System.Windows.FrameworkElement>尚未定義支援範本，或支援裝飾項目。 這些功能所導入控制項類別例如<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
-   **更多的動畫支援：** 某些動畫支援已定義在 WPF 核心層級，但<xref:System.Windows.FrameworkElement>延伸實作<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>和相關的成員。  
  
 從類別階層架構，可以看出許多[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]類別衍生自<xref:System.Windows.FrameworkElement>、 直接或透過中繼基底類別，例如<xref:System.Windows.Controls.Panel>或<xref:System.Windows.Controls.Control>。  
  
 如果您想要使用<xref:System.Windows.FrameworkElement>做為基底類別，您可能想要先檢查現有的衍生的類別。 <xref:System.Windows.FrameworkElement> 將多個基本案例中，提供支援，但也缺少一些功能 」 中的項目 」 的意義的建置組塊，用來建立適合[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]中[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 比方說，<xref:System.Windows.FrameworkElement>並未定義任何真實的內容模型。<xref:System.Windows.FrameworkElement>為基底類別不會定義可以建立內容[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]子項目。 特別是，您可能想要查看<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.FrameworkElement" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the rendered height of this element.</summary>
        <value>項目的高度，以值 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值為 0 （零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是其他高度輸入和版面配置系統為基礎的導出的值。 值，由配置系統本身，根據實際呈現階段，並可能因此落後稍微設定值的屬性例如<xref:System.Windows.FrameworkElement.Height%2A>所輸入變更的基礎。  
  
 因為<xref:System.Windows.FrameworkElement.ActualHeight%2A>是計算的值，您應該注意可能有多個，或累加式報告，來變更各種作業的結果由配置系統。 配置系統可能會計算子項目所需的測量空間、父項目的條件約束，依此類推。  
  
 雖然您無法設定此屬性從[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>樣式中的值。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會顯示各種高度屬性。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the rendered width of this element.</summary>
        <value>項目的寬度，以值 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值為 0 （零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是其他寬度輸入和版面配置系統為基礎的導出的值。 值，由配置系統本身，根據實際呈現階段，並可能因此落後稍微設定值的屬性例如<xref:System.Windows.FrameworkElement.Width%2A>所輸入變更的基礎。  
  
 因為<xref:System.Windows.FrameworkElement.ActualWidth%2A>是計算的值，您應該注意可能有多個，或累加式報告，來變更各種作業的結果由配置系統。 配置系統可能會計算子項目所需的測量空間、父項目的條件約束，依此類推。  
  
 雖然您無法設定此屬性從[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>樣式中的值。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會顯示各種寬度屬性。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Child element to be added.</param>
        <summary>Adds the provided object to the logical tree of this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法的物件，代表項目的邏輯子項目集合的實作。 屬性 getter 或 setter，處理已變更事件，建構函式，或將集合型別本身內的類別可能透過集合維護的子元素的集合。  
  
 控制作者的處理邏輯樹狀結構，此層級不是建議的作法，除非可用控制項的基底類別的內容模型都適用於程式控制項案例。 請考慮在層級的子類別化<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 這些類別提供特定的強制執行的邏輯樹狀結構子項目，透過專用的內容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。 如需有關如何使用<xref:System.Windows.FrameworkElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 如果呼叫時之邏輯樹狀結構正在反覆執行另一個處理序一次，則可能會擲回例外狀況。  
  
   
  
## Examples  
 下列範例會實作`Child`在自訂屬性<xref:System.Windows.FrameworkElement>執行它自己的視覺層實作。 屬性 setter 的設計，所以如果值變更時，會從邏輯樹狀結構，以及類別的特定視覺集合移除的舊值。 快取的屬性值時，並再新值加入至邏輯樹狀結構和自訂的視覺集合。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Builds the current template's visual tree if necessary, and returns a value that indicates whether the visual tree was rebuilt by this call.</summary>
        <returns>
          <see langword="true" /> if visuals were added to the tree; returns <see langword="false" /> otherwise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以呼叫這個方法，以保證視覺化樹狀結構項目的已完成。 此保證步驟可能需要如果程式碼會檢查樹狀結構中的子項目。 典型的項目，呼叫應用程式內的邏輯<xref:System.Windows.FrameworkElement.ApplyTemplate%2A>並非必要，因為範本將會在適當的時間點的項目在其存留期自動套用。  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> 每個量值上呼叫傳 WPF 架構層級配置系統。  
  
 <xref:System.Windows.FrameworkElement> 在衍生的類別可以使用<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>的情況下，明確地呼叫這個方法後，或由配置系統通知的類別處理常式。 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 是範本完全產生，並附加至邏輯樹狀結構後呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">The final area within the parent that this element should use to arrange itself and its children.</param>
        <summary>Implements <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (defined as virtual in <see cref="T:System.Windows.UIElement" />) and seals the implementation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是密封格式。 若要覆寫項目配置的排列傳遞特別為您自訂項目中的邏輯您<xref:System.Windows.FrameworkElement>衍生的類別必須覆寫<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">The final area within the parent that this element should use to arrange itself and its children.</param>
        <summary>When overridden in a derived class, positions child elements and determines a size for a <see cref="T:System.Windows.FrameworkElement" /> derived class.</summary>
        <returns>The actual size used.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>控制作者想要自訂版面配置處理的排列傳遞都應該覆寫這個方法。實作模式應該呼叫<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上每個可見的子元素，並傳遞最後所需的大小，為每個子項目的<paramref name="finalRect" />參數。父項目應該呼叫<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上每個子系，否則子元素將不會轉譯。許多衍生的類別會提供這個方法的實作。顯著的包括： <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />，<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />和<see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />。</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts the initialization process for this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您正在調整它們的方式仍未公開或連線到任何項目樹狀結構項目，您可以在個別的項目上呼叫這個方法。 比方說，您可能已建立新<xref:System.Windows.FrameworkElement>，但不是尚未將它附加到任何邏輯樹狀結構。 或者，您的項目所在的子元素，在其中之邏輯樹狀結構可能未連線至視窗或應用程式頁面。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>實作這個方法以提供您的項目初始化期間載入處理序的項目之前應該發生的特殊處理。您的實作應該呼叫基底實作，因為基底 （預設值） 實作設定追蹤的初始設定部分內部旗標。一個可能的實作是使用這個方法來攔截到您自己的私用類別初始化常式，尚未啟用的建構函式。基底實作將會擲回例外狀況，如果<see cref="M:System.Windows.FrameworkElement.BeginInit" />超過一次上呼叫相同的項目之前<see cref="M:System.Windows.FrameworkElement.EndInit" />所呼叫。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins the sequence of actions contained in the provided storyboard.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">The storyboard to begin.</param>
        <summary>Begins the sequence of actions that are contained in the provided storyboard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>可以定址標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
   
  
## Examples  
 下列範例會擷取<xref:System.Windows.Media.Animation.Storyboard>從 [資源]，然後執行可<xref:System.Windows.Media.Animation.Storyboard>內部的事件時處理的類別。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">The storyboard to begin.</param>
        <param name="handoffBehavior">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</param>
        <summary>Begins the sequence of actions contained in the provided storyboard, with options specified for what should happen if the property is already animated.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>可以定址標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
 可以指定遞移式行為的屬性為<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
   
  
## Examples  
 下列範例會擷取<xref:System.Windows.Media.Animation.Storyboard>從 [資源]，然後執行可<xref:System.Windows.Media.Animation.Storyboard>內部的事件時處理的類別。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">The storyboard to begin.</param>
        <param name="handoffBehavior">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</param>
        <param name="isControllable">Declares whether the animation is controllable (can be paused) after it is started.</param>
        <summary>Begins the sequence of actions contained in the provided storyboard, with specified state for control of the animation after it is started.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>可以定址標記中公開的屬性。  
  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)或可供程式碼中參考。  
  
 可以指定遞移式行為的屬性為<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" />所用的項目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>可以用來驗證物件的多個屬性的值。 例如，假設應用程式會提示使用者輸入的位址，然後填入型別的物件`Address`，其中具有屬性`Street`， `City`， `ZipCode`，和`Country`，值的使用者提供。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。 例如，<xref:System.Windows.Controls.ValidationRule>可以確保，郵遞區號就是有效的地址的國家/地區。  
  
 子項目會繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|中繼資料屬性設定為 **，則為 true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例是應用程式會檢查使用者是否已設定為相等的值的兩個物件的屬性的一部分。 第一個範例會建立兩個<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至不同的資料來源。 <xref:System.Windows.Controls.StackPanel>具有<xref:System.Windows.Data.BindingGroup>包含<xref:System.Windows.Controls.ValidationRule>，以檢查兩個字串是否相等。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 下列範例所示<xref:System.Windows.Controls.ValidationRule>先前範例所使用。  在<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法覆寫時，此範例會取得每個來源物件的<xref:System.Windows.Data.BindingGroup>，並檢查之物件的屬性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 要叫用<xref:System.Windows.Controls.ValidationRule>，呼叫<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>方法。  下列範例會呼叫<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>按鈕的 click 事件發生時。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attempts to bring this element into view, within any scrollable regions it is contained within.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to bring this element into view, within any scrollable regions it is contained within.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件來自 目前的項目。 會引發這個事件，以便可由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似的類別。 預期的行為是，父項目，標示為已處理的事件資料，在處理事件和事件的來源資料被引進的邏輯內嵌在透過檢視<xref:System.Windows.Controls.ScrollViewer>控制項。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件和<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法傳輸相關的成功或失敗，而不是，事件通常是標示為成功處理上的任何資訊。 問題的原因失敗可以包括項目設定，例如<xref:System.Windows.UIElement.Visibility%2A>以外的某個值<xref:System.Windows.Visibility.Visible>。  
  
 如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 將會看見。  
  
 藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上任何父可捲動區域包含的項目。 如果這個項目不包含在可捲動區域，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但沒有作用，因為會不有任何事件接聽程式。  
  
   
  
## Examples  
 下列範例會實作應用程式瀏覽事件，每當回應的處理常式[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]正要巡覽至包含片段。 片段以命名[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]遵循雜湊符號 （#），並實作的行為會導致要捲動到檢視範圍內的項目。 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 和<xref:System.Windows.FrameworkElement.RequestBringIntoView>要求在範例中的捲動行為。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Specified size of the element that should also be brought into view.</param>
        <summary>Attempts to bring the provided region size of this element into view, within any scrollable regions it is contained within.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件來自 目前的項目。 會引發這個事件，以便可由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似的類別。 預期的行為是，父項目，標示為已處理的事件資料，在處理事件和事件的來源資料被引進的邏輯內嵌在透過檢視<xref:System.Windows.Controls.ScrollViewer>控制項。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件和<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法傳輸相關的成功或失敗，而不是，事件通常是標示為成功處理上的任何資訊。 問題的原因失敗可以包括項目設定，例如<xref:System.Windows.UIElement.Visibility%2A>以外的某個值<xref:System.Windows.Visibility.Visible>。  
  
 如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 將會看見。  
  
 藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上任何父可捲動區域包含的項目。 如果這個項目不包含在可捲動區域，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但沒有作用，因為會不有任何事件接聽程式。  
  
   
  
## Examples  
 下列範例會在限制的捲動區域中有大型的圖形。 頁面上的按鈕有捲動檢視來大量圖形的特定區域的處理常式。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the context menu element that should appear whenever the context menu is requested through [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</summary>
        <value>指派給這個項目的操作功能表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生類別，而且是可行的<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性。 不過，這會建立令人混淆的內容功能表經驗的使用者並不建議此做法。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs just before any context menu on the element is closed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要隱藏關閉內容功能表的 事件處理常式應將其標記為已處理。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考事件的基礎服務定義：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkElement>，會公開基礎的服務事件不會對應<xref:System.Windows.FrameworkElement.ContextMenuClosing>識別項，您可以使用它的觸發程序)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生的類別，但是<xref:System.Windows.FrameworkElement.ContextMenuClosing>事件將不會引發快顯功能表的直接。 相反地，會引發事件，從 「 擁有 」 做為屬性的內容功能表，且只會在使用者嘗試以關閉在 UI 中的內容功能表時所引發的項目。 但是它可能是<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性 （巢狀的內容功能表）。 在此情況下<xref:System.Windows.Controls.ContextMenu>實際上並擁有巢狀<xref:System.Windows.Controls.ContextMenu>然後可能會引發事件，與正在巢狀的內容功能表上的事件來源。  
  
 <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Closed>) 但<xref:System.Windows.Controls.ContextMenu.Closed>事件不會為您提供取消的使用者動作的機會。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when any context menu on the element is opened.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手動開啟內容功能表，為已處理的事件處理常式時，應該標記相關的事件。 否則，現有的值<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性會用來自動開啟內容功能表。 標記處理事件會有效地取消的預設動作，並可能會重設的值有機會<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。 不過，是您應該注意的時間問題。 為了完全取代透過內容功能表<xref:System.Windows.FrameworkElement.ContextMenuOpening>處理常式中，初始的內容功能表必須不是 null 或空白。 或者，您可能需要處理事件，並手動開啟新的內容功能表。 如需詳細資訊，請參閱[如何： 處理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考基礎附加的事件：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkElement>，會公開基礎的服務事件不會對應<xref:System.Windows.FrameworkElement.ContextMenuOpening>識別項，可用於觸發程序)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>衍生的類別，但不是會從內容功能表開啟做為來源引發這個事件。 從 「 擁有 」 做為屬性的內容功能表，且只會在使用者嘗試在 UI 中開啟內容功能表時所引發的項目，會引發事件。 可能會<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，但是您應該避免這種情況 (如需詳細資訊，請參閱<xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Opened>) 但<xref:System.Windows.Controls.ContextMenu.Opened>不會為您提供取消的使用者動作的機會。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cursor that displays when the mouse pointer is over this element.</summary>
        <value>要顯示的游標。 預設值依這個相依性屬性定義為 <see langword="null" />。 不過，執行階段的實際預設值會受各種因素影響。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您設定此屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。 提供的字串應評估為<xref:System.Windows.Input.CursorType>值。 如需詳細資訊，請參閱<xref:System.Windows.Input.Cursor>。  
  
 這個屬性所建立的資料指標將還是不會顯示當滑鼠指標位在這個項目也是取決於值的<xref:System.Windows.FrameworkElement.ForceCursor%2A>屬性。 此外，事件相關的考量，例如使用中拖曳滑鼠擷取、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性的值。  
  
 若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。  
  
 `null`預設真的表示實際的資料指標的值判斷此處延後，應該從別處取得。 如果看到不含以程式設計方式從任何來源的值，預設資料指標，是以視覺化方式超過[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]應用程式將會箭號。 不過，暫時性游標會變更不會設定為<xref:System.Windows.FrameworkElement.Cursor%2A>時透過傳送的項目值。 <xref:System.Windows.FrameworkElement.Cursor%2A>屬性將只報告非 null 值在實際設於何處，例如透過程式碼或樣式的情況下。 每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.UIElement.QueryCursor>事件。 事件反昇，且此路由上的任何項目都有機會處理事件，並設定資料指標到這個事件的引數的值。 這是會產生在大部分情況下以視覺化方式明顯的資料指標的機制。 如果<xref:System.Windows.UIElement.QueryCursor>處理常式傳回一個資料指標結果，則事件處理，而且引數中已變更的值的優先順序高於值<xref:System.Windows.FrameworkElement.Cursor%2A>屬性在任何層級，除非<xref:System.Windows.FrameworkElement.ForceCursor%2A>設定。  
  
 您如果不建立自訂游標，通常有設定此屬性的靜態屬性值<xref:System.Windows.Input.Cursors>類別。 設定<xref:System.Windows.FrameworkElement.Cursor%2A>程式碼中需要下列其中之一：  
  
-   呼叫<xref:System.Windows.Input.Cursor>建構函式來取得<xref:System.Windows.Input.Cursor>執行個體。 這兩個簽章<xref:System.Windows.Input.Cursor>建構函式使用資料流或檔案，您所建立的頁數<xref:System.Windows.Input.Cursor>自訂的資料指標的物件。  
  
-   使用<xref:System.Windows.Input.CursorConverter>類別和其<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>方法，以指定的資料指標<xref:System.Windows.Input.CursorType>，或可以評估為字串<xref:System.Windows.Input.CursorType>，並轉換至傳回<xref:System.Windows.Input.Cursor>。  
  
 設定<xref:System.Windows.Input.Cursor>自訂值中未啟用部分信任。 如需有關自訂的資料指標的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會示範如何刻意設定游標圖形。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Cursor" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the data context for an element when it participates in data binding.</summary>
        <value>用做為資料內容的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，例如路徑繫結的資料來源的相關資訊。  
  
 資料內容設為直接[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，並將該物件的內容來評估的繫結。 或者，您可以將資料內容設<xref:System.Windows.Data.DataSourceProvider>物件。  
  
 這個相依性屬性會繼承屬性值。 如果沒有其他值的項目子系<xref:System.Windows.FrameworkElement.DataContext%2A>透過本機值或樣式，所建立，則對屬性系統將會設定這個值為<xref:System.Windows.FrameworkElement.DataContext%2A>指派此值與最接近的父項目的值。  
  
 或者，您可以使用的下列屬性的其中一個<xref:System.Windows.Data.Binding>類別來明確指定繫結來源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。 如需詳細資訊，請參閱[How to： 指定的繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkElement.DataContext%2A>大部分都是設為<xref:System.Windows.Data.Binding>宣告。 您可以使用屬性項目語法或屬性語法。 在範例中，此頁面上顯示屬性語法。 您也可以使用程式碼來設定<xref:System.Windows.FrameworkElement.DataContext%2A>。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> 是可繫結的屬性，為 dbtype_iunknown 其中一個內容可能繫結至另一個。 不過，如果您繫結至<xref:System.Windows.FrameworkElement.DataContext%2A>，請小心不要建立循環繫結參考 (請不要繫結<xref:System.Windows.FrameworkElement.DataContext%2A>，這是因為屬性值繼承性質而這麼做<xref:System.Windows.FrameworkElement.DataContext%2A>屬性)。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 直接內嵌的物件做為父項目中的任何繫結的資料內容。 一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>衍生的類別。 或者，任何未經處理資料[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]物件適用於繫結，可能會放在這裡，以實際的繫結稍後所定義的類型。  
  
 *bindingUsage*  
 評估為適當的資料內容繫結使用方式。 如需詳細資訊，請參閱[Binding 標記延伸模組](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 下列其中之一： 或。 定義為資源中之物件的未經處理資料時，就會使用這種使用方式。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 從所要求之物件的金鑰識別碼<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例將說明資料內容繫結上的作用，並提供所定義的繫結屬性的特定值的資訊。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the data context for this element changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需資料內容和資料繫結的說明，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  當<xref:System.Windows.FrameworkElement.DataContext%2A>潛在影響的項目變更時，這個項目上的所有資料繫結屬性。 這適用於任何項目邏輯樹狀結構中，目前項目的子項目繼承的資料內容，以及目前的項目本身。 所有這類的現有繫結必須重新解譯新<xref:System.Windows.FrameworkElement.DataContext%2A>並會重新評估繫結結果。 資料繫結引擎不具決定性的這些處，相對於的引發順序有關<xref:System.Windows.FrameworkElement.DataContextChanged>事件。 重新評估可能可以事件之前、 發生事件之後，或以任何混合。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.DataContext" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the key to use to reference the style for this control, when theme styles are used or defined.</summary>
        <value>樣式索引鍵。 若要當做佈景主題樣式查閱一部分正常運作，這個值必須是要加上樣式之控制項的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性通常是透過其直接屬性存取子的任何不設定。 相反地，您覆寫這個相依性屬性的特定類型的中繼資料每次您建立新<xref:System.Windows.FrameworkElement>衍生的類別。 當您衍生的控制項時，呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法針對<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>控制項中的靜態建構函式中的識別項，衍生類別 （或對等的類別初始化）。  
  
 控制項通常會覆寫它自己的型別，這個屬性的預設值，但在某些情況下也可以使用基底類型有主題字典中的樣式。 如果基底控制項的 [控制項] 範本已完整定義該衍生的控制項的視覺表示法，而且衍生的型別公開的任何其他成員不需要額外的項目控制項範本的一部分，這樣做只實際。  
  
 如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>屬性`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例說明的 < 備註 > 中所討論的相依性屬性中繼資料覆寫使用量。 此程式碼定義的自訂控制項類別`NumericUpDown`適用於從專用的控制項程式庫組件。 參考某些私用的初始化函式所示的靜態建構函式時，註冊類別處理常式 (另一個常見的控制項子類別化案例，請參閱 <<c0> [ 標示路由傳送事件中當做 Handled，和類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md))，最後覆寫<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>相依性屬性的中繼資料上`NumericUpDown`類別。 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 一律會傳回它自己的型別為預期的索引鍵，這是用來查閱某些任意否則非樣式控制項之樣式的佈景主題樣式系統的慣例。 完整的範例也會定義該索引鍵所參考的實際控制項佈景主題樣式請參閱[NumericUpDown 自訂控制項搭配主題和 UI 自動化支援範例](http://go.microsoft.com/fwlink/?LinkID=160025)。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  
[!code-csharp[CustomControlNumericUpDown#Close](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#close)]
[!code-vb[CustomControlNumericUpDown#Close](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#close)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the initialization process for the element is complete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.FrameworkElement.BeginInit%2A>之前已呼叫過，基底實作將會引發<xref:System.Windows.FrameworkElement.Initialized>事件。 否則，如果<xref:System.Windows.FrameworkElement.BeginInit%2A>，不會呼叫或找不取決於是否<xref:System.Windows.FrameworkElement.BeginInit%2A>已呼叫<xref:System.Windows.FrameworkElement.Initialized>就不會引發，並改為擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.FrameworkElement.EndInit" /> was called without <see cref="M:System.Windows.FrameworkElement.BeginInit" /> having previously been called on the element.</exception>
        <block subset="none" type="overrides">
          <para>實作這個方法以提供您的項目初始化期間載入處理序的項目時應該發生的特殊處理。您的實作應該呼叫基底實作，因為基底 （預設值） 實作設定追蹤的初始設定部分內部旗標。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the requested element.</param>
        <summary>Finds an element that has the provided identifier name.</summary>
        <returns>The requested element. This can be <see langword="null" /> if no matching element was found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果項目具有子項目，這些子項目會遞迴搜尋所有要求的具名項目。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> 目前的項目範圍內的運作方式。 如需詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">The key identifier for the requested resource.</param>
        <summary>Searches for a resource with the specified key, and throws an exception if the requested resource is not found.</summary>
        <returns>The requested resource. If no resource with the provided key was found, an exception is thrown. An <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> value might also be returned in the exception case.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。 如果您不想處理的例外狀況所導致的呼叫<xref:System.Windows.FrameworkElement.FindResource%2A>，呼叫<xref:System.Windows.FrameworkElement.TryFindResource%2A>改為。 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 傳回`null`當找不到要求的資源，並不會擲回例外狀況。  
  
 如果呼叫的項目上找不到資源，父項目邏輯樹狀結構中是搜尋下一步，然後應用程式，然後佈景主題，和最後系統資源。 這項查閱方法等同於樹狀結構會如何搜尋如果所要求資源標記中動態資源參考。 如需資源查閱的詳細資訊，請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 一般而言，您立即轉換<xref:System.Windows.FrameworkElement.FindResource%2A>值傳回至屬性的型別，您設定與傳回的資源。  
  
 資源索引鍵不一定是字串。 例如，樣式的佈景主題層級的控制項索引鍵，<xref:System.Type>的控制項，和應用程式或網頁的樣式的控制項通常會使用這個相同的金鑰慣例。 如需詳細資訊，請參閱[設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)或[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
   
  
## Examples  
 下列範例會取得一個具名的資源，並將它轉換成適當型別來填滿屬性。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" /> was not found and an event handler does not exist for the <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> event.  -or-  <paramref name="resourceKey" /> was not found and the <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> property is <see langword="false" /> in the <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> event.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the direction that text and other [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elements flow within any parent element that controls their layout.</summary>
        <value>方向文字和其他 [！INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 項目的流程，其父項目，做為列舉值中。 預設值是 <see cref="F:System.Windows.FlowDirection.LeftToRight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性屬性的使用方式設定<xref:System.Windows.FrameworkElement.FlowDirection%2A>這個項目上。 由於設定的屬性值繼承<xref:System.Windows.FrameworkElement.FlowDirection%2A>可能可以設定項目上<xref:System.Windows.FrameworkElement.FlowDirection%2A>上未設定的所有子項目<xref:System.Windows.FrameworkElement.FlowDirection%2A>在本機或透過其他方式，例如樣式。  
  
 這個屬性未自動設定做為一部分的任何應用程式的文化特性資訊，因為項目可能包含不一定是要遵循的文化特性資訊所隱含的一般流程方向的內容。 如需有關全球化考量的詳細資訊，請參閱[WPF 的全球化](~/docs/framework/wpf/advanced/globalization-for-wpf.md)。  
  
 這個屬性具有已定義[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]屬性存取子，所以它是做為相依性屬性。 不過，它也會註冊為附加，所以它也可以當作附加屬性。 附加的註冊是主要，讓支援繼承屬性值，但此屬性也可用以做為 true 的附加屬性。 附加的屬性的使用方式，才適用，如果您想要設定文字方向上的物件具有<xref:System.Windows.FrameworkElement>的會執行配置時，父項目不是本身<xref:System.Windows.FrameworkElement>，而且已經沒有更直接定義`FlowDirection`屬性。 (例如流程的某些文件類別<xref:System.Windows.Documents.Block>和<xref:System.Windows.Documents.Inline>自行定義`FlowDirection`，和此屬性也可以設定文字方向。 屬性值會再讀取最終內容主機而不需要附加的屬性使用方式）。  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個屬性也可以設定不是類別上<xref:System.Windows.FrameworkElement>衍生類別中，由下列[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]附加的屬性使用方式：  
  
 `<` *物件* `FrameworkElement.` **FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 這個屬性是相依性屬性和附加的屬性。請參閱 < 備註 >。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a property that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</summary>
        <value>要在取得焦點時套用的樣式。 相依性屬性中所宣告的預設值是空的靜態<see cref="T:System.Windows.Style" />。 不過，執行階段的有效值通常是 (但不一定總是) 佈景主題支援為控制項所提供的樣式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會影響視覺外觀，但不會報告<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>中繼資料中。 這是因為視覺外觀變更是事件驅動和在任何時候，可能不適用，因此通常不應報告中繼資料中的任何視覺效果或版面配置資訊。  
  
 在概念上，套用至控制項的焦點視覺行為應該保持一致控制項。 如果您正在撰寫整個佈景主題，只變更焦點視覺化樣式為最實用的方式，來強制執行一致性。 設定這個屬性上個別控制項樣式，而非佈景主題的部分不是預定的使用方式，這個屬性，因為它可能會造成混淆的使用者經驗，關於鍵盤焦點。 如果您打算是刻意不一致的佈景主題的控制項特定行為，更好的方法是使用觸發程序在樣式為個別的輸入的狀態的屬性，例如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做並不會以方式以視覺化方式會影響任何現有的焦點視覺化樣式。 如需有關的設計目的<xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>及替代專注屬性，請參閱[樣式的焦點在控制項和 FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式的索引鍵。 索引鍵參考中現有的資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether this <see cref="T:System.Windows.FrameworkElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by the <see cref="P:System.Windows.FrameworkElement.Cursor" /> property.</summary>
        <value>
          <see langword="true" /> 如果這個項目上方的資料指標簡報強制使用目前<see cref="P:System.Windows.FrameworkElement.Cursor" />設定資料指標 （包括所有子系項目上）; 否則<see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您將此屬性設定為`true`將會覆寫子項目所建立的資料指標喜好設定。 這樣做，一般應用程式[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能會造成混淆的使用者，特別是如果子元素嘗試以指定資料指標。 設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>中控制項的子類別化或複合 （compositing） 的情況下更適當。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會強制資料指標的值。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The target <see cref="T:System.Windows.DependencyProperty" /> to get the binding from.</param>
        <summary>Returns the <see cref="T:System.Windows.Data.BindingExpression" /> that represents the binding on the specified property.</summary>
        <returns>A <see cref="T:System.Windows.Data.BindingExpression" /> if the target property has an active binding; otherwise, returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢查傳回值`null`是一種技術可用來判斷屬性是否有作用中的繫結。  
  
 這個方法是其實只是方便包裝<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>方法。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> 將目前的執行個體傳遞和`dp`參數<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The element to return a <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> for.</param>
        <summary>Gets the value of the <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> attached property for the specified <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>The requested flow direction, as a value of the enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的主要用途為支援附加的屬性的語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定的排列方式，其父項目中的資料流程方向。 若要取得值，在目前<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">The size of the part of the element that does visual presentation.</param>
        <summary>Returns a geometry for a clipping mask. The mask applies if the layout system attempts to arrange an element that is larger than the available display space.</summary>
        <returns>The clipping geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將減去邊界`layoutSlotSize`版面配置系統行為的一部分。  
  
 傳回的 null 參考會指出沒有裁剪部分會發生。 預設實作一定會傳回`null`時<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。 這個方法會覆寫<xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>。 <xref:System.Windows.FrameworkElement>實作會使用<xref:System.Windows.FrameworkElement.MaxHeight%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>在其計算中。 數個類別的子<xref:System.Windows.FrameworkElement>覆寫這個方法一次。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>會覆寫永遠傳回`null`因為裝飾項通常會刻意一般範圍外。 <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> 和<xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType>傳回`null`如果<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>預設實作一定會傳回<see langword="null" />時<see cref="P:System.Windows.UIElement.ClipToBounds" />是<see langword="false" />。覆寫通常仍會保留此行為，但有例外狀況，根據關聯性和衍生的類別和其配置邏輯，而不是基底類別的用途。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Name of the child to find.</param>
        <summary>Returns the named element in the visual tree of an instantiated <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>The requested element. May be <see langword="null" /> if no element of the requested name exists.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的範本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]有獨立的名稱範圍。 這是因為樣板是重複使用，而且在範本中定義的任何名稱不能是唯一的當多個執行個體，每個控制項的具現化的範本。 呼叫<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>方法以傳回物件具現化後，來自範本的參考。 您無法使用<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>方法來尋找範本中的項目，因為<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>扮演更常見的範圍，而且之間沒有連線<xref:System.Windows.Controls.ControlTemplate>類別本身和具現化的範本，一旦套用。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 提供這個方法與相同的功能。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 已受到保護而不是公用，並使用正確名稱範圍，使其得以存取的範本內的項目和尋找名為項目的考量。 使用<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>當您需要取得其父控制項以外的項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an alternative logical parent for this element if there is no visual parent.</summary>
        <returns>Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫<xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>。 預設值<xref:System.Windows.FrameworkElement>實作會傳回預期單一視覺化父項目，也就是相同的結果，以取得<xref:System.Windows.FrameworkElement.Parent%2A>值。 在衍生的類別實作可能會傳回替代的父代關聯性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the requested child element in the collection.</param>
        <summary>Overrides <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />, and returns a child at the specified index from a collection of child elements.</summary>
        <returns>The requested child element. This should not return <see langword="null" />; if the provided index is out of range, an exception is thrown.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Windows.FrameworkElement>實作中，唯一有效的索引為零。 內容模型的<xref:System.Windows.FrameworkElement.GetVisualChild%2A>支援零個或一個子項目不是集合。  
  
   
  
## Examples  
 下列範例示範如何自訂裝飾項會使用所宣告的值<xref:System.Windows.Media.VisualCollection>它所維護的多個 visual 的子系。 這些值會回報的覆寫透過<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此實作僅適用於不會維護任何更具描述性的集合的視覺化子項目數的項目。沒有這類集合的任何項目必須覆寫這個方法，並將索引對應至對等的索引中受到該元素的子項目集合。從零到範圍中的索引<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />（減一） 應該傳回有效的項目; 其他任何索引應該擲回例外狀況超出範圍。範例項目類型的支援子集合，並覆寫<see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />傳回多個可能的子系是<see cref="T:System.Windows.Controls.Panel" />。中的預設實作<see cref="T:System.Windows.FrameworkElement" />會假設只有一個 visual 的子系。傳遞給任何數值<paramref name="index" />非零的例外狀況擲回的原因。數個通用的項目，例如裝飾項目、 裝飾項或具有特定的轉譯項目覆寫<see cref="T:System.Windows.FrameworkElement" />實作 （從中繼基底類別實作）。某些實作仍強制執行一個 visual 的子系，而其他人可讓集合。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the suggested height of the element.</summary>
        <value>項目的高度，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值是 <see cref="F:System.Double.NaN" />。 這個值必須等於或大於 0.0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> 其中三個可寫入屬性位於<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。 其他兩個是<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 之間有衝突，如果這些值，應用程式的實際高度決定的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後，如果它在範圍內是<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 如果這個項目是一些其他項目內的子元素，然後將此屬性設定為值其實只是建議的值。 版面配置系統，以及特定配置的邏輯父項目會使用值為非繫結輸入配置程序期間。 實際上，<xref:System.Windows.FrameworkElement>是幾乎子元素的意義; 即使在您設定<xref:System.Windows.FrameworkElement.Height%2A>上<xref:System.Windows.Window>。 (如<xref:System.Windows.Window>，基礎的應用程式模型建立建立 Hwnd 基本呈現假設時，會使用值主控應用程式。)  
  
 此外，可接受<xref:System.Double>值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 這是您在程式碼中指定自動調整大小行為的方式。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您設定值的字串 「 自動 」 （不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填入可用的高度。 不過請注意，特定控制項通常會提供預設值，透過其預設佈景主題樣式，將會停用自動調整大小行為，除非它是特別重新啟用。  
  
 這個屬性傳回的值一律為任何已設定為它的值相同。 相較之下，值<xref:System.Windows.FrameworkElement.ActualHeight%2A>而有所不同。 這種情形是以靜態方式因為配置基於某些原因，拒絕建議的大小或立刻顯示。 版面配置系統本身會在相對於的屬性系統組以非同步方式運作<xref:System.Windows.FrameworkElement.Height%2A>並不一定有處理該特定尚未調整大小屬性變更。  
  
 值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。  
  
 驗證檢查，除了沒有繫結的不具決定性上限數值<xref:System.Windows.FrameworkElement.Height%2A>的版面配置系統會強制執行 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=nameWithType>但小於<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿設定<xref:System.Windows.FrameworkElement.Height%2A>大幅超過大小上限的任何可能的視覺顯示，或者您可能會超過此不具決定性的上限值。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 如需上限資訊，請參閱＜備註＞。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
 **Auto**  
 啟用自動調整大小行為。 請參閱＜備註＞。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Height" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the horizontal alignment characteristics applied to this element when it is composed within a parent element, such as a panel or items control.</summary>
        <value>此水平對齊方式設定作為列舉值。 預設值為 <see cref="F:System.Windows.HorizontalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.Width%2A>屬性已明確設定項目上，這些度量在配置期間需要更高的優先順序，將會取消一般設定作用的<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>至<xref:System.Windows.HorizontalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]實際上會相依性屬性的屬性存取子。 這個特定的相依性屬性經常會有子類別化項目，特別是控制項中以不同方式設定其明顯"default"值。 這通常發生在兩種方式之一： 重新登錄相依性屬性的特定子類別，但具有不同的中繼資料來設定其預設值。或以不同的方式設定該相依性屬性的值為預設樣式套用。 例如，明顯 「 預設 」 的<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>如<xref:System.Windows.Controls.Label>控制項將會是<xref:System.Windows.HorizontalAlignment.Left>，即使<xref:System.Windows.Controls.Label>繼承<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>直接從<xref:System.Windows.FrameworkElement>。 這是因為該值重設的預設樣式中<xref:System.Windows.Controls.Label>，樣式的控制項範本內。  
  
 <xref:System.Windows.Controls.Canvas> 不會使用<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>撰寫版面配置，因為時<xref:System.Windows.Controls.Canvas>根據絕對位置。  
  
 當繼承<xref:System.Windows.Controls.Label>或衍生類別，<xref:System.Windows.Controls.Label>會重新定義為此相依性屬性的預設值<xref:System.Windows.HorizontalAlignment.Left>。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the scope limits for property value inheritance, resource key lookup, and RelativeSource FindAncestor lookup.</summary>
        <value>列舉值。 預設值為 <see cref="F:System.Windows.InheritanceBehavior.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目中的特定界限樹狀組<xref:System.Windows.FrameworkElement.InheritanceBehavior%2A>刻意限制的繼承行為，強制資源查閱檢查應用程式資源，或防止 RelativeSource FindAncestor 查閱查詢目前的項目範圍內或任何進一步。 使用繫結，就會發生 RelativeSource FindAncestor 查閱<xref:System.Windows.Data.RelativeSource>具有其<xref:System.Windows.Data.RelativeSource.Mode%2A>屬性設定為<xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType>值。  
  
 如果您想要將此屬性設定衍生的類別，您應該在靜態建構函式或其他初始化常式中如此做。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when this <see cref="T:System.Windows.FrameworkElement" /> is initialized. This event coincides with cases where the value of the <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件將在每次引發<xref:System.Windows.FrameworkElement.EndInit%2A>或<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>呼叫的方法。 任一種方法的呼叫可以有來自應用程式程式碼，或透過[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]處理器的行為時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理網頁。  
  
 您是否選擇處理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取決於您的需求。 如果您不需要讀取項目屬性，想要重設的屬性，並不需要任何配置資訊，<xref:System.Windows.FrameworkElement.Initialized>可能會更好的事件，以根據採取行動。 如果您需要的項目，才能使用，所有屬性，而且您將設定重設配置，可能是屬性<xref:System.Windows.FrameworkElement.Loaded>可能會更好的事件，以根據採取行動。 請小心重新進入的如果您的處理常式會由配置系統表示新的配置傳遞需要解譯任何屬性重設。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>屬性，如果您不確定哪些屬性可以要求新的版面配置上的值通過，在變更時。)  
  
 如需詳細資訊有關順序的物件事件<xref:System.Windows.FrameworkElement>，以及是否有數個相關應用程式和項目類別，請參閱[物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>輸入範圍，可修改替代輸入法之輸入的解譯方式。 預設值是<see langword="null" />（結果會在預設的命令處理）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個相依性屬性會繼承屬性值。 如果沒有其他值的項目子系<xref:System.Windows.FrameworkElement.InputScope%2A>透過本機值或樣式，所建立，則對屬性系統將會設定這個值為<xref:System.Windows.FrameworkElement.InputScope%2A>指派此值與最接近的祖系項目的值。  
  
 雖然[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法使用量列為和語法上允許中, 設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]並不常見。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.InputScope" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this element has been initialized, either during processing by a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor, or by explicitly having its <see cref="M:System.Windows.FrameworkElement.EndInit" /> method called.</summary>
        <value>
          <see langword="true" /> 如果項目初始化每個先前提及 [！INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 處理或方法呼叫。否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性也可能`true`如果此項目已移動邏輯樹狀結構內，使它有新的父項目，並且因此變成一次重新載入。  
  
 如果您也會使用這個屬性很有用<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>。 邏輯樹狀結構中所載入的項目[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器會確保進行初始化。 不在邏輯樹狀結構中的元素會初始化時<xref:System.Windows.FrameworkElement.EndInit%2A>呼叫。 沒有任何特定處理的情況下<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>，建構函式會傳回初始化的結果時，會發生此情況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this element has been loaded for presentation.</summary>
        <value>
          <see langword="true" /> 如果目前的項目附加至項目樹狀結構中;<see langword="false" />如果項目已永遠不會附加到載入的項目樹狀結構。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從新建構<xref:System.Windows.FrameworkElement>，這個屬性一開始`false`，且會維持`true`設為它之後`true`，即使之後移除元素已連線的邏輯樹狀結構中程式碼。 `true` 狀態是項目會載入簡報引擎時設定的一般呈現邏輯。  
  
 一般而言，載入項目會轉譯，但不是全部<xref:System.Windows.FrameworkElement>衍生的類別中有一份簡報和其他屬性，例如<xref:System.Windows.UIElement.Visibility%2A>可能會影響簡報。  
  
   
  
## Examples  
 下列範例會實作兩個處理常式： 一個處理<xref:System.Windows.FrameworkElement.Loaded>的根項目，所以某些已載入頁面的根項目，因為這是事件的事件。 此處理常式會攔截到使用者控制項，並呼叫<xref:System.Windows.FrameworkElement.IsLoaded%2A>，以確保根項目會載入完全。 這兩個處理常式呼叫相同的函式 （未顯示），將會填入子項目，以更新的資料。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets localization/globalization language information that applies to an element.</summary>
        <value>這個項目的語言資訊。 預設值是<see cref="T:System.Windows.Markup.XmlLanguage" />具有其<see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />值設定為字串"EN-US"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字串格式會依照 RFC 3066 標準。 例如，美國英文是"EN-US"。 如需值和格式的詳細資訊，請參閱<xref:System.Windows.Markup.XmlLanguage>。  
  
 這個相依性屬性會繼承屬性值。 如果沒有其他值的項目子系<xref:System.Windows.FrameworkElement.Language%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkElement.Language%2A>指派此值與最接近的祖系項目的值。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 定義的一般意義`xml:lang`屬性。 <xref:System.Windows.FrameworkElement.Language%2A> 基本上會公開這個屬性為相依性屬性的意義。 <xref:System.Windows.FrameworkElement.Language%2A> 可以透過程式設計的方式，調整，而且可以參與平行設計的方式的屬性系統值繼承如何`xml:lang`屬性可以繼承中的子系項目範圍[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]。 如果您設定<xref:System.Windows.FrameworkElement.Language%2A>，此值會變成`xml:lang`並覆寫任何先前的值。 如需詳細資訊，請參閱[xml: lang 處理在 XAML 中](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Language" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a graphics transformation that should apply to this element when  layout is performed.</summary>
        <value>轉換應該使用這個項目。 預設值為 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相對於<xref:System.Windows.UIElement.RenderTransform%2A>，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>會影響結果的版面配置。  
  
 設定轉換提供強大的縮放和旋轉的功能。 不過，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>忽略<xref:System.Windows.Media.TranslateTransform>作業。 這是因為子項目的的版面配置系統行為<xref:System.Windows.FrameworkElement>自動更正任何位移的縮放或旋轉項目到配置的位置和座標系統的父項目。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 如果您不需要完全傳遞配置系統案例中叫用會導致效能不佳的應用程式。 當您將套用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>至<xref:System.Windows.Controls.Panel.Children%2A>集合<xref:System.Windows.Controls.Panel>觸發新的行程由配置系統，強制所有螢幕物件 remeasured 和重新排列。 如果您要更新的完整應用程式[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]，這項功能可能完全您的需要。 不過，如果您不需要完整的配置傳遞，使用<xref:System.Windows.UIElement.RenderTransform%2A>屬性，它不會叫用這個版面配置系統，並因此，通常是比較好的選擇，此案例。  
  
 範例案例其中<xref:System.Windows.FrameworkElement.LayoutTransform%2A>有用包括： 旋轉元素，例如功能表元件從水平為垂直或反之亦然，縮放比例元素 （拉近） 焦點，提供編輯行為，依此類推。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例示範如何套用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>的項目。 此範例會建立的執行個體<xref:System.Windows.Controls.Button>和裝載在父<xref:System.Windows.Controls.Grid>。 它也會使用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>屬性，將套用<xref:System.Windows.Media.RotateTransform>至<xref:System.Windows.Controls.Button>。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the element is laid out, rendered, and ready for interaction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> 通常是最後一個事件中引發的項目初始化順序。 它將會引發這個事件之後<xref:System.Windows.FrameworkElement.Initialized>。 您是否選擇處理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取決於您的需求。 如果您不需要讀取項目屬性，想要重設的屬性，並不需要任何配置資訊，<xref:System.Windows.FrameworkElement.Initialized>可能會更好的事件，以根據採取行動。 如果您需要的項目，才能使用，所有屬性，而且您將設定重設配置，可能是屬性<xref:System.Windows.FrameworkElement.Loaded>可能會更好的事件，以根據採取行動。 請小心重新進入的如果您的處理常式會由配置系統表示新的配置傳遞需要解譯任何屬性重設。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>屬性，如果您不確定哪些屬性可以要求新的版面配置上的值通過，在變更時。)  
  
 如需詳細資訊有關順序的物件事件<xref:System.Windows.FrameworkElement>，以及是否有數個相關應用程式和項目類別，請參閱[物件存留期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為： 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同時會引發由於使用者啟動系統的佈景主題變更的控制項上。 佈景主題變更會導致控制項樣板和自主視覺化樹狀結構，因此使得卸載再重新載入整個控制項的失效。 因此<xref:System.Windows.FrameworkElement.Loaded>無法假設發生只頁面第一次載入時透過巡覽至頁面。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.Loaded" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for logical child elements of this element.</summary>
        <value>此項目的邏輯子項目列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 可讓您逐一查看項目子系。 這適用於項目可能沒有定義且固定的集合，但仍然會包含一個以上的子元素，特別是<xref:System.Windows.FrameworkContentElement>子項目。  
  
 如需有關如何使用<xref:System.Windows.FrameworkElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the outer margin of an element.</summary>
        <value>提供項目的邊界值。 預設值是<see cref="T:System.Windows.Thickness" />使用所有屬性皆等於 0 （零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 邊界是這個項目和其他配置建立時將相鄰的項目之間的間距[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 共用的項目可能是對等項目 （例如中其他項目的一般父控制項的集合），或也可能是此項目的父代。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> 設定為<xref:System.Windows.Thickness>結構，而不是數字，讓對稱性設定邊界。 <xref:System.Windows.Thickness>結構本身支援字串型別轉換，好讓您可以指定非對稱<xref:System.Windows.FrameworkElement.Margin%2A>中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]也屬性語法。  
  
 非零邊界適用於外部項目配置的空間<xref:System.Windows.FrameworkElement.ActualWidth%2A>和<xref:System.Windows.FrameworkElement.ActualHeight%2A>。  
  
 邊界會加總的同層級項目在版面配置。例如，都與 30 的邊界設定邊緣相鄰的兩個相鄰項目會有 60 之間的空間單位。  
  
 已設定邊界的項目將不會通常限制指定的大小<xref:System.Windows.FrameworkElement.Margin%2A>配置的矩形空間不是已夠大，邊界以及元素內容區域。 計算配置時，將會改為限制項目的內容區域。 邊界會被限制的唯一情況也是內容已被限制到零。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *左、 上、 靠右下*  
 數字值介於 0 和<xref:System.Double.PositiveInfinity>旗標會指定四個可能維度屬性的<xref:System.Windows.Thickness>結構。  
  
 屬性使用方式也會接受縮寫對稱與邏輯上提供的順序套用的值。 比方說，`Margin="20"`會解譯成表示<xref:System.Windows.Thickness>且其所有屬性設定為 20。 `Margin="20,50"` 將解譯成表示<xref:System.Windows.Thickness>與<xref:System.Windows.Thickness.Left%2A>和<xref:System.Windows.Thickness.Right%2A>設為 20，和<xref:System.Windows.Thickness.Top%2A>和<xref:System.Windows.Thickness.Bottom%2A>設定為 50。  
  
 預設單位<xref:System.Windows.Thickness>量值是[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]。 您也可以藉由附加單位類型字串來指定其他單位`cm`， `in`，或`pt`任何量值。  
  
 數字作為值[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]屬性不需要指定小數位數 （0 是可以接受的並沒有提供的 0.0)。 如需有關[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>。  
  
 *thicknessReference*  
 將現有的物件參考<xref:System.Windows.Thickness>。 這可能是`}`、 a、 或`}`參考。 如需有關[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Margin" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum height constraint of the element.</summary>
        <value>最大高度的項目，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值是 <see cref="F:System.Double.PositiveInfinity" />。 這個值可以是等於或大於 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 仍有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。 其他兩個是<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.Height%2A>。  如果這些值之間沒有衝突，實際高度判斷應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後如果每個範圍中，在<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制，只不過您必須使用[X:static 標記延伸](~/docs/framework/xaml-services/x-static-markup-extension.md)如果您需要明確地設定這個值為<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum width constraint of the element.</summary>
        <value>項目的最大寬度，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值是 <see cref="F:System.Double.PositiveInfinity" />。 這個值可以是等於或大於 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 仍有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。 其他兩個是<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.Width%2A>。 如果這些值之間沒有衝突，這是第一次應用程式的實際寬度判斷順序<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後如果每個範圍中，在<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制，只不過您必須使用[X:static 標記延伸](~/docs/framework/xaml-services/x-static-markup-extension.md)來設定這個值為<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">The available size that the parent element can give to the child elements.</param>
        <summary>Implements basic measure-pass layout system behavior for <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>The desired size of this element in layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>連接 WPF 核心層級和 WPF 架構層級配置量值實作。 <xref:System.Windows.FrameworkElement>實作密封方法。 若要調整 WPF 架構層級為基礎的任何項目的測量行程配置行為，請覆寫<xref:System.Windows.FrameworkElement.MeasureOverride%2A>改為。 若要調整量值會傳遞刻意不會在 WPF 架構層級上建置或使用的項目配置行為<xref:System.Windows.FrameworkElement>，覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">The available size that this element can give to child elements. Infinity can be specified as a value to indicate that the element will size to whatever content is available.</param>
        <summary>When overridden in a derived class, measures the size in layout required for child elements and determines a size for the <see cref="T:System.Windows.FrameworkElement" />-derived class.</summary>
        <returns>The size that this element determines it needs during layout, based on its calculations of child element sizes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫<xref:System.Windows.FrameworkElement.MeasureOverride%2A>來實作您的項目自訂版面配置調整大小行為，如在參與[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]版面配置系統。 您的實作應該執行下列作業：  
  
1.  逐一查看項目的特定集合的子系屬於配置中，呼叫<xref:System.Windows.UIElement.Measure%2A>每個子項目上。  
  
2.  立即取得<xref:System.Windows.UIElement.DesiredSize%2A>的子系上 (這設定為屬性之後<xref:System.Windows.UIElement.Measure%2A>稱為)。  
  
3.  計算父系的子項目測量為基礎的網路所需的大小。  
  
 傳回值<xref:System.Windows.FrameworkElement.MeasureOverride%2A>應該是項目的自己所需大小，就會變成目前的項目之父元素的輸入量值。 同樣的程序會在頁面的根項目為止，持續進行的版面配置系統。  
  
 在此過程中，子元素可能會傳回較大<xref:System.Windows.UIElement.DesiredSize%2A>大小比初始`availableSize`來表示的子項目想更多空間。 這可能會藉由引進可捲動區域，藉由建立某些方式堆疊的順序或任何數目的解決方案來進行測量或排列內容調整父控制項、 處理中您自己的實作。  
  
> [!IMPORTANT]
>  項目應該呼叫<xref:System.Windows.UIElement.Measure%2A>在此程序期間每個子系，否則子項目會無法正確調整大小或排列。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>下列非編譯程式碼會示範這項實作模式。<c>VisualChildren</c>代表您自己的項目應該定義的子系的可列舉集合屬性。屬性可以命名為任何項目。<c>VisualChildren</c>是基於此範例中，以替代名稱<c>VisualChildren</c>不是 [！INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 所提供 [！INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 或部分的命名模式... [！ code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)][！ code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum height constraint of the element.</summary>
        <value>項目的最小高度，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<see cref="F:System.Double.PositiveInfinity" />不是有效的也不是<see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。  其他兩個是<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果這些值之間沒有衝突，實際高度判斷應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後如果每個範圍中，在<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.MinHeight" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum width constraint of the element.</summary>
        <value>最小寬度的項目，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<see cref="F:System.Double.PositiveInfinity" />不正確，也不是<see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。  其他兩個是<xref:System.Windows.FrameworkElement.Width%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果這些值之間沒有衝突，這是第一次應用程式的實際寬度判斷順序<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後如果每個範圍中，在<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 這會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.MinWidth" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">The direction that focus is to be moved, as a value of the enumeration.</param>
        <summary>Moves the keyboard focus away from this element and to another element in a provided traversal direction.</summary>
        <returns>Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist or could not be keyboard focused.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作會覆寫<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType>和密封方法。  
  
   
  
## Examples  
 下列範例會實作處理數個可能的按鈕輸入處理常式。 每個按鈕表示可能<xref:System.Windows.Input.FocusNavigationDirection>。 處理常式會追蹤目前的鍵盤焦點，並呼叫的項目<xref:System.Windows.FrameworkElement.MoveFocus%2A>該元素，指定適當的<xref:System.Windows.Input.FocusNavigationDirection>初始化為<xref:System.Windows.Input.TraversalRequest>型別參數提供。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the identifying name of the element. The name provides a reference so that code-behind, such as event handler code, can refer to a markup element after it is constructed during processing by a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor.</summary>
        <value>項目的名稱。 預設為空字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的使用方式是指定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]做為屬性標記的項目名稱。  
  
 這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 名稱必須是唯一的名稱範圍內。 如需詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 取得<xref:System.Windows.FrameworkElement.Name%2A>如果您要建立項目中的程式碼並不常見。 如果已經在程式碼中有適當的參考，您可以直接呼叫方法和屬性項目上的參考，而且通常不會需要<xref:System.Windows.FrameworkElement.Name%2A>。 這個例外狀況是如果<xref:System.Windows.FrameworkElement.Name%2A>字串具有某些多載意義，例如是否要顯示在該名稱很有用[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼後置如果原始<xref:System.Windows.FrameworkElement.Name%2A>已從標記設定也不建議，並於載入後變更屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]不會變更原始的物件參考。 只有在剖析期間明確建立的基礎命名範圍時，會建立物件參考。 您必須特別呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>進行有效變更<xref:System.Windows.FrameworkElement.Name%2A>已經載入的項目屬性。  
  
 一個值得注意的大小寫設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼很重要時，才能註冊名稱，將分鏡腳本的項目執行，以便在執行階段可以參考它們。 您可以註冊之前，可能也需要具現化，並指派<xref:System.Windows.NameScope>執行個體。 請參閱 < 範例 > 一節中，或[概觀腳本](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 設定<xref:System.Windows.FrameworkElement.Name%2A>從程式碼具有有限的應用程式，但取得項目<xref:System.Windows.FrameworkElement.Name%2A>更常見。 一個特定案例中，這是您的應用程式是否支援頁面會重新載入至應用程式，而執行的階段程式碼不一定是程式碼後置定義該網頁瀏覽模型。 公用程式方法<xref:System.Windows.FrameworkElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkElement>，可以找到任何元素<xref:System.Windows.FrameworkElement.Name%2A>該項目的邏輯樹狀結構中，搜尋視樹狀目錄中以遞迴方式。 或者您可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，這也會採用<xref:System.Windows.FrameworkElement.Name%2A>做為引數的字串。  
  
 常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 實作的介面<xref:System.Windows.Markup.INameScope>。 此介面的實作應該強制執行的名稱是其範圍內模稜兩可。 定義這個介面的根項目也將 namescope 行為界限定義所有相關[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]。  
  
 <xref:System.Windows.FrameworkElement.Name%2A>屬性也可做為其他處理序的識別項。 比方說， [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] automation 模型將使用<xref:System.Windows.FrameworkElement.Name%2A>為用戶端和提供者的 AutomationId。  
  
 所使用的字串值<xref:System.Windows.FrameworkElement.Name%2A>有一些限制，如基礎所加諸[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)所定義[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]規格。 最值得注意的是，<xref:System.Windows.FrameworkElement.Name%2A>必須以字母或底線字元 (_) 開頭，而且必須包含字母、 數字或底線。 如需詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> 是非常少無法以動畫顯示的相依性屬性的其中一個 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>是`true`中繼資料中)，因為名稱本身是重要的目標動畫。 資料繫結<xref:System.Windows.FrameworkElement.Name%2A>是可行，但是極不常見的案例，因為資料繫結<xref:System.Windows.FrameworkElement.Name%2A>無法提供預期的主要用途，屬性的： 若要提供的程式碼後置識別連接點。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.NameProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 下列範例會設定<xref:System.Windows.FrameworkElement.Name%2A>屬性中的程式碼，並再註冊到新建立的 名稱<xref:System.Windows.NameScope>藉由呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>。 如下圖所示的技巧是使用分鏡腳本，建立動畫的需求，因為分鏡腳本必須由目標<xref:System.Windows.FrameworkElement.Name%2A>，並不能設為目標的物件參考。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Name" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, is invoked whenever application code or internal processes call <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。  
  
 範本是項目的已完成的視覺化樹狀結構的 [範本] 屬性是來自區段<xref:System.Windows.Style>，它會套用項目。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在衍生類別的<see cref="T:System.Windows.FrameworkElement" />可以使用此方法為通知的各種可能的案例:-您可以呼叫自己的實作會建立項目的視覺化樹狀結構的其餘部分的程式碼。 -您可以執行已套用至範本，例如取得來自範本的具名項目參考的視覺化樹狀結構所依賴的程式碼。 -您可以引入只對現有範本的視覺化樹狀結構完成後的服務。 -您可以設定狀態和屬性的項目範本內其他因素而定。比方說，屬性值可能只會探索所知道的父項目，或當特定衍生類別會使用一般的範本。實作者應該一律會呼叫基底實作自己的實作之前。<see cref="T:System.Windows.FrameworkElement" />本身具有沒有預設值可能會實作，而中介的類別。 <see cref="T:System.Windows.Controls.Control" />提供類似的覆寫， <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Provides data about the event.</param>
        <summary>Invoked whenever an unhandled <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> routed event reaches this class in its route. Implement this method to add class handling for this event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data.</param>
        <summary>Invoked whenever an unhandled <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> routed event reaches this class in its route. Implement this method to add class handling for this event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data.</param>
        <summary>Invoked whenever an unhandled <see cref="E:System.Windows.UIElement.GotFocus" /> event reaches this element in its route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於在某些其他 * 基底的項目，所公開的方法<xref:System.Windows.FrameworkElement.OnGotFocus%2A>沒有預設實作。 具體來說，它有實作會關閉，覆寫基底項目的下一個層級中的 null 實作<xref:System.Windows.UIElement.OnGotFocus%2A>。 叫用時，<xref:System.Windows.FrameworkElement.OnGotFocus%2A>鍵盤焦點由於目前的項目產生事件的案例中此項目上設定適當的焦點行為。 <xref:System.Windows.FrameworkElement.OnGotFocus%2A>處理常式不會將標示為已處理，即使當焦點設定為目前的項目之事件引數。 如果事件的來源是另一個項目樹狀目錄 （不是目前項目），此處理常式沒有任何作用。  
  
 您可以覆寫此方法，以變更您的項目，則預設焦點行為，但請注意，變更焦點行為，如此一來可能會更好可藉由不允許完全可設定焦點的項目 (請參閱<xref:System.Windows.UIElement.Focusable%2A>)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您想以標記引數中處理事件，您應該注意的其他項目樹狀結構中的父項目中的事件處理的結果。因為這個處理常式都會具有反昇路由的事件，將焦點設定至目前<paramref name="sender" />每個事件引數，可能不適合。焦點可能需要前往複合式子元素或父項目，根據某些控制項的組合。只建議為已處理，因此標示焦點事件，事件會透過路由傳送的視覺化樹狀結構的全部內容是否撰寫您撰寫的控制項的一部分。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.FrameworkElement.Initialized" /> event. This method is invoked whenever <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> is set to <see langword="true" /> internally.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此特定 * 方法不是類別處理常式攔截。 或其不完全遵循建立[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上 * 方法慣例相符的事件可能會隱藏所覆寫這個方法，並且不會呼叫基底實作。  
  
 請注意，<xref:System.Windows.FrameworkElement.IsInitialized%2A>屬性是唯讀的因此您不能設定<xref:System.Windows.FrameworkElement.IsInitialized%2A>來強制初始化行為。 設定初始設定狀態是只藉由完成[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]架構。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虛擬方法的預設實作會引發事件，如上面所述。覆寫應呼叫基底實作以保留此行為。如果您無法呼叫基底實作，不只將您不會引發<see cref="E:System.Windows.FrameworkElement.Initialized" />事件，如通常預期的<see cref="T:System.Windows.FrameworkElement" />衍生的類別，但您也會隱藏兩個重要樣式和佈景主題樣式初始化作業實作這個基底實作。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The event data that describes the property that changed, as well as old and new values.</param>
        <summary>Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkElement" /> has been updated. The specific dependency property that changed is reported in the arguments parameter. Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是偵測一般的屬性變更或失效。 它改為僅供修改的一般失效模式如果已知廣泛分類屬性的特定資訊。  
  
 這可能會叫用方法多次物件的存留期間。 因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。 不過，您會使用這個方法如果<xref:System.Windows.FrameworkElement>包含大量的值相互關聯的相依性屬性，或如果它包含邏輯，例如轉譯行為，必須重新執行的幾個相關的屬性失效的情況。  
  
 請注意，相同具名`OnPropertyChanged`方法具有不同簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別。 確認`OnPropertyChanged`用於資料物件通知，而且是合約的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>請務必呼叫基底實作，在實作中的第一個作業。如果沒有這樣做將會大幅停用整個 [！INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 屬性系統，會導致不正確地回報的值。特定<see cref="T:System.Windows.FrameworkElement" />實作也會負責維護適當狀態的各種會影響可見的使用者介面的屬性。這些包括失效的視覺化樹狀結構，根據在適當時間樣式的變更。</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Details of the old and new size involved in the change.</param>
        <summary>Raises the <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> event, using the specified information as part of the eventual event data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>。 如果您呼叫這個方法則會重設<xref:System.Windows.FrameworkElement.ActualWidth%2A>屬性，<xref:System.Windows.FrameworkElement.ActualHeight%2A>屬性，或兩者，根據指定為提供的引數中的變更，並且您總是會引發此事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>不要覆寫這個方法的一般配置案例。版面配置系統運作刻意非同步的方式，以確保所有的可能配置排列，和量值的情況下都計算在內。版面配置系統覆寫方法<see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />和<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />通常就足夠了任何必要的配置可自訂的。<see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />公開為虛擬機器。您可以覆寫<see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />更正的執行階段行為的變更與輸入結合控制項事件的例外狀況的重新編輯畫在回應中的可能會提供不正確的配置資訊。您仍可能會覆寫這個方法 （其受到保護但未密封） 衍生類別中。請務必呼叫基底實作，以保留上面所提的行為，除非您有非常特定的理由要停用預設 WPF 架構層級的轉譯行為。無法引發<see cref="E:System.Windows.FrameworkElement.SizeChanged" />事件會導致非標準的版面配置的行為，如果使用標準的 WPF 架構層級版面配置系統實作。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">The old style.</param>
        <param name="newStyle">The new style.</param>
        <summary>Invoked when the style in use on this element changes, which will invalidate the layout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法已設定的樣式變更條件內部旗標的預設實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您應該通常不會有覆寫這個方法。任何變更，包括量值為樣式或排列變更已經會觸發另一個轉譯循環，假設典型實作<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />，或預設值。覆寫的<see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />可能適合如果您<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />實作刻意的最佳化或支援部分更新，但仍想要更直接套用樣式的變更。(部分的更新會嘗試避免多次累加呼叫<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />和<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上任何子項目)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Provides data about the event.</param>
        <summary>Invoked whenever an unhandled <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> routed event reaches this class in its route. Implement this method to add class handling for this event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Provides data about the event.</param>
        <summary>Invoked whenever the <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> routed event reaches this class in its route. Implement this method to add class handling for this event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">The old parent element. May be <see langword="null" /> to indicate that the element did not have a visual parent previously.</param>
        <summary>Invoked when the parent of this element in the visual tree is changed. Overrides <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視覺化樹狀結構是不同的邏輯樹狀結構，因為後者省略集合，例如不以視覺化的方式，呈現的項目，並展開根據其佈景主題和樣式複合 （compositing） 的某些項目。 如需詳細資訊，請參閱 [WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虛擬方法的預設實作會查詢以取得新的父項、 引發各種初始化事件，並初始化狀態的相關設定內部的旗標<see cref="T:System.Windows.FrameworkElement" />依適當情況。最後，它會呼叫後續的基底實作，做為宣告由<see cref="T:System.Windows.UIElement" />，接著呼叫其基底<see cref="T:System.Windows.Media.Visual" />。請務必呼叫基底實作以保留此行為，否則為項目樹狀結構行為，這個項目宣告為另一個項目子系時可能無法如預期般。一些現有 [！INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 類別覆寫這個方法，例如： <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />， <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />。最常見的案例是新的父系必須是特定類型的強制執行。這可能會擲回例外狀況，如果新的父項失敗的型別測試的方式。此案例中的特定的版本存在於清單項目和功能表項目，其中沒有意義的任何外部的父 visual 擁有適當的集合，來儲存它們中的實作。請注意，這種情況下不一定會引發例外狀況，因為可能需要重設父代會對不其 「 一般 」 父系的元素的設計工具案例。也在某些項目，通常是根項目，例如覆寫這個方法<see cref="T:System.Windows.Window" />。另一種情況是明顯的根目錄中的項目標記，但其中的項目自動產生已編譯的邏輯樹狀結構中的大於基礎結構 (例如<see cref="T:System.Windows.Controls.Page" />)。<see cref="T:System.Windows.Window" />和<see cref="T:System.Windows.Controls.Page" />實作刻意密封方法。</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether this element incorporates style properties from theme styles.</summary>
        <value>
          <see langword="true" /> 如果這個項目不會使用佈景主題樣式屬性。樣式產生的所有屬性都來自於本機應用程式樣式和佈景主題樣式屬性不會套用。 <see langword="false" /> 如果應用程式樣式套用第一次，然後佈景主題樣式適用於應用程式樣式中未明確設定的屬性。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。  
  
> [!IMPORTANT]
>  如果您設定<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>至`true`控制，您將會隱藏佈景主題樣式所提供的預設控制項範本。 該控制項範本通常包含內容展示器和其他複合項目可提供基本[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]功能和控制項的視覺效果。 如果您想要繼續支援相同的功能，做為預設佈景主題樣式的控制項，您必須提供具有複寫相同的結構的控制項範本的其他樣式。 如需詳細資訊，請參閱[控制項撰寫概觀](~/docs/framework/wpf/controls/control-authoring-overview.md)。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical parent  element of this element.</summary>
        <value>此項目的邏輯父代。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> 可能是`null`項目未具現化，但未連接至任何最後會連接到頁面層級的根項目或應用程式物件的邏輯樹狀結構中。  
  
 請注意，根據您的應用程式功能，有可能變更邏輯父項目，可以保留此屬性的值不會反映該變更。 您通常應該取得的值之前您需要它。  
  
 請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)邏輯樹狀目錄中周遊的詳細資訊和案例使用<xref:System.Windows.FrameworkElement.Parent%2A>適當探索是做為父項目的一個技巧。  
  
 屬性引擎有可能重新計算所有的屬性值的項目時，它會重設父代，因為有些屬性是繼承的處理邏輯樹狀結構的值。 <xref:System.Windows.FrameworkElement.DataContext%2A>可套用的項目會重設父代時，也可以變更繫結。  
  
 變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。  
  
 最常見的案例使用<xref:System.Windows.FrameworkElement.Parent%2A>屬性是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkElement>屬性值從父代。 範本，<xref:System.Windows.FrameworkElement.Parent%2A>範本的最終會`null`。 若要取得略過此點，並將延伸至邏輯樹狀結構實際套用的範本，請使用<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。  
  
 請注意這個屬性不會報告在這些項從邏輯樹狀結構父項中的視覺化樹狀結構父代。 視覺化樹狀結構的父代不是一般的應用程式案例通常會特別重要，但可能某些視覺層級的情況下所需的父項目。 請參閱 <xref:System.Windows.Media.VisualTreeHelper>。  
  
   
  
## Examples  
 下列範例程式碼會檢查有項目的父代，，然後使用從父代的屬性值在比對的子元素設定屬性。 在此情況下，這些是會影響呈現大小屬性。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">The child element reporting the change.</param>
        <summary>Supports incremental layout implementations in specialized subclasses of <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> is invoked when a child element has invalidated a property that is marked in metadata as affecting the parent's measure or arrange passes during layout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目具有子項目所在某些屬性無效的而且屬性被標示為<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>或<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>屬性中繼資料，在註冊期間，會叫用此方法。 方法引動過程會告知哪個特定子項目必須重新測量，如果此項目支援的配置部分 （累加） 更新的父項目。  
  
 根據預設，<xref:System.Windows.FrameworkElement>不支援累加配置，然後在<xref:System.Windows.FrameworkElement>類別，這個方法有預設的實作。 覆寫這個方法，可能需要的案例不常見，因為它會要求您修改預設版面配置系統行為。  
  
 範例實作的狀況可能是如果類別具有明顯比 WPF 架構層級配置系統更嚴格的可能的子元素的類型限制。 基於這些自訂項目本質，屬性變更可能會刻意延後當您實作某些自訂版面配置的行為。 比方說，測量/排列方法覆寫，嘗試最佳化子項目的呈現階段，可能會延後某些類型的變更通常會導致另一個配置傳遞。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">The direction for which a prospective focus change should be determined.</param>
        <summary>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</summary>
        <returns>The next element that focus would move to if focus were actually traversed. May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 是實際移動焦點的相關的方法。  
  
   
  
## Examples  
 下列範例會實作處理數個可能的按鈕輸入，每個按鈕，表示可能的處理常式<xref:System.Windows.Input.FocusNavigationDirection>。 處理常式會追蹤目前的鍵盤焦點，並呼叫的項目<xref:System.Windows.FrameworkElement.PredictFocus%2A>該項目上，並指定適當<xref:System.Windows.Input.FocusNavigationDirection>初始化為<xref:System.Windows.Input.TraversalRequest>型別參數提供。 而不需要移動的項目，做為<xref:System.Windows.FrameworkElement.MoveFocus%2A>一樣，此處理常式變更視覺效果用途的預測的焦點目的地實體的維度。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. These directions are not legal for <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Name to use for the specified name-object mapping.</param>
        <param name="scopedElement">Object for the mapping.</param>
        <summary>Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.NameScope.RegisterName%2A>。 實作會檢查後續的父項目，直到找到適用<xref:System.Windows.NameScope>實作，其位於藉由尋找可實作項目<xref:System.Windows.Markup.INameScope>。 如需命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>會需要正確的應用程式程式碼中建立時的動畫分鏡腳本連結。 這是因為其中一個索引鍵的分鏡腳本屬性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，會使用執行階段名稱查詢，而不是能夠充分目標項目的參考。 即使該元素是可供參考從程式碼存取，也是如此。 如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[概觀腳本](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">The element to remove.</param>
        <summary>Removes the provided object from this element's logical tree. <see cref="T:System.Windows.FrameworkElement" /> updates the affected logical tree parent pointers to keep in sync with this deletion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法實作的邏輯子系的項目表示物件的集合。 這可能是屬性 getter 或 setter，類別處理常式的`Changed`事件、 建構函式，或集合內的類型本身。  
  
 控制項的作者，處理邏輯樹狀結構，此層級不建議的作法，除非是提供基底控制項類別的內容模型沒有適合。 請考慮在層級的子類別化<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 這些類別會提供透過專用的邏輯子系的特定增強的內容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。  
  
   
  
## Examples  
 下列範例會實作`Child`在自訂屬性<xref:System.Windows.FrameworkElement>執行它自己的視覺層實作。 屬性 setter 的設計，因此如果的值變更時，會從邏輯樹狀結構，以及類別的特定視覺集合移除的舊值。 會快取的值，並接著新值加入至標準 WPF 架構層級邏輯樹狀結構和自訂的視覺集合。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> is called on this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件表示至父代<xref:System.Windows.Controls.ScrollViewer>（或衍生類別） 所引發的項目<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件應該會顯示可捲動區域內。 <xref:System.Windows.Controls.ScrollViewer>然後會將標示<xref:System.Windows.FrameworkElement.RequestBringIntoView>為已處理，使用類別處理事件的事件。 一般情況下<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件資料應該不會標示為已處理的任何類別，並控制捲動區域，或任何執行個體處理常式，因為這樣會干擾呼叫的項目，目的是<xref:System.Windows.FrameworkElement.BringIntoView%2A>。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> routed event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the locally-defined resource dictionary.</summary>
        <value>目前在本機定義的資源字典，其中每項資源都可以使用索引鍵存取。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，且通常是針對任何個別頁面或應用程式的根項目。 放置在此層級的資源字典，可以更輕鬆地尋找個別的子系中的項目頁面 （或從任何頁面上，在應用程式的情況下）。 在大部分的應用程式案例中，我們建議樣式定義做為物件項目內的資源字典，或定義為外部資源，以便可以是獨立的整個樣式資源 （這種方式有助於個別設計工具責任從開發人員責任分隔需要加以編輯的實體檔案）。  
  
 請注意，這個屬性會傳回直接在該元素中宣告的資源字典。 這是不同於實際資源對應程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中所定義的資源。  
  
 資源也可以從集合中的程式碼所參考，但請注意在中建立資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]絕對不會之前之後存取<xref:System.Windows.FrameworkElement.Loaded>宣告字典的項目就會引發。 以非同步方式並不會剖析資源的事實上，即使<xref:System.Windows.FrameworkElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義資源。 因此您應該通常只存取[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]資源定義為一部分的執行階段程式碼，或透過其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。 當您透過程式碼存取資源時，它是基本上等同於從進行參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除或使用程式碼來查詢集合中的資源所需的方法。 <xref:System.Windows.FrameworkElement.Resources%2A>屬性是可設定為支援完全取代項目是一個新的或不同的資源集合的案例<xref:System.Windows.ResourceDictionary>。  
  
 請注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的語法不包括的項目<xref:System.Windows.ResourceDictionary>。 這是隱含的集合語法; 的範例可以省略標記，表示集合項目。 會改為指定做為項目加入至集合的項目。 如需有關隱含的集合和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，請參閱[XAML 語法的詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 其中一個案例其中<xref:System.Windows.ResourceDictionary>還是明確地指定為項目就是引進的一個合併的字典，在此情況下是否有通常該任何子項目<xref:System.Windows.ResourceDictionary>。 如需詳細資訊，請參閱[合併資源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一或多個物件項目，其中每個定義的資源。 每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>值必須是唯一的[X:key 指示詞](~/docs/framework/xaml-services/x-key-directive.md)，從擷取值時做為唯一索引鍵<xref:System.Windows.ResourceDictionary>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attaches a binding to this element for the specified dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifies the destination property where the binding should be established.</param>
        <param name="path">The source property name or the path to the property used for the binding.</param>
        <summary>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</summary>
        <returns>Records the conditions of the binding. This return value can be useful for error checking.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>依據提供`path`參數。 此簽章是更方便，如果您要建立簡單的預設繫結。 如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。  
  
   
  
## Examples  
 下列範例會設定使用特定路徑的繫結。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identifies the property where the binding should be established.</param>
        <param name="binding">Represents the specifics of the data binding.</param>
        <summary>Attaches a binding to this element, based on the provided binding object.</summary>
        <returns>Records the conditions of the binding. This return value can be useful for error checking.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">The element that specifies a flow direction.</param>
        <param name="value">A value of the enumeration, specifying the direction.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> attached property for the provided element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的屬性的語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定的排列方式，其父項目中的資料流程方向。 在目前設定的值<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The property to which the resource is bound.</param>
        <param name="name">The name of the resource.</param>
        <summary>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資源參考是可讓您使用類似[DynamicResource 標記延伸](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)標記中。 資源參考建立內部的運算式，提供執行階段的延遲為基礎的指定屬性的值。 每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkElement.Resources" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.FrameworkElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`，只要至少一個索引鍵的資源正在本機<xref:System.Windows.FrameworkElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkElement.Style" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.FrameworkElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.Style>本機設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkElement.Triggers" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.FrameworkElement.Triggers" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回`true`如果<xref:System.Windows.FrameworkElement.Triggers%2A>屬性在本機設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when either the <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> or the <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> properties change value on this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為： 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。  
  
 版面配置系統會讀取內容內<xref:System.Windows.SizeChangedEventArgs>引數類別，這個事件，以判斷是否應該在報告的大小變更視為重要。 這可讓版面配置系統或您的特定控制項的版面配置實作來避免強制版面配置變更，因為以視覺化方式無法察覺舊的和新的高度或寬度值之間的差異。 無法察覺的差異可能是因為浮點資料類型的捨入或相同結果的計算。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the source value changes for any existing property binding on this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the style used by this element when it is rendered.</summary>
        <value>如有，則為項目已套用的非預設樣式。 否則為 <see langword="null" />。 預設建構預設<see cref="T:System.Windows.FrameworkElement" />是<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制項，通常是提供的預設樣式來自控制項主題設定，或樣式通常由套用至該類型的控制項在頁面或應用程式層級 （隱含樣式） 的資源目前的樣式。 這個屬性不會設定或傳回預設 （佈景主題） 樣式，但會傳回隱含樣式或項目做為明確樣式。 在隱含或明確樣式的情況下，樣式是指定為資源，或在本機定義並不重要。  
  
 設定樣式會有一些限制。 您可以重設整個<xref:System.Windows.FrameworkElement.Style%2A>屬性至新<xref:System.Windows.Style>在任何時間，這會強制配置重新編輯畫。 不過，一旦該樣式會放在使用中載入的項目，<xref:System.Windows.Style>應該被視為已密封。 嘗試變更的任何個別的使用中樣式屬性 (例如在集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。 標記中定義的樣式會被視為正在使用中，一旦載入時將它從資源字典 （資源），或載入它包含在的頁面 （適用於內嵌樣式）。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> 是具有特殊的優先順序的相依性屬性。 本機設定樣式通常都是在運作的最高的優先順序屬性系統中。 如果<xref:System.Windows.FrameworkElement.Style%2A>為 null 此時，在載入中指定該類型的本機或應用程式資源的隱含樣式屬性系統檢查期間。 如果樣式時仍然是 null，這個步驟之後，將顯示用途的動作樣式通常是來自預設 （佈景主題） 的樣式，但中不會傳回預設樣式<xref:System.Windows.FrameworkElement.Style%2A>屬性值。 請參閱[相依性屬性的值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)或[設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式的索引鍵。 索引鍵參考中現有的資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性項目語法不可行，但不是建議用於大部分的樣式案例。 請參閱[內嵌樣式和樣板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例會定義資源字典中的樣式。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Style" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">The name of the requested ambient property.</param>
        <summary>For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</summary>
        <returns>
          <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作。 只有在 <xref:System.Windows.FrameworkElement> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an arbitrary object value that can be used to store custom information about this element.</summary>
        <value>預定的值。 此屬性沒有預設值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性相當於其他 Microsoft 程式撰寫模型，例如 Visual Basic 應用程式或 Windows Form 中的標記屬性。 <xref:System.Windows.FrameworkElement.Tag%2A> 目的為了提供既有的屬性位置，您可以在其中儲存有關任何一些基本的自訂資訊<xref:System.Windows.FrameworkElement>而不需要您子類別化項目。  
  
 因為此屬性會接受物件，您必須使用屬性項目用法才能設定<xref:System.Windows.FrameworkElement.Tag%2A>屬性在 XAML 中具有已知與內建型別轉換子，例如字串的物件以外的任何項目。 這種方式中使用的物件通常不是在標準 WPF 命名空間內，因此可能也需要命名空間對應至外部命名空間才能引進做為 XAML 項目。 如需詳細資訊，請參閱[XAML 命名空間和 WPF XAML 命名空間對應](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)和[XAML 和自訂類別 wpf](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.TagProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Tag" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the target value changes for any property binding on this element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。 這通常表示有問題的繫結是雙向繫結，繫結的相依性屬性 affirms，先前的屬性值無效現在根據任何驗證或快取的屬性或資料來源支援的配置。  
  
 使用事件資料的<xref:System.Windows.FrameworkElement.TargetUpdated>事件，以判定所報告的目標值更新的特定屬性。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a reference to the template parent of this element. This property is not relevant if the element was not created through a template.</summary>
        <value>項目其<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />造成要建立這個項目。 這個值通常是<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 通常是`null`會在您的應用程式標記或程式碼中建立的物件。 這是因為您建立這些物件直接，不會透過範本。 物件或一般名稱參考來查核邏輯樹狀結構根目錄中，從取得的參考，不是來自範本。  
  
 狀況下<xref:System.Windows.FrameworkElement.TemplatedParent%2A>可能`null`包含點擊測試查核視覺化樹狀結構，與特定低階事件輸入的事件處理等作業<xref:System.Windows.Media.VisualTreeHelper>，或使用列舉值，這可能會傳回來源的項目從範本。 另一種情況是如果您特別呼叫<xref:System.Windows.FrameworkTemplate.FindName%2A>針對現有<xref:System.Windows.FrameworkTemplate>和會使用傳回的物件。  
  
 範本是範本的內容會一次建立的實際共用的物件。 因此，如果您取得的項目，以來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。 若要連接至邏輯樹狀結構頁面的這類的範本參考，您應該取得<xref:System.Windows.FrameworkElement.TemplatedParent%2A>值，並繼續瀏覽所需的項目樹狀結構。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>工具提示物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性的值屬於型別<xref:System.Windows.Controls.ToolTip>，該值就會用於工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值為任何其他型別，則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。 如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>。 服務類別會提供可用來進一步自訂的附加的屬性<xref:System.Windows.Controls.ToolTip>。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 會變成顯示的文字字串<xref:System.Windows.FrameworkElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 提供物件項目表單，應該做的內容中的某些物件<xref:System.Windows.FrameworkElement>。 通常這會是<xref:System.Windows.FrameworkElement>或其他項目所建立的配置複合<xref:System.Windows.FrameworkElement.ToolTip%2A>，最後會包含與撰寫的文字內容。 在這種用法，<xref:System.Windows.Controls.ToolTip>元素建立隱含從已剖析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>屬性。  
  
 <`ToolTip` .../>  
 請參閱 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.Controls.ToolTip>中程式碼，然後設定<xref:System.Windows.FrameworkElement.ToolTip%2A>屬性<xref:System.Windows.Controls.Primitives.StatusBar>控制項。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs just before any tooltip on the element is closed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 標示<xref:System.Windows.FrameworkElement.ToolTipClosing>為已處理的事件並不會取消關閉工具提示。 工具提示顯示之後，關閉工具提示會進行只回應使用者互動與 UI。  
  
 此事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用來自服務未公開新增/移除服務層級事件的事件方法的實作。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when any tooltip on the element is opened.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止出現在 UI 中，您的處理常式的工具提示<xref:System.Windows.FrameworkElement.ToolTipOpening>可以標示<xref:System.Windows.Controls.ToolTipEventArgs>處理的事件資料。 否則，顯示工具提示，使用值<xref:System.Windows.FrameworkElement.ToolTip%2A>做為工具提示內容的屬性。 另一個可能的狀況是您可以撰寫會重設的值的處理常式<xref:System.Windows.FrameworkElement.ToolTip%2A>針對項目，事件來源，才會顯示工具提示的屬性。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> 系統不會引發如果的值<xref:System.Windows.FrameworkElement.ToolTip%2A>是`null`或其他未設定。 不刻意設定<xref:System.Windows.FrameworkElement.ToolTip%2A>至`null`tooltip 為開啟，或開啟; 這並不會影響關閉工具提示中，且會改為建立在 UI 中讓人困擾的視覺成品時。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用來自服務未公開新增/移除服務層級事件的事件方法的實作。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.ToolTip" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of triggers established directly on this element, or in child elements.</summary>
        <value>強類型的集合<see cref="T:System.Windows.Trigger" />物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個屬性只能在設定[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]集合語法所示，透過或存取的集合物件和使用的各種方法，例如 Add。 用來存取集合物件本身屬性是唯讀，集合本身為讀寫。 屬性只存在於根項目。嘗試尋找它，或將它設定其他位置，將會導致擲回例外狀況。  
  
 這個屬性不會啟用檢查存在於這個項目上的使用中的樣式部分的觸發程序。 它只會報告常值加入至集合，在標記或程式碼中的觸發程序的集合。 項目通常不會有此類項目根據預設 (透過範本執行個體)。它目前更常見是來自改為建立在樣式中的複合控制項的觸發程序。  
  
 方面的行為 (與嘗試建立的效果是來自哪一個項目宣告<xref:System.Windows.FrameworkElement.Triggers%2A>集合)，觸發條件和觸發程序的效果可能是因為在這個項目，或可能是因為在其子項目邏輯樹狀結構中。 請注意，如果您使用存留期事件，例如<xref:System.Windows.FrameworkElement.Loaded>若要取得此集合，子元素的觸發程序會尚未完全載入，而會小於在執行階段會真正的集合。  
  
 請注意，項目上建立觸發程序的集合只支援<xref:System.Windows.EventTrigger>，不屬性觸發程序 (<xref:System.Windows.Trigger>)。 如果您需要屬性觸發程序，必須將這些樣式或範本中，並再指派該樣式或範本的項目可以是直接透過<xref:System.Windows.FrameworkElement.Style%2A>屬性，或間接透過隱含樣式參考。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreTriggers*  
 一或多個定義<xref:System.Windows.EventTrigger>項目。 每個這類觸發程序必須包含有效的分鏡腳本動作和參考。 請注意，這個集合只能建立在頁面的根項目上。 如需詳細資訊，請參閱[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">The key identifier of the resource to be found.</param>
        <summary>Searches for a resource with the specified key, and returns that resource if found.</summary>
        <returns>The found resource, or <see langword="null" /> if no resource with the provided <paramref name="key" /> is found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果呼叫的項目上找不到資源，處理邏輯樹狀結構向上搜尋父資源樹狀結構，在樹狀結構的方式相同搜尋的若資源已由索引鍵要求在執行階段。 方法會傳回`null`該金鑰的任何資源存不在於任何位置中資源樹狀目錄中，每個樹狀結構時的現有的條件時，才可<xref:System.Windows.FrameworkElement.TryFindResource%2A>呼叫。  
  
 通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A>方法具有類似的行為不同之處在於它擲回例外狀況，如果不傳回提供的索引鍵的任何資源。  
  
   
  
## Examples  
 下列範例會實作為按鈕處理常式，其中按鈕被按下設定它的背景資源定義的筆刷來取得藉由呼叫<xref:System.Windows.FrameworkElement.TryFindResource%2A>本身。 這會瀏覽項目樹狀結構，並找到資源 (資源本身中定義[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]而且不會顯示)。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the element is removed from within an element tree of loaded elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為： 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同時會引發由於使用者啟動系統的佈景主題變更的控制項上。 佈景主題變更會導致控制項樣板和自主視覺化樹狀結構，因此使得卸載再重新載入整個控制項的失效。 因此<xref:System.Windows.FrameworkElement.Unloaded>無法假設只會發生在巡覽離開該頁面。  
  
 請注意，<xref:System.Windows.FrameworkElement.Unloaded>應用程式會開始關閉之後，不會引發事件。 所定義的條件時，就會發生應用程式關閉<xref:System.Windows.Application.ShutdownMode%2A>屬性，就會發生。 如果您將清除程式碼中的處理常式<xref:System.Windows.FrameworkElement.Unloaded>事件，例如，用於<xref:System.Windows.Window>或<xref:System.Windows.Controls.UserControl>，它可能不會呼叫如預期般。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.FrameworkElement.Unloaded" /> routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Name of the name-object pair to remove from the current scope.</param>
        <summary>Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您只需要取消註冊名稱如果您想要重新註冊該相同名稱的另一個項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reapplies the default style to the current <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether layout rounding should be applied to this element's size and position during layout.</summary>
        <value>
          <see langword="true" /> 如果套用配置進位;否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>屬性的項目是`true`，期間所計算的所有非整數像素值<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>傳遞會捨入到整個像素值。  
  
 子項目會繼承這個屬性。  
  
> [!NOTE]
>  您應該設定<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>至`true`根元素。 版面配置系統會將子座標加入至父代的座標。因此，如果父座標不像素界限上，子座標也不像素界限上。 如果<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>不可設定的根目錄、 設定<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>上的子系，以取得您想要的效果。  
  
 繪製像素界限的物件排除半透明效果的邊緣時，所產生的消除鋸齒邊緣落在裝置像素。 下圖顯示落在裝置像素的單一像素寬度列的輸出。 左邊的行號不會使用配置進位，且已消除鋸齒。 在右邊的列會使用配置進位。  
  
 ![反&#45;鋸齒線條與單一像素線條比較。](~/add/media/pixelsnaplinecompare.PNG "消除鋸齒線條與單一像素線條比較。")  
  
 當您使用配置進位，<xref:System.Windows.GridUnitType.Star>調整大小、 版面配置系統會建立小型的變化中的資料行或資料列的度量，以避免呈現子像素。 例如，如果方格具有 3 個資料行大小的 100 總寬度<xref:System.Windows.GridUnitType.Star>，而不是建立三個資料行 33.3 等寬，版面配置系統會建立 2 個資料行具有 33 和其中的寬度為 34 的寬度。  
  
> [!NOTE]
>  .NET 4.6 中已變更版面配置進位，以減少含邊界之控制項中的裁剪功能的執行個體。 根據預設，如果您的目標 Framework 是.NET Framework 4.6 或更高版本，會啟用這項功能。 以舊版 framework 為目標的應用程式可以選擇加入新行為加入 app.config 檔案中的下列設定：`<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>`設定才會生效，.NET Framework 4.6 上執行應用程式時。  
  
   
  
## Examples  
 下列範例示範效果，<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>屬性有單一像素寬度的一行。 左邊的行號不會使用配置進位，並在右邊的列會使用配置進位。 如果緩時變調整視窗，您可以在該版面配置進位會時看到的差異。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the vertical alignment characteristics applied to this element when it is composed within a parent element such as a panel or items control.</summary>
        <value>垂直對齊設定。 預設值為 <see cref="F:System.Windows.VerticalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.Width%2A>屬性已明確設定項目上，這些度量需要配置優先者列] 和 [取消設定此屬性的規則的效果<xref:System.Windows.VerticalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]實際上會相依性屬性的屬性存取子。 這個特定的相依性屬性相當常有衍生的項目類別，特別是控制項中以不同方式設定其明顯"default"值。 這通常發生在兩種方式之一： 重新登錄相依性屬性的特定衍生類別中，但具有不同的中繼資料來設定其預設值;或以不同的方式設定該相依性屬性的值為預設樣式套用。 例如，明顯 「 預設 」 的<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>如<xref:System.Windows.Controls.ComboBoxItem>控制項將會是<xref:System.Windows.VerticalAlignment.Center>，即使<xref:System.Windows.Controls.ComboBoxItem>繼承<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>直接從<xref:System.Windows.FrameworkElement>。 這是因為該值重設的預設樣式中<xref:System.Windows.Controls.ComboBoxItem>，樣式的控制項範本內。  
  
 <xref:System.Windows.Controls.Canvas> 不會使用<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>撰寫版面配置，因為時<xref:System.Windows.Controls.Canvas>根據絕對位置。  
  
 當繼承<xref:System.Windows.Controls.ComboBoxItem>或任何衍生類別，<xref:System.Windows.Controls.ComboBoxItem>會重新定義預設值，這個屬性是<xref:System.Windows.VerticalAlignment.Center>。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of visual child elements within this element.</summary>
        <value>這個項目的視覺化子項目數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>實作<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>一律會傳回零個或一個。 維護可能會超過一個視覺化子集合的類別必須覆寫這個屬性與<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 這個屬性通常用來決定用於實作的版面配置覆寫目前的子集合的上限 (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>， <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>)。  
  
   
  
## Examples  
 下列範例示範如何自訂裝飾項會使用所宣告的值<xref:System.Windows.Media.VisualCollection>它會維護其多個 visual 的子系，並報告這些值的覆寫透過<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您的類別支援多個視覺子項子項目集合中，覆寫這個屬性，該集合中傳回的項目計數。即使集合物件本身傳回的資料計數，您必須這麼做。在 WPF 架構層級元素的配置邏輯會假設所有項目會傳回有效的計數，透過其<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />屬性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the width of the element.</summary>
        <value>項目的寬度，請在 [！INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 預設值是 <see cref="F:System.Double.NaN" />。 這個值必須等於或大於 0.0。 如需上限資訊，請參閱＜備註＞。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。  其他兩個是<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果這些值之間沒有衝突，這是第一次應用程式的實際寬度判斷順序<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後如果每個範圍中，在<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 這個屬性傳回的值一律為任何已設定為它的值相同。 相較之下，值<xref:System.Windows.FrameworkElement.ActualWidth%2A>而有所不同。 版面配置可能會拒絕某些原因建議的大小。 此外，版面配置系統本身以非同步方式運作的相對屬性的系統集<xref:System.Windows.FrameworkElement.Width%2A>並不一定有處理該特定尚未調整大小屬性變更。  
  
 此外，可接受<xref:System.Double>值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 這是您指定自動調整大小行為的方式。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您設定值的字串 「 自動 」 （不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填入可用的寬度。 不過請注意，特定控制項通常會提供將會停用自動調整大小行為，除非它是特別重新啟用其預設樣式中的預設值。  
  
 驗證檢查，除了沒有繫結的不具決定性上限數值<xref:System.Windows.FrameworkElement.Width%2A>的版面配置系統會強制執行 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=nameWithType>但小於<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿設定<xref:System.Windows.FrameworkElement.Width%2A>大幅超過大小上限的任何可能的視覺顯示，或者您可能會超過此不具決定性的上限值。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字串表示法<xref:System.Double>等於或大於 0.0 的值。 如需上限資訊，請參閱＜備註＞。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。  
  
 *qualifiedDouble*  
 A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 為英吋。1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點。1pt==(96/72) 像素  
  
 `Auto`  
 啟用自動調整大小行為。 請參閱＜備註＞。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.FrameworkElement.Width" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>