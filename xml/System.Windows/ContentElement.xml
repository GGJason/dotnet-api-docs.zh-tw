<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f414ea08984adb4625dff8e31e567084a0cfa2a2" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65009167" /></Metadata><TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="c631d-101">提供內容項目的 WPF 核心層級基底類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-101">Provides a WPF core-level base class for content elements.</span></span> <span data-ttu-id="c631d-102">內容項目是專為流程樣式表示所設計，其使用直覺式標記導向配置模型以及刻意保持簡單的物件模型。</span><span class="sxs-lookup"><span data-stu-id="c631d-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-103"><xref:System.Windows.ContentElement> 會定義下列的一般內容特性：</span><span class="sxs-lookup"><span data-stu-id="c631d-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="c631d-104">輸入：所有<xref:System.Windows.ContentElement>鍵盤、 滑鼠、 拖放作業、 手寫筆控制項和加速器的基本輸入擷取衍生的類別提供支援。</span><span class="sxs-lookup"><span data-stu-id="c631d-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="c631d-105">焦點：所有<xref:System.Windows.ContentElement>衍生的類別都是可能可設定焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="c631d-106">(不過，預設可焦點化狀態<xref:System.Windows.ContentElement>基底類別是`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="c631d-107">如需有關如何製作<xref:System.Windows.ContentElement>可設定焦點，請參閱<xref:System.Windows.ContentElement.Focusable%2A>。)此外，這個類別包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]可用來周遊焦點相關的項目範圍。</span><span class="sxs-lookup"><span data-stu-id="c631d-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="c631d-108">事件：<xref:System.Windows.ContentElement>包括相關事件與相關的輸入和焦點; 它也包含狀態變更事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="c631d-109">在許多情況下，<xref:System.Windows.ContentElement>事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="c631d-110">在某些情況下，路由的事件都有通道和事件反昇路由傳送策略，以在偵測到相同的狀態或條件的不同事件引發。</span><span class="sxs-lookup"><span data-stu-id="c631d-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="c631d-111">此外，<xref:System.Windows.ContentElement>定義[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，可以引發路由事件與路由，可以新增或移除事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="c631d-112"><xref:System.Windows.ContentElement> 共用許多常見[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]與<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="c631d-113">這些常見[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]並非來自共用的類別繼承。</span><span class="sxs-lookup"><span data-stu-id="c631d-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="c631d-114">但它們共用通用的命名、 類似的行為和類似內部實作[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]在每個類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="c631d-115">相似度是的因為<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>雖然彼此有其標記的物件模型行為的不同目的，是每個類別的基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="c631d-116">特別的是，<xref:System.Windows.UIElement>的子系<xref:System.Windows.Media.Visual>，以提供較低層級圖形對轉譯<xref:System.Windows.ContentElement>矩形的區域內撰寫的視窗中，而<xref:System.Windows.ContentElement>會延遲轉譯讓概念的詳細通用的文件的情況下，例如流向和換行，更輕鬆地支援。</span><span class="sxs-lookup"><span data-stu-id="c631d-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="c631d-117">這兩個相關類別也會實作通用的介面<xref:System.Windows.IInputElement>和<xref:System.Windows.Media.Animation.IAnimatable>。</span><span class="sxs-lookup"><span data-stu-id="c631d-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  

 ## <a name="notes-to-inheritors"></a><span data-ttu-id="c631d-118">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="c631d-118">Notes to inheritors</span></span>

 <span data-ttu-id="c631d-119"><xref:System.Windows.ContentElement>類別並未尚未定義流程樣式表示完整的內容項目中的所有層面。</span><span class="sxs-lookup"><span data-stu-id="c631d-119">The <xref:System.Windows.ContentElement> class does not yet define all aspects of a complete content element for flow-style presentation.</span></span> <span data-ttu-id="c631d-120"><xref:System.Windows.FrameworkContentElement> 立即衍生類別<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-120"><xref:System.Windows.FrameworkContentElement> is an immediately derived class of <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c631d-121"><xref:System.Windows.FrameworkContentElement> 包含一組更完整的支援轉譯的其他成員<xref:System.Windows.FrameworkContentElement>內容裝載和使用 WPF 架構層級配置系統內。</span><span class="sxs-lookup"><span data-stu-id="c631d-121"><xref:System.Windows.FrameworkContentElement> includes a more complete set of additional members that support rendering a <xref:System.Windows.FrameworkContentElement> within a content host and using the WPF framework-level layout system.</span></span>

 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-122">初始化 <see cref="T:System.Windows.ContentElement" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-122">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c631d-123">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="c631d-123">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="c631d-124">要處理的路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-124">An identifier for the routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="c631d-125">處理常式實作的參考。</span><span class="sxs-lookup"><span data-stu-id="c631d-125">A reference to the handler implementation.</span></span></param>
        <summary><span data-ttu-id="c631d-126">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="c631d-126">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-127">您可以新增相同的處理常式，相同事件多次，而不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-127">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="c631d-128">不過，處理常式實際叫用的多次時處理事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-128">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="c631d-129">因此，請考慮如何這種行為可能會有副作用，都應該在自己的處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-129">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="c631d-130">您通常使用這個方法來提供的 「 新增 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。</span><span class="sxs-lookup"><span data-stu-id="c631d-130">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="c631d-131">要處理之路由事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-131">An identifier for the.routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="c631d-132">處理常式實作的參考。</span><span class="sxs-lookup"><span data-stu-id="c631d-132">A reference to the handler implementation.</span></span></param>
        <param name="handledEventsToo"><span data-ttu-id="c631d-133"><see langword="true" /> 表示註冊處理常式，以便即使路由事件在其事件資料中標記為已處理，仍會叫用該處理常式。<see langword="false" /> 表示以預設條件註冊處理常式，也就是如果路由事件已經標記為已處理，則不會叫用該處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-133"><see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span></span>  
  
<span data-ttu-id="c631d-134">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-134">The default is <see langword="false" />.</span></span>  
  
<span data-ttu-id="c631d-135">請勿定期要求重新處理路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-135">Do not routinely ask to rehandle a routed event.</span></span></param>
        <summary><span data-ttu-id="c631d-136">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="c631d-136">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span> <span data-ttu-id="c631d-137">將 <paramref name="handledEventsToo" /> 指定為 <see langword="true" />，為已標示為由事件路由上另一個項目處理的事件叫用提供的處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-137">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-138">實用的方式處理低階的輸入的事件是一個複雜的工作。</span><span class="sxs-lookup"><span data-stu-id="c631d-138">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="c631d-139">許多控制項實作的行為，其中特定事件標示為已處理，並已由另一個更具直覺性的事件所取代。</span><span class="sxs-lookup"><span data-stu-id="c631d-139">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="c631d-140">一般而言，控制項只會將平台的輸入的事件，為已處理，如果沒有這項操作的一些設計意圖。</span><span class="sxs-lookup"><span data-stu-id="c631d-140">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="c631d-141">在某些情況下，這些設計目的不可能您的輸入事件的特定處理的要求。</span><span class="sxs-lookup"><span data-stu-id="c631d-141">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="c631d-142">針對這些案例是該註冊處理常式`handledEventsToo`做為`true`適合。</span><span class="sxs-lookup"><span data-stu-id="c631d-142">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="c631d-143">但您不應該這麼定期。</span><span class="sxs-lookup"><span data-stu-id="c631d-143">But you should not do this routinely.</span></span> <span data-ttu-id="c631d-144">叫用處理常式以回應所有的事件，即使處理將會使您自己的應用程式事件處理邏輯更為複雜。</span><span class="sxs-lookup"><span data-stu-id="c631d-144">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="c631d-145">如果處理常式邏輯則相當大，可能會看到效能降低。</span><span class="sxs-lookup"><span data-stu-id="c631d-145">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="c631d-146">您應該保留使用附加的情況下，您已經發現特定控制項所處理的事件，您仍然想要處理的應用程式邏輯在開發程序已經處理的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-146">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="c631d-147">為避免處理行為的某些事件控制項組合的類別的另一個方法是使用該事件預覽替代方案。</span><span class="sxs-lookup"><span data-stu-id="c631d-147">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="c631d-148">例如，如果<xref:System.Windows.ContentElement.MouseLeftButtonDown>標示為已處理的類別處理，您可以加入處理常式<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>改為。</span><span class="sxs-lookup"><span data-stu-id="c631d-148">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="c631d-149">您可以新增相同的處理常式，相同事件多次，而不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-149">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="c631d-150">不過，處理常式實際叫用的多次時處理事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-150">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="c631d-151">因此，請考慮如何這種行為可能會有副作用，都應該在自己的處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-151">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="c631d-152">您通常使用這個方法來提供的 「 新增 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。</span><span class="sxs-lookup"><span data-stu-id="c631d-152">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c631d-153">下列範例會實作上叫用處理常式<xref:System.Windows.FrameworkElement.Initialized>將定義的處理常式附加至其中一個頁面上的具名元素在頁面上的事件`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-153">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="c631d-154">這個處理常式會叫用，即使路由中的另一個項目會標示為已處理到達路由中的處理項目之前共用的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-154">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route"><span data-ttu-id="c631d-155">處理常式新增至事件路由。</span><span class="sxs-lookup"><span data-stu-id="c631d-155">The event route that handlers are added to.</span></span></param>
        <param name="e"><span data-ttu-id="c631d-156">用來新增處理常式的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-156">The event data that is used to add the handlers.</span></span> <span data-ttu-id="c631d-157">這個方法會使用<see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />建立處理常式的引數的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-157">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span></span></param>
        <summary><span data-ttu-id="c631d-158">加入至指定的處理常式<see cref="T:System.Windows.EventRoute" />目前<see cref="T:System.Windows.ContentElement" />事件處理常式集合。</span><span class="sxs-lookup"><span data-stu-id="c631d-158">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-159">這個方法用於內容主機項目 (不論是否在實作<xref:System.Windows.IContentHost>) 以將內容裝載子元素的處理常式新增至主機<xref:System.Windows.EventRoute>。</span><span class="sxs-lookup"><span data-stu-id="c631d-159">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-160">取得或設定值，這個值表示這個項目是否可以作為拖放作業的目標。</span><span class="sxs-lookup"><span data-stu-id="c631d-160">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span></span></summary>
        <value><span data-ttu-id="c631d-161">如果這個項目可以作為拖放作業的目標，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-161"><see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-162">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-162">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-163">拖放作業不會預設啟用，且必須藉由設定刻意啟用<xref:System.Windows.ContentElement.AllowDrop%2A>至`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-163">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="c631d-164">超過此基本的設定，拖放行為完全是特定的實作並不由定義<xref:System.Windows.ContentElement>或任何其他基底元素類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-164">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="c631d-165">某些控制項，例如<xref:System.Windows.Controls.RichTextBox>，沒有預設行為，但不是<xref:System.Windows.ContentElement>衍生的類別有這類行為。</span><span class="sxs-lookup"><span data-stu-id="c631d-165">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="c631d-166">如需有關功能的詳細資訊，請參閱[拖放概觀](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-166">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="c631d-167"><xref:System.Windows.FrameworkContentElement> 覆寫這個實作中的相依性屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-167"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="c631d-168">具體而言，<xref:System.Windows.FrameworkContentElement>指定這個屬性可讓屬性值繼承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`中繼資料中)。</span><span class="sxs-lookup"><span data-stu-id="c631d-168">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="c631d-169">在此內容中的屬性值繼承表示，如果有任何其他值的子項目<xref:System.Windows.ContentElement.AllowDrop%2A>指派透過本機值或最接近的父項目的值，與指派 （同樣地，無論是在樣式中，依預設此值的樣式值或本機值），則會從該父項目值屬性系統指派的所有未指派的子元素。</span><span class="sxs-lookup"><span data-stu-id="c631d-169">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="c631d-170">這表示您可以指定是否要允許卸除作業的根項目，並再傳播至所有值<xref:System.Windows.FrameworkContentElement>沒有特別將其指派值的子項目`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-170">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-171">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-171">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-172">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-172">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="c631d-173">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-173">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-174">None</span><span class="sxs-lookup"><span data-stu-id="c631d-174">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c631d-175">下列範例會設定<xref:System.Windows.ContentElement.AllowDrop%2A>在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c631d-175">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-176">識別 <see cref="P:System.Windows.ContentElement.AllowDrop" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-176">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c631d-177">將動畫套用至這個項目上所指定的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-177">Applies an animation to a specified dependency property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="c631d-178">要繪製的屬性之識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-178">The identifier for the property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="c631d-179">控制並宣告動畫的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="c631d-179">The animation clock that controls and declares the animation.</span></span></param>
        <summary><span data-ttu-id="c631d-180">將動畫套用至這個項目上所指定的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-180">Applies an animation to a specified dependency property on this element.</span></span> <span data-ttu-id="c631d-181">任何現有動畫都會停止並取代為新的動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-181">Any existing animations are stopped and replaced with the new animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-182">若要移除屬性的動畫，請指定 做為該屬性的識別項`dp`並指定`clock`做為`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-182">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="c631d-183">這會移除動畫，動畫的屬性設定為其基底值。</span><span class="sxs-lookup"><span data-stu-id="c631d-183">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="c631d-184">不過，並不會停止原先相關聯的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="c631d-184">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="c631d-185">指派給該時鐘的任何其他動畫都會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="c631d-185">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="c631d-186">要製作動畫的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-186">The property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="c631d-187">控制並宣告動畫的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="c631d-187">The animation clock that controls and declares the animation.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="c631d-188">列舉值。</span><span class="sxs-lookup"><span data-stu-id="c631d-188">A value of the enumeration.</span></span> <span data-ttu-id="c631d-189">預設值是 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，將停止任何現有的動畫，並以新的動畫取代。</span><span class="sxs-lookup"><span data-stu-id="c631d-189">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span></span></param>
        <summary><span data-ttu-id="c631d-190">將動畫套用至這個項目上所指定的相依性屬性，且可以指定此屬性已經有執行中的動畫時會發生哪種情況。</span><span class="sxs-lookup"><span data-stu-id="c631d-190">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-191">若要移除屬性的動畫，請指定 做為該屬性的識別項`dp`並指定`clock`做為`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-191">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="c631d-192">這會移除動畫，動畫的屬性設定為其基底值。</span><span class="sxs-lookup"><span data-stu-id="c631d-192">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="c631d-193">不過，並不會停止原先相關聯的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="c631d-193">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="c631d-194">指派給該時鐘的任何其他動畫都會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="c631d-194">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-195">取得值，指出是否至少一個觸控擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-195">Gets a value that indicates whether at least one touch is captured to this element.</span></span></summary>
        <value><span data-ttu-id="c631d-196"><see langword="true" /> 如果至少一個觸控，擷取至這個項目;否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-196"><see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-197">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-197">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-198">取得值，指出是否至少一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-198">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="c631d-199"><see langword="true" /> 如果至少一個觸控，擷取至這個項目或其視覺化樹狀結構中; 在任何子項目否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-199"><see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-200">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-200">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-201">取得值，指出是否至少一個觸控已按下此項目上方。</span><span class="sxs-lookup"><span data-stu-id="c631d-201">Gets a value that indicates whether at least one touch is pressed over this element.</span></span></summary>
        <value><span data-ttu-id="c631d-202"><see langword="true" /> 如果至少一個觸控在這個項目; 按下否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-202"><see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-203">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-203">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-204">取得值，指出是否至少一個觸控已按下此項目或其視覺化樹狀結構中的任何子項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-204">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="c631d-205"><see langword="true" /> 如果至少一個觸控在這個項目或其視覺化樹狀結構中; 在任何子項目按下否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-205"><see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-206">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-206">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c631d-207">這個項目上，會啟動指定的動畫屬性的動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-207">Starts an animation for a specified animated property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="c631d-208">要繪製之屬性，指定為相依性屬性識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-208">The property to animate, which is specified as a dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="c631d-209">若要啟動動畫的時刻表。</span><span class="sxs-lookup"><span data-stu-id="c631d-209">The timeline of the animation to start.</span></span></param>
        <summary><span data-ttu-id="c631d-210">這個項目上，會啟動指定的動畫屬性的動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-210">Starts an animation for a specified animated property on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-211">當您檢查是否建立屬性的動畫時，請注意，動畫會開始被視為轉譯之外的非動畫的起始點的第一個框架時以動畫顯示。</span><span class="sxs-lookup"><span data-stu-id="c631d-211">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="c631d-212">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>for`animation`是`null`，然後會移除任何目前動畫，並保留屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="c631d-212">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="c631d-213">如果整個`animation`值是`null`、 從屬性中移除所有動畫和屬性值還原為其基底值。</span><span class="sxs-lookup"><span data-stu-id="c631d-213">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="c631d-214">不過，原先相關聯的動畫時間軸不會停止。</span><span class="sxs-lookup"><span data-stu-id="c631d-214">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="c631d-215">指派給該時間軸中的任何其他動畫都會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="c631d-215">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="c631d-216">要繪製之屬性，指定為相依性屬性識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-216">The property to animate, which is specified as the dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="c631d-217">要套用動畫的時刻表。</span><span class="sxs-lookup"><span data-stu-id="c631d-217">The timeline of the animation to be applied.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="c631d-218">指定新動畫如何與已經影響屬性值的任何目前 （執行中） 動畫互動的列舉值。</span><span class="sxs-lookup"><span data-stu-id="c631d-218">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span></span></param>
        <summary><span data-ttu-id="c631d-219">如果屬性已經有執行中的動畫，會發生特定的動畫，針對指定的動畫屬性，這個項目，且可選擇指定項目上的啟動。</span><span class="sxs-lookup"><span data-stu-id="c631d-219">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-220">當您檢查是否建立屬性的動畫時，請注意，動畫會開始被視為轉譯之外的非動畫的起始點的第一個框架時以動畫顯示。</span><span class="sxs-lookup"><span data-stu-id="c631d-220">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="c631d-221">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>for`animation`是`null`，然後會移除任何目前動畫，並保留屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="c631d-221">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="c631d-222">如果整個`animation`值是`null`、 從屬性中移除所有動畫和屬性值還原為其基底值。</span><span class="sxs-lookup"><span data-stu-id="c631d-222">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="c631d-223">不過，原先相關聯的動畫時間軸不會停止。</span><span class="sxs-lookup"><span data-stu-id="c631d-223">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="c631d-224">指派給該時間軸中的任何其他動畫都會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="c631d-224">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-225">嘗試強制將滑鼠的捕捉給這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-225">Attempts to force capture of the mouse to this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-226"><see langword="true" /> 如果成功捕捉滑鼠;，否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-226"><see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-227">若要擷取項目必須先啟用。</span><span class="sxs-lookup"><span data-stu-id="c631d-227">To be captured, an element must be enabled.</span></span> <span data-ttu-id="c631d-228">檢查是否<xref:System.Windows.ContentElement.IsEnabled%2A>已`true`之前先呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-228">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="c631d-229">如果呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>會傳回`true`，然後<xref:System.Windows.ContentElement.IsMouseCaptured%2A>也是`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="c631d-230">如果呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>傳回`true`，則<xref:System.Windows.ContentElement.GotMouseCapture>並<xref:System.Windows.ContentElement.IsMouseCapturedChanged>引發事件，與<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>事件中的項目報告資料其中<xref:System.Windows.ContentElement.CaptureMouse%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-230">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="c631d-231">如果您強制擷取時，您可能會干擾現有的擷取-特別是使用與拖曳和置放滑鼠的擷取。</span><span class="sxs-lookup"><span data-stu-id="c631d-231">If you force capture, you might interfere with existing captures - especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="c631d-232">若要清除滑鼠捕捉，從所有的項目，請呼叫<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>具有`element`提供的參數`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-232">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c631d-233">下列範例會捕捉到滑鼠，或釋放擷取，根據是否已捕捉滑鼠的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-233">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="c631d-234">請注意此範例會將潛在擷取目標項目<xref:System.Windows.IInputElement>介面，並因此一開始呼叫<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-234">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c631d-235">轉換成<xref:System.Windows.IInputElement>是一種技術，如果您不確定您要擷取的項目滑鼠是否會很有用<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-235">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c631d-236">介面型別轉換和介面方法呼叫然後呼叫適當的型別特有 CaptureMouse 實作在內部而不需要轉型為試用版<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-236">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c631d-237">針對其他成員可以使用這個相同的轉換方法，<xref:System.Windows.IInputElement>定義，例如許多輸入相關的事件和其他輸入相關的方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-237">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-238">嘗試強制手寫筆的捕捉給這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-238">Attempts to force capture of the stylus to this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-239"><see langword="true" /> 如果成功捕捉手寫筆;，否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-239"><see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-240">一律根據基礎的預設手寫筆裝置的預設實作會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-240">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="c631d-241">不過，如果您要擴充提供輸入系統的裝置實作的輸入的裝置，就可以建立一個系統可能會傳回不同結果的替代的手寫筆裝置實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-241">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="c631d-242">元素擷取手寫筆，當它收到手寫筆輸入，即使手寫筆位於其範圍外也一樣。</span><span class="sxs-lookup"><span data-stu-id="c631d-242">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="c631d-243">要捕捉手寫筆通常只會在拖放作業期間。</span><span class="sxs-lookup"><span data-stu-id="c631d-243">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c631d-244">呼叫這個方法會呼叫基礎靜態<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-244">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="c631d-245">實際擷取行為被藉由使用中的手寫筆裝置實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-245">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="c631d-246">若要擷取項目必須先啟用。</span><span class="sxs-lookup"><span data-stu-id="c631d-246">To be captured, an element must be enabled.</span></span> <span data-ttu-id="c631d-247">檢查是否<xref:System.Windows.ContentElement.IsEnabled%2A>已`true`傳回才能呼叫<xref:System.Windows.ContentElement.CaptureStylus%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-247">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="c631d-248">如果呼叫<xref:System.Windows.ContentElement.CaptureStylus%2A>會傳回`true`，<xref:System.Windows.ContentElement.IsStylusCaptured%2A>也是`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-248">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="c631d-249">要擷取的裝置。</span><span class="sxs-lookup"><span data-stu-id="c631d-249">The device to capture.</span></span></param>
        <summary><span data-ttu-id="c631d-250">嘗試強制將觸控擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-250">Attempts to force capture of a touch to this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-251"><see langword="true" /> 如果指定的觸控擷取至這個項目;，否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-251"><see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-252"><xref:System.Windows.ContentElement.CaptureTouch%2A> 會傳回`false`如果<xref:System.Windows.Input.TouchDevice>目前擷取至另一個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-252"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="c631d-253">如果<xref:System.Windows.ContentElement.CaptureTouch%2A>會傳回`true`，然後在<xref:System.Windows.ContentElement.GotTouchCapture>就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-253">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="c631d-254">若要釋放的單一觸控從這個項目擷取，請使用<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>方法並指定要釋放的觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="c631d-254">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="c631d-255">若要釋放所有修飾，從這個項目，請使用<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-255">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c631d-256"><paramref name="touchDevice" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-256"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-257">取得集合<see cref="T:System.Windows.Input.CommandBinding" />與這個項目相關聯的物件。</span><span class="sxs-lookup"><span data-stu-id="c631d-257">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="c631d-258">所有集合<see cref="T:System.Windows.Input.CommandBinding" />物件。</span><span class="sxs-lookup"><span data-stu-id="c631d-258">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-259">A<xref:System.Windows.Input.CommandBinding>啟用這個項目的特定命令的命令處理，並宣告命令、 其事件，以及由這個項目附加的處理常式之間的連結。</span><span class="sxs-lookup"><span data-stu-id="c631d-259">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="c631d-260">典型的另一種方式填入<xref:System.Windows.ContentElement.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以程式設計的方式。</span><span class="sxs-lookup"><span data-stu-id="c631d-260">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="c631d-261">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="c631d-261">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="c631d-262">XAML 值</span><span class="sxs-lookup"><span data-stu-id="c631d-262">XAML Values</span></span>  
 <span data-ttu-id="c631d-263">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="c631d-263">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="c631d-264">一或多個<xref:System.Windows.Input.CommandBinding>項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-264">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="c631d-265">每一種應有<xref:System.Windows.Input.CommandBinding.Command%2A>屬性設為已知的命令，並針對設定屬性<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-265">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="c631d-266">如需詳細資訊，請參閱<xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="c631d-266">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-267">輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-267">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-268">此事件建立的別名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-268">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-269">附加至事件處理常式<xref:System.Windows.ContentElement.DragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-269">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-270">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-270">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-271">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-271">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="c631d-272">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-272">Routing strategy</span></span>|<span data-ttu-id="c631d-273">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-273">Bubbling</span></span>|  
|<span data-ttu-id="c631d-274">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-274">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-275">對應的通道事件是<xref:System.Windows.ContentElement.PreviewDragEnter>。</span><span class="sxs-lookup"><span data-stu-id="c631d-275">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="c631d-276">覆寫<xref:System.Windows.ContentElement.OnDragEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-276">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-277">識別 <see cref="E:System.Windows.ContentElement.DragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-277">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-278">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-278">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-279">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-279">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-280">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-280">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-281">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-281">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-282">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-282">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-283">輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-283">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-284">本項目中建立的別名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-284">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-285">附加至事件處理常式<xref:System.Windows.ContentElement.DragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-285">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-286">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-286">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-287">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-287">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="c631d-288">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-288">Routing strategy</span></span>|<span data-ttu-id="c631d-289">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-289">Bubbling</span></span>|  
|<span data-ttu-id="c631d-290">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-290">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-291">對應的通道事件是<xref:System.Windows.DragDrop.PreviewDragLeave>。</span><span class="sxs-lookup"><span data-stu-id="c631d-291">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="c631d-292">覆寫<xref:System.Windows.ContentElement.OnDragLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-292">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-293">識別 <see cref="E:System.Windows.ContentElement.DragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-293">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-294">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-294">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-295">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-295">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-296">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-296">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-297">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-297">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-298">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-298">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-299">在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-299">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-300">即使拖曳來源中項目範圍，就會發生此事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-300">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="c631d-301">如果拖曳開始界限之外，然後將移內，也會引發這個事件，以及<xref:System.Windows.ContentElement.DragEnter>和相關預覽事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-301">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="c631d-302">本項目中建立的別名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-302">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-303">附加至事件處理常式<xref:System.Windows.ContentElement.DragOver>事件會附加至基礎<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-303">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-304">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-305">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-305">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="c631d-306">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-306">Routing strategy</span></span>|<span data-ttu-id="c631d-307">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-307">Bubbling</span></span>|  
|<span data-ttu-id="c631d-308">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-308">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-309">對應的通道事件是<xref:System.Windows.DragDrop.PreviewDragOver>。</span><span class="sxs-lookup"><span data-stu-id="c631d-309">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="c631d-310">覆寫<xref:System.Windows.ContentElement.OnDragOver%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-310">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-311">識別 <see cref="E:System.Windows.ContentElement.DragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-311">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-312">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-313">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-314">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-315">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-316">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-317">輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-317">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-318">本項目中建立的別名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-318">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-319">附加至事件處理常式<xref:System.Windows.ContentElement.Drop>事件會附加至基礎<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-319">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-320">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-320">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-321">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-321">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="c631d-322">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-322">Routing strategy</span></span>|<span data-ttu-id="c631d-323">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-323">Bubbling</span></span>|  
|<span data-ttu-id="c631d-324">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-324">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-325">對應的通道事件是<xref:System.Windows.ContentElement.PreviewDrop>。</span><span class="sxs-lookup"><span data-stu-id="c631d-325">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="c631d-326">覆寫<xref:System.Windows.ContentElement.OnDrop%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-326">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-327">識別 <see cref="E:System.Windows.ContentElement.Drop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-327">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-328">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-328">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-329">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-329">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-330">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-330">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-331">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-331">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-332">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-332">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-333">嘗試將焦點設定至這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-333">Attempts to set focus to this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-334"><see langword="true" /> 如果鍵盤焦點，可以設定為這個項目;<see langword="false" />如果這個方法呼叫並未強制焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-334"><see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-335">若要可設定焦點，<xref:System.Windows.ContentElement.Focusable%2A>並<xref:System.Windows.ContentElement.IsEnabled%2A>兩者都必須是`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-335">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="c631d-336">請注意，幾乎所有<xref:System.Windows.ContentElement>衍生的類別不是<xref:System.Windows.ContentElement.Focusable%2A>預設。</span><span class="sxs-lookup"><span data-stu-id="c631d-336">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="c631d-337">即使項目是在特定樹狀結構中的可設定焦點且已啟用，事件處理，（例如針對複合控制項） 可能會回應預覽焦點事件可藉由不允許焦點，因此這個方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-337">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="c631d-338">焦點通常由兩個不同的概念︰ 鍵盤焦點和邏輯焦點，並不一定相同。</span><span class="sxs-lookup"><span data-stu-id="c631d-338">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="c631d-339">這個方法會設定邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-339">This method sets the logical focus.</span></span> <span data-ttu-id="c631d-340">沒有特別; 設定鍵盤焦點的程式設計方法鍵盤焦點取決於使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-340">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="c631d-341">如需詳細資訊，請參閱 <<c0> [ 焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)並[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-341">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="c631d-342">如果呼叫<xref:System.Windows.ContentElement.Focus%2A>會傳回`true`，<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>並<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>還有`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-342">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="c631d-343">如果相關的屬性尚未存在`true`，當您呼叫<xref:System.Windows.ContentElement.Focus%2A>，以下列順序引發一或多個下列事件： <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>， <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> （來源為新的焦點目標）， <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>， <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>，<xref:System.Windows.ContentElement.LostKeyboardFocus>， <xref:System.Windows.ContentElement.GotKeyboardFocus> （來源為新的焦點目標）。</span><span class="sxs-lookup"><span data-stu-id="c631d-343">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c631d-344">下列範例會尋找指定的具名文件中的段落的頁面載入事件處理常式，並將焦點設定至它。</span><span class="sxs-lookup"><span data-stu-id="c631d-344">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="c631d-345">段落不在預設情況下，可設定焦點這個特定的段落有套用樣式 （未顯示），用於樣式<xref:System.Windows.Setter>進行可設定焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-345">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-346">取得或設定元素是否能夠接收焦點的值。</span><span class="sxs-lookup"><span data-stu-id="c631d-346">Gets or sets a value that indicates whether the element can receive focus.</span></span></summary>
        <value><span data-ttu-id="c631d-347">如果這個項目可設定焦點，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-347"><see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span></span> <span data-ttu-id="c631d-348">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-348">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-349">只有具有焦點的項目收到鍵盤輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-349">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="c631d-350">在衍生的類別是可設定焦點，根據預設，特定衍生的類別可能會覆寫這個相依性屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-350">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="c631d-351">當繼承<xref:System.Windows.Documents.Hyperlink>或其衍生的類別，<xref:System.Windows.Documents.Hyperlink>覆寫這個相依性屬性的中繼資料，並會重新定義預設值，這個屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-351">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
### <a name="dependency-property-information"></a><span data-ttu-id="c631d-352">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-352">Dependency property information</span></span>
  
|||  
|-|-|  
|<span data-ttu-id="c631d-353">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-353">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="c631d-354">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-354">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-355">None</span><span class="sxs-lookup"><span data-stu-id="c631d-355">None</span></span>|  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="c631d-356">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="c631d-356">Notes to inheritors</span></span>

<span data-ttu-id="c631d-357">當您衍生自<xref:System.Windows.ContentElement>，請考慮是否要讓您是可設定焦點，因為依預設它不是可設定焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-357">When you derive from <xref:System.Windows.ContentElement>, consider whether you want your element to be focusable, because by default it will not be focusable.</span></span> <span data-ttu-id="c631d-358">如果您想您可設定焦點的項目時，覆寫衍生的類別靜態建構函式中的這個屬性的中繼資料，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c631d-358">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span></span>  

[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
[!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
<span data-ttu-id="c631d-359">其中`myElement`是類別名稱，您會在覆寫中繼資料值的類型。</span><span class="sxs-lookup"><span data-stu-id="c631d-359">where `myElement` is the class name of the type that you are overriding the metadata value on.</span></span>
  
## Examples  
 <span data-ttu-id="c631d-360">下列範例會建立樣式，<xref:System.Windows.Documents.Paragraph>可焦點化預設情況下並為其提供視覺化行為，收到焦點時。</span><span class="sxs-lookup"><span data-stu-id="c631d-360">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-361">發生於 <see cref="P:System.Windows.ContentElement.Focusable" /> 屬性的值變更時。</span><span class="sxs-lookup"><span data-stu-id="c631d-361">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-362">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-362">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-363">識別 <see cref="P:System.Windows.ContentElement.Focusable" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-363">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="c631d-364">要檢查的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-364">The.dependency property to check.</span></span></param>
        <summary><span data-ttu-id="c631d-365">傳回這個項目上指定屬性的基底屬性值，不管任何執行中的可能動畫值，或停止動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-365">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span></span></summary>
        <returns><span data-ttu-id="c631d-366">屬性值，就好像指定的相依性屬性未附加任何動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-366">The property value as if no animations are attached to the specified dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-367">如果未不附加任何動畫屬性，則<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>傳回值一定是相同<xref:System.Windows.DependencyObject.GetValue%2A>傳回值。</span><span class="sxs-lookup"><span data-stu-id="c631d-367">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="c631d-368">如果有附加的動畫，然後所有可能的動畫衍生值包括 開始和停止值會被忽略，而且屬性的值取決於所有可能的輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-368">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="c631d-369">如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-369">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-370">在衍生類別中覆寫，則會傳回替代[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]如果視覺化父代不存在，這個項目的父代。</span><span class="sxs-lookup"><span data-stu-id="c631d-370">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span></span></summary>
        <returns><span data-ttu-id="c631d-371">物件，如果在衍生類別的實作有替代父代連接要報告。</span><span class="sxs-lookup"><span data-stu-id="c631d-371">An object, if implementation of a derived class has an alternate parent connection to report.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-372">預設虛擬實作這個方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-372">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="c631d-373"><xref:System.Windows.FrameworkContentElement> 提供實用的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-373"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="c631d-374">替代的父代是用於事件的路由，在其中項目會建立替代父結構，讓它的事件會路由傳送分離至標準的父代，則視覺樹狀結構路由傳送的標準模式的方式的情況下則會在向下預覽路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-374">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-375">輸入系統報告其下牽涉此元素的拖放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-375">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-376"><xref:System.Windows.ContentElement.GiveFeedback>事件允許來源修改滑鼠指標外觀，以便將使用者的視覺化回饋提供拖放作業期間的拖曳事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-376">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="c631d-377">視覺化回饋強調拖放作業正在處理中。</span><span class="sxs-lookup"><span data-stu-id="c631d-377">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="c631d-378">本項目中建立的別名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.GiveFeedback>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-378">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-379">附加至事件處理常式<xref:System.Windows.ContentElement.GiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-379">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-380">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-380">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-381">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-381">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="c631d-382">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-382">Routing strategy</span></span>|<span data-ttu-id="c631d-383">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-383">Bubbling</span></span>|  
|<span data-ttu-id="c631d-384">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-384">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="c631d-385">對應的通道事件是<xref:System.Windows.ContentElement.PreviewGiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="c631d-385">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="c631d-386">覆寫<xref:System.Windows.ContentElement.OnGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-386">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-387">識別 <see cref="E:System.Windows.ContentElement.GiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-387">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-388">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-388">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-389">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-389">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-390">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-390">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-391">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-391">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-392">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-392">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-393">此元素取得邏輯焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-393">Occurs when this element gets logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-394">如果使用的方法呼叫刻意強制焦點，但存在於不同範圍的上一個鍵盤焦點，則邏輯焦點與鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-394">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="c631d-395">在此案例中，鍵盤焦點會維持其所在和項目其中<xref:System.Windows.ContentElement.Focus%2A>方法呼叫仍取得邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-395">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="c631d-396">此事件的更精確地解譯時，就是引發時間的值<xref:System.Windows.ContentElement.IsFocused%2A>路由的項目屬性變更時，從`false`來`true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-396">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="c631d-397">此事件會使用事件反昇的路由，因為接收焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-397">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-398">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-398">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-399">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-400">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-400">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="c631d-401">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-401">Routing strategy</span></span>|<span data-ttu-id="c631d-402">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-402">Bubbling</span></span>|  
|<span data-ttu-id="c631d-403">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-403">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="c631d-404">沒有任何對應的通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-404">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-405">覆寫<xref:System.Windows.ContentElement.OnGotFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-405">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-406">識別 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-406">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-407">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-408">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-409">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-410">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-411">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-412">鍵盤以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-412">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-413"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 是類似的事件追蹤會維護項目中; 的焦點狀態的屬性中的狀態變更<xref:System.Windows.ContentElement.GotKeyboardFocus>的許多相同的情況下，就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-413"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="c631d-414">此事件會使用事件反昇的路由，因為具有焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-414">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-415">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際擁有焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-415">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="c631d-416">本項目中建立的別名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.GotKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-416">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-417">附加至事件處理常式<xref:System.Windows.ContentElement.GotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-417">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-418">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-418">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-419">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-419">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="c631d-420">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-420">Routing strategy</span></span>|<span data-ttu-id="c631d-421">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-421">Bubbling</span></span>|  
|<span data-ttu-id="c631d-422">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-422">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c631d-423">對應的通道事件是<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-423">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c631d-424">覆寫<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-424">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-425">識別 <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-425">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-426">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-426">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-427">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-427">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-428">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-428">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-429">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-429">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-430">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-430">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-431">此元素擷取滑鼠時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-431">Occurs when this element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-432">元素擷取滑鼠，當它收到滑鼠輸入，即使滑鼠指標位於其範圍外也一樣。</span><span class="sxs-lookup"><span data-stu-id="c631d-432">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="c631d-433">滑鼠通常只會在拖放作業期間擷取，直到擷取拖放作業的拖放動作，就會發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-433">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="c631d-434">此事件會使用事件反昇的路由，因為已擷取的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-434">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-435">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>在事件資料，以判斷實際項目具有滑鼠擷取。</span><span class="sxs-lookup"><span data-stu-id="c631d-435">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="c631d-436">本項目中建立的別名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.GotMouseCapture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-436">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-437">附加至事件處理常式<xref:System.Windows.ContentElement.GotMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-437">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-438">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-438">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-439">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-439">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="c631d-440">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-440">Routing strategy</span></span>|<span data-ttu-id="c631d-441">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-441">Bubbling</span></span>|  
|<span data-ttu-id="c631d-442">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-442">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-443">沒有任何已定義的對應通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-443">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-444">覆寫<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-444">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-445">識別 <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-445">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-446">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-446">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-447">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-447">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-448">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-448">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-449">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-449">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-450">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-450">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-451">此元素擷取手寫筆時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-451">Occurs when this element captures the stylus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-452">元素擷取手寫筆，當它收到手寫筆輸入，即使在指標位於其範圍外也一樣。</span><span class="sxs-lookup"><span data-stu-id="c631d-452">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c631d-453">手寫筆通常只會在拖放作業期間擷取，並且保持擷取，直到拖放作業的拖放動作發生為止。</span><span class="sxs-lookup"><span data-stu-id="c631d-453">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="c631d-454">此事件會使用事件反昇的路由，因為已擷取的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-454">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-455">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷已擷取的實際項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-455">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="c631d-456">此事件會建立這個類別的附加事件的別名，讓<xref:System.Windows.ContentElement.GotStylusCapture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-456">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-457">附加至事件處理常式<xref:System.Windows.ContentElement.GotStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-457">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-458">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-458">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-459">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-459">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="c631d-460">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-460">Routing strategy</span></span>|<span data-ttu-id="c631d-461">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-461">Bubbling</span></span>|  
|<span data-ttu-id="c631d-462">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-462">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-463">沒有任何已定義的對應通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-463">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-464">覆寫<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-464">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-465">識別 <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-465">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-466">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-466">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-467">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-467">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-468">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-468">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-469">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-469">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-470">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-470">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-471">當觸控擷取至這個項目時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-471">Occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-472">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-472">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-473">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-473">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="c631d-474">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-474">Routing strategy</span></span>|<span data-ttu-id="c631d-475">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-475">Bubbling</span></span>|  
|<span data-ttu-id="c631d-476">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-476">Delegate</span></span>|<span data-ttu-id="c631d-477"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-477"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-478">覆寫<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-478">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-479">識別 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-479">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-480">取得值，指出此項目是否有任何動畫的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-480">Gets a value that indicates whether this element has any animated properties.</span></span></summary>
        <value><span data-ttu-id="c631d-481"><see langword="true" /> 如果這個項目有附加至其內容; 的動畫否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-481"><see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-482">這個屬性會傳回`true`持續性 （unclocked，一律執行） 的動畫，或有特定的時間軸的動畫。</span><span class="sxs-lookup"><span data-stu-id="c631d-482">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-483">取得與這個項目相關聯的輸入繫結的集合。</span><span class="sxs-lookup"><span data-stu-id="c631d-483">Gets the collection of input bindings that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="c631d-484">輸入的繫結的集合。</span><span class="sxs-lookup"><span data-stu-id="c631d-484">The collection of input bindings.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-485">輸入繫結支援命令與輸入裝置繫的結。</span><span class="sxs-lookup"><span data-stu-id="c631d-485">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="c631d-486">比方說，<xref:System.Windows.Input.MouseBinding>實作輸入繫結包含滑鼠裝置特有的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-486">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="c631d-487">輸入繫結的集合包含屬於此類型的輸入繫結和也會宣告執行個體的輸入繫結。</span><span class="sxs-lookup"><span data-stu-id="c631d-487">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="c631d-488">相關的屬性， <xref:System.Windows.ContentElement.CommandBindings%2A>，維護命令繫結的集合。</span><span class="sxs-lookup"><span data-stu-id="c631d-488">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="c631d-489">這些繫結與不同的輸入繫結，因為它們代表的下一個層級的命令處理，會為其繫結至已知的命令和類別的特定處理常式的動作。</span><span class="sxs-lookup"><span data-stu-id="c631d-489">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="c631d-490">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="c631d-490">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="c631d-491">XAML 值</span><span class="sxs-lookup"><span data-stu-id="c631d-491">XAML Values</span></span>  
 <span data-ttu-id="c631d-492">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="c631d-492">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="c631d-493">一或多個<xref:System.Windows.Input.InputBinding>項目 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>衍生的類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-493">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="c631d-494">每一種應該要有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>屬性設定。</span><span class="sxs-lookup"><span data-stu-id="c631d-494">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-495">取得或設定值，這個值，指出是否啟用這個項目中[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c631d-495">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="c631d-496">如果啟用這個項目，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-496"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-497">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-497">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-498">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-498">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-499">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-499">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="c631d-500">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-500">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-501">None</span><span class="sxs-lookup"><span data-stu-id="c631d-501">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c631d-502">下列範例會建立包含提供替代的視覺行為的屬性 setter 的樣式時<xref:System.Windows.Documents.Hyperlink>設定為<xref:System.Windows.ContentElement.IsEnabled%2A> `false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-502">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-503">發生時的值<see cref="P:System.Windows.ContentElement.IsEnabled" />此項目變更的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-503">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-504">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-504">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-505">取得值，這個值會變成的傳回值<see cref="P:System.Windows.ContentElement.IsEnabled" />衍生類別中。</span><span class="sxs-lookup"><span data-stu-id="c631d-505">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span></span></summary>
        <value><span data-ttu-id="c631d-506">如果啟用這個項目，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-506"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## <a name="notes-to-inheritors"></a><span data-ttu-id="c631d-507">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="c631d-507">Notes to inheritors</span></span>

<span data-ttu-id="c631d-508">這個屬性的預設實作會快取的值，並也會計算這個項目的父項目是否已啟用。</span><span class="sxs-lookup"><span data-stu-id="c631d-508">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span></span> <span data-ttu-id="c631d-509">如果未啟用父代，子元素不能有效地啟用實際的使用者介面中。</span><span class="sxs-lookup"><span data-stu-id="c631d-509">If the parent is not enabled, the child element cannot be effectively enabled in practical user interface.</span></span> <span data-ttu-id="c631d-510">如果您選擇覆寫這個實作，請確定您呼叫以保留此行為的基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-510">If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-511">識別 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-511">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-512">取得值，決定這個項目是否具有邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-512">Gets a value that determines whether this element has logical focus.</span></span></summary>
        <value><span data-ttu-id="c631d-513">如果這個項目具有邏輯焦點，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-513"><see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-514">如果某個應用程式多個焦點分區，例如功能表內容和應用程式的其餘部分之間，可能會與鍵盤焦點不同邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-514">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="c631d-515">在此案例中，鍵盤焦點都只能有一個應用程式的 UI 項目上，不過，其他焦點分割中的特定項目可能仍會保有邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-515">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="c631d-516">如需有關邏輯焦點的詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)並[焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-516">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-517">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-517">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-518">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-518">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="c631d-519">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-519">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-520">None</span><span class="sxs-lookup"><span data-stu-id="c631d-520">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c631d-521">下列範例會建立樣式，<xref:System.Windows.Documents.Paragraph>可焦點化預設情況下並為其提供視覺化行為，收到焦點時。</span><span class="sxs-lookup"><span data-stu-id="c631d-521">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-522">識別 <see cref="P:System.Windows.ContentElement.IsFocused" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-522">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-523">取得值，指出輸入法系統 (例如 [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]) 是否已為處理這個項目的輸入而啟用。</span><span class="sxs-lookup"><span data-stu-id="c631d-523">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span></span></summary>
        <value><span data-ttu-id="c631d-524">如果輸入法為使用中，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-524"><see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-525">基礎附加屬性的預設值是<see langword="true" />; 不過，這個值會受到輸入方法在執行階段的狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-525">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-526">這個屬性會傳回值，該附加屬性由<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>針對目前已啟用輸入法 （鍵盤、 語音和其他輸入的裝置）。</span><span class="sxs-lookup"><span data-stu-id="c631d-526">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-527">取得值，指出這個項目是否具有鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-527">Gets a value that indicates whether this element has keyboard focus.</span></span></summary>
        <value><span data-ttu-id="c631d-528">如果這個項目具有鍵盤焦點，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-528"><see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-529">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-530">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-531">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-531">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="c631d-532">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-532">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-533">None</span><span class="sxs-lookup"><span data-stu-id="c631d-533">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-534">發生時的值<see cref="P:System.Windows.ContentElement.IsKeyboardFocused" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-534">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-535">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-535">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-536">識別 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-536">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-537">取得值，指出鍵盤焦點是否在項目或項目子系內的任何位置。</span><span class="sxs-lookup"><span data-stu-id="c631d-537">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span></span></summary>
        <value><span data-ttu-id="c631d-538">如果鍵盤焦點在項目或其子項目上，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-538"><see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-539">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-539">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-540">這個屬性值的變更通常會引發<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件，除非在衍生的類別已覆寫<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>隱藏的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-540">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="c631d-541">您未設定此屬性直接，但您也可以呼叫的項目設定焦點<xref:System.Windows.ContentElement.Focus%2A>，或藉由<xref:System.Windows.ContentElement.MoveFocus%2A>要求。</span><span class="sxs-lookup"><span data-stu-id="c631d-541">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="c631d-542">這些方法會呼叫其中一種方法可能會變更這個屬性值。</span><span class="sxs-lookup"><span data-stu-id="c631d-542">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-543">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-543">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-544">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-544">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="c631d-545">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-545">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-546">None</span><span class="sxs-lookup"><span data-stu-id="c631d-546">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-547">發生時的值<see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-547">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-548">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-548">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-549">識別 <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-549">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-550">取得值，指出是否要將滑鼠擷取由這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-550">Gets a value that indicates whether the mouse is captured by this element.</span></span></summary>
        <value><span data-ttu-id="c631d-551">如果項目具有滑鼠擷取，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-551"><see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-552">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-552">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-553">滑鼠捕捉狀態與相關程序中的拖放作業。</span><span class="sxs-lookup"><span data-stu-id="c631d-553">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-554">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-554">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-555">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-555">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="c631d-556">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-556">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-557">None</span><span class="sxs-lookup"><span data-stu-id="c631d-557">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c631d-558">下列範例會根據是否已捕捉滑鼠的項目，開啟或關閉滑鼠捕捉狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-558">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-559">發生時的值<see cref="P:System.Windows.ContentElement.IsMouseCaptured" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-559">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-560">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-560">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-561">識別 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-561">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-562">取得值，決定滑鼠捕捉是否由這個項目或其項目樹狀結構中的子項目所保留。</span><span class="sxs-lookup"><span data-stu-id="c631d-562">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span></span></summary>
        <value><span data-ttu-id="c631d-563">如果這個項目或包含的項目具有滑鼠擷取，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-563"><see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-564">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-564">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-565">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-565">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-566">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-566">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="c631d-567">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-567">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-568">None</span><span class="sxs-lookup"><span data-stu-id="c631d-568">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-569">發生時的值<see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />這個項目上的變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-569">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-570">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-570">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-571">識別 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-571">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-572">取得值，指出滑鼠指標位置是否與點擊測試結果對應，該結果會將複合項目納入考量。</span><span class="sxs-lookup"><span data-stu-id="c631d-572">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="c631d-573">如果滑鼠指標位於與點擊測試相同的項目結果上方，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-573"><see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-574">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-574">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-575">不同於<xref:System.Windows.ContentElement.IsMouseOver%2A>，這個屬性才`true`如果滑鼠指標位在常值的項目-以用於點擊測試。</span><span class="sxs-lookup"><span data-stu-id="c631d-575">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element - as it is for a hit test.</span></span> <span data-ttu-id="c631d-576">如果滑鼠指標位於子系項目上方，特別是項目的一部分的項目更深入的範本和複合 （compositing），這個屬性會是`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-576">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="c631d-577">除非您知道控制項的複合 （比方說，您使用這個屬性的自訂控制項範本中的控制項，您所定義），這個屬性可能會傳回非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="c631d-577">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="c631d-578">大部分的情況下，您不撰寫控制項，使用<xref:System.Windows.ContentElement.IsMouseOver%2A>改。</span><span class="sxs-lookup"><span data-stu-id="c631d-578">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="c631d-579">如果將滑鼠擷取由這個項目，而且這個屬性為`true`次擷取的詳細資訊，此屬性會繼續傳回`true`直到遺失滑鼠捕捉並的指標不是透過其範圍。</span><span class="sxs-lookup"><span data-stu-id="c631d-579">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-580">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-580">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-581">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-581">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="c631d-582">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-582">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-583">None</span><span class="sxs-lookup"><span data-stu-id="c631d-583">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-584">發生時的值<see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-584">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-585">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-585">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-586">識別 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-586">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-587">取得值，指出滑鼠指標是否位於這個項目上方 （包括視覺子項目或其複合控制項）。</span><span class="sxs-lookup"><span data-stu-id="c631d-587">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span></span></summary>
        <value><span data-ttu-id="c631d-588">如果滑鼠指標位在這個項目或其子項目上方，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-588"><see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-589">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-589">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-590">雖然類似"IsMouseOverChanged 」 事件不存在，便會執行數個類似的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-590">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="c631d-591">例如，您可以使用<xref:System.Windows.ContentElement.MouseEnter>， <xref:System.Windows.ContentElement.MouseMove>，和<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。</span><span class="sxs-lookup"><span data-stu-id="c631d-591">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="c631d-592">如果此元素擷取滑鼠，這個屬性會保持`true`直到遺失滑鼠捕捉並滑鼠指標離開項目範圍。</span><span class="sxs-lookup"><span data-stu-id="c631d-592">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-593">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-593">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-594">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-594">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="c631d-595">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-595">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-596">None</span><span class="sxs-lookup"><span data-stu-id="c631d-596">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c631d-597">下列範例會建立包含提供替代的視覺行為的屬性 setter 的樣式時<xref:System.Windows.Documents.Hyperlink>報表<xref:System.Windows.ContentElement.IsMouseOver%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-597">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-598">識別 <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-598">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-599">取得值，指出是否將手寫筆擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-599">Gets a value that indicates whether the stylus is captured to this element.</span></span></summary>
        <value><span data-ttu-id="c631d-600">如果項目具有手寫筆擷取，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-600"><see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-601">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-601">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-602">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-602">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-603">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-603">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-604">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-604">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-605">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-605">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="c631d-606">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-606">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-607">None</span><span class="sxs-lookup"><span data-stu-id="c631d-607">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-608">發生時的值<see cref="P:System.Windows.ContentElement.IsStylusCaptured" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-608">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-609">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-609">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-610">識別 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-610">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-611">取得值，決定手寫筆捕捉是否由這個項目，包括子元素和複合控制項保留。</span><span class="sxs-lookup"><span data-stu-id="c631d-611">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span></span></summary>
        <value><span data-ttu-id="c631d-612"><see langword="true" /> 如果手寫筆捕捉保留在這個項目;否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-612"><see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-613">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-613">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-614">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-614">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-615">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-615">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-616">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-616">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="c631d-617">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-617">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-618">None</span><span class="sxs-lookup"><span data-stu-id="c631d-618">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-619">發生時的值<see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-619">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-620">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-620">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-621">識別 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-621">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-622">取得值，指出手寫筆位置是否與點擊測試結果相對應，該結果會將複合項目納入考量。</span><span class="sxs-lookup"><span data-stu-id="c631d-622">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="c631d-623">如果手寫筆位於與點擊測試相同的項目上方，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-623"><see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-624">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-624">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-625">不同於<xref:System.Windows.ContentElement.IsStylusOver%2A>，這個屬性才`true`如果手寫筆在元素上方。</span><span class="sxs-lookup"><span data-stu-id="c631d-625">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="c631d-626">如果手寫筆改為透過子元素或元素的更深入的複合 （compositing） 一部分的項目，這個屬性會是`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-626">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="c631d-627">除非您知道控制項的複合 （比方說，您使用這個屬性的自訂控制項範本中的控制項，您所定義），這個屬性可能會傳回非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="c631d-627">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="c631d-628">大部分的情況下，您不撰寫控制項，使用<xref:System.Windows.ContentElement.IsStylusOver%2A>改。</span><span class="sxs-lookup"><span data-stu-id="c631d-628">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="c631d-629">如果這個項目具有手寫筆擷取，而且這個屬性就`true`擷取時，這個屬性會保持`true`直到手寫筆擷取遺失，且其範圍不是手寫筆。</span><span class="sxs-lookup"><span data-stu-id="c631d-629">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="c631d-630">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-630">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-631">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-631">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-632">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-632">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-633">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-633">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="c631d-634">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-634">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-635">None</span><span class="sxs-lookup"><span data-stu-id="c631d-635">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-636">發生時的值<see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" />這個項目上的屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-636">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-637">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-637">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-638">識別 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-638">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-639">取得值，指出手寫筆是否位於這個項目上方 （包括視覺子項目）。</span><span class="sxs-lookup"><span data-stu-id="c631d-639">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span></span></summary>
        <value><span data-ttu-id="c631d-640"><see langword="true" /> 如果手寫筆在項目或其子項目;否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-640"><see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c631d-641">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-641">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-642">如果這個項目具有手寫筆擷取，這個屬性會保持`true`直到遺失手寫筆捕捉並指標超出其範圍。</span><span class="sxs-lookup"><span data-stu-id="c631d-642">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="c631d-643">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-644">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c631d-645">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-645">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-646">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-646">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="c631d-647">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="c631d-647">Metadata properties set to `true`</span></span>|<span data-ttu-id="c631d-648">None</span><span class="sxs-lookup"><span data-stu-id="c631d-648">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-649">識別 <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-649">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-650">焦點在這個項目上方且按下按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-650">Occurs when a key is pressed while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-651">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="c631d-651">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c631d-652"><xref:System.Windows.ContentElement.KeyDown>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。</span><span class="sxs-lookup"><span data-stu-id="c631d-652">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c631d-653">這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-653">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="c631d-654">本項目中建立的別名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.KeyDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-654">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-655">附加至事件處理常式<xref:System.Windows.ContentElement.KeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-655">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-656">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-656">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-657">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-657">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="c631d-658">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-658">Routing strategy</span></span>|<span data-ttu-id="c631d-659">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-659">Bubbling</span></span>|  
|<span data-ttu-id="c631d-660">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-660">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c631d-661">對應的通道事件是<xref:System.Windows.ContentElement.PreviewKeyDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-661">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="c631d-662">覆寫<xref:System.Windows.ContentElement.OnKeyDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-662">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-663">識別 <see cref="E:System.Windows.ContentElement.KeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-663">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-664">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-664">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-665">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-665">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-666">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-666">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-667">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-667">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-668">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-668">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-669">焦點在這個項目上方且放開按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-669">Occurs when a key is released while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-670">本項目中建立的別名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.ContentElement.KeyUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-670">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-671">附加至事件處理常式<xref:System.Windows.ContentElement.KeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-671">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-672">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-672">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-673">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-673">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="c631d-674">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-674">Routing strategy</span></span>|<span data-ttu-id="c631d-675">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-675">Bubbling</span></span>|  
|<span data-ttu-id="c631d-676">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-676">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c631d-677">對應的通道事件是<xref:System.Windows.ContentElement.PreviewKeyUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-677">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="c631d-678">覆寫<xref:System.Windows.ContentElement.OnKeyUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-678">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-679">識別 <see cref="E:System.Windows.ContentElement.KeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-679">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-680">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-680">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-681">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-681">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-682">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-682">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-683">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-683">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-684">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-684">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-685">此元素失去邏輯焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-685">Occurs when this element loses logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-686">如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同範圍中，則邏輯焦點會與鍵盤焦點不同。</span><span class="sxs-lookup"><span data-stu-id="c631d-686">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="c631d-687">在此案例中，鍵盤焦點會維持其所在位置和項目其中<xref:System.Windows.ContentElement.Focus%2A>方法呼叫仍取得邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="c631d-687">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="c631d-688">此事件的更精確地解譯時，就是引發時間的值<xref:System.Windows.ContentElement.IsFocused%2A>路由的項目屬性變更時從`true`至`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-688">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="c631d-689">因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-689">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-690">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-690">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-691">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-691">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-692">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-692">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="c631d-693">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-693">Routing strategy</span></span>|<span data-ttu-id="c631d-694">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-694">Bubbling</span></span>|  
|<span data-ttu-id="c631d-695">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-695">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="c631d-696">沒有任何對應的通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-696">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-697">覆寫<xref:System.Windows.ContentElement.OnLostFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-697">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-698">識別 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-698">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-699">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-699">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-700">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-700">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-701">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-701">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-702">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-702">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-703">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-703">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-704">鍵盤不再以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-704">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-705">因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-705">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-706">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-706">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c631d-707">此事件建立的別名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.LostKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-707">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-708">附加至事件處理常式<xref:System.Windows.ContentElement.LostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-708">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-709">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-710">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-710">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="c631d-711">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-711">Routing strategy</span></span>|<span data-ttu-id="c631d-712">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-712">Bubbling</span></span>|  
|<span data-ttu-id="c631d-713">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-713">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c631d-714">對應的通道事件是<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-714">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c631d-715">覆寫<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-715">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-716">識別 <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-716">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-717">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-717">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-718">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-718">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-719">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-719">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-720">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-720">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-721">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-721">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-722">此元素失去滑鼠擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-722">Occurs when this element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-723">當項目捕捉到滑鼠時，它收到滑鼠輸入，即使在指標位於其範圍外。</span><span class="sxs-lookup"><span data-stu-id="c631d-723">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c631d-724">是通常只有在捕捉滑鼠拖放作業。</span><span class="sxs-lookup"><span data-stu-id="c631d-724">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c631d-725">因為此事件會使用事件反昇的路由，失去擷取的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-725">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-726">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際遺失擷取的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-726">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="c631d-727">此事件建立的別名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.LostMouseCapture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-727">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-728">附加至事件處理常式<xref:System.Windows.ContentElement.LostMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-728">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-729">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-729">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-730">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-730">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="c631d-731">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-731">Routing strategy</span></span>|<span data-ttu-id="c631d-732">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-732">Bubbling</span></span>|  
|<span data-ttu-id="c631d-733">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-733">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-734">沒有任何已定義的對應通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-734">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-735">覆寫<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-735">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-736">識別 <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-736">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-737">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-737">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-738">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-738">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-739">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-739">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-740">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-740">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-741">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-741">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-742">此元素失去手寫筆擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-742">Occurs when this element loses stylus capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-743">元素擷取手寫筆，當它收到手寫筆輸入，即使在指標位於其範圍外也一樣。</span><span class="sxs-lookup"><span data-stu-id="c631d-743">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c631d-744">要捕捉手寫筆通常只會在拖放作業期間。</span><span class="sxs-lookup"><span data-stu-id="c631d-744">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c631d-745">因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-745">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-746">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-746">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c631d-747">此事件建立的別名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.LostStylusCapture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-747">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-748">附加至事件處理常式<xref:System.Windows.ContentElement.LostStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-748">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-749">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-749">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-750">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-750">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="c631d-751">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-751">Routing strategy</span></span>|<span data-ttu-id="c631d-752">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-752">Bubbling</span></span>|  
|<span data-ttu-id="c631d-753">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-753">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-754">沒有任何已定義的對應通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-754">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-755">覆寫<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-755">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-756">識別 <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-756">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-757">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-757">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-758">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-758">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-759">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-759">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-760">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-760">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-761">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-761">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-762">這個項目失去觸控擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-762">Occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-763">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-763">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-764">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-764">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="c631d-765">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-765">Routing strategy</span></span>|<span data-ttu-id="c631d-766">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-766">Bubbling</span></span>|  
|<span data-ttu-id="c631d-767">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-767">Delegate</span></span>|<span data-ttu-id="c631d-768"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-768"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-769">覆寫<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-769">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-770">識別 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-770">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-771">指標在此元素上方且按下任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-771">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-772">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-772">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-773">附加至事件處理常式<xref:System.Windows.ContentElement.MouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-773">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-774"><xref:System.Windows.ContentElement.MouseDown>通常就會引發事件一起<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>，對應到其中的兩個標準的滑鼠按鈕按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-774">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c631d-775"><xref:System.Windows.ContentElement.MouseLeftButtonDown> 並<xref:System.Windows.ContentElement.MouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-775"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c631d-776">請參閱備註<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-776">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c631d-777">少數<xref:System.Windows.ContentElement>衍生的類別具有類似控制項的行為，例如， <xref:System.Windows.Documents.Hyperlink>，可能具有固有處理按鈕的滑鼠事件的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-777">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="c631d-778">滑鼠左的按鈕向下事件是最可能的事件，讓控制項中的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-778">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="c631d-779">類別處理，通常會將標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-779">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="c631d-780">一旦被標示為已處理，通常無法引發另一個執行個體處理常式附加至該項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-780">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="c631d-781">也不通常會引發任何其他類別或執行個體處理常式附加至事件反昇方向朝向 UI 樹狀目錄中的根項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-781">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="c631d-782">您可以解決的問題，在上述的重要概述，並仍收到<xref:System.Windows.ContentElement.MouseDown>滑鼠左的按鈕向下事件已處理就使用任一這些方案的類別衍生類別上的事件：</span><span class="sxs-lookup"><span data-stu-id="c631d-782">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="c631d-783">附加的處理常式<xref:System.Windows.ContentElement.PreviewMouseDown>未標示為已由控制項所處理的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-783">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="c631d-784">請注意，因為這是預覽事件，路由從根目錄開始，並向下控制項。</span><span class="sxs-lookup"><span data-stu-id="c631d-784">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="c631d-785">藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.ContentElement.AddHandler%2A>，然後選擇 [簽章] 選項，可讓處理常式來接聽事件，即使它們已經標示為已處理路由的事件資料中。</span><span class="sxs-lookup"><span data-stu-id="c631d-785">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-786">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-786">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-787">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-787">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="c631d-788">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-788">Routing strategy</span></span>|<span data-ttu-id="c631d-789">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-789">Bubbling</span></span>|  
|<span data-ttu-id="c631d-790">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-790">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-791">對應的通道事件是<xref:System.Windows.ContentElement.PreviewMouseDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-791">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="c631d-792">覆寫<xref:System.Windows.ContentElement.OnMouseDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-792">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-793">識別 <see cref="E:System.Windows.ContentElement.MouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-793">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-794">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-794">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-795">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-795">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-796">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-796">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-797">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-797">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-798">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-798">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-799">滑鼠指標進入此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-799">Occurs when the mouse pointer enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-800"><xref:System.Windows.ContentElement.MouseEnter> 已[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-800"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c631d-801">直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-801">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c631d-802">不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。</span><span class="sxs-lookup"><span data-stu-id="c631d-802">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c631d-803">雖然<xref:System.Windows.ContentElement.MouseEnter>播放軌，當滑鼠指標進入範圍的項目，這個事件更多解譯為常值回報<xref:System.Windows.ContentElement.IsMouseOver%2A>屬性值已從`false`至`true`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="c631d-803">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="c631d-804">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseEnter>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-804">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-805">附加至事件處理常式<xref:System.Windows.ContentElement.MouseEnter>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-805">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-806">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-806">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-807">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-807">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="c631d-808">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-808">Routing strategy</span></span>|<span data-ttu-id="c631d-809">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-809">Direct</span></span>|  
|<span data-ttu-id="c631d-810">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-810">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-811">覆寫<xref:System.Windows.ContentElement.OnMouseEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-811">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-812">識別 <see cref="E:System.Windows.ContentElement.MouseEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-812">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-813">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-813">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-814">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-814">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-815">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-815">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-816">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-816">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-817">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-817">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-818">滑鼠指標離開此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-818">Occurs when the mouse pointer leaves the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-819"><xref:System.Windows.ContentElement.MouseLeave> 已[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-819"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c631d-820">直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-820">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c631d-821">不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。</span><span class="sxs-lookup"><span data-stu-id="c631d-821">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c631d-822">雖然<xref:System.Windows.ContentElement.MouseLeave>播放軌，當滑鼠離開項目，這個事件更多解譯為常值回報<xref:System.Windows.ContentElement.IsMouseOver%2A>屬性值已從`true`至`false`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="c631d-822">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="c631d-823">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseLeave>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-823">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-824">附加至事件處理常式<xref:System.Windows.ContentElement.MouseLeave>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-824">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-825">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-825">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-826">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-826">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="c631d-827">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-827">Routing strategy</span></span>|<span data-ttu-id="c631d-828">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-828">Direct</span></span>|  
|<span data-ttu-id="c631d-829">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-829">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-830">覆寫<xref:System.Windows.ContentElement.OnMouseLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-830">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-831">識別 <see cref="E:System.Windows.ContentElement.MouseLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-831">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-832">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-832">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-833">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-833">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-834">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-834">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-835">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-835">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-836">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-836">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-837">滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-837">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-838">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循事件反昇路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-838">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-839">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-839">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-840">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-840">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-841">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-841">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-842">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-842">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-843">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-843">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-844">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-844">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c631d-845">少數<xref:System.Windows.ContentElement>衍生的類別具有類似控制項的行為，例如， <xref:System.Windows.Documents.Hyperlink>，可能具有固有處理按鈕的滑鼠事件的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-845">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="c631d-846">滑鼠左的按鈕向下事件是最可能的事件，讓控制項中的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-846">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="c631d-847">類別處理，通常會將標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-847">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="c631d-848">一旦被標示為已處理，通常無法引發另一個執行個體處理常式附加至該項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-848">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="c631d-849">也不通常會引發任何其他類別或執行個體處理常式附加至事件反昇方向朝向 UI 樹狀目錄中的根項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-849">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="c631d-850">您可以解決的問題，在上述的重要概述，並仍收到<xref:System.Windows.ContentElement.MouseLeftButtonDown>滑鼠左的按鈕向下事件已處理就使用任一這些方案的類別衍生類別上的事件：</span><span class="sxs-lookup"><span data-stu-id="c631d-850">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="c631d-851">附加的處理常式<xref:System.Windows.ContentElement.PreviewMouseDown>未標示為已由控制項所處理的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-851">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="c631d-852">請注意，因為這是預覽事件，路由從根目錄開始，並向下控制項。</span><span class="sxs-lookup"><span data-stu-id="c631d-852">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="c631d-853">藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.ContentElement.AddHandler%2A>，然後選擇 [簽章] 選項，可讓處理常式來接聽事件，即使它們已經標示為已處理路由的事件資料中。</span><span class="sxs-lookup"><span data-stu-id="c631d-853">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-854">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-854">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-855">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-855">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="c631d-856">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-856">Routing strategy</span></span>|<span data-ttu-id="c631d-857">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-857">Direct</span></span>|  
|<span data-ttu-id="c631d-858">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-858">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-859">覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-859">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-860">識別 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-860">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-861">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-861">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-862">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-862">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-863">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-863">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-864">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-864">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-865">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-865">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-866">滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-866">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-867">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循事件反昇路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-867">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-868">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-868">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-869">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-869">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-870">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-870">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-871">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-871">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-872">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-872">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-873">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-873">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-874">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-874">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-875">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-875">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="c631d-876">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-876">Routing strategy</span></span>|<span data-ttu-id="c631d-877">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-877">Direct</span></span>|  
|<span data-ttu-id="c631d-878">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-878">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-879">覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-879">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-880">識別 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-880">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-881">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-881">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-882">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-882">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-883">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-883">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-884">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-884">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-885">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-885">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-886">滑鼠指標在此元素上方移動時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-886">Occurs when the mouse pointer moves while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-887">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-887">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-888">附加至事件處理常式<xref:System.Windows.ContentElement.MouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-888">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-889">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-890">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-890">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="c631d-891">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-891">Routing strategy</span></span>|<span data-ttu-id="c631d-892">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-892">Bubbling</span></span>|  
|<span data-ttu-id="c631d-893">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-893">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-894">對應的通道事件是<xref:System.Windows.ContentElement.PreviewMouseMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-894">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="c631d-895">覆寫<xref:System.Windows.ContentElement.OnMouseMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-895">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-896">識別 <see cref="E:System.Windows.ContentElement.MouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-896">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-897">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-897">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-898">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-898">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-899">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-899">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-900">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-900">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-901">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-901">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-902">滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-902">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-903">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循事件反昇路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-903">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-904">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-904">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-905">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-905">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-906">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-906">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-907">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-907">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-908">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-908">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-909">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-909">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-910">向右按鈕的滑鼠事件中通常會有原生處理的應用程式案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-910">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="c631d-911">比方說，向下的滑鼠右按鈕可能會顯示內容功能表。</span><span class="sxs-lookup"><span data-stu-id="c631d-911">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="c631d-912">請參閱[ContextMenu 概觀](~/docs/framework/wpf/controls/contextmenu-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-912">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-913">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-913">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-914">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-914">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="c631d-915">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-915">Routing strategy</span></span>|<span data-ttu-id="c631d-916">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-916">Direct</span></span>|  
|<span data-ttu-id="c631d-917">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-917">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-918">覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-918">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-919">識別 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-919">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-920">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-920">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-921">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-921">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-922">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-922">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-923">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-923">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-924">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-924">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-925">滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-925">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-926">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循事件反昇路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-926">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-927">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-927">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-928">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-928">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-929">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-929">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-930">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-930">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-931">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-931">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-932">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-932">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-933">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-933">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-934">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-934">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="c631d-935">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-935">Routing strategy</span></span>|<span data-ttu-id="c631d-936">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-936">Direct</span></span>|  
|<span data-ttu-id="c631d-937">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-937">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-938">覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-938">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-939">識別 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-939">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-940">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-940">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-941">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-941">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-942">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-942">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-943">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-943">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-944">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-944">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-945">在此元素上方放開任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-945">Occurs when any mouse button is released over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-946">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-946">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-947">附加至事件處理常式<xref:System.Windows.ContentElement.MouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-947">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-948"><xref:System.Windows.ContentElement.MouseUp>通常就會引發事件一起<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>，對應至其中的兩個標準的滑鼠按鈕的版本。</span><span class="sxs-lookup"><span data-stu-id="c631d-948">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c631d-949"><xref:System.Windows.ContentElement.MouseLeftButtonUp> 並<xref:System.Windows.ContentElement.MouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-949"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c631d-950">請參閱備註<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-950">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-951">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-951">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-952">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-952">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="c631d-953">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-953">Routing strategy</span></span>|<span data-ttu-id="c631d-954">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-954">Bubbling</span></span>|  
|<span data-ttu-id="c631d-955">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-955">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-956">對應的通道事件是<xref:System.Windows.ContentElement.PreviewMouseUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-956">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="c631d-957">覆寫<xref:System.Windows.ContentElement.OnMouseUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-957">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-958">識別 <see cref="E:System.Windows.ContentElement.MouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-958">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-959">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-959">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-960">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-960">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-961">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-961">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-962">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-962">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-963">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-963">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-964">滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-964">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-965">焦點或滑鼠捕捉會優先於滑鼠指標的所在;因此，如果您收到<xref:System.Windows.ContentElement.MouseWheel>焦點或擷取的項目中的事件，將滑鼠指標可能實際上是透過另一個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-965">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="c631d-966">此事件建立的別名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.MouseWheel>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-966">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-967">附加至事件處理常式<xref:System.Windows.ContentElement.MouseWheel>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-967">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-968">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-968">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-969">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-969">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="c631d-970">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-970">Routing strategy</span></span>|<span data-ttu-id="c631d-971">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-971">Bubbling</span></span>|  
|<span data-ttu-id="c631d-972">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-972">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="c631d-973">對應的通道事件是<xref:System.Windows.ContentElement.PreviewMouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="c631d-973">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="c631d-974">覆寫<xref:System.Windows.ContentElement.OnMouseWheel%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-974">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-975">識別 <see cref="E:System.Windows.ContentElement.MouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-975">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-976">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-976">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-977">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-977">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-978">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-978">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-979">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-979">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-980">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-980">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="c631d-981">周遊要求，其中包含屬性，表示周遊現有的定位順序或方向，以視覺化方式移動中的模式。</span><span class="sxs-lookup"><span data-stu-id="c631d-981">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span></span></param>
        <summary><span data-ttu-id="c631d-982">嘗試將焦點從這個項目移至另一個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-982">Attempts to move focus from this element to another element.</span></span> <span data-ttu-id="c631d-983">要移動焦點的方向是由指引方向，這個項目的視覺化父項目組織內解譯指定。</span><span class="sxs-lookup"><span data-stu-id="c631d-983">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-984"><see langword="true" /> 如果已執行要求的周遊;否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-984"><see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-985">請確定您檢查傳回的值，這個方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-985">Make sure you check the return value of this method.</span></span> <span data-ttu-id="c631d-986">傳回值為`false`如果周遊時碰到控制項的組合所定義的定位停駐點，並周遊要求並未要求要包裝，可能會傳回。</span><span class="sxs-lookup"><span data-stu-id="c631d-986">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-987">傳回類別特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基礎結構。</span><span class="sxs-lookup"><span data-stu-id="c631d-987">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span></summary>
        <returns><span data-ttu-id="c631d-988">因型別而異的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-988">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="c631d-989">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="c631d-989">Notes to inheritors</span></span>

<span data-ttu-id="c631d-990">此方法的實作會在呼叫特定的建構函式通常是<xref:System.Windows.Automation.Peers.AutomationPeer" />實作，並將它傳回為傳回值。</span><span class="sxs-lookup"><span data-stu-id="c631d-990">The implementation of this method is typically to call the constructor of a specific <xref:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span></span>  
  
 <span data-ttu-id="c631d-991">所有<xref:System.Windows.ContentElement>衍生的類別應該實作這個方法，以提供自己的特定<xref:System.Windows.Automation.Peers.AutomationPeer>WPF 基礎結構的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-991">All <xref:System.Windows.ContentElement> derived classes should implement this method in order to provide their own specific <xref:System.Windows.Automation.Peers.AutomationPeer> implementations to the WPF infrastructure.</span></span> <span data-ttu-id="c631d-992">如需實作此模式的詳細資訊，請參閱<xref:System.Windows.Automation.Peers.AutomationPeer>。</span><span class="sxs-lookup"><span data-stu-id="c631d-992">For details on implementing this pattern, see <xref:System.Windows.Automation.Peers.AutomationPeer>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-993">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-993">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-994">當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-994">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-995">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-995">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-996">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-996">This method has no default implementation.</span></span> <span data-ttu-id="c631d-997">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-997">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-998">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-998">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-999">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-999">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1000">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1000">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1001">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1001">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1002">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1002">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1003">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1003">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1004">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1004">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1005">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1005">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1006">當未處理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1006">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1007">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1007">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1008">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1008">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1009">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1009">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1010">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1010">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1011">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1011">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1012">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1012">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1013">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1013">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1014">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1014">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1015">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1015">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1016">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1016">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1017">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1017">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1018">當未處理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1018">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1019">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1019">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1020">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1020">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1021">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1021">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1022">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1022">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1023">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1023">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1024">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1024">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1025">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1025">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1026">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1026">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1027">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1027">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1028">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1028">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1029">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1029">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1030">當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1030">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1031">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1031">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1032">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1032">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1033">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1033">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1034">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1034">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1035">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1035">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1036">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1036">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1037">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1037">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1038">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1038">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1039">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1039">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1040">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1040">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1041">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1041">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1042">當未處理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1042">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1043">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1043">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1044">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1044">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1045">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1045">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1046">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1046">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1047">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1047">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1048">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1048">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1049">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1049">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1050">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1050">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1051">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1051">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1052">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1052">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1053">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1053">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="c631d-1054">此事件資料必須包含 <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-1054">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="c631d-1055">使用所提供的事件資料引發 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1055">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1056">此方法中，雖然是虛擬的沒有預設實作會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1056">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="c631d-1057">這在 \* 方法實作用來引發事件，這個相同的方法實作是在內部叫用來引發事件時<xref:System.Windows.ContentElement.IsFocused%2A>屬性值變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-1057">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="c631d-1058"><xref:System.Windows.ContentElement.OnGotFocus%2A>實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 只提供便利的方式來加入類別處理該事件的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1058">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="c631d-1059">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="c631d-1059">Notes to inheritors</span></span>

<span data-ttu-id="c631d-1060">除非您有不會引發焦點事件變成故意或不尋常的需要，請確定您的實作會呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1060">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="c631d-1061">否則，<xref:System.Windows.ContentElement.GotFocus>通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1061">Otherwise, the <xref:System.Windows.ContentElement.GotFocus> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="c631d-1062">如果您不想要您可設定焦點的項目，您可以防止項目設定成為可設定焦點<xref:System.Windows.ContentElement.Focusable>至`false`。</span><span class="sxs-lookup"><span data-stu-id="c631d-1062">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <xref:System.Windows.ContentElement.Focusable> to `false`.</span></span>
<span data-ttu-id="c631d-1063">請注意，預設<xref:System.Windows.ContentElement.Focusable>不是可設定焦點，因此設定<xref:System.Windows.ContentElement.Focusable>刻意不可能需要。</span><span class="sxs-lookup"><span data-stu-id="c631d-1063">Note that by default a <xref:System.Windows.ContentElement.Focusable> is not focusable, therefore setting <xref:System.Windows.ContentElement.Focusable> deliberately might not be necessary.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1064">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1064">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1065">當未處理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1065">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1066">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1066">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1067">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1067">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1068">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1068">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1069">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1069">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1070">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1070">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1071">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1071">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1072">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1072">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1073">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1073">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1074">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1074">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1075">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1075">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1076">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1076">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1077">當未處理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1077">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1078">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1078">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1079">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1079">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1080">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1080">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1081">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1081">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1082">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1082">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1083">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1083">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1084">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1084">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1085">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1085">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1086">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1086">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1087">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1087">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1088">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1088">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1089">當未處理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1089">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1090">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1090">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1091">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1091">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1092">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1092">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1093">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1093">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1094">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1094">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1095">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1095">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1096">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1096">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1097">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1097">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1098">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1098">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1099">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1099">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1100"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1100">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1101">提供的類別處理<see cref="E:System.Windows.ContentElement.GotTouchCapture" />觸控擷取至這個項目時所發生的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1101">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1102"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1102">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1103">覆寫<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>衍生類別來處理在<xref:System.Windows.ContentElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1103">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="c631d-1104">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1104">Be sure to call the base class' <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1105">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1105">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1106">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1106">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1107">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1107">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1108">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>相依性屬性變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-1108">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="c631d-1109">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1109">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1110">則<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1110">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1111">請注意，<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1111">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="c631d-1112">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1112">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1113">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1113">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1114">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1114">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1115">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1115">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1116"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1116">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1117">在此項目引發 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 事件前叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1117">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span></span> <span data-ttu-id="c631d-1118">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1118">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1119">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1119">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1120">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1120">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1121">則<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1121">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1122">請注意，<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1122">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="c631d-1123">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1123">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1124">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1124">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1125">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1125">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1126">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1126">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1127">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1127">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1128">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1128">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1129">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1129">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1130">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1130">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1131">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1131">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1132">則<xref:System.Windows.ContentElement.IsMouseCapturedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1132">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1133">請注意，<xref:System.Windows.ContentElement.IsMouseCapturedChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1133">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="c631d-1134">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1134">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1135">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1135">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1136">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1136">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1137">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1137">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1138"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1138">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1139">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1139">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1140">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1140">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c631d-1141">這個虛擬方法，就會引發時的值<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1141">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1142">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1142">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1143">則<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1143">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1144">請注意，事件不是路由的事件。因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1144">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span></span>  
  
<span data-ttu-id="c631d-1145">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1145">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1146">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1146">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1147">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1147">You may call base either before or after your special handling, depending on your requirements.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1148">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1148">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1149">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1149">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1150">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1150">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1151">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1151">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1152">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1152">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1153">則<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1153">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1154">請注意，<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1154">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="c631d-1155">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1155">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1156">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1156">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1157">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1157">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1158">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1158">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1159"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1159">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1160">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1160">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1161">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1161">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1162">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1162">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1163">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1163">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1164">則<xref:System.Windows.ContentElement.IsStylusCapturedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1164">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1165">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1165">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c631d-1166">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1166">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1167">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1167">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1168">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1168">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1169">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1169">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1170">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1170">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1171">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1171">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1172">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1172">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1173">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1173">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1174">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1174">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1175">則<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1175">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1176">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1176">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c631d-1177">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1177">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1178">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1178">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1179">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1179">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1180">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1180">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1181">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1181">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1182">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> 事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1182">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="c631d-1183">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1183">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1184">這個虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="c631d-1184">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="c631d-1185">虛擬方法會先引發，並可以操作為必要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1185">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c631d-1186">則<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1186">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c631d-1187">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1187">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c631d-1188">因此您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="c631d-1188">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c631d-1189">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1189">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1190">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1190">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1191">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1191">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1192">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1192">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1193">當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1193">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1194">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1194">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1195">按鍵輸入是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1195">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1196">其他可依賴按鍵，例如，輸入和命令繫結的程式設計功能可能會處理按鍵之前它會公開為一般的按鍵輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-1196">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="c631d-1197">如果這些輸入系統功能將事件標示為已處理，然後<xref:System.Windows.ContentElement.OnKeyDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1197">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1198">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1198">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1199">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1199">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1200">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1200">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1201">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1201">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1202">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1202">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1203">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1203">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1204">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1204">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1205">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1205">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1206">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1206">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1207">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1207">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1208">當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1208">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1209">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1209">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1210">按鍵輸入是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1210">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1211">其他可依賴按鍵，例如，輸入和命令繫結的程式設計功能可能會處理按鍵之前它會公開為一般的按鍵輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-1211">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="c631d-1212">如果這些輸入系統功能將事件標示為已處理，然後<xref:System.Windows.ContentElement.OnKeyUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1212">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1213">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1213">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1214">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1214">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1215">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1215">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1216">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1216">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1217">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1217">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1218">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1218">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1219">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1219">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1220">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1220">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1221">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1221">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1222">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1222">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="c631d-1223">此事件資料必須包含 <see cref="E:System.Windows.ContentElement.LostFocus" /> 事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-1223">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="c631d-1224">使用所提供的事件資料引發 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1224">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1225">此方法中，雖然是虛擬的沒有預設實作會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1225">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="c631d-1226">這在 \* 方法實作用來引發事件，這個相同的方法實作是在內部叫用來引發事件時<xref:System.Windows.ContentElement.IsFocused%2A>屬性值變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-1226">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="c631d-1227">這項實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 只提供便利的方式來加入類別處理該事件的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1227">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c631d-1228">除非您有不會引發焦點事件變成故意或不尋常的需要，請確定您的實作會呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1228">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="c631d-1229">否則，<see cref="E:System.Windows.ContentElement.LostFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1229">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="c631d-1230">如果您不想要您可設定焦點的項目，您可以防止項目設定成為可設定焦點<see cref="P:System.Windows.ContentElement.Focusable" />至<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1230">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1231">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1231">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1232">當未處理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1232">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1233">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1233">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1234">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1234">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1235">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1235">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1236">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1236">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1237">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1237">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1238">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1238">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1239">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1239">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1240">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1240">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1241">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1241">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1242">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1242">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1243">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1243">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1244">當未處理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1244">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1245">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1245">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1246">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1246">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1247">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1247">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1248">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1248">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1249">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1249">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1250">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1250">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1251">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1251">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1252">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1252">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1253">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1253">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1254">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1254">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1255">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1255">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1256">當未處理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1256">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1257">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1257">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1258">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1258">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1259">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1259">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1260">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1260">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1261">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1261">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1262">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1262">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1263">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1263">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1264">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1264">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1265">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1265">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1266">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1266">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1267"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1267">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1268">提供的類別處理<see cref="E:System.Windows.ContentElement.LostTouchCapture" />路由的事件的這個項目失去觸控擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-1268">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1269"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1269">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1270">覆寫<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>衍生類別來處理在<xref:System.Windows.ContentElement.LostTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1270">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="c631d-1271">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1271">Be sure to call the base class' <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1272">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1272">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1273">此事件資料會報告有關按下的滑鼠按鈕以及已處理狀態的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="c631d-1273">This event data reports details about the mouse button that was pressed and the handled state.</span></span></param>
        <summary><span data-ttu-id="c631d-1274">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1274">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1275">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1275">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1276">滑鼠按鈕的動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1276">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1277">其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1277">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c631d-1278">如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.ContentElement.OnMouseDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1278">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1279">如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.ContentElement.MouseLeftButtonDown>和<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1279">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c631d-1280">其中一個這些事件可能會發生在接收端的項目上時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="c631d-1280">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c631d-1281">如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-1281">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c631d-1282">如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1282">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c631d-1283">類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-1283">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c631d-1284">藉由處理<xref:System.Windows.ContentElement.OnMouseDown%2A>，當其中隱含類別處理負責動作下的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="c631d-1284">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="c631d-1285">此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1285">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c631d-1286">每個特定按鈕的直接事件也有虛擬機器 \* 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。</span><span class="sxs-lookup"><span data-stu-id="c631d-1286">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c631d-1287">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1287">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1288">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1288">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1289">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1289">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1290">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1290">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1291">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1291">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1292">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1292">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1293">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1293">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1294">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1294">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1295">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1295">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1296">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1296">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1297">當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1297">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span></span> <span data-ttu-id="c631d-1298">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1298">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1299">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1299">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1300">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1300">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1301">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1301">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c631d-1302">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1302">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1303">在此情況下，符合的事件是路由的事件，提供直接的路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-1303">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="c631d-1304">將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1304">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1305">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1305">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1306">當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1306">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span></span> <span data-ttu-id="c631d-1307">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1307">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1308">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1308">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1309">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1309">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1310">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1310">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c631d-1311">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1311">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1312">在此情況下，符合的事件是路由的事件，提供直接的路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-1312">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="c631d-1313">將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1313">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1314">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1314">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1315">事件資料會報告滑鼠左鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1315">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="c631d-1316">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1316">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span></span> <span data-ttu-id="c631d-1317">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1317">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1318"><xref:System.Windows.ContentElement.MouseLeftButtonDown>似乎事件反昇路由事件，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1318">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1319"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1319"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="c631d-1320">雖然您可以將標記<xref:System.Windows.ContentElement.MouseLeftButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1320">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1321">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1321">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1322">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1322">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1323">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1323">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1324">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1324">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1325">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1325">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c631d-1326">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1326">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c631d-1327">不論您選擇呼叫的基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-1327">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c631d-1328">無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1328">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="c631d-1329">例如，您可以從衍生<xref:System.Windows.Controls.Button>，並覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>在您的衍生類別，而不需要呼叫基底實作中，不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1329">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1330">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1330">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1331">事件資料會報告已放開滑鼠左鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-1331">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="c631d-1332">當未處理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1332">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1333">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1333">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1334"><xref:System.Windows.ContentElement.MouseLeftButtonUp>似乎事件反昇路由事件，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1334">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1335"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1335"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="c631d-1336">雖然您可以將標記<xref:System.Windows.ContentElement.MouseLeftButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1336">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1337">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1337">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1338">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1338">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1339">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1339">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1340">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1340">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1341">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1341">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1342">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1342">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1343">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1343">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1344">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1344">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1345">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1345">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1346">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1346">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1347">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1347">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1348">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1348">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1349">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1349">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1350">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1350">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1351">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1351">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1352">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1352">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1353">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1353">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1354">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1354">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1355">事件資料會報告滑鼠右鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1355">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="c631d-1356">當未處理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1356">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1357">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1357">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1358"><xref:System.Windows.ContentElement.MouseRightButtonDown>似乎事件反昇路由事件，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1358">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1359"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1359"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c631d-1360">雖然您可以將標記<xref:System.Windows.ContentElement.MouseRightButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1360">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1361">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1361">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1362">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1362">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1363">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1363">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1364">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1364">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1365">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1365">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c631d-1366">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1366">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c631d-1367">不論您選擇呼叫的基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-1367">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c631d-1368">無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1368">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="c631d-1369">例如，您可以從衍生<xref:System.Windows.Controls.Control>，並覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>在您的衍生類別，而不需要呼叫基底; 不過，此覆寫會停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。</span><span class="sxs-lookup"><span data-stu-id="c631d-1369">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1370">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1370">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1371">事件資料會報告已放開滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-1371">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="c631d-1372">當未處理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1372">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1373">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1373">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1374"><xref:System.Windows.ContentElement.MouseRightButtonUp>似乎事件反昇路由事件，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1374">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1375"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1375"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="c631d-1376">雖然您可以將標記<xref:System.Windows.ContentElement.MouseRightButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1376">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1377">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1377">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1378">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1378">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1379">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1379">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1380">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1380">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1381">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1381">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1382">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1382">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1383">事件資料會報告滑鼠按鈕已釋放。</span><span class="sxs-lookup"><span data-stu-id="c631d-1383">The event data reports that the mouse button was released.</span></span></param>
        <summary><span data-ttu-id="c631d-1384">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1384">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1385">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1385">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1386">滑鼠按鈕的動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1386">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1387">其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1387">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c631d-1388">如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.ContentElement.OnMouseUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1388">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1389">如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.ContentElement.MouseLeftButtonUp>和<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1389">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="c631d-1390">其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="c631d-1390">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c631d-1391">如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-1391">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c631d-1392">如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1392">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c631d-1393">類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-1393">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c631d-1394">藉由處理<xref:System.Windows.ContentElement.OnMouseUp%2A>，當其中隱含類別處理負責處理動作的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="c631d-1394">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="c631d-1395">此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1395">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c631d-1396">每個特定按鈕的直接事件也有虛擬機器 \* 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。</span><span class="sxs-lookup"><span data-stu-id="c631d-1396">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c631d-1397">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1397">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1398">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1398">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1399">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1399">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1400">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1400">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1401">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1401">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1402">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1402">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1403">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1403">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1404">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1404">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1405">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1405">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1406">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1406">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1407">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1407">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1408">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1408">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1409">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1409">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1410">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1410">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1411">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1411">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1412">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1412">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1413">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1413">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1414">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1414">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1415">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1415">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1416">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1416">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1417">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1417">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1418">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1418">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1419">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1419">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1420">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1420">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1421">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1421">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1422">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1422">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1423">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1423">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1424">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1424">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1425">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1425">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1426">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1426">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1427">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1427">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1428">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1428">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1429">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1429">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1430">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1430">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1431">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1431">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1432">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1432">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1433">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1433">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1434">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1434">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1435">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1435">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1436">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1436">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1437">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1437">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1438">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1438">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1439">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1439">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1440">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1440">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1441">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1441">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1442">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1442">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1443">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1443">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1444">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1444">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1445">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1445">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1446">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1446">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1447">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1447">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1448">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1448">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1449">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1449">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1450">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1450">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1451">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1451">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1452">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1452">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1453">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1453">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1454">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1454">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1455">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1455">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1456">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1456">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1457">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1457">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1458">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1458">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1459">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1459">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1460">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1460">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1461">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1461">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1462">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1462">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1463">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1463">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1464">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1464">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1465">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1465">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1466">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1466">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1467">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1467">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1468">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1468">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1469">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1469">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1470">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1470">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1471">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1471">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1472">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1472">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1473">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1473">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1474">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1474">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1475">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1475">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1476">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1476">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1477">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1477">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1478">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1478">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1479">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1479">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1480">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1480">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1481">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1481">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1482">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1482">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1483">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1483">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1484">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1484">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1485">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1485">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1486">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1486">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1487">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1487">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1488">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1488">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1489">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1489">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1490">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1490">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1491">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1491">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1492">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1492">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1493">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1493">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1494">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1494">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1495">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1495">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1496">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1496">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1497">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1497">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1498">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1498">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1499">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1499">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1500">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1500">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1501">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1501">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1502">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1502">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1503">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1503">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1504">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1504">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1505">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1505">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1506">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1506">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1507">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1507">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1508">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1508">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1509">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1509">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1510">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1510">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1511">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1511">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1512">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1512">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1513">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1513">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1514">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1514">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1515">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1515">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1516">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1516">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1517">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1517">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1518">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1518">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1519">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1519">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1520">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1520">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1521">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1521">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1522">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1522">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1523">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1523">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1524">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1524">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1525">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1525">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1526">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1526">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1527">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1527">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1528">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1528">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1529">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1529">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1530">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1530">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1531">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1531">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1532">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1532">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1533">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1533">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1534">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1534">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1535">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1535">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1536">事件資料會報告一個或多個滑鼠按鈕已按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1536">The event data reports that one or more mouse buttons were pressed.</span></span></param>
        <summary><span data-ttu-id="c631d-1537">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1537">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1538">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1538">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1539">滑鼠按鈕的動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1539">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1540">其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1540">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c631d-1541">如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1541">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1542">如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1542">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="c631d-1543">其中一個這些事件可能會發生在接收端的項目上時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="c631d-1543">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c631d-1544">如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-1544">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c631d-1545">如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1545">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c631d-1546">類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-1546">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c631d-1547">藉由處理<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>，當其中隱含類別處理負責動作下的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="c631d-1547">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="c631d-1548">此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1548">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c631d-1549">每個特定按鈕的直接事件也有虛擬機器 \* 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。</span><span class="sxs-lookup"><span data-stu-id="c631d-1549">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c631d-1550">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1550">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1551">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1551">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1552">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1552">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1553">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1553">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1554">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1554">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1555">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1555">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1556">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1556">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1557">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1557">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1558">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1558">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1559">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1559">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1560">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1560">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1561">事件資料會報告滑鼠左鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1561">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="c631d-1562">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1562">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1563">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1563">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1564"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1564">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1565"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1565"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="c631d-1566">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1566">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1567">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1567">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1568">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1568">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1569">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1569">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1570">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1570">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1571">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1571">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c631d-1572">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1572">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c631d-1573">不論您選擇呼叫的基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-1573">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c631d-1574">無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1574">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="c631d-1575">例如，您可以從衍生<xref:System.Windows.Controls.Button>，並覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>在您的衍生類別，而不需要呼叫基底實作中，不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1575">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1576">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1576">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1577">事件資料會報告已放開滑鼠左鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-1577">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="c631d-1578">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1578">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1579">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1579">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1580"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1580">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1581"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1581"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="c631d-1582">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1582">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1583">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1583">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1584">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1584">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1585">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1585">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1586">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1586">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1587">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1587">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1588">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1588">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1589">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1589">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1590">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1590">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1591">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1591">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1592">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1592">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1593">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1593">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1594">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1594">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1595">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1595">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1596">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1596">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1597">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1597">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1598">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1598">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1599">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1599">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1600">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1600">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1601">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1601">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1602">事件資料會報告滑鼠右鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1602">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="c631d-1603">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1603">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1604">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1604">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1605"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1605">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1606"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1606"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c631d-1607">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1607">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1608">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1608">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1609">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1609">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1610">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1610">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1611">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1611">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1612">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1612">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c631d-1613">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1613">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c631d-1614">不論您選擇呼叫的基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-1614">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c631d-1615">無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1615">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="c631d-1616">例如，您可以從衍生<xref:System.Windows.Controls.Control>，並覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>在您的衍生類別，而不需要呼叫基底; 不過，此覆寫會停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。</span><span class="sxs-lookup"><span data-stu-id="c631d-1616">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1617">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1617">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1618">事件資料會報告已放開滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-1618">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="c631d-1619">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1619">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1620">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1620">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1621"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。</span><span class="sxs-lookup"><span data-stu-id="c631d-1621">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c631d-1622"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1622"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="c631d-1623">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1623">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c631d-1624">不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1624">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c631d-1625">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1625">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c631d-1626">如果您想要覆寫此邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-1626">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c631d-1627">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1627">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c631d-1628">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1628">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1629">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1629">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="c631d-1630">事件資料會報告一個或多個滑鼠按鈕已釋放。</span><span class="sxs-lookup"><span data-stu-id="c631d-1630">The event data reports that one or more mouse buttons were released.</span></span></param>
        <summary><span data-ttu-id="c631d-1631">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1631">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1632">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1632">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1633">滑鼠按鈕的動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1633">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c631d-1634">其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1634">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c631d-1635">如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1635">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c631d-1636">如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-1636">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="c631d-1637">其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="c631d-1637">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c631d-1638">如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="c631d-1638">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c631d-1639">如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1639">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c631d-1640">類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="c631d-1640">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c631d-1641">藉由處理<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>，當其中隱含類別處理負責處理動作的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="c631d-1641">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="c631d-1642">此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1642">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c631d-1643">每個特定按鈕的直接事件也有虛擬機器 \* 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。</span><span class="sxs-lookup"><span data-stu-id="c631d-1643">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c631d-1644">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1644">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1645">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1645">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1646">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1646">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1647">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1647">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1648">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1648">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1649">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1649">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1650">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1650">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1651">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1651">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1652">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1652">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1653">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1653">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1654">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1654">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1655">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1655">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1656">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1656">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1657">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1657">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1658">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1658">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1659">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1659">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1660">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1660">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1661">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1661">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1662">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1662">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1663">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1663">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1664">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1664">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1665">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1665">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1666">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1666">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1667">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1667">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1668">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1668">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1669">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1669">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1670">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1670">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1671">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1671">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1672">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1672">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1673">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1673">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1674">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1674">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1675">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1675">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1676">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1676">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1677">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1677">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1678">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1678">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1679">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1679">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1680">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1680">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1681">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1681">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1682">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1682">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1683">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1683">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1684">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1684">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1685">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1685">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1686">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1686">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1687">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1687">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1688">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1688">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1689">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1689">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1690">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1690">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1691">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1691">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1692">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1692">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1693">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1693">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1694">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1694">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1695">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1695">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1696">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1696">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1697">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1697">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1698">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1698">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1699">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1699">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1700">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1700">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1701">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1701">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1702">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1702">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1703">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1703">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1704">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1704">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1705">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1705">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1706">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1706">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1707">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1707">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1708">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1708">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1709">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1709">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1710">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1710">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1711">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1711">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1712">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1712">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1713">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1713">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1714">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1714">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1715">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1715">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1716">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1716">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1717">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1717">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1718">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1718">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1719">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1719">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1720">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1720">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1721">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1721">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1722">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1722">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1723">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1723">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1724">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1724">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1725">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1725">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1726">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1726">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1727">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1727">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1728">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1728">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1729">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1729">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1730">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1730">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1731">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1731">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1732">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1732">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1733">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1733">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1734">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1734">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1735">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1735">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1736">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1736">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1737">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1737">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1738">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1738">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1739">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1739">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1740">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1740">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1741">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1741">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1742">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1742">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1743">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1743">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1744">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1744">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1745">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1745">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1746">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1746">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1747">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1747">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1748">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1748">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1749">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1749">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1750">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1750">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1751">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1751">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1752">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1752">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1753">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1753">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1754">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1754">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1755">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1755">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1756">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1756">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1757">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1757">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1758">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1758">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1759">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1759">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1760">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1760">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1761">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1761">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1762">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1762">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1763">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1763">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1764">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1764">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1765">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1765">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1766">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1766">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1767">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1767">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1768">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1768">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1769">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1769">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1770">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1770">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1771">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1771">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1772">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1772">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1773">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1773">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1774">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1774">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1775">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1775">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1776">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1776">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1777">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1777">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1778">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1778">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1779">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1779">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1780">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1780">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1781">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1781">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1782">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1782">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1783">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1783">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1784">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1784">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1785">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1785">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1786">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1786">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1787">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1787">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1788">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1788">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1789">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1789">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1790">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1790">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1791">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1791">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1792">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1792">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1793">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1793">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1794">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1794">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1795">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1795">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1796">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1796">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1797">當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1797">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1798">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1798">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1799">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1799">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1800">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1800">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1801">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1801">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1802">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1802">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1803">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1803">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1804">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1804">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1805">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1805">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1806">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1806">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1807">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1807">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c631d-1808">是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。</span><span class="sxs-lookup"><span data-stu-id="c631d-1808">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1809"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1809">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1810">提供的類別處理<see cref="E:System.Windows.ContentElement.PreviewTouchDown" />路由在觸控按下此項目時所發生的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1810">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1811"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1811">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1812">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>衍生類別來處理在<xref:System.Windows.ContentElement.PreviewTouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1812">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="c631d-1813">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1813">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1814"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1814">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1815">提供的類別處理<see cref="E:System.Windows.ContentElement.PreviewTouchMove" />路由的事件的觸控式移動此項目內時，就會發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-1815">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1816"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1816">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1817">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>衍生類別來處理在<xref:System.Windows.ContentElement.PreviewTouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1817">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="c631d-1818">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1818">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1819"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1819">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1820">提供的類別處理<see cref="E:System.Windows.ContentElement.PreviewTouchUp" />發生於此項目內放開觸控時的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1820">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1821"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1821">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1822">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>衍生類別來處理在<xref:System.Windows.ContentElement.PreviewTouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1822">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="c631d-1823">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1823">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1824">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1824">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1825">當未處理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1825">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1826">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1826">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1827">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1827">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1828">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1828">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1829">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1829">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1830">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1830">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1831">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1831">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1832">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1832">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1833">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1833">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1834">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1834">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1835">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1835">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1836">包含事件資料的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1836">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1837">當未處理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1837">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1838">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1838">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1839">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1839">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1840">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1840">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1841">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1841">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1842">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1842">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1843">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1843">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1844">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1844">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1845">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1845">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1846">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1846">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1847">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1847">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1848">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1848">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1849">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1849">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1850">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1850">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1851">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1851">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1852">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1852">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1853">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1853">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1854">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1854">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1855">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1855">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1856">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1856">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1857">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1857">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1858">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1858">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1859">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1859">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1860">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1860">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1861">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1861">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1862">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1862">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1863">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1863">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1864">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1864">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1865">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1865">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1866">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1866">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1867">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1867">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1868">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1868">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1869">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1869">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1870">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1870">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1871">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1871">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1872">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1872">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1873">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1873">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1874">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1874">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1875">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1875">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1876">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1876">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1877">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1877">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1878">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1878">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1879">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1879">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1880">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1880">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1881">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1881">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1882">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1882">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1883">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1883">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1884">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1884">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1885">當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1885">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span></span> <span data-ttu-id="c631d-1886">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1886">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1887">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1887">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1888">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1888">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1889">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1889">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c631d-1890">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1890">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1891">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1891">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1892">將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1892">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1893">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1893">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1894">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1894">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1895">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1895">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1896">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1896">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1897">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1897">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1898">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1898">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1899">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1899">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1900">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1900">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1901">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1901">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1902">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1902">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1903">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1903">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1904">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1904">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1905">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1905">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1906">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1906">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1907">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1907">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1908">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1908">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1909">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1909">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1910">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1910">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1911">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1911">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1912">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1912">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1913">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1913">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1914">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1914">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1915">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1915">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1916">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1916">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1917">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1917">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1918">當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1918">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span></span> <span data-ttu-id="c631d-1919">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1919">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1920">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1920">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1921">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1921">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c631d-1922">您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-1922">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c631d-1923">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1923">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1924">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1924">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1925">將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1925">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1926">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1926">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1927">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1927">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1928">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1928">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1929">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1929">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1930">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1930">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1931">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1931">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1932">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1932">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1933">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1933">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1934">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1934">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1935">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1935">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1936">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1936">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1937">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1937">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1938">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1938">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1939">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1939">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1940">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1940">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1941">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1941">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1942">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1942">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1943">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1943">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1944">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1944">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1945">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1945">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1946">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1946">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1947">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1947">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1948">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1948">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1949">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1949">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1950">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1950">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1951">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1951">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1952">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1952">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1953">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1953">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1954">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1954">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1955">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1955">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1956">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1956">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1957">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1957">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1958">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1958">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1959">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1959">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1960">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1960">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1961">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1961">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1962">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1962">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1963">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1963">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1964">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1964">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1965">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1965">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1966">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1966">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1967">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1967">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1968">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1968">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1969">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1969">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1970">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1970">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1971">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1971">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1972">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1972">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1973">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1973">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1974">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-1974">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1975">當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-1975">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="c631d-1976">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1976">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1977">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1977">This method has no default implementation.</span></span> <span data-ttu-id="c631d-1978">因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1978">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c631d-1979">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-1979">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c631d-1980">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1980">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c631d-1981">On \* 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-1981">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c631d-1982">因此，您的實作必須檢查的事件資料的來源屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-1982">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c631d-1983">它不應該嘗試重新引發此事件，在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c631d-1983">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c631d-1984">藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-1984">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c631d-1985">其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-1985">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1986"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1986">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1987">提供的類別處理<see cref="E:System.Windows.ContentElement.TouchDown" />發生於在觸控按下此項目內的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1987">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1988"><xref:System.Windows.ContentElement.OnTouchDown%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1988">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1989">覆寫<xref:System.Windows.ContentElement.OnTouchDown%2A>衍生類別來處理在<xref:System.Windows.ContentElement.TouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1989">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="c631d-1990">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnTouchDown%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1990">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1991"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1991">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1992">提供的類別處理<see cref="E:System.Windows.ContentElement.TouchEnter" />路由的事件，當觸控從移動時，就會發生外部或內部此元素的邊界。</span><span class="sxs-lookup"><span data-stu-id="c631d-1992">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1993"><xref:System.Windows.ContentElement.OnTouchEnter%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1993">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1994">覆寫<xref:System.Windows.ContentElement.OnTouchEnter%2A>衍生類別來處理在<xref:System.Windows.ContentElement.TouchEnter>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1994">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="c631d-1995">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnTouchEnter%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1995">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-1996"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-1996">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-1997">提供的類別處理<see cref="E:System.Windows.ContentElement.TouchLeave" />路由的事件，當觸控從移動時，就會發生內部或外部此元素的邊界。</span><span class="sxs-lookup"><span data-stu-id="c631d-1997">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-1998"><xref:System.Windows.ContentElement.OnTouchLeave%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-1998">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-1999">覆寫<xref:System.Windows.ContentElement.OnTouchLeave%2A>衍生類別來處理在<xref:System.Windows.ContentElement.TouchLeave>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-1999">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="c631d-2000">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnTouchLeave%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2000">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-2001"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-2001">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-2002">提供的類別處理<see cref="E:System.Windows.ContentElement.TouchMove" />路由的事件的觸控式移動此項目內時，就會發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2002">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2003"><xref:System.Windows.ContentElement.OnTouchMove%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-2003">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-2004">覆寫<xref:System.Windows.ContentElement.OnTouchMove%2A>衍生類別來處理在<xref:System.Windows.ContentElement.TouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2004">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="c631d-2005">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnTouchMove%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2005">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-2006"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="c631d-2006">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="c631d-2007">提供的類別處理<see cref="E:System.Windows.ContentElement.TouchUp" />發生於此項目內放開觸控時的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2007">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2008"><xref:System.Windows.ContentElement.OnTouchUp%2A>方法有沒有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-2008">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="c631d-2009">覆寫<xref:System.Windows.ContentElement.OnTouchUp%2A>衍生類別來處理在<xref:System.Windows.ContentElement.TouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2009">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="c631d-2010">請務必呼叫基底類別<xref:System.Windows.ContentElement.OnTouchUp%2A>方法的基底類別，因此可接收事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2010">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="c631d-2011">要求的焦點周遊方向。</span><span class="sxs-lookup"><span data-stu-id="c631d-2011">The direction of the requested focus traversal.</span></span></param>
        <summary><span data-ttu-id="c631d-2012">當在衍生類別中覆寫時，傳回的項目，會接收指定的焦點周遊方向焦點，而不實際將焦點移至該項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2012">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span></span></summary>
        <returns><span data-ttu-id="c631d-2013">項目，就會取得焦點，如果<see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />實際上有叫用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2013">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2014">這個類別中，這個方法的預設實作不完整，而且一律傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-2014">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2015">輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2015">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2016">此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewDragEnter>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2016">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2017">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewDragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2017">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2018">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2018">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2019">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2019">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="c631d-2020">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2020">Routing strategy</span></span>|<span data-ttu-id="c631d-2021">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2021">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2022">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2022">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-2023">對應的事件反昇事件是<xref:System.Windows.ContentElement.DragEnter>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2023">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="c631d-2024">覆寫<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2024">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2025">識別 <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2025">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2026">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2026">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2027">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2027">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2028">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2028">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2029">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2029">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2030">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2030">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2031">輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2031">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2032">此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewDragLeave>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2032">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2033">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewDragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2033">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2034">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2034">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2035">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2035">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="c631d-2036">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2036">Routing strategy</span></span>|<span data-ttu-id="c631d-2037">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2037">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2038">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2038">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-2039">對應的事件反昇事件是<xref:System.Windows.ContentElement.DragLeave>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2039">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="c631d-2040">覆寫<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2040">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2041">識別 <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2041">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2042">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2042">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2043">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2043">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2044">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2044">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2045">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2045">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2046">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2046">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2047">在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2047">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2048">此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewDragOver>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2048">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2049">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewDragOver>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2049">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2050">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2050">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2051">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2051">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="c631d-2052">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2052">Routing strategy</span></span>|<span data-ttu-id="c631d-2053">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2053">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2054">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2054">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-2055">對應的事件反昇事件是<xref:System.Windows.ContentElement.DragOver>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2055">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="c631d-2056">覆寫<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2056">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2057">識別 <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2057">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2058">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2058">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2059">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2059">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2060">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2060">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2061">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2061">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2062">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2062">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2063">輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2063">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2064">此事件建立的別名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewDrop>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2064">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2065">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewDrop>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2065">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2066">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2066">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2067">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2067">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="c631d-2068">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2068">Routing strategy</span></span>|<span data-ttu-id="c631d-2069">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2069">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2070">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2070">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c631d-2071">對應的事件反昇事件是<xref:System.Windows.ContentElement.Drop>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2071">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="c631d-2072">覆寫<xref:System.Windows.ContentElement.OnPreviewDrop%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2072">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2073">識別 <see cref="E:System.Windows.ContentElement.PreviewDrop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2073">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2074">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2074">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2075">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2075">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2076">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2076">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2077">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2077">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2078">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2078">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2079">拖放操作開始時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2079">Occurs when a drag-and-drop operation is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2080"><xref:System.Windows.ContentElement.PreviewGiveFeedback>事件可讓使用者視覺化回饋提供拖放作業期間修改滑鼠指標的外觀的拖曳事件的來源。</span><span class="sxs-lookup"><span data-stu-id="c631d-2080">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="c631d-2081">此事件建立的別名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewGiveFeedback>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2081">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2082">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewGiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2082">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2083">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2083">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2084">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2084">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="c631d-2085">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2085">Routing strategy</span></span>|<span data-ttu-id="c631d-2086">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2086">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2087">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2087">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="c631d-2088">對應的事件反昇事件是<xref:System.Windows.ContentElement.GiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2088">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="c631d-2089">覆寫<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2089">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2090">識別 <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2090">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2091">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2091">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2092">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2092">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2093">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2093">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2094">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2094">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2095">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2095">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2096">鍵盤以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2096">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2097">這個事件會使用通道路由，因為具有焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2097">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-2098">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際擁有焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-2098">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="c631d-2099">此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2099">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2100">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2100">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2101">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2101">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2102">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2102">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="c631d-2103">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2103">Routing strategy</span></span>|<span data-ttu-id="c631d-2104">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2104">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2105">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2105">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c631d-2106">對應的事件反昇事件是<xref:System.Windows.ContentElement.GotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2106">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c631d-2107">覆寫<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2107">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2108">識別 <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2108">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2109">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2109">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2110">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2110">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2111">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2111">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2112">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2112">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2113">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2113">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2114">鍵盤以此元素為焦點且按下按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2114">Occurs when a key is pressed while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2115">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="c631d-2115">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c631d-2116"><xref:System.Windows.ContentElement.KeyDown>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。</span><span class="sxs-lookup"><span data-stu-id="c631d-2116">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c631d-2117">這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2117">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="c631d-2118">此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewKeyDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2118">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2119">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewKeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2119">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2120">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2120">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2121">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2121">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="c631d-2122">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2122">Routing strategy</span></span>|<span data-ttu-id="c631d-2123">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2123">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2124">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2124">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c631d-2125">對應的事件反昇事件是<xref:System.Windows.ContentElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2125">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2126">覆寫<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2126">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2127">識別 <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2127">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2128">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2128">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2129">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2129">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2130">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2130">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2131">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2131">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2132">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2132">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2133">鍵盤以此元素為焦點且放開按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2133">Occurs when a key is released while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2134">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="c631d-2134">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c631d-2135"><xref:System.Windows.ContentElement.KeyUp>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。</span><span class="sxs-lookup"><span data-stu-id="c631d-2135">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c631d-2136">這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2136">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="c631d-2137">如需詳細資訊，請檢查個別控制項的文件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2137">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="c631d-2138">此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewKeyUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2138">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2139">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewKeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2139">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2140">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2140">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2141">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2141">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="c631d-2142">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2142">Routing strategy</span></span>|<span data-ttu-id="c631d-2143">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2143">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2144">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2144">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c631d-2145">對應的事件反昇事件是<xref:System.Windows.ContentElement.KeyUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2145">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2146">覆寫<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2146">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2147">識別 <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2147">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2148">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2148">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2149">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2149">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2150">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2150">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2151">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2151">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2152">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2152">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2153">鍵盤不再以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2153">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2154">由於這個事件會使用通道路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2154">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c631d-2155">檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="c631d-2155">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c631d-2156">此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2156">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2157">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2157">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2158">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2158">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2159">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2159">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="c631d-2160">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2160">Routing strategy</span></span>|<span data-ttu-id="c631d-2161">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2161">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2162">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2162">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c631d-2163">對應的事件反昇事件是<xref:System.Windows.ContentElement.LostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2163">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c631d-2164">覆寫<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2164">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2165">識別 <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2165">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2166">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2166">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2167">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2167">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2168">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2168">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2169">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2169">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2170">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2170">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2171">指標在此元素上方且按下任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2171">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2172">此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewMouseDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2172">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2173">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewMouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2173">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2174"><xref:System.Windows.ContentElement.PreviewMouseDown>通常就會引發事件一起<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>，對應到其中的兩個標準的滑鼠按鈕按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-2174">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c631d-2175"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 並<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2175"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c631d-2176">請參閱備註<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2176">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2177">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2177">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2178">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2178">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="c631d-2179">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2179">Routing strategy</span></span>|<span data-ttu-id="c631d-2180">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2180">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2181">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2181">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2182">對應的事件反昇事件是<xref:System.Windows.ContentElement.MouseDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2182">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2183">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2183">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2184">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2184">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2185">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2185">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2186">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2186">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2187">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2187">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2188">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2188">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2189">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2189">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2190">滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2190">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2191">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循通道路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2191">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-2192">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2192">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-2193">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2193">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-2194">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2194">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-2195">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2195">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-2196">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2196">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-2197">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2197">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2198">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2198">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2199">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2199">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="c631d-2200">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2200">Routing strategy</span></span>|<span data-ttu-id="c631d-2201">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2201">Direct</span></span>|  
|<span data-ttu-id="c631d-2202">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2202">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2203">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2203">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2204">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2204">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2205">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2205">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2206">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2206">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2207">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2207">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2208">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2208">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2209">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2209">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2210">滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2210">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2211">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循通道路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2211">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-2212">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2212">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-2213">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2213">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-2214">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2214">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-2215">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2215">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-2216">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2216">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-2217">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2217">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2218">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2218">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2219">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2219">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="c631d-2220">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2220">Routing strategy</span></span>|<span data-ttu-id="c631d-2221">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2221">Direct</span></span>|  
|<span data-ttu-id="c631d-2222">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2222">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2223">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2223">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2224">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2224">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2225">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2225">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2226">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2226">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2227">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2227">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2228">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2228">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2229">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2229">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2230">滑鼠指標在此元素上方且移動滑鼠指標時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2230">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2231">當發生這個事件都將滑鼠指標第一次進入項目的範圍中，也當滑鼠指標移動同時仍保有的項目範圍內。</span><span class="sxs-lookup"><span data-stu-id="c631d-2231">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="c631d-2232">此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewMouseMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2232">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2233">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2233">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2234">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2234">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2235">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2235">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="c631d-2236">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2236">Routing strategy</span></span>|<span data-ttu-id="c631d-2237">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2237">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2238">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2238">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c631d-2239">對應的事件反昇事件是<xref:System.Windows.ContentElement.MouseMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2239">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2240">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2240">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2241">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2241">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2242">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2242">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2243">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2243">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2244">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2244">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2245">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2245">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2246">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2246">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2247">滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2247">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2248">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循通道路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2248">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-2249">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2249">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-2250">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2250">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-2251">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2251">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-2252">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2252">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-2253">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2253">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-2254">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2254">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2255">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2255">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2256">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2256">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="c631d-2257">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2257">Routing strategy</span></span>|<span data-ttu-id="c631d-2258">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2258">Direct</span></span>|  
|<span data-ttu-id="c631d-2259">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2259">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2260">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2260">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2261">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2261">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2262">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2262">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2263">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2263">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2264">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2264">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2265">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2265">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2266">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2266">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2267">滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2267">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2268">雖然這[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎會遵循通道路由項目樹狀結構中，它實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2268">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c631d-2269">此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2269">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c631d-2270">此事件的引數公開 （expose) 的引數的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2270">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c631d-2271">如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2271">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c631d-2272">就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2272">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c631d-2273">事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2273">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c631d-2274">針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2274">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2275">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2275">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2276">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2276">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="c631d-2277">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2277">Routing strategy</span></span>|<span data-ttu-id="c631d-2278">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2278">Direct</span></span>|  
|<span data-ttu-id="c631d-2279">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2279">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2280">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2280">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2281">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2281">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2282">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2282">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2283">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2283">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2284">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2284">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2285">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2285">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2286">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2286">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2287">滑鼠指標在此元素上方且放開任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2287">Occurs when any mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2288">此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewMouseUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2288">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2289">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewMouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2289">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2290"><xref:System.Windows.ContentElement.PreviewMouseUp>通常就會引發事件一起<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>，對應到其中的兩個標準的滑鼠按鈕按下。</span><span class="sxs-lookup"><span data-stu-id="c631d-2290">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c631d-2291"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 並<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到達事件路由中的此項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2291"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c631d-2292">請參閱備註<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2292">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2293">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2293">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2294">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2294">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="c631d-2295">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2295">Routing strategy</span></span>|<span data-ttu-id="c631d-2296">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2296">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2297">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2297">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2298">對應的事件反昇事件是<xref:System.Windows.ContentElement.MouseUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2298">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2299">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2299">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2300">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2300">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2301">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2301">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2302">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2302">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2303">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2303">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2304">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2304">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2305">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2305">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2306">滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2306">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2307">焦點或滑鼠捕捉會優先於滑鼠指標的所在;因此，如果您接收這個事件的焦點或擷取的項目時，滑鼠指標實際上可能是透過另一個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2307">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="c631d-2308">此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewMouseMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2308">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2309">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2309">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2310">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2310">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2311">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2311">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="c631d-2312">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2312">Routing strategy</span></span>|<span data-ttu-id="c631d-2313">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2313">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2314">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2314">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="c631d-2315">對應的事件反昇事件是<xref:System.Windows.ContentElement.MouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2315">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="c631d-2316">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2316">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2317">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2317">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2318">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2318">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2319">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2319">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2320">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2320">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2321">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2321">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2322">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2322">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2323">拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2323">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2324"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件可讓拖曳來源，來宣告是否應取消拖放作業。</span><span class="sxs-lookup"><span data-stu-id="c631d-2324">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="c631d-2325">此事件建立的別名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2325">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2326">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2326">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2327">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2327">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2328">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2328">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="c631d-2329">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2329">Routing strategy</span></span>|<span data-ttu-id="c631d-2330">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2330">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2331">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2331">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="c631d-2332">對應的事件反昇事件是<xref:System.Windows.ContentElement.QueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2332">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="c631d-2333">覆寫<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2333">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2334">識別 <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2334">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2335">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2335">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2336">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2336">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2337">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2337">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2338">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2338">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2339">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2339">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2340">手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2340">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2341">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusButtonDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2341">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2342">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2342">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2343">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2343">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2344">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2344">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2345">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2345">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2346">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2346">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="c631d-2347">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2347">Routing strategy</span></span>|<span data-ttu-id="c631d-2348">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2348">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2349">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2349">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2350">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2350">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2351">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2351">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2352">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2352">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2353">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2353">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2354">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2354">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2355">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2355">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2356">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2356">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2357">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2357">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2358">手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2358">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2359">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusButtonUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2359">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2360">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2360">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2361">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2361">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2362">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2362">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2363">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2363">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2364">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2364">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="c631d-2365">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2365">Routing strategy</span></span>|<span data-ttu-id="c631d-2366">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2366">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2367">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2367">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2368">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2368">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2369">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2369">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2370">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2370">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2371">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2371">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2372">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2372">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2373">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2373">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2374">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2374">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2375">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2375">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2376">手寫筆在此項目上方且碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2376">Occurs when the stylus touches the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2377">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2377">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2378">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2378">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2379">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2379">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2380">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2380">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2381">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2381">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2382">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2382">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="c631d-2383">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2383">Routing strategy</span></span>|<span data-ttu-id="c631d-2384">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2384">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2385">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2385">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="c631d-2386">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2386">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2387">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2387">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2388">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2388">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2389">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2389">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2390">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2390">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2391">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2391">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2392">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2392">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2393">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2393">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2394">手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2394">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2395">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusInAirMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2395">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2396">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2396">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2397">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2397">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2398">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2398">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2399">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2400">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2400">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="c631d-2401">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2401">Routing strategy</span></span>|<span data-ttu-id="c631d-2402">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2402">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2403">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2403">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2404">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2404">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2405">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2405">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2406">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2406">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2407">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2408">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2409">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2410">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2411">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2412">手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2412">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2413">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusInRange>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2413">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2414">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2414">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2415">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2415">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2416">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2416">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2417">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2418">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2418">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="c631d-2419">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2419">Routing strategy</span></span>|<span data-ttu-id="c631d-2420">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2420">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2421">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2421">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2422">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2422">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="c631d-2423">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2423">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2424">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2424">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2425">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2425">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2426">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2426">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2427">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2427">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2428">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2428">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2429">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2429">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2430">手寫筆在項目上方移動時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2430">Occurs when the stylus moves while over the element.</span></span> <span data-ttu-id="c631d-2431">手寫筆必須在受到數位板偵測時移動才能引發此事件，否則會改為引發 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2431">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2432">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2432">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2433">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2433">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2434">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2434">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2435">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2435">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2436">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2437">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2437">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="c631d-2438">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2438">Routing strategy</span></span>|<span data-ttu-id="c631d-2439">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2439">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2440">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2440">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2441">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2441">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2442">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2442">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2443">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2443">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2444">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2445">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2446">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2447">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2448">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2449">手寫筆遠離數位板而無法被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2449">Occurs when the stylus is too far from the digitizer to be detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2450">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2450">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2451">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2451">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2452">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2452">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2453">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2453">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2454">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2454">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2455">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2455">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="c631d-2456">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2456">Routing strategy</span></span>|<span data-ttu-id="c631d-2457">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2457">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2458">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2458">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2459">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2459">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="c631d-2460">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2460">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2461">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2461">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2462">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2462">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2463">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2463">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2464">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2464">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2465">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2465">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2466">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2466">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2467">使用者執行其中一種手寫筆筆勢時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2467">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2468">手寫筆筆勢的相關資訊，請參閱<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2468">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="c631d-2469">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2469">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2470">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2470">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2471">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2471">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2472">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2472">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2473">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2473">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2474">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2474">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="c631d-2475">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2475">Routing strategy</span></span>|<span data-ttu-id="c631d-2476">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2476">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2477">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2477">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="c631d-2478">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2478">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="c631d-2479">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2479">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2480">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2480">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2481">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2481">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2482">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2482">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2483">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2483">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2484">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2484">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2485">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2485">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2486">手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2486">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2487">此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewStylusDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2487">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2488">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2488">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2489">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2489">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2490">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2490">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2491">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2491">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2492">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2492">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="c631d-2493">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2493">Routing strategy</span></span>|<span data-ttu-id="c631d-2494">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2494">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2495">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2495">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2496">對應的事件反昇事件是<xref:System.Windows.ContentElement.StylusUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2496">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2497">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2497">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2498">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2498">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2499">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2499">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2500">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2500">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2501">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2501">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2502">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2502">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2503">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2503">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2504">此元素以一種與裝置無關的方式取得文字時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2504">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2505"><xref:System.Windows.ContentElement.PreviewTextInput>事件可讓元件或應用程式以與裝置無關的方式接聽文字輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-2505">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="c631d-2506">鍵盤是主要的方法<xref:System.Windows.ContentElement.PreviewTextInput>; 不過也可以產生語音、 手寫和其他輸入的裝置<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2506">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="c631d-2507">因為索引鍵組合-在預設鍵盤或輸入的法編輯器-透過多個索引鍵的事件可能會引發一個文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2507">Because of key combinations - either in default keyboards or through input method editors - multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="c631d-2508">此事件建立的別名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.PreviewTextInput>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2508">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2509">附加至事件處理常式<xref:System.Windows.ContentElement.PreviewTextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2509">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2510">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2510">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2511">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2511">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="c631d-2512">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2512">Routing strategy</span></span>|<span data-ttu-id="c631d-2513">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2513">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2514">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2514">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="c631d-2515">對應的事件反昇事件是<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2515">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="c631d-2516">覆寫<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2516">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2517">識別 <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2517">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2518">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2518">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2519">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2519">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2520">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2520">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2521">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2521">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2522">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2522">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2523">手指在這個項目上方且在螢幕上觸控時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2523">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2524">根據預設，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指觸控螢幕，並移動之前不會發生的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2524">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="c631d-2525">手指在螢幕上按住卻不必移動它會使用按下並按住行為<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2525">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="c631d-2526">按住不放的行為相當於按一下滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-2526">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="c631d-2527">會造成<xref:System.Windows.ContentElement.PreviewTouchDown>並<xref:System.Windows.ContentElement.TouchDown>事件發生在手指觸控螢幕，如設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>; 附加屬性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="c631d-2527">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2528">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2528">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2529">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2529">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="c631d-2530">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2530">Routing strategy</span></span>|<span data-ttu-id="c631d-2531">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2531">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2532">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2532">Delegate</span></span>|<span data-ttu-id="c631d-2533"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2533"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2534">對應的事件反昇事件是<xref:System.Windows.ContentElement.TouchDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2534">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2535">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2535">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2536">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2536">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2537">手指在這個項目上方且在螢幕上移動時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2537">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2538">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2538">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2539">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2539">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="c631d-2540">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2540">Routing strategy</span></span>|<span data-ttu-id="c631d-2541">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2541">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2542">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2542">Delegate</span></span>|<span data-ttu-id="c631d-2543"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2543"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2544">對應的事件反昇事件是<xref:System.Windows.ContentElement.TouchMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2544">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2545">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2545">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2546">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2546">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2547">手指在這個項目上方且離開螢幕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2547">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2548">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2548">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2549">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2549">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="c631d-2550">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2550">Routing strategy</span></span>|<span data-ttu-id="c631d-2551">通道</span><span class="sxs-lookup"><span data-stu-id="c631d-2551">Tunneling</span></span>|  
|<span data-ttu-id="c631d-2552">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2552">Delegate</span></span>|<span data-ttu-id="c631d-2553"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2553"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2554">對應的事件反昇事件是<xref:System.Windows.ContentElement.TouchUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2554">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2555">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2555">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2556">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2556">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2557">拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2557">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2558"><xref:System.Windows.ContentElement.QueryContinueDrag>事件可讓拖曳來源能夠決定是否應取消拖放作業。</span><span class="sxs-lookup"><span data-stu-id="c631d-2558">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="c631d-2559">此事件建立的別名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.QueryContinueDrag>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2559">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2560">附加至事件處理常式<xref:System.Windows.ContentElement.QueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2560">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2561">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2561">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2562">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2562">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="c631d-2563">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2563">Routing strategy</span></span>|<span data-ttu-id="c631d-2564">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2564">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2565">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2565">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="c631d-2566">對應的通道事件是<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2566">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="c631d-2567">覆寫<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2567">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2568">識別 <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2568">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2569">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2569">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2570">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2570">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2571">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2571">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2572">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2572">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2573">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2573">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2574">要求顯示游標時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2574">Occurs when the cursor is requested to display.</span></span> <span data-ttu-id="c631d-2575">每當滑鼠指標移動至新位置時，都會引發此事件，這意謂游標物件可能會根據其新位置而變更。</span><span class="sxs-lookup"><span data-stu-id="c631d-2575">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2576">此事件建立的別名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.QueryCursor>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2576">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2577">附加至事件處理常式<xref:System.Windows.ContentElement.QueryCursor>事件會附加至基礎<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2577">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2578">此事件名稱所參考的資料指標不一定是文字游標 （有時稱為插入點）。</span><span class="sxs-lookup"><span data-stu-id="c631d-2578">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="c631d-2579">相反地，此內容中的資料指標是宣告螢幕上的圖形化顯示數個可能的輸入相關的裝置或在 Windows 程式設計的概念相關的物件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2579">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="c631d-2580">該物件由<xref:System.Windows.Input.Cursor>在 WPF 中的類別。</span><span class="sxs-lookup"><span data-stu-id="c631d-2580">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="c631d-2581">WPF 輸入的系統可讓您變更這個資料指標，當它表示滑鼠指標的螢幕上的位置。</span><span class="sxs-lookup"><span data-stu-id="c631d-2581">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="c631d-2582">您可以使用預先定義的值從<xref:System.Windows.Input.Cursors>列舉型別，或者您可以宣告為影像檔的自訂游標。</span><span class="sxs-lookup"><span data-stu-id="c631d-2582">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="c631d-2583">接聽<xref:System.Windows.ContentElement.QueryCursor>事件就不會針對資料指標管理而有效率的技術。</span><span class="sxs-lookup"><span data-stu-id="c631d-2583">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="c631d-2584">相反地，每個項目應該定義自己的資料指標行為<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2584">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="c631d-2585">您只應依賴<xref:System.Windows.ContentElement.QueryCursor>如果您不使用 WPF 架構層級基底項目，或在異常的情況下，其中定義每個項目為基礎的資料指標的行為不符合您的需求。</span><span class="sxs-lookup"><span data-stu-id="c631d-2585">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="c631d-2586">如需有關實作資料指標行為，以回應<xref:System.Windows.ContentElement.QueryCursor>，請參閱<xref:System.Windows.Input.QueryCursorEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2586">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2587">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2587">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2588">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2588">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="c631d-2589">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2589">Routing strategy</span></span>|<span data-ttu-id="c631d-2590">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2590">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2591">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2591">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="c631d-2592">沒有任何已定義的對應通道事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2592">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c631d-2593">覆寫<xref:System.Windows.ContentElement.OnQueryCursor%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2593">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2594">識別 <see cref="E:System.Windows.ContentElement.QueryCursor" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2594">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2595">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2595">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2596">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2596">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2597">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2597">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2598">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2598">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2599">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2599">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c631d-2600"><see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料，也會識別要引發的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2600">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span></span></param>
        <summary><span data-ttu-id="c631d-2601">引發特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2601">Raises a specific routed event.</span></span> <span data-ttu-id="c631d-2602">要引發的 <see cref="T:System.Windows.RoutedEvent" /> 是在所提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 執行個體內識別 (作為該事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2602">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2603">`e`參數的型別為路由的事件的所有資料的通用基底類型; 不過，事件資料應該被授與為最特定的事件資料類型，可供所引發的事件，因為<xref:System.Windows.RoutedEventArgs>衍生的類別包含實際的特定資料是針對特定的事件時，會引發這個事件的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2603">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="c631d-2604"><xref:System.Windows.RoutedEventArgs> 不是狀態屬性事件;它也會識別要引發哪個路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2604"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="c631d-2605">此事件引發的模式和路由的事件資料，同時與不同[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和資料類別，通常只包含事件相關的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2605">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c631d-2606">下列範例會建立事件資料、 將事件識別碼附加至資料，然後引發自訂的路由的事件使用事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2606">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-2607">釋放所有擷取到的觸控裝置，從這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2607">Releases all captured touch devices from this element.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-2608">如果這個項目保有擷取，請釋放滑鼠捕捉。</span><span class="sxs-lookup"><span data-stu-id="c631d-2608">Releases the mouse capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2609">如果這個項目未存放擷取，呼叫這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2609">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="c631d-2610">請考慮檢查值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>之前先呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2610">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c631d-2611">下列處理常式會擷取，或根據滑鼠按鈕狀態的滑鼠捕捉釋放。</span><span class="sxs-lookup"><span data-stu-id="c631d-2611">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="c631d-2612">此範例示範如何將擷取的滑鼠移動的替代方案的考量，而非移動滑鼠指標[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c631d-2612">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-2613">手寫筆裝置捕捉，則釋放如果這個項目保有擷取。</span><span class="sxs-lookup"><span data-stu-id="c631d-2613">Releases the stylus device capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2614">如果這個項目未存放擷取，呼叫這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2614">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="c631d-2615">請考慮檢查值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>之前先呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2615">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="c631d-2616">要釋放的裝置。</span><span class="sxs-lookup"><span data-stu-id="c631d-2616">The device to release.</span></span></param>
        <summary><span data-ttu-id="c631d-2617">正在嘗試釋出指定的觸控裝置，從這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2617">Attempts to release the specified touch device from this element.</span></span></summary>
        <returns><span data-ttu-id="c631d-2618"><see langword="true" /> 如果已發行的觸控裝置。否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2618"><see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c631d-2619"><paramref name="touchDevice" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2619"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="c631d-2620">處理常式附加的路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2620">The identifier of the.routed event for which the handler is attached.</span></span></param>
        <param name="handler"><span data-ttu-id="c631d-2621">要從這個項目上的事件處理常式集合中移除的特定處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-2621">The specific handler implementation to remove from the event handler collection on this element.</span></span></param>
        <summary><span data-ttu-id="c631d-2622">從這個項目中移除指定的路由事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2622">Removes the specified routed event handler from this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2623">最常見的案例，使用這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是您實作時會[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自訂路由事件，特別是當您實作在處理常式的 「 移除 」 邏輯時相關聯的 「 包裝函式 」 事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]層級。</span><span class="sxs-lookup"><span data-stu-id="c631d-2623">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="c631d-2624">這個接下來的範例 < 備註 > 一節將說明此案例。</span><span class="sxs-lookup"><span data-stu-id="c631d-2624">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="c631d-2625">如果沒有任何處理常式註冊以比對方法呼叫的輸入的參數的準則，則呼叫這個方法任何作用。</span><span class="sxs-lookup"><span data-stu-id="c631d-2625">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="c631d-2626">如果多個處理常式已連結的事件處理常式存放區中，比對準則，也就是第一個處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2626">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="c631d-2627">此行為是配合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]行為`-=`運算子。</span><span class="sxs-lookup"><span data-stu-id="c631d-2627">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="c631d-2628">既不`routedEvent`也`handler`可能是`null`。</span><span class="sxs-lookup"><span data-stu-id="c631d-2628">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="c631d-2629">嘗試提供其中一個值做為`null`會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-2629">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="c631d-2630">這個方法會忽略`handledEventsToo`加上第一個處理常式是否提供的參數資訊<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章，可讓已處理事件的處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2630">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="c631d-2631">任一種類型的處理常式會移除。</span><span class="sxs-lookup"><span data-stu-id="c631d-2631">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-2632">傳回序列化程序是否應序列化的內容<see cref="P:System.Windows.ContentElement.CommandBindings" />這個類別的執行個體上的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2632">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="c631d-2633">如果應序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2633"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2634">這會傳回`true`如果<xref:System.Windows.ContentElement.CommandBindings%2A>本機設定。</span><span class="sxs-lookup"><span data-stu-id="c631d-2634">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="c631d-2635">這`ShouldSerialize`提供方法，因為<xref:System.Windows.UIElement.CommandBindings%2A>屬性並沒有簡單的預設值。</span><span class="sxs-lookup"><span data-stu-id="c631d-2635">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="c631d-2636">這個方法會指出屬性是否已變更其預設值。</span><span class="sxs-lookup"><span data-stu-id="c631d-2636">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="c631d-2637">您通常叫用這個方法如果在開發設計工具或開發您自己的控制項併入<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2637">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="c631d-2638">如需詳細資訊，請參閱 <<c0> [ 定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2638">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c631d-2639">傳回序列化程序是否應序列化的內容<see cref="P:System.Windows.ContentElement.InputBindings" />這個類別的執行個體上的屬性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2639">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="c631d-2640">如果應序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2640"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2641">這會傳回`true`如果<xref:System.Windows.ContentElement.InputBindings%2A>本機設定。</span><span class="sxs-lookup"><span data-stu-id="c631d-2641">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="c631d-2642">這`ShouldSerialize`提供方法，因為<xref:System.Windows.UIElement.InputBindings%2A>屬性並沒有簡單的預設值。</span><span class="sxs-lookup"><span data-stu-id="c631d-2642">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="c631d-2643">這個方法會指出屬性是否已變更其預設值。</span><span class="sxs-lookup"><span data-stu-id="c631d-2643">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="c631d-2644">您通常叫用這個方法如果在開發設計工具或開發您自己的控制項併入<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2644">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="c631d-2645">如需詳細資訊，請參閱 <<c0> [ 定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2645">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2646">手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2646">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2647">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusButtonDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2647">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2648">附加至事件處理常式<xref:System.Windows.ContentElement.StylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2648">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2649">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2649">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2650">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2650">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2651">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2651">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2652">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2652">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="c631d-2653">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2653">Routing strategy</span></span>|<span data-ttu-id="c631d-2654">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2654">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2655">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2655">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2656">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2656">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2657">覆寫<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2657">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2658">識別 <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2658">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2659">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2659">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2660">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2660">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2661">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2661">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2662">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2662">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2663">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2663">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2664">手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2664">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2665">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusButtonUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2665">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2666">附加至事件處理常式<xref:System.Windows.ContentElement.StylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2666">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2667">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2667">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2668">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2668">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2669">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2669">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2670">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2670">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="c631d-2671">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2671">Routing strategy</span></span>|<span data-ttu-id="c631d-2672">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2672">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2673">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2673">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c631d-2674">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2674">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2675">覆寫<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2675">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2676">識別 <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2676">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2677">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2677">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2678">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2678">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2679">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2679">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2680">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2680">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2681">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2681">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2682">手寫筆在此項目上方且碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2682">Occurs when the stylus touches the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2683">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusDown>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2683">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2684">附加至事件處理常式<xref:System.Windows.ContentElement.StylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2684">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2685">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2685">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2686">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2686">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2687">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2688">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2688">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="c631d-2689">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2689">Routing strategy</span></span>|<span data-ttu-id="c631d-2690">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2690">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2691">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2691">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="c631d-2692">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2692">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2693">覆寫<xref:System.Windows.ContentElement.OnStylusDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2693">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2694">識別 <see cref="E:System.Windows.ContentElement.StylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2694">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2695">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2696">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2697">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2698">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2699">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2700">手寫筆進入此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2700">Occurs when the stylus enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2701"><xref:System.Windows.ContentElement.StylusEnter> 已[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-2701"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c631d-2702">直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-2702">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c631d-2703">不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。</span><span class="sxs-lookup"><span data-stu-id="c631d-2703">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c631d-2704">雖然<xref:System.Windows.ContentElement.StylusEnter>手寫筆輸入的項目，這個事件更多的界限時的追蹤記錄解譯為常值回報<xref:System.Windows.ContentElement.IsStylusOver%2A>屬性值已從`false`至`true`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="c631d-2704">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="c631d-2705">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusEnter>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2705">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2706">附加至事件處理常式<xref:System.Windows.ContentElement.StylusEnter>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2706">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2707">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2707">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2708">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2708">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2709">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2710">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2710">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="c631d-2711">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2711">Routing strategy</span></span>|<span data-ttu-id="c631d-2712">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2712">Direct</span></span>|  
|<span data-ttu-id="c631d-2713">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2713">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2714">覆寫<xref:System.Windows.ContentElement.OnStylusEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2714">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2715">識別 <see cref="E:System.Windows.ContentElement.StylusEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2715">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2716">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2716">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2717">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2717">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2718">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2718">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2719">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2719">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2720">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2720">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2721">手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2721">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2722">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusInAirMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2722">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2723">附加至事件處理常式<xref:System.Windows.ContentElement.StylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2723">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2724">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2724">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2725">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2725">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2726">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2726">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2727">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2727">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="c631d-2728">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2728">Routing strategy</span></span>|<span data-ttu-id="c631d-2729">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2729">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2730">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2730">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2731">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2731">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2732">覆寫<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2732">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2733">識別 <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2733">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2734">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2734">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2735">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2735">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2736">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2736">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2737">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2737">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2738">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2738">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2739">手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2739">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2740">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusInRange>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2740">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2741">附加至事件處理常式<xref:System.Windows.ContentElement.StylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2741">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2742">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2742">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2743">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2743">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2744">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2744">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2745">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2745">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="c631d-2746">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2746">Routing strategy</span></span>|<span data-ttu-id="c631d-2747">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2747">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2748">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2748">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2749">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2749">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="c631d-2750">覆寫<xref:System.Windows.ContentElement.OnStylusInRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2750">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2751">識別 <see cref="E:System.Windows.ContentElement.StylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2751">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2752">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2752">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2753">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2753">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2754">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2754">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2755">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2755">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2756">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2756">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2757">手寫筆離開元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2757">Occurs when the stylus leaves the bounds of the element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2758"><xref:System.Windows.ContentElement.StylusLeave> 已[路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="c631d-2758"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c631d-2759">直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。</span><span class="sxs-lookup"><span data-stu-id="c631d-2759">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c631d-2760">不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。</span><span class="sxs-lookup"><span data-stu-id="c631d-2760">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c631d-2761">雖然<xref:System.Windows.ContentElement.StylusLeave>追蹤何時手寫筆離開元素，此事件的邊界更多解譯為常值回報<xref:System.Windows.ContentElement.IsStylusOver%2A>屬性值已從`true`至`false`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="c631d-2761">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="c631d-2762">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusLeave>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2762">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2763">附加至事件處理常式<xref:System.Windows.ContentElement.StylusLeave>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2763">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2764">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2764">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2765">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2765">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2766">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2766">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2767">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2767">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="c631d-2768">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2768">Routing strategy</span></span>|<span data-ttu-id="c631d-2769">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2769">Direct</span></span>|  
|<span data-ttu-id="c631d-2770">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2770">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2771">覆寫<xref:System.Windows.ContentElement.OnStylusLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2771">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2772">識別 <see cref="E:System.Windows.ContentElement.StylusLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2772">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2773">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2773">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2774">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2774">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2775">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2775">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2776">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2776">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2777">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2777">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2778">當手寫筆移至此項目上方時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2778">Occurs when the stylus moves over this element.</span></span> <span data-ttu-id="c631d-2779">手寫筆在數位板上必須移動才會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2779">The stylus must move while on the digitizer to raise this event.</span></span> <span data-ttu-id="c631d-2780">否則，會改為引發 <see cref="E:System.Windows.ContentElement.StylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="c631d-2780">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2781">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusMove>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2781">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2782">附加至事件處理常式<xref:System.Windows.ContentElement.StylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2782">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2783">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2783">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2784">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2784">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2785">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2785">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2786">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2786">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="c631d-2787">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2787">Routing strategy</span></span>|<span data-ttu-id="c631d-2788">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2788">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2789">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2789">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2790">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2790">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2791">覆寫<xref:System.Windows.ContentElement.OnStylusMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2791">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2792">識別 <see cref="E:System.Windows.ContentElement.StylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2792">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2793">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2793">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2794">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2794">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2795">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2795">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2796">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2796">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2797">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2797">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2798">手寫筆在此項目上方，且遠離數位板而無法被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2798">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2799">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusOutOfRange>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2799">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2800">附加至事件處理常式<xref:System.Windows.ContentElement.StylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2800">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2801">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2801">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2802">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2802">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2803">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2803">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2804">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2804">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="c631d-2805">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2805">Routing strategy</span></span>|<span data-ttu-id="c631d-2806">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2806">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2807">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2807">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2808">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2808">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="c631d-2809">覆寫<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2809">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2810">識別 <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2810">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2811">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2811">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2812">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2812">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2813">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2813">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2814">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2814">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2815">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2815">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2816">使用者執行其中一種手寫筆筆勢時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2816">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2817">手寫筆筆勢的相關資訊的詳細資訊，請參閱<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2817">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="c631d-2818">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusSystemGesture>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2818">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2819">附加至事件處理常式<xref:System.Windows.ContentElement.StylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2819">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2820">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2820">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2821">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2821">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2822">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2822">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2823">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2823">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="c631d-2824">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2824">Routing strategy</span></span>|<span data-ttu-id="c631d-2825">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2825">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2826">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2826">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="c631d-2827">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2827">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="c631d-2828">覆寫<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2828">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2829">識別 <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2829">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2830">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2830">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2831">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2831">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2832">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2832">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2833">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2833">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2834">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2834">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2835">手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2835">Occurs when the user raises the stylus off the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2836">此事件建立的別名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.StylusUp>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2836">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2837">附加至事件處理常式<xref:System.Windows.ContentElement.StylusUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2837">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c631d-2838">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c631d-2838">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c631d-2839">如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c631d-2839">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2840">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2840">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2841">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2841">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="c631d-2842">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2842">Routing strategy</span></span>|<span data-ttu-id="c631d-2843">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2843">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2844">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2844">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c631d-2845">對應的通道事件是<xref:System.Windows.ContentElement.PreviewStylusUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2845">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2846">覆寫<xref:System.Windows.ContentElement.OnStylusUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2846">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2847">識別 <see cref="E:System.Windows.ContentElement.StylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2847">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2848">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2848">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2849">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2849">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2850">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2850">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2851">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2851">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2852">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2852">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2853">此元素以一種與裝置無關的方式取得文字時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2853">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="c631d-2854">此事件可能已被標示為已處理的複合控制項的內部實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-2854">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="c631d-2855">請參閱下方的備註。</span><span class="sxs-lookup"><span data-stu-id="c631d-2855">See Remark below.</span></span>  
  
 <span data-ttu-id="c631d-2856"><xref:System.Windows.ContentElement.TextInput>事件可能已被標示為已處理的複合控制項的內部實作。</span><span class="sxs-lookup"><span data-stu-id="c631d-2856">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="c631d-2857">例如，<xref:System.Windows.Controls.TextBox>是複合控制項，<xref:System.Windows.ContentElement.TextInput>事件已標示為已處理，其複合 （compositing） 內。</span><span class="sxs-lookup"><span data-stu-id="c631d-2857">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="c631d-2858">控制項執行這項操作，因為控制項必須解譯某些類型的輸入，例如方向鍵，該控制項的特殊意義。</span><span class="sxs-lookup"><span data-stu-id="c631d-2858">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="c631d-2859">如果您使用<xref:System.Windows.ContentElement.PreviewTextInput>做為您用來附加文字輸入的處理常式的事件，您可能會收到更好的結果。</span><span class="sxs-lookup"><span data-stu-id="c631d-2859">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="c631d-2860">這項技術會規避大部分的情況下，其中已將這個事件標記為已處理控制項組合，而收到此事件路由事件時，防止您的處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2860">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="c631d-2861"><xref:System.Windows.ContentElement.TextInput>事件可讓元件或應用程式以與裝置無關的方式接聽文字輸入。</span><span class="sxs-lookup"><span data-stu-id="c631d-2861">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="c631d-2862">鍵盤是主要的方法<xref:System.Windows.ContentElement.TextInput>，但也可以將語音、 手寫和其他輸入的裝置<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2862">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="c631d-2863">因為索引鍵組合-在預設鍵盤或輸入的法編輯器-透過多個索引鍵的事件可能會引發一個文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2863">Because of key combinations - either in default keyboards or through input method editors - multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="c631d-2864">此事件建立的別名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.ContentElement.TextInput>屬於類別的成員清單時<xref:System.Windows.ContentElement>繼承為基底的項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2864">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c631d-2865">附加至事件處理常式<xref:System.Windows.ContentElement.TextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="c631d-2865">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2866">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2866">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2867">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2867">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="c631d-2868">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2868">Routing strategy</span></span>|<span data-ttu-id="c631d-2869">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2869">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2870">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2870">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="c631d-2871">對應的通道事件是<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2871">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="c631d-2872">覆寫<xref:System.Windows.ContentElement.OnTextInput%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2872">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2873">識別 <see cref="E:System.Windows.ContentElement.TextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2873">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2874">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c631d-2874">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c631d-2875">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="c631d-2875">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c631d-2876">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="c631d-2876">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c631d-2877">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2877">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c631d-2878">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2878">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2879">手指在這個項目上方且在螢幕上觸控時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2879">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2880">根據預設，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指觸控螢幕，並移動之前不會發生的事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2880">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="c631d-2881">手指在螢幕上按住卻不必移動它會使用按下並按住行為<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2881">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="c631d-2882">按住不放的行為相當於按一下滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="c631d-2882">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="c631d-2883">會造成<xref:System.Windows.ContentElement.PreviewTouchDown>並<xref:System.Windows.ContentElement.TouchDown>事件發生在手指觸控螢幕，如設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>; 附加屬性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="c631d-2883">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2884">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2884">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2885">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2885">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="c631d-2886">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2886">Routing strategy</span></span>|<span data-ttu-id="c631d-2887">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2887">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2888">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2888">Delegate</span></span>|<span data-ttu-id="c631d-2889"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2889"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2890">對應的通道事件是<xref:System.Windows.ContentElement.PreviewTouchDown>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="c631d-2891">覆寫<xref:System.Windows.ContentElement.OnTouchDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2891">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2892">識別 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2892">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2893">當觸控從移動時，就會發生外部或內部此元素的邊界。</span><span class="sxs-lookup"><span data-stu-id="c631d-2893">Occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c631d-2894">一律引發這個事件，或有觸控式裝置擷取至這個 UI 項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2894">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2895">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2895">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2896">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2896">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="c631d-2897">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2897">Routing strategy</span></span>|<span data-ttu-id="c631d-2898">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2898">Direct</span></span>|  
|<span data-ttu-id="c631d-2899">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2899">Delegate</span></span>|<span data-ttu-id="c631d-2900"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2900"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2901">覆寫<xref:System.Windows.ContentElement.OnTouchEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2901">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2902">識別 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2902">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2903">取得已擷取至這個項目的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="c631d-2903">Gets all touch devices that are captured to this element.</span></span></summary>
        <value><span data-ttu-id="c631d-2904">列舉<see cref="T:System.Windows.Input.TouchDevice" />物件已擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2905">取得其視覺化樹狀結構中的所有觸控裝置，會擷取至這個項目] 或 [任何子項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2905">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="c631d-2906">列舉<see cref="T:System.Windows.Input.TouchDevice" />物件已擷取至這個項目或其視覺化樹狀結構中的任何子項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2906">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2907">取得這個項目之上的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="c631d-2907">Gets all touch devices that are over this element.</span></span></summary>
        <value><span data-ttu-id="c631d-2908">列舉<see cref="T:System.Windows.Input.TouchDevice" />這個項目之上的物件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2908">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2909">取得這個項目之上的所有觸控裝置或任何子項目，其視覺化樹狀結構中。</span><span class="sxs-lookup"><span data-stu-id="c631d-2909">Gets all touch devices that are over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="c631d-2910">列舉<see cref="T:System.Windows.Input.TouchDevice" />物件在這個項目或其視覺化樹狀結構中的任何子項目。</span><span class="sxs-lookup"><span data-stu-id="c631d-2910">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2911">當觸控從移動時，就會發生內部或外部此元素的邊界。</span><span class="sxs-lookup"><span data-stu-id="c631d-2911">Occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2912">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2912">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2913">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2913">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="c631d-2914">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2914">Routing strategy</span></span>|<span data-ttu-id="c631d-2915">直接</span><span class="sxs-lookup"><span data-stu-id="c631d-2915">Direct</span></span>|  
|<span data-ttu-id="c631d-2916">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2916">Delegate</span></span>|<span data-ttu-id="c631d-2917"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2917"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2918">覆寫<xref:System.Windows.ContentElement.OnTouchLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2918">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2919">識別 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2919">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2920">手指在這個項目上方且在螢幕上移動時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2920">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2921">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2921">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2922">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2922">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="c631d-2923">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2923">Routing strategy</span></span>|<span data-ttu-id="c631d-2924">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2924">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2925">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2925">Delegate</span></span>|<span data-ttu-id="c631d-2926"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2926"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2927">對應的通道事件是<xref:System.Windows.ContentElement.PreviewTouchMove>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2927">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="c631d-2928">覆寫<xref:System.Windows.ContentElement.OnTouchMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2928">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2929">識別 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2929">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2930">手指在這個項目上方且離開螢幕時發生。</span><span class="sxs-lookup"><span data-stu-id="c631d-2930">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c631d-2931">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="c631d-2931">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c631d-2932">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="c631d-2932">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="c631d-2933">路由策略</span><span class="sxs-lookup"><span data-stu-id="c631d-2933">Routing strategy</span></span>|<span data-ttu-id="c631d-2934">事件反昇</span><span class="sxs-lookup"><span data-stu-id="c631d-2934">Bubbling</span></span>|  
|<span data-ttu-id="c631d-2935">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="c631d-2935">Delegate</span></span>|<span data-ttu-id="c631d-2936"><xref:System.EventHandler%601> 型別的<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2936"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c631d-2937">對應的通道事件是<xref:System.Windows.ContentElement.PreviewTouchUp>。</span><span class="sxs-lookup"><span data-stu-id="c631d-2937">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="c631d-2938">覆寫<xref:System.Windows.ContentElement.OnTouchUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c631d-2938">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c631d-2939">識別 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="c631d-2939">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>