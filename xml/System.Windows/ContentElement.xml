<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="43995-101">提供內容項目的 WPF 核心層級基底類別。</span><span class="sxs-lookup"><span data-stu-id="43995-101">Provides a WPF core-level base class for content elements.</span></span> <span data-ttu-id="43995-102">內容項目是專為流程樣式表示所設計，其使用直覺式標記導向配置模型以及刻意保持簡單的物件模型。</span><span class="sxs-lookup"><span data-stu-id="43995-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-103"><xref:System.Windows.ContentElement> 定義下列的一般內容特性：</span><span class="sxs-lookup"><span data-stu-id="43995-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="43995-104">輸入： 所有<xref:System.Windows.ContentElement>從鍵盤、 滑鼠、 拖放作業、 手寫筆控制項和快速鍵的基本輸入擷取衍生的類別提供支援。</span><span class="sxs-lookup"><span data-stu-id="43995-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="43995-105">焦點： 所有<xref:System.Windows.ContentElement>衍生的類別都是可能可設定焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="43995-106">(不過的預設可設定焦點狀態<xref:System.Windows.ContentElement>基底類別是`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="43995-107">如需詳細資訊，使<xref:System.Windows.ContentElement>可設定焦點，請參閱<xref:System.Windows.ContentElement.Focusable%2A>。)此外，這個類別包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]可讓您周遊焦點相關的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="43995-108">事件：<xref:System.Windows.ContentElement>包含事件相關的輸入和焦點，則它也包含狀態變更的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="43995-109">在許多情況下，<xref:System.Windows.ContentElement>事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="43995-110">在某些情況下，路由的事件都有通道和反昇路由策略，以在偵測到相同的狀態或條件的不同事件引發。</span><span class="sxs-lookup"><span data-stu-id="43995-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="43995-111">此外，<xref:System.Windows.ContentElement>定義[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，可以提高路由傳送事件，可以新增或移除事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="43995-112"><xref:System.Windows.ContentElement> 共用許多常見[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]與<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="43995-113">這些一般[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]不是來自共用的類別繼承。</span><span class="sxs-lookup"><span data-stu-id="43995-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="43995-114">但不要共用通用的命名、 類似行為，以及類似內部實作[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]中每個類別。</span><span class="sxs-lookup"><span data-stu-id="43995-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="43995-115">相似度是因為<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>是每個類別的基底的項目，不過每個都有不同的目的，標記物件模型的行為。</span><span class="sxs-lookup"><span data-stu-id="43995-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="43995-116">特別的是，<xref:System.Windows.UIElement>從衍生<xref:System.Windows.Media.Visual>，以提供較低層級圖形支援轉譯<xref:System.Windows.ContentElement>矩形區域在複合的視窗中，而<xref:System.Windows.ContentElement>會延遲轉譯讓更多的概念更輕鬆地支援文件的情況下，流量和換行，例如通用的。</span><span class="sxs-lookup"><span data-stu-id="43995-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="43995-117">這兩個相關類別也實作通用介面<xref:System.Windows.IInputElement>和<xref:System.Windows.Media.Animation.IAnimatable>。</span><span class="sxs-lookup"><span data-stu-id="43995-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para><span data-ttu-id="43995-118"><see cref="T:System.Windows.ContentElement" />類別並未尚未定義流程樣式表示的完整內容項目中的所有層面。</span><span class="sxs-lookup"><span data-stu-id="43995-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span></span> <span data-ttu-id="43995-119"><see cref="T:System.Windows.FrameworkContentElement" /> 是立即在衍生的類別的<see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="43995-119"><see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span></span> <span data-ttu-id="43995-120"><see cref="T:System.Windows.FrameworkContentElement" /> 包含一組更完整的支援轉譯的其他成員<see cref="T:System.Windows.FrameworkContentElement" />內容主機和使用 WPF 架構層級配置系統中。</span><span class="sxs-lookup"><span data-stu-id="43995-120"><see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span></span></para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-121">初始化 <see cref="T:System.Windows.ContentElement" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43995-122">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="43995-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="43995-123">要處理的路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-123">An identifier for the routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="43995-124">處理常式實作的參考。</span><span class="sxs-lookup"><span data-stu-id="43995-124">A reference to the handler implementation.</span></span></param>
        <summary><span data-ttu-id="43995-125">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="43995-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-126">您可以加入相同的處理常式事件多次，而不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="43995-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="43995-127">不過，此處理常式實際叫用時處理事件的多次。</span><span class="sxs-lookup"><span data-stu-id="43995-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="43995-128">因此，請考慮如何這種行為可能會有副作用，都應該在處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="43995-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="43995-129">您通常使用這個方法來提供的 「 加入 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。</span><span class="sxs-lookup"><span data-stu-id="43995-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="43995-130">要處理之路由事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-130">An identifier for the.routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="43995-131">處理常式實作的參考。</span><span class="sxs-lookup"><span data-stu-id="43995-131">A reference to the handler implementation.</span></span></param>
        <param name="handledEventsToo">
          <span data-ttu-id="43995-132"><see langword="true" /> 表示註冊處理常式，以便即使路由事件在其事件資料中標記為已處理，仍會叫用該處理常式。<see langword="false" /> 表示以預設條件註冊處理常式，也就是如果路由事件已經標記為已處理，則不會叫用該處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-132"><see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span></span>  
  
 <span data-ttu-id="43995-133">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-133">The default is <see langword="false" />.</span></span>  
  
 <span data-ttu-id="43995-134">請勿定期要求重新處理路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-134">Do not routinely ask to rehandle a routed event.</span></span></param>
        <summary><span data-ttu-id="43995-135">加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</span><span class="sxs-lookup"><span data-stu-id="43995-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span> <span data-ttu-id="43995-136">將 <paramref name="handledEventsToo" /> 指定為 <see langword="true" />，以針對已經由事件路由上另一個項目標記為已處理的路由事件，叫用提供的處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-137">在可行的方式處理低階輸入是一個複雜的工作。</span><span class="sxs-lookup"><span data-stu-id="43995-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="43995-138">許多控制項實作特定事件標示為已處理，而取代為另一個更具直覺性事件的行為。</span><span class="sxs-lookup"><span data-stu-id="43995-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="43995-139">一般而言，控制項只會將平台輸入的事件，為已處理，如果沒有這麼做一些設計用意。</span><span class="sxs-lookup"><span data-stu-id="43995-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="43995-140">在某些情況下，這些設計目的不可能的輸入事件的特定處理的需要。</span><span class="sxs-lookup"><span data-stu-id="43995-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="43995-141">這些案例是該註冊處理常式取代`handledEventsToo`為`true`適合。</span><span class="sxs-lookup"><span data-stu-id="43995-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="43995-142">但您不應該這麼例行性。</span><span class="sxs-lookup"><span data-stu-id="43995-142">But you should not do this routinely.</span></span> <span data-ttu-id="43995-143">叫用處理常式以回應所有事件，即使處理將會使得您自己的應用程式事件處理邏輯。</span><span class="sxs-lookup"><span data-stu-id="43995-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="43995-144">如果處理常式邏輯的很大，可能會看到效能降低。</span><span class="sxs-lookup"><span data-stu-id="43995-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="43995-145">您應該保留附加尚未處理的情況下，您已經發現特定控制項所處理的事件，您仍然想要處理的應用程式邏輯在開發程序的事件處理常式的使用。</span><span class="sxs-lookup"><span data-stu-id="43995-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="43995-146">避免處理行為的某些事件控制組合類別的另一個技術是使用該事件預覽替代方案。</span><span class="sxs-lookup"><span data-stu-id="43995-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="43995-147">例如，如果<xref:System.Windows.ContentElement.MouseLeftButtonDown>標示為已處理的類別處理，您可以加入處理常式<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>改為。</span><span class="sxs-lookup"><span data-stu-id="43995-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="43995-148">您可以加入相同的處理常式事件多次，而不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="43995-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="43995-149">不過，此處理常式實際叫用時處理事件的多次。</span><span class="sxs-lookup"><span data-stu-id="43995-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="43995-150">因此，請考慮如何這種行為可能會有副作用，都應該在處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="43995-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="43995-151">您通常使用這個方法來提供的 「 加入 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。</span><span class="sxs-lookup"><span data-stu-id="43995-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43995-152">下列範例會實作上叫用的處理常式<xref:System.Windows.FrameworkElement.Initialized>將定義的處理常式附加至其中一個具名的項目頁面使用頁面上的事件`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="43995-153">會叫用這個處理常式，即使此路由上的另一個項目標示為已處理到達路由處理項目之前共用的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route"><span data-ttu-id="43995-154">加入處理常式的事件路由。</span><span class="sxs-lookup"><span data-stu-id="43995-154">The event route that handlers are added to.</span></span></param>
        <param name="e"><span data-ttu-id="43995-155">用於加入處理常式的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-155">The event data that is used to add the handlers.</span></span> <span data-ttu-id="43995-156">這個方法會使用引數的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性來建立處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span></span></param>
        <summary><span data-ttu-id="43995-157">針對目前的 <see cref="T:System.Windows.EventRoute" /> 事件處理常式集合，將處理常式加入至指定的 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="43995-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-158">這個方法用於內容主機項目 (不論是否實作<xref:System.Windows.IContentHost>) 以便將內容主機子項目的處理常式新增至主機<xref:System.Windows.EventRoute>。</span><span class="sxs-lookup"><span data-stu-id="43995-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-159">取得或設定值，這個值表示這個項目是否可以作為拖放作業的目標。</span><span class="sxs-lookup"><span data-stu-id="43995-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span></span></summary>
        <value>
          <span data-ttu-id="43995-160">如果這個項目可以用來做為拖放作業的目標則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-160"><see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-161">預設值是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-161">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-162">拖放作業依預設，未啟用，且必須藉由設定刻意啟用<xref:System.Windows.ContentElement.AllowDrop%2A>至`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="43995-163">超出此基本設定，拖放行為完全實作特定，不由定義<xref:System.Windows.ContentElement>或其他類型的基底項目類別。</span><span class="sxs-lookup"><span data-stu-id="43995-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="43995-164">某些控制項，例如<xref:System.Windows.Controls.RichTextBox>，沒有預設行為，但不是<xref:System.Windows.ContentElement>具有這類行為的衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="43995-165">如需拖放的詳細資訊，請參閱[拖曳和卸除概觀](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="43995-166"><xref:System.Windows.FrameworkContentElement> 覆寫這個實作中的相依性屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="43995-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="43995-167">具體來說，<xref:System.Windows.FrameworkContentElement>指定這個屬性可讓屬性值繼承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`中繼資料中)。</span><span class="sxs-lookup"><span data-stu-id="43995-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="43995-168">在此內容中的屬性值繼承表示，如果有任何其他值作為具有子元素<xref:System.Windows.ContentElement.AllowDrop%2A>指派透過本機值或最接近的父元素的值指派 （同樣地，有兩種預設的樣式，此值與樣式值或為區域數值），然後從該父項目值屬性系統指派給所有未指派的子項目。</span><span class="sxs-lookup"><span data-stu-id="43995-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="43995-169">這表示您可以指定是否允許拖放作業在根項目，然後將傳播到所有的值<xref:System.Windows.FrameworkContentElement>沒有特別將其指派的值的子項目`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-170">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-171">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="43995-172">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-173">無</span><span class="sxs-lookup"><span data-stu-id="43995-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-174">下列範例會設定<xref:System.Windows.ContentElement.AllowDrop%2A>中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="43995-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-175">識別 <see cref="P:System.Windows.ContentElement.AllowDrop" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43995-176">將動畫套用至這個項目上所指定的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-176">Applies an animation to a specified dependency property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="43995-177">要繪製的屬性之識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-177">The identifier for the property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="43995-178">控制並宣告動畫的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="43995-178">The animation clock that controls and declares the animation.</span></span></param>
        <summary><span data-ttu-id="43995-179">將動畫套用至這個項目上所指定的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-179">Applies an animation to a specified dependency property on this element.</span></span> <span data-ttu-id="43995-180">任何現有動畫都會停止並取代為新的動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-180">Any existing animations are stopped and replaced with the new animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-181">若要移除屬性的動畫，指定做為該屬性的識別項`dp`並指定`clock`為`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="43995-182">這會移除動畫和動畫的屬性設定為其基底值。</span><span class="sxs-lookup"><span data-stu-id="43995-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="43995-183">不過，並不會停止原先相關聯的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="43995-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="43995-184">指派給該時鐘的其他任何動畫會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="43995-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="43995-185">要製作動畫的屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-185">The property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="43995-186">控制並宣告動畫的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="43995-186">The animation clock that controls and declares the animation.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="43995-187">列舉值。</span><span class="sxs-lookup"><span data-stu-id="43995-187">A value of the enumeration.</span></span> <span data-ttu-id="43995-188">預設為 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，其會停止任何現有動畫並以新動畫取代。</span><span class="sxs-lookup"><span data-stu-id="43995-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span></span></param>
        <summary><span data-ttu-id="43995-189">將動畫套用至這個項目上所指定的相依性屬性，且可以指定此屬性已經有執行中的動畫時會發生哪種情況。</span><span class="sxs-lookup"><span data-stu-id="43995-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-190">若要移除屬性的動畫，指定做為該屬性的識別項`dp`並指定`clock`為`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="43995-191">這會移除動畫和動畫的屬性設定為其基底值。</span><span class="sxs-lookup"><span data-stu-id="43995-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="43995-192">不過，並不會停止原先相關聯的動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="43995-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="43995-193">指派給該時鐘的其他任何動畫會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="43995-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-194">取得值，這個值表示是否至少有一個觸控擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-194">Gets a value that indicates whether at least one touch is captured to this element.</span></span></summary>
        <value>
          <span data-ttu-id="43995-195">如果至少有一個觸控擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-195"><see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-196">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-197">取得值，這個值表示是否至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目。</span><span class="sxs-lookup"><span data-stu-id="43995-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span></span></summary>
        <value>
          <span data-ttu-id="43995-198">如果至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-198"><see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-199">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-200">取得值，這個值表示是否至少有一個觸控在這個項目上按下。</span><span class="sxs-lookup"><span data-stu-id="43995-200">Gets a value that indicates whether at least one touch is pressed over this element.</span></span></summary>
        <value>
          <span data-ttu-id="43995-201">如果至少有一個觸控在這個項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-201"><see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-202">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-203">取得值，這個值表示是否至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下。</span><span class="sxs-lookup"><span data-stu-id="43995-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span></span></summary>
        <value>
          <span data-ttu-id="43995-204">如果至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-204"><see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-205">識別 <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43995-206">針對這個項目之指定的動畫屬性，開始播放動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-206">Starts an animation for a specified animated property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="43995-207">要顯示動畫的屬性，該屬性會指定為相依性屬性識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-207">The property to animate, which is specified as a dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="43995-208">啟動動畫的時刻表。</span><span class="sxs-lookup"><span data-stu-id="43995-208">The timeline of the animation to start.</span></span></param>
        <summary><span data-ttu-id="43995-209">針對這個項目之指定的動畫屬性，開始播放動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-209">Starts an animation for a specified animated property on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-210">當您檢查屬性是否動畫效果時，請注意，動畫會開始視為動畫呈現非動畫的起始點的第一個框架時。</span><span class="sxs-lookup"><span data-stu-id="43995-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="43995-211">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>如`animation`是`null`，然後移除任何目前的動畫，並保留屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="43995-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="43995-212">如果整個`animation`值是`null`、 從屬性移除所有動畫和屬性值還原成其基底值。</span><span class="sxs-lookup"><span data-stu-id="43995-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="43995-213">不過，並不會停止原先相關聯的動畫時間軸。</span><span class="sxs-lookup"><span data-stu-id="43995-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="43995-214">指派給該時間軸中的其他任何動畫會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="43995-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="43995-215">要顯示動畫的屬性，該屬性會指定為相依性屬性識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-215">The property to animate, which is specified as the dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="43995-216">套用動畫的時刻表。</span><span class="sxs-lookup"><span data-stu-id="43995-216">The timeline of the animation to be applied.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="43995-217">一個列舉值，這個值指定新的動畫如何與已經影響屬性值的任何目前 (執行中) 動畫互動。</span><span class="sxs-lookup"><span data-stu-id="43995-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span></span></param>
        <summary><span data-ttu-id="43995-218">針對此項目上指定的動畫屬性啟動特定動畫，且可以選擇指定如果屬性已經有執行中的動畫時會發生何種情況。</span><span class="sxs-lookup"><span data-stu-id="43995-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-219">當您檢查屬性是否動畫效果時，請注意，動畫會開始視為動畫呈現非動畫的起始點的第一個框架時。</span><span class="sxs-lookup"><span data-stu-id="43995-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="43995-220">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>如`animation`是`null`，然後移除任何目前的動畫，並保留屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="43995-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="43995-221">如果整個`animation`值是`null`、 從屬性移除所有動畫和屬性值還原成其基底值。</span><span class="sxs-lookup"><span data-stu-id="43995-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="43995-222">不過，並不會停止原先相關聯的動畫時間軸。</span><span class="sxs-lookup"><span data-stu-id="43995-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="43995-223">指派給該時間軸中的其他任何動畫會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="43995-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-224">嘗試強制將滑鼠的捕捉給這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-224">Attempts to force capture of the mouse to this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-225">如果成功捕捉到滑鼠則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-225"><see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-226">若要擷取項目都必須啟用。</span><span class="sxs-lookup"><span data-stu-id="43995-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="43995-227">檢查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`之前先呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="43995-228">如果呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>傳回`true`，然後<xref:System.Windows.ContentElement.IsMouseCaptured%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="43995-229">如果呼叫<xref:System.Windows.ContentElement.CaptureMouse%2A>傳回`true`，然後在<xref:System.Windows.ContentElement.GotMouseCapture>和<xref:System.Windows.ContentElement.IsMouseCapturedChanged>引發事件，與<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>事件中的項目報告資料其中<xref:System.Windows.ContentElement.CaptureMouse%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="43995-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="43995-230">如果您強制擷取時，您可能會干擾現有的擷取 — 尤其是使用與拖放滑鼠相關聯的擷取。</span><span class="sxs-lookup"><span data-stu-id="43995-230">If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="43995-231">若要清除所有項目從滑鼠擷取，請呼叫<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>與`element`提供做為參數`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43995-232">下列範例會擷取滑鼠或捕捉，根據是否已捕捉滑鼠的項目所釋放。</span><span class="sxs-lookup"><span data-stu-id="43995-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="43995-233">請注意此範例會轉換潛在擷取目標項目<xref:System.Windows.IInputElement>介面，並因此初始呼叫<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="43995-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43995-234">轉型為<xref:System.Windows.IInputElement>是如果您不確定是否要擷取的項目，則滑鼠就很有用的技巧<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="43995-235">介面型別轉換和介面方法呼叫然後呼叫適當的型別而異 CaptureMouse 實作在內部不需要試用版轉換為<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="43995-236">同樣的轉換技術的運作方式的其他成員的<xref:System.Windows.IInputElement>定義，例如許多輸入相關的事件和其他輸入相關的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-237">嘗試強制將手寫筆的捕捉給這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-237">Attempts to force capture of the stylus to this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-238">如果成功捕捉到手寫筆則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-238"><see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-239">永遠根據基礎的預設手寫筆裝置的預設實作會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="43995-240">不過，如果可延伸提供輸入系統的裝置實作的輸入的裝置，則可以替代手寫筆裝置的實作可能會傳回不同的結果，以建立系統。</span><span class="sxs-lookup"><span data-stu-id="43995-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="43995-241">當項目擷取手寫筆時，即使手寫筆在其範圍外接收手寫筆輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="43995-242">通常只會在拖放作業期間擷取手寫筆。</span><span class="sxs-lookup"><span data-stu-id="43995-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="43995-243">呼叫這個方法會呼叫基礎靜態<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="43995-244">實際擷取行為的實作方法的使用中的手寫筆裝置的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="43995-245">若要擷取項目都必須啟用。</span><span class="sxs-lookup"><span data-stu-id="43995-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="43995-246">檢查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`傳回才能呼叫<xref:System.Windows.ContentElement.CaptureStylus%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="43995-247">如果呼叫<xref:System.Windows.ContentElement.CaptureStylus%2A>傳回`true`，<xref:System.Windows.ContentElement.IsStylusCaptured%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="43995-248">要擷取的裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-248">The device to capture.</span></span></param>
        <summary><span data-ttu-id="43995-249">嘗試強制將觸控擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-249">Attempts to force capture of a touch to this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-250">如果指定的觸控已擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-250"><see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> 會傳回`false`如果<xref:System.Windows.Input.TouchDevice>目前擷取另一個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="43995-252">如果<xref:System.Windows.ContentElement.CaptureTouch%2A>傳回`true`，然後在<xref:System.Windows.ContentElement.GotTouchCapture>就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="43995-253">若要釋放擷取的單一觸控從這個項目，使用<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>方法並指定要發行的觸控式裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="43995-254">若要釋放所有的工作，從這個項目，使用<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="43995-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="43995-255"><paramref name="touchDevice" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43995-255"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-256">取得與這個項目關聯之 <see cref="T:System.Windows.Input.CommandBinding" /> 物件的集合。</span><span class="sxs-lookup"><span data-stu-id="43995-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="43995-257">所有 <see cref="T:System.Windows.Input.CommandBinding" /> 物件的集合。</span><span class="sxs-lookup"><span data-stu-id="43995-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-258">A<xref:System.Windows.Input.CommandBinding>啟用這個項目的特定命令的命令處理，並宣告命令、 其事件，以及由這個項目附加的處理常式之間的連結。</span><span class="sxs-lookup"><span data-stu-id="43995-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="43995-259">典型的另一種方式填入<xref:System.Windows.ContentElement.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以程式設計的方式。</span><span class="sxs-lookup"><span data-stu-id="43995-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="43995-260">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="43995-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="43995-261">XAML 值</span><span class="sxs-lookup"><span data-stu-id="43995-261">XAML Values</span></span>  
 <span data-ttu-id="43995-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="43995-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="43995-263">一或多個<xref:System.Windows.Input.CommandBinding>項目。</span><span class="sxs-lookup"><span data-stu-id="43995-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="43995-264">每一個都應該有<xref:System.Windows.Input.CommandBinding.Command%2A>屬性設定為已知的命令，而且屬性設定為<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="43995-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="43995-265">如需詳細資訊，請參閱<xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="43995-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-266">輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-267">此事件會建立一個別名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-268">事件處理常式附加至<xref:System.Windows.ContentElement.DragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-269">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-270">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="43995-271">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-271">Routing strategy</span></span>|<span data-ttu-id="43995-272">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-272">Bubbling</span></span>|  
|<span data-ttu-id="43995-273">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-274">對應通道的事件<xref:System.Windows.ContentElement.PreviewDragEnter>。</span><span class="sxs-lookup"><span data-stu-id="43995-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="43995-275">覆寫<xref:System.Windows.ContentElement.OnDragEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-276">識別 <see cref="E:System.Windows.ContentElement.DragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-277">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-278">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-279">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-280">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-281">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-282">輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-283">此事件會建立一個別名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-284">事件處理常式附加至<xref:System.Windows.ContentElement.DragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-285">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-286">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="43995-287">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-287">Routing strategy</span></span>|<span data-ttu-id="43995-288">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-288">Bubbling</span></span>|  
|<span data-ttu-id="43995-289">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-290">對應通道的事件<xref:System.Windows.DragDrop.PreviewDragLeave>。</span><span class="sxs-lookup"><span data-stu-id="43995-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="43995-291">覆寫<xref:System.Windows.ContentElement.OnDragLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-292">識別 <see cref="E:System.Windows.ContentElement.DragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-293">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-294">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-295">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-296">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-297">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-298">在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-299">即使拖曳來自項目範圍中，就會發生此事件。</span><span class="sxs-lookup"><span data-stu-id="43995-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="43995-300">如果拖曳啟動界限之外，然後移動到內部，也會引發這個事件，以及<xref:System.Windows.ContentElement.DragEnter>和相關的預覽事件。</span><span class="sxs-lookup"><span data-stu-id="43995-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="43995-301">此事件會建立一個別名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-302">事件處理常式附加至<xref:System.Windows.ContentElement.DragOver>事件會附加至基礎<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-303">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-304">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="43995-305">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-305">Routing strategy</span></span>|<span data-ttu-id="43995-306">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-306">Bubbling</span></span>|  
|<span data-ttu-id="43995-307">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-308">對應通道的事件<xref:System.Windows.DragDrop.PreviewDragOver>。</span><span class="sxs-lookup"><span data-stu-id="43995-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="43995-309">覆寫<xref:System.Windows.ContentElement.OnDragOver%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-310">識別 <see cref="E:System.Windows.ContentElement.DragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-311">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-312">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-313">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-314">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-315">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-316">輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-317">此事件會建立一個別名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-318">事件處理常式附加至<xref:System.Windows.ContentElement.Drop>事件會附加至基礎<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-319">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-320">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="43995-321">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-321">Routing strategy</span></span>|<span data-ttu-id="43995-322">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-322">Bubbling</span></span>|  
|<span data-ttu-id="43995-323">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-324">對應通道的事件<xref:System.Windows.ContentElement.PreviewDrop>。</span><span class="sxs-lookup"><span data-stu-id="43995-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="43995-325">覆寫<xref:System.Windows.ContentElement.OnDrop%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-326">識別 <see cref="E:System.Windows.ContentElement.Drop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-327">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-328">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-329">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-330">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-331">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-332">嘗試將焦點設定至此項目。</span><span class="sxs-lookup"><span data-stu-id="43995-332">Attempts to set focus to this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-333">如果可將鍵盤焦點設定至此項目則為 <see langword="true" />，如果這個方法無法強制設定焦點則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-333"><see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-334">若要可設定焦點，<xref:System.Windows.ContentElement.Focusable%2A>和<xref:System.Windows.ContentElement.IsEnabled%2A>兩者都必須是`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="43995-335">請注意，幾乎所有<xref:System.Windows.ContentElement>衍生的類別不<xref:System.Windows.ContentElement.Focusable%2A>預設。</span><span class="sxs-lookup"><span data-stu-id="43995-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="43995-336">即使項目是在特定的樹狀結構中的可設定焦點且已啟用，事件處理，（例如，針對複合控制項） 可能會回應預覽焦點事件藉由禁止焦點，因此這個方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="43995-337">焦點通常由兩個不同的概念： 鍵盤焦點和邏輯焦點，並不一定相同。</span><span class="sxs-lookup"><span data-stu-id="43995-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="43995-338">這個方法會設定邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-338">This method sets the logical focus.</span></span> <span data-ttu-id="43995-339">沒有以程式設計方式來設定鍵盤焦點，特別是; 方法鍵盤焦點是由使用者輸入所決定。</span><span class="sxs-lookup"><span data-stu-id="43995-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="43995-340">如需詳細資訊，請參閱[焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="43995-341">如果呼叫<xref:System.Windows.ContentElement.Focus%2A>傳回`true`，<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>和<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="43995-342">如果相關的屬性尚未`true`，當您呼叫<xref:System.Windows.ContentElement.Focus%2A>，一或多個下列事件會依照下列順序引發： <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>， <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> （來源為新的焦點目標） <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>， <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>，<xref:System.Windows.ContentElement.LostKeyboardFocus>， <xref:System.Windows.ContentElement.GotKeyboardFocus> （來源為新的焦點目標）。</span><span class="sxs-lookup"><span data-stu-id="43995-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43995-343">下列範例會尋找指定的具名文件中的段落的頁面載入事件處理常式，並設定焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="43995-344">段落不在預設情況下，可設定焦點這個特定的段落有套用的樣式 （未顯示），使用樣式<xref:System.Windows.Setter>使其可設定焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-345">取得或設定元素是否能夠接收焦點的值。</span><span class="sxs-lookup"><span data-stu-id="43995-345">Gets or sets a value that indicates whether the element can receive focus.</span></span></summary>
        <value>
          <span data-ttu-id="43995-346">如果項目可設定焦點則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-346"><see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span></span> <span data-ttu-id="43995-347">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-347">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-348">只有已取得焦點的項目收到鍵盤輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="43995-349">在衍生的類別是可設定焦點，根據預設，某些衍生的類別可能會覆寫這個相依性屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="43995-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="43995-350">當繼承<xref:System.Windows.Documents.Hyperlink>或其衍生的類別，<xref:System.Windows.Documents.Hyperlink>會覆寫這個相依性屬性的中繼資料，並會重新定義預設值，這個屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-351">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-352">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="43995-353">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-354">無</span><span class="sxs-lookup"><span data-stu-id="43995-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-355">下列範例會建立樣式使<xref:System.Windows.Documents.Paragraph>預設可設定焦點，並提供視覺化行為收到焦點時。</span><span class="sxs-lookup"><span data-stu-id="43995-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-356">當您衍生自<see cref="T:System.Windows.ContentElement" />，請考慮是否要讓您為可設定焦點，因為依預設它會為可設定焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span></span> <span data-ttu-id="43995-357">如果您希望您可設定焦點的項目時，覆寫衍生的類別靜態建構函式中的這個屬性的中繼資料，如下所示：</span><span class="sxs-lookup"><span data-stu-id="43995-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span></span>  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 <span data-ttu-id="43995-358">其中<paramref name="myElement" />之類型的中繼資料值覆寫上的類別名稱。</span><span class="sxs-lookup"><span data-stu-id="43995-358">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span></span></para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-359">發生於 <see cref="P:System.Windows.ContentElement.Focusable" /> 屬性的值變更時。</span><span class="sxs-lookup"><span data-stu-id="43995-359">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-360">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-360">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-361">識別 <see cref="P:System.Windows.ContentElement.Focusable" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-361">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="43995-362">要檢查的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-362">The.dependency property to check.</span></span></param>
        <summary><span data-ttu-id="43995-363">傳回這個項目上指定屬性的基底屬性值，不管任何執行中的可能動畫值，或停止動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-363">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span></span></summary>
        <returns><span data-ttu-id="43995-364">屬性值，就好像指定的相依性屬性未附加任何動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-364">The property value as if no animations are attached to the specified dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-365">如果屬性未不附加任何動畫則<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>傳回值一定是相同<xref:System.Windows.DependencyObject.GetValue%2A>傳回值。</span><span class="sxs-lookup"><span data-stu-id="43995-365">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="43995-366">如果附加的動畫，然後所有的可能動畫衍生值包括開始和停止值會被忽略，而且屬性值取決於所有可能的輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-366">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="43995-367">如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-367">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-368">當在衍生類別中覆寫時，如果沒有視覺化父項目存在，則會為這個項目傳回替代的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父項目。</span><span class="sxs-lookup"><span data-stu-id="43995-368">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span></span></summary>
        <returns><span data-ttu-id="43995-369">一個物件，如果衍生類別的實作有替代父代連接要報告。</span><span class="sxs-lookup"><span data-stu-id="43995-369">An object, if implementation of a derived class has an alternate parent connection to report.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-370">預設的虛擬實作這個方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-370">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="43995-371"><xref:System.Windows.FrameworkContentElement> 提供實際的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-371"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="43995-372">替代的父代是用於事件的路由，在其中項目會建立替代父結構，讓它的事件會路由傳送偏離標準模式的視覺化樹狀目錄以標準的父代，路由的方式的情況下或在中向下預覽路由策略。</span><span class="sxs-lookup"><span data-stu-id="43995-372">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-373">輸入系統報告其下牽涉此元素的拖放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-373">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-374"><xref:System.Windows.ContentElement.GiveFeedback>事件允許拖曳事件修改滑鼠指標外觀，以便將使用者視覺化回應提供拖放作業期間的來源。</span><span class="sxs-lookup"><span data-stu-id="43995-374">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="43995-375">視覺回應強調拖放作業正在進行。</span><span class="sxs-lookup"><span data-stu-id="43995-375">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="43995-376">此事件會建立一個別名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.GiveFeedback>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-376">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-377">事件處理常式附加至<xref:System.Windows.ContentElement.GiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-377">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-378">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-378">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-379">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-379">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="43995-380">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-380">Routing strategy</span></span>|<span data-ttu-id="43995-381">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-381">Bubbling</span></span>|  
|<span data-ttu-id="43995-382">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-382">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="43995-383">對應通道的事件<xref:System.Windows.ContentElement.PreviewGiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="43995-383">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="43995-384">覆寫<xref:System.Windows.ContentElement.OnGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-384">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-385">識別 <see cref="E:System.Windows.ContentElement.GiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-385">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-386">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-386">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-387">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-387">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-388">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-388">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-389">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-389">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-390">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-390">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-391">此元素取得邏輯焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-391">Occurs when this element gets logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-392">如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同的範圍與鍵盤焦點不同邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-392">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="43995-393">在此案例中，鍵盤焦點會維持其所在和項目位置<xref:System.Windows.ContentElement.Focus%2A>方法呼叫仍取得邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-393">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="43995-394">這個事件的更精確的解釋是它時引發的值<xref:System.Windows.ContentElement.IsFocused%2A>屬性路由的項目已從`false`至`true`。</span><span class="sxs-lookup"><span data-stu-id="43995-394">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="43995-395">由於這個事件會使用反昇路由，接收焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-395">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-396">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-396">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-397">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-397">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-398">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-398">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="43995-399">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-399">Routing strategy</span></span>|<span data-ttu-id="43995-400">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-400">Bubbling</span></span>|  
|<span data-ttu-id="43995-401">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-401">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="43995-402">沒有任何對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-402">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-403">覆寫<xref:System.Windows.ContentElement.OnGotFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-403">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-404">識別 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-404">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-405">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-405">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-406">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-406">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-407">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-407">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-408">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-408">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-409">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-409">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-410">鍵盤以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-410">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 是類似的事件可追蹤之屬性維護的項目; 焦點狀態中的狀態變更<xref:System.Windows.ContentElement.GotKeyboardFocus>的許多相同的情況下，就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="43995-412">這個事件會使用反昇路由，因為具有焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-412">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-413">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際具有焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-413">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="43995-414">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.GotKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-414">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-415">事件處理常式附加至<xref:System.Windows.ContentElement.GotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-415">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-416">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-417">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-417">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="43995-418">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-418">Routing strategy</span></span>|<span data-ttu-id="43995-419">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-419">Bubbling</span></span>|  
|<span data-ttu-id="43995-420">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-420">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="43995-421">對應通道的事件<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="43995-421">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="43995-422">覆寫<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-422">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-423">識別 <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-423">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-424">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-424">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-425">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-425">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-426">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-426">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-427">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-427">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-428">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-428">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-429">此元素擷取滑鼠時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-429">Occurs when this element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-430">當項目捕捉到滑鼠時，它收到滑鼠輸入，即使將滑鼠指標位於其範圍外。</span><span class="sxs-lookup"><span data-stu-id="43995-430">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="43995-431">滑鼠通常只會在拖放作業期間擷取並且擷取之前拖放作業的拖放動作發生。</span><span class="sxs-lookup"><span data-stu-id="43995-431">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="43995-432">這個事件會使用反昇路由，因為已擷取的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-432">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-433">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>資料，以判斷實際項目具有滑鼠擷取的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-433">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="43995-434">此事件會建立一個別名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.GotMouseCapture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-434">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-435">事件處理常式附加至<xref:System.Windows.ContentElement.GotMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-435">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-436">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-437">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-437">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="43995-438">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-438">Routing strategy</span></span>|<span data-ttu-id="43995-439">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-439">Bubbling</span></span>|  
|<span data-ttu-id="43995-440">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-440">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-441">沒有定義對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-441">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-442">覆寫<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-442">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-443">識別 <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-443">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-444">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-445">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-446">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-447">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-448">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-449">此元素擷取手寫筆時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-449">Occurs when this element captures the stylus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-450">當項目擷取手寫筆時，即使指標位於其範圍外接收手寫筆輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-450">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="43995-451">手寫筆通常只會在拖放作業期間擷取，並保留擷取，直到拖放作業的拖放動作發生。</span><span class="sxs-lookup"><span data-stu-id="43995-451">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="43995-452">這個事件會使用反昇路由，因為已擷取的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-452">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-453">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷已擷取的實際項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-453">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="43995-454">此事件會建立這個類別的附加事件的別名，讓<xref:System.Windows.ContentElement.GotStylusCapture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-454">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-455">事件處理常式附加至<xref:System.Windows.ContentElement.GotStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-455">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-456">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-456">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-457">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-457">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="43995-458">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-458">Routing strategy</span></span>|<span data-ttu-id="43995-459">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-459">Bubbling</span></span>|  
|<span data-ttu-id="43995-460">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-460">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-461">沒有定義對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-461">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-462">覆寫<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-462">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-463">識別 <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-463">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-464">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-464">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-465">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-465">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-466">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-466">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-467">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-467">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-468">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-468">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-469">當觸控擷取至這個項目時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-469">Occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-470">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-470">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-471">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-471">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="43995-472">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-472">Routing strategy</span></span>|<span data-ttu-id="43995-473">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-473">Bubbling</span></span>|  
|<span data-ttu-id="43995-474">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-474">Delegate</span></span>|<span data-ttu-id="43995-475">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-475"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-476">覆寫<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-476">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-477">識別 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-477">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-478">取得值，指出這個項目是否有任何動畫屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-478">Gets a value that indicates whether this element has any animated properties.</span></span></summary>
        <value>
          <span data-ttu-id="43995-479">如果這個項目有附加至其任一屬性的動畫則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-479"><see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-480">這個屬性會傳回`true`持續性 （unclocked，一律執行） 的動畫，或有特定的時間表的動畫。</span><span class="sxs-lookup"><span data-stu-id="43995-480">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-481">取得與這個項目關聯的輸入繫結集合。</span><span class="sxs-lookup"><span data-stu-id="43995-481">Gets the collection of input bindings that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="43995-482">輸入繫結的集合。</span><span class="sxs-lookup"><span data-stu-id="43995-482">The collection of input bindings.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-483">輸入繫結支援命令與輸入裝置繫的結。</span><span class="sxs-lookup"><span data-stu-id="43995-483">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="43995-484">例如，<xref:System.Windows.Input.MouseBinding>實作輸入繫結包含滑鼠裝置特有的屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-484">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="43995-485">輸入繫結的集合包含屬於此類型的輸入繫結和也會宣告執行個體的輸入繫結。</span><span class="sxs-lookup"><span data-stu-id="43995-485">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="43995-486">相關的屬性， <xref:System.Windows.ContentElement.CommandBindings%2A>，維持命令繫結的集合。</span><span class="sxs-lookup"><span data-stu-id="43995-486">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="43995-487">這些繫結不同的輸入繫結，因為它們代表的下一個層級的命令處理它們的繫結至已知的命令和類別的特定處理常式的動作。</span><span class="sxs-lookup"><span data-stu-id="43995-487">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="43995-488">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="43995-488">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="43995-489">XAML 值</span><span class="sxs-lookup"><span data-stu-id="43995-489">XAML Values</span></span>  
 <span data-ttu-id="43995-490">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="43995-490">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="43995-491">一或多個<xref:System.Windows.Input.InputBinding>項目 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>衍生類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-491">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="43995-492">每一個都應該要有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>屬性設定。</span><span class="sxs-lookup"><span data-stu-id="43995-492">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-493">取得或設定值，這個值表示這個項目是否已在 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中啟用。</span><span class="sxs-lookup"><span data-stu-id="43995-493">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value>
          <span data-ttu-id="43995-494">如果已啟用該項目則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-494"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-495">預設值是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="43995-495">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-496">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-496">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-497">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-497">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="43995-498">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-498">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-499">無</span><span class="sxs-lookup"><span data-stu-id="43995-499">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-500">下列範例會建立包含可提供替代的視覺化行為的屬性 setter 的樣式時<xref:System.Windows.Documents.Hyperlink>設<xref:System.Windows.ContentElement.IsEnabled%2A> `false`。</span><span class="sxs-lookup"><span data-stu-id="43995-500">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-501">當這個項目的 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-501">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-502">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-502">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-503">取得值，這個值會成為衍生類別中 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 的傳回值。</span><span class="sxs-lookup"><span data-stu-id="43995-503">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span></span></summary>
        <value>
          <span data-ttu-id="43995-504">如果已啟用該項目則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-504"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-505">這個屬性的預設實作快取的值，而且也會計算這個項目之父項目是否已啟用。</span><span class="sxs-lookup"><span data-stu-id="43995-505">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span></span> <span data-ttu-id="43995-506">(如果未啟用父代，無法在實際有效地啟用的子項目[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果您選擇覆寫這個實作，請確定呼叫基底實作以保留此行為。</span><span class="sxs-lookup"><span data-stu-id="43995-506">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-507">識別 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-507">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-508">取得值，決定這個項目是否具有邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-508">Gets a value that determines whether this element has logical focus.</span></span></summary>
        <value>
          <span data-ttu-id="43995-509">如果這個項目擁有邏輯焦點則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-509"><see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-510">如果某個應用程式多個焦點分區，例如功能表內容和應用程式的其餘部分之間，可能會與鍵盤焦點不同邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-510">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="43995-511">在此案例中，應用程式 UI 的一個項目上只能是鍵盤焦點，不過，其他焦點分割中的特定項目可能仍會保留邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-511">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="43995-512">如需有關邏輯焦點的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)和[焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-512">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-513">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-513">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-514">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-514">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="43995-515">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-515">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-516">無</span><span class="sxs-lookup"><span data-stu-id="43995-516">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-517">下列範例會建立樣式使<xref:System.Windows.Documents.Paragraph>預設可設定焦點，並提供視覺化行為收到焦點時。</span><span class="sxs-lookup"><span data-stu-id="43995-517">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-518">識別 <see cref="P:System.Windows.ContentElement.IsFocused" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-518">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-519">取得值，這個值指出是否已啟用輸入方法系統，例如 [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]，以處理此項目的輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-519">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span></span></summary>
        <value>
          <span data-ttu-id="43995-520">如果輸入方法作用中則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-520"><see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-521">基礎附加屬性的預設值是<see langword="true" />; 不過，這個值會受到輸入法在執行階段的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-521">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-522">這個屬性會傳回附加的屬性所傳回的值<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>針對目前啟用輸入法 （鍵盤、 語音、 和其他輸入的裝置）。</span><span class="sxs-lookup"><span data-stu-id="43995-522">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-523">取得值，指出這個項目是否具有鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-523">Gets a value that indicates whether this element has keyboard focus.</span></span></summary>
        <value>
          <span data-ttu-id="43995-524">如果這個項目具有鍵盤焦點則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-524"><see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-525">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-525">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-526">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-526">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-527">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-527">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="43995-528">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-528">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-529">無</span><span class="sxs-lookup"><span data-stu-id="43995-529">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-530">當這個項目的 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-530">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-531">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-531">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-532">識別 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-532">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-533">取得值，這個值表示鍵盤焦點是否在項目內或子項目內的任意處。</span><span class="sxs-lookup"><span data-stu-id="43995-533">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span></span></summary>
        <value>
          <span data-ttu-id="43995-534">如果鍵盤焦點在項目或其子項目上則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-534"><see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-535">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-535">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-536">對這個屬性的值的變更通常引發<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件，除非在衍生的類別已覆寫<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>来隱藏的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-536">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="43995-537">您未設定這個屬性直接，但是您可以將焦點設定至的項目藉由呼叫<xref:System.Windows.ContentElement.Focus%2A>，或藉由<xref:System.Windows.ContentElement.MoveFocus%2A>要求。</span><span class="sxs-lookup"><span data-stu-id="43995-537">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="43995-538">這些方法會呼叫其中一項可能會變更這個屬性值。</span><span class="sxs-lookup"><span data-stu-id="43995-538">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-539">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-539">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-540">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-540">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="43995-541">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-541">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-542">無</span><span class="sxs-lookup"><span data-stu-id="43995-542">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-543">當這個項目的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-543">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-544">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-544">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-545">識別 <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-545">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-546">取得值，這個值表示滑鼠是否由這個項目所捕捉。</span><span class="sxs-lookup"><span data-stu-id="43995-546">Gets a value that indicates whether the mouse is captured by this element.</span></span></summary>
        <value>
          <span data-ttu-id="43995-547">如果項目已具有滑鼠捕捉則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-547"><see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-548">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-548">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-549">與處理序中的拖放作業相關的滑鼠捕捉的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-549">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-550">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-550">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-551">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-551">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="43995-552">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-552">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-553">無</span><span class="sxs-lookup"><span data-stu-id="43995-553">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-554">下列範例會根據滑鼠是否已擷取項目，開啟或關閉滑鼠擷取狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-554">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-555">當這個項目的 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-555">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-556">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-556">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-557">識別 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-557">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-558">取得值，決定滑鼠捕捉是否由這個項目或其項目樹狀結構中的子項目所保留。</span><span class="sxs-lookup"><span data-stu-id="43995-558">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span></span></summary>
        <value>
          <span data-ttu-id="43995-559">如果這個項目或包含的項目具有滑鼠捕捉則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-559"><see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-560">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-560">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-561">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-561">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-562">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-562">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="43995-563">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-563">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-564">無</span><span class="sxs-lookup"><span data-stu-id="43995-564">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-565">當這個項目的 <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> 值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-565">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-566">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-566">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-567">識別 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-567">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-568">取得值，指出滑鼠指標位置是否與點擊測試結果對應，該結果會將複合項目納入考量。</span><span class="sxs-lookup"><span data-stu-id="43995-568">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value>
          <span data-ttu-id="43995-569"><see langword="true" /> 如果滑鼠指標位於相同的項目結果與點擊測試。否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-569"><see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-570">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-570">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-571">不同於<xref:System.Windows.ContentElement.IsMouseOver%2A>，這個屬性才`true`如果滑鼠指標常值的項目，因為其適用於點擊測試。</span><span class="sxs-lookup"><span data-stu-id="43995-571">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element—as it is for a hit test.</span></span> <span data-ttu-id="43995-572">如果滑鼠指標位於子項目上方，特別是在項目一部分的項目更深入的範本和複合 （compositing），這個屬性會是`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-572">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="43995-573">除非您知道控制項的複合 （例如，您使用這個屬性的自訂控制項範本中的控制項，您定義），這個屬性可能會傳回非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="43995-573">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="43995-574">大部分的情況下都不製作控制項，使用<xref:System.Windows.ContentElement.IsMouseOver%2A>改為。</span><span class="sxs-lookup"><span data-stu-id="43995-574">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="43995-575">如果將滑鼠擷取由這個項目，而且這個屬性為`true`在擷取時，這個屬性會繼續傳回`true`直到失去滑鼠捕捉但其範圍不是指標。</span><span class="sxs-lookup"><span data-stu-id="43995-575">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-576">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-576">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-577">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-577">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="43995-578">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-578">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-579">無</span><span class="sxs-lookup"><span data-stu-id="43995-579">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-580">當這個項目的 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-580">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-581">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-581">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-582">識別 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-582">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-583">取得值，這個值表示滑鼠指標是否位於這個項目上方 (包括視覺子項目或其複合控制項)。</span><span class="sxs-lookup"><span data-stu-id="43995-583">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span></span></summary>
        <value>
          <span data-ttu-id="43995-584">如果滑鼠指標位於項目或其子項目上方則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-584"><see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-585">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-585">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-586">雖然類似"IsMouseOverChanged 」 事件不存在，便會執行數個類似的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-586">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="43995-587">例如，您可以使用<xref:System.Windows.ContentElement.MouseEnter>， <xref:System.Windows.ContentElement.MouseMove>，和<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。</span><span class="sxs-lookup"><span data-stu-id="43995-587">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="43995-588">如果此元素擷取滑鼠，這個屬性會保留`true`直到已失去滑鼠捕捉滑鼠指標離開項目範圍。</span><span class="sxs-lookup"><span data-stu-id="43995-588">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-589">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-589">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-590">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-590">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="43995-591">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-591">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-592">無</span><span class="sxs-lookup"><span data-stu-id="43995-592">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="43995-593">下列範例會建立包含可提供替代的視覺化行為的屬性 setter 的樣式時<xref:System.Windows.Documents.Hyperlink>報表<xref:System.Windows.ContentElement.IsMouseOver%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-593">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-594">識別 <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-594">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-595">取得值，指出是否將手寫筆擷取至這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-595">Gets a value that indicates whether the stylus is captured to this element.</span></span></summary>
        <value>
          <span data-ttu-id="43995-596">如果項目已具有手寫筆捕捉則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-596"><see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-597">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-597">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-598">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-598">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-599">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-599">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-600">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-600">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-601">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-601">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="43995-602">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-602">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-603">無</span><span class="sxs-lookup"><span data-stu-id="43995-603">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-604">當這個項目的 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-604">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-605">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-605">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-606">識別 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-606">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-607">取得值，這個值決定手寫筆捕捉是否由這個項目 (包括子項目和複合控制項) 保有。</span><span class="sxs-lookup"><span data-stu-id="43995-607">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span></span></summary>
        <value>
          <span data-ttu-id="43995-608">如果手寫筆捕捉保留在這個項目內則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-608"><see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-609">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-609">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-610">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-610">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-611">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-611">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-612">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-612">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="43995-613">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-613">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-614">無</span><span class="sxs-lookup"><span data-stu-id="43995-614">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-615">當這個項目的 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-615">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-616">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-616">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-617">識別 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-617">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-618">取得值，指出手寫筆位置是否與點擊測試結果相對應，該結果會將複合項目納入考量。</span><span class="sxs-lookup"><span data-stu-id="43995-618">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value>
          <span data-ttu-id="43995-619">如果手寫筆位於與點擊測試相同的項目上方則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-619"><see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-620">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-620">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-621">不同於<xref:System.Windows.ContentElement.IsStylusOver%2A>，這個屬性才`true`如果手寫筆在元素上方。</span><span class="sxs-lookup"><span data-stu-id="43995-621">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="43995-622">如果手寫筆改為透過子元素或元素的更深入的複合 （compositing） 的一部分的項目，這個屬性會是`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-622">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="43995-623">除非您知道控制項的複合 （例如，您使用這個屬性的自訂控制項範本中的控制項，您定義），這個屬性可能會傳回非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="43995-623">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="43995-624">大部分的情況下都不製作控制項，使用<xref:System.Windows.ContentElement.IsStylusOver%2A>改為。</span><span class="sxs-lookup"><span data-stu-id="43995-624">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="43995-625">如果這個項目具有手寫筆擷取，而且這個屬性是`true`在擷取時，這個屬性會保持`true`直到手寫筆擷取遺失，且其範圍不是手寫筆。</span><span class="sxs-lookup"><span data-stu-id="43995-625">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="43995-626">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-626">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-627">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-627">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-628">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-628">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-629">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-629">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="43995-630">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-630">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-631">無</span><span class="sxs-lookup"><span data-stu-id="43995-631">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-632">當這個項目的 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 屬性值變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-632">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-633">這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-633">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-634">識別 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-634">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-635">取得值，這個值表示手寫筆是否位於這個項目上方 (包括視覺化子項目)。</span><span class="sxs-lookup"><span data-stu-id="43995-635">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span></span></summary>
        <value>
          <span data-ttu-id="43995-636">如果手寫筆位於項目或其子項目上方則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-636"><see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="43995-637">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-637">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-638">如果這個項目具有手寫筆擷取，這個屬性會保留`true`直到手寫筆擷取是遺失而且已超出其範圍的指標。</span><span class="sxs-lookup"><span data-stu-id="43995-638">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="43995-639">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-639">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-640">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-640">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="43995-641">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="43995-641">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-642">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-642">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="43995-643">中繼資料屬性設定為 `true`</span><span class="sxs-lookup"><span data-stu-id="43995-643">Metadata properties set to `true`</span></span>|<span data-ttu-id="43995-644">無</span><span class="sxs-lookup"><span data-stu-id="43995-644">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-645">識別 <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-645">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-646">焦點在這個項目上方且按下按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-646">Occurs when a key is pressed while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-647">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="43995-647">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="43995-648"><xref:System.Windows.ContentElement.KeyDown>是可能無法如預期般特定控制項的較低層級文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-648">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="43995-649">這是因為有些控制項會有複合控制項，或提供文字的高階版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="43995-649">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="43995-650">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.KeyDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-650">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-651">事件處理常式附加至<xref:System.Windows.ContentElement.KeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-651">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-652">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-652">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-653">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-653">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="43995-654">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-654">Routing strategy</span></span>|<span data-ttu-id="43995-655">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-655">Bubbling</span></span>|  
|<span data-ttu-id="43995-656">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-656">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="43995-657">對應通道的事件<xref:System.Windows.ContentElement.PreviewKeyDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-657">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="43995-658">覆寫<xref:System.Windows.ContentElement.OnKeyDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-658">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-659">識別 <see cref="E:System.Windows.ContentElement.KeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-659">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-660">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-660">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-661">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-661">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-662">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-662">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-663">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-663">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-664">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-664">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-665">焦點在這個項目上方且放開按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-665">Occurs when a key is released while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-666">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.ContentElement.KeyUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-666">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-667">事件處理常式附加至<xref:System.Windows.ContentElement.KeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-667">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-668">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-668">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-669">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-669">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="43995-670">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-670">Routing strategy</span></span>|<span data-ttu-id="43995-671">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-671">Bubbling</span></span>|  
|<span data-ttu-id="43995-672">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-672">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="43995-673">對應通道的事件<xref:System.Windows.ContentElement.PreviewKeyUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-673">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="43995-674">覆寫<xref:System.Windows.ContentElement.OnKeyUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-674">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-675">識別 <see cref="E:System.Windows.ContentElement.KeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-675">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-676">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-676">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-677">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-677">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-678">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-678">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-679">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-679">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-680">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-680">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-681">此元素失去邏輯焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-681">Occurs when this element loses logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-682">如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同範圍中，則邏輯焦點會與鍵盤焦點不同。</span><span class="sxs-lookup"><span data-stu-id="43995-682">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="43995-683">在此案例中、 鍵盤焦點會維持為，其所在和項目位置<xref:System.Windows.ContentElement.Focus%2A>方法呼叫仍取得邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="43995-683">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="43995-684">這個事件的更精確的解釋是它時引發的值<xref:System.Windows.ContentElement.IsFocused%2A>屬性路由的項目從變更`true`至`false`。</span><span class="sxs-lookup"><span data-stu-id="43995-684">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="43995-685">由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-685">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-686">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-686">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-687">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-688">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-688">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="43995-689">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-689">Routing strategy</span></span>|<span data-ttu-id="43995-690">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-690">Bubbling</span></span>|  
|<span data-ttu-id="43995-691">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-691">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="43995-692">沒有任何對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-692">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-693">覆寫<xref:System.Windows.ContentElement.OnLostFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-693">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-694">識別 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-694">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-695">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-696">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-697">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-698">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-699">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-700">鍵盤不再以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-700">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-701">由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-701">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-702">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-702">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="43995-703">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.LostKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-703">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-704">事件處理常式附加至<xref:System.Windows.ContentElement.LostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-704">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-705">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-705">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-706">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-706">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="43995-707">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-707">Routing strategy</span></span>|<span data-ttu-id="43995-708">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-708">Bubbling</span></span>|  
|<span data-ttu-id="43995-709">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-709">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="43995-710">對應通道的事件<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="43995-710">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="43995-711">覆寫<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-711">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-712">識別 <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-712">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-713">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-713">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-714">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-714">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-715">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-715">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-716">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-716">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-717">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-717">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-718">此元素失去滑鼠擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-718">Occurs when this element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-719">當項目捕捉到滑鼠時，它收到滑鼠輸入，即使指標位於其範圍外。</span><span class="sxs-lookup"><span data-stu-id="43995-719">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="43995-720">滑鼠通常只會在拖放作業期間擷取。</span><span class="sxs-lookup"><span data-stu-id="43995-720">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="43995-721">由於這個事件會使用反昇路由，失去擷取項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-721">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-722">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際遺失擷取的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-722">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="43995-723">此事件會建立一個別名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.LostMouseCapture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-723">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-724">事件處理常式附加至<xref:System.Windows.ContentElement.LostMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-724">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-725">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-725">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-726">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-726">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="43995-727">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-727">Routing strategy</span></span>|<span data-ttu-id="43995-728">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-728">Bubbling</span></span>|  
|<span data-ttu-id="43995-729">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-729">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-730">沒有定義對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-730">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-731">覆寫<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-731">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-732">識別 <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-732">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-733">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-733">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-734">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-734">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-735">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-735">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-736">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-736">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-737">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-737">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-738">此元素失去手寫筆擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-738">Occurs when this element loses stylus capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-739">當項目擷取手寫筆時，即使指標位於其範圍外接收手寫筆輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-739">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="43995-740">通常只會在拖放作業期間擷取手寫筆。</span><span class="sxs-lookup"><span data-stu-id="43995-740">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="43995-741">由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-741">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-742">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-742">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="43995-743">此事件會建立一個別名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.LostStylusCapture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-743">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-744">事件處理常式附加至<xref:System.Windows.ContentElement.LostStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-744">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-745">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-745">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-746">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-746">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="43995-747">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-747">Routing strategy</span></span>|<span data-ttu-id="43995-748">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-748">Bubbling</span></span>|  
|<span data-ttu-id="43995-749">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-749">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-750">沒有定義對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-750">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-751">覆寫<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-751">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-752">識別 <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-752">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-753">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-753">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-754">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-754">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-755">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-755">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-756">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-756">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-757">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-757">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-758">當這個項目失去觸控擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-758">Occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-759">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-759">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-760">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-760">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="43995-761">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-761">Routing strategy</span></span>|<span data-ttu-id="43995-762">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-762">Bubbling</span></span>|  
|<span data-ttu-id="43995-763">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-763">Delegate</span></span>|<span data-ttu-id="43995-764">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-764"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-765">覆寫<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-765">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-766">識別 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-766">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-767">指標在此元素上方且按下任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-767">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-768">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-768">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-769">事件處理常式附加至<xref:System.Windows.ContentElement.MouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-769">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-770"><xref:System.Windows.ContentElement.MouseDown>通常就會引發事件一起可能<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>，這對應到其中的兩個標準滑鼠按鈕的按下。</span><span class="sxs-lookup"><span data-stu-id="43995-770">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="43995-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> 和<xref:System.Windows.ContentElement.MouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="43995-772">請參閱備註<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-772">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43995-773">少數<xref:System.Windows.ContentElement>衍生類別，例如具有類似控制項的行為， <xref:System.Windows.Documents.Hyperlink>，可能具有固有的類別處理滑鼠按鈕的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-773">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="43995-774">滑鼠左鍵按下事件是最有可能有控制項中的類別處理事件。</span><span class="sxs-lookup"><span data-stu-id="43995-774">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="43995-775">處理通常類別標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。</span><span class="sxs-lookup"><span data-stu-id="43995-775">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="43995-776">一旦處理標記事件，通常無法引發另一個執行個體處理常式附加至該元素。</span><span class="sxs-lookup"><span data-stu-id="43995-776">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="43995-777">不通常也會引發任何其他類別或執行個體的處理常式附加到反昇方向朝向 UI 樹狀目錄中的根項目。</span><span class="sxs-lookup"><span data-stu-id="43995-777">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="43995-778">您可以解決問題，會在前面的重要概述，仍然會接收<xref:System.Windows.ContentElement.MouseDown>滑鼠左鍵，往下處理使用其中一個這些方案的類別衍生類別上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="43995-778">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="43995-779">附加的處理常式<xref:System.Windows.ContentElement.PreviewMouseDown>未標示為已由控制項所處理的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-779">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="43995-780">請注意，因為這是預覽事件時，路由從根目錄開始，並透過通道傳送到控制項。</span><span class="sxs-lookup"><span data-stu-id="43995-780">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="43995-781">藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.ContentElement.AddHandler%2A>，然後選擇讓接聽事件，即使它們已標示為已處理路由的事件資料中的處理常式的簽章選項。</span><span class="sxs-lookup"><span data-stu-id="43995-781">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-782">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-782">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-783">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-783">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="43995-784">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-784">Routing strategy</span></span>|<span data-ttu-id="43995-785">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-785">Bubbling</span></span>|  
|<span data-ttu-id="43995-786">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-786">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-787">對應通道的事件<xref:System.Windows.ContentElement.PreviewMouseDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-787">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="43995-788">覆寫<xref:System.Windows.ContentElement.OnMouseDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-788">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-789">識別 <see cref="E:System.Windows.ContentElement.MouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-789">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-790">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-790">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-791">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-791">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-792">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-792">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-793">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-793">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-794">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-794">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-795">滑鼠指標進入此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-795">Occurs when the mouse pointer enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-796"><xref:System.Windows.ContentElement.MouseEnter> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="43995-796"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="43995-797">直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。</span><span class="sxs-lookup"><span data-stu-id="43995-797">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="43995-798">不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。</span><span class="sxs-lookup"><span data-stu-id="43995-798">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="43995-799">雖然<xref:System.Windows.ContentElement.MouseEnter>時滑鼠指標進入項目的邊界時發生，此事件的詳細追蹤逐字報告<xref:System.Windows.ContentElement.IsMouseOver%2A>屬性值已經從`false`至`true`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="43995-799">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="43995-800">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseEnter>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-800">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-801">事件處理常式附加至<xref:System.Windows.ContentElement.MouseEnter>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-801">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-802">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-802">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-803">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-803">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="43995-804">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-804">Routing strategy</span></span>|<span data-ttu-id="43995-805">直接</span><span class="sxs-lookup"><span data-stu-id="43995-805">Direct</span></span>|  
|<span data-ttu-id="43995-806">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-806">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-807">覆寫<xref:System.Windows.ContentElement.OnMouseEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-807">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-808">識別 <see cref="E:System.Windows.ContentElement.MouseEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-808">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-809">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-809">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-810">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-810">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-811">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-811">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-812">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-812">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-813">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-813">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-814">滑鼠指標離開此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-814">Occurs when the mouse pointer leaves the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-815"><xref:System.Windows.ContentElement.MouseLeave> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="43995-815"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="43995-816">直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。</span><span class="sxs-lookup"><span data-stu-id="43995-816">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="43995-817">不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。</span><span class="sxs-lookup"><span data-stu-id="43995-817">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="43995-818">雖然<xref:System.Windows.ContentElement.MouseLeave>曲目，當滑鼠離開項目時，此事件多逐字報告<xref:System.Windows.ContentElement.IsMouseOver%2A>屬性值已經從`true`至`false`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="43995-818">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="43995-819">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseLeave>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-819">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-820">事件處理常式附加至<xref:System.Windows.ContentElement.MouseLeave>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-820">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-821">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-821">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-822">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-822">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="43995-823">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-823">Routing strategy</span></span>|<span data-ttu-id="43995-824">直接</span><span class="sxs-lookup"><span data-stu-id="43995-824">Direct</span></span>|  
|<span data-ttu-id="43995-825">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-825">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-826">覆寫<xref:System.Windows.ContentElement.OnMouseLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-826">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-827">識別 <see cref="E:System.Windows.ContentElement.MouseLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-827">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-828">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-828">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-829">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-829">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-830">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-830">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-831">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-831">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-832">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-832">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-833">滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-833">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-834">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-834">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-835">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-835">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-836">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-836">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-837">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-837">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-838">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-838">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-839">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-839">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-840">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-840">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43995-841">少數<xref:System.Windows.ContentElement>衍生類別，例如具有類似控制項的行為， <xref:System.Windows.Documents.Hyperlink>，可能具有固有的類別處理滑鼠按鈕的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-841">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="43995-842">滑鼠左鍵按下事件是最有可能有控制項中的類別處理事件。</span><span class="sxs-lookup"><span data-stu-id="43995-842">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="43995-843">處理通常類別標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。</span><span class="sxs-lookup"><span data-stu-id="43995-843">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="43995-844">一旦處理標記事件，通常無法引發另一個執行個體處理常式附加至該元素。</span><span class="sxs-lookup"><span data-stu-id="43995-844">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="43995-845">不通常也會引發任何其他類別或執行個體的處理常式附加到反昇方向朝向 UI 樹狀目錄中的根項目。</span><span class="sxs-lookup"><span data-stu-id="43995-845">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="43995-846">您可以解決問題，會在前面的重要概述，仍然會接收<xref:System.Windows.ContentElement.MouseLeftButtonDown>滑鼠左鍵，往下處理使用其中一個這些方案的類別衍生類別上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="43995-846">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="43995-847">附加的處理常式<xref:System.Windows.ContentElement.PreviewMouseDown>未標示為已由控制項所處理的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-847">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="43995-848">請注意，因為這是預覽事件時，路由從根目錄開始，並透過通道傳送到控制項。</span><span class="sxs-lookup"><span data-stu-id="43995-848">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="43995-849">藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.ContentElement.AddHandler%2A>，然後選擇讓接聽事件，即使它們已標示為已處理路由的事件資料中的處理常式的簽章選項。</span><span class="sxs-lookup"><span data-stu-id="43995-849">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-850">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-850">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-851">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-851">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="43995-852">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-852">Routing strategy</span></span>|<span data-ttu-id="43995-853">直接</span><span class="sxs-lookup"><span data-stu-id="43995-853">Direct</span></span>|  
|<span data-ttu-id="43995-854">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-854">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-855">覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-855">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-856">識別 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-856">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-857">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-857">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-858">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-858">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-859">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-859">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-860">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-860">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-861">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-861">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-862">滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-862">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-863">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-863">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-864">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-864">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-865">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-865">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-866">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-866">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-867">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-867">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-868">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-868">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-869">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-869">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-870">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-870">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-871">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-871">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="43995-872">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-872">Routing strategy</span></span>|<span data-ttu-id="43995-873">直接</span><span class="sxs-lookup"><span data-stu-id="43995-873">Direct</span></span>|  
|<span data-ttu-id="43995-874">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-874">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-875">覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-875">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-876">識別 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-876">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-877">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-877">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-878">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-878">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-879">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-879">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-880">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-880">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-881">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-881">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-882">滑鼠指標在此元素上方移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-882">Occurs when the mouse pointer moves while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-883">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-883">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-884">事件處理常式附加至<xref:System.Windows.ContentElement.MouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-884">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-885">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-885">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-886">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-886">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="43995-887">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-887">Routing strategy</span></span>|<span data-ttu-id="43995-888">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-888">Bubbling</span></span>|  
|<span data-ttu-id="43995-889">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-889">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-890">對應通道的事件<xref:System.Windows.ContentElement.PreviewMouseMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="43995-891">覆寫<xref:System.Windows.ContentElement.OnMouseMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-891">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-892">識別 <see cref="E:System.Windows.ContentElement.MouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-892">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-893">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-893">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-894">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-894">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-895">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-895">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-896">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-896">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-897">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-897">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-898">滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-898">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-899">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-899">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-900">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-900">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-901">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-901">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-902">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-902">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-903">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-903">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-904">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-904">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-905">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-905">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-906">滑鼠右鍵事件中通常會有原生處理應用程式案例。</span><span class="sxs-lookup"><span data-stu-id="43995-906">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="43995-907">比方說，向下的滑鼠右按鈕可能會顯示內容功能表。</span><span class="sxs-lookup"><span data-stu-id="43995-907">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="43995-908">請參閱[ContextMenu 概觀](~/docs/framework/wpf/controls/contextmenu-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-908">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-909">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-909">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-910">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-910">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="43995-911">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-911">Routing strategy</span></span>|<span data-ttu-id="43995-912">直接</span><span class="sxs-lookup"><span data-stu-id="43995-912">Direct</span></span>|  
|<span data-ttu-id="43995-913">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-913">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-914">覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-914">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-915">識別 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-915">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-916">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-916">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-917">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-917">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-918">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-918">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-919">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-919">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-920">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-920">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-921">滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-921">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-922">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-922">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-923">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-923">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-924">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-924">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-925">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-925">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-926">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-926">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-927">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-927">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-928">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-928">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-929">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-929">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-930">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-930">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="43995-931">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-931">Routing strategy</span></span>|<span data-ttu-id="43995-932">直接</span><span class="sxs-lookup"><span data-stu-id="43995-932">Direct</span></span>|  
|<span data-ttu-id="43995-933">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-933">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-934">覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-934">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-935">識別 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-935">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-936">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-936">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-937">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-937">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-938">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-938">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-939">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-939">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-940">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-940">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-941">在此元素上方放開任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-941">Occurs when any mouse button is released over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-942">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-942">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-943">事件處理常式附加至<xref:System.Windows.ContentElement.MouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-943">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-944"><xref:System.Windows.ContentElement.MouseUp>通常就會引發事件一起可能<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>，這對應至其中的兩個標準滑鼠按鈕的版本。</span><span class="sxs-lookup"><span data-stu-id="43995-944">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="43995-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> 和<xref:System.Windows.ContentElement.MouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="43995-946">請參閱備註<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-946">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-947">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-947">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-948">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-948">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="43995-949">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-949">Routing strategy</span></span>|<span data-ttu-id="43995-950">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-950">Bubbling</span></span>|  
|<span data-ttu-id="43995-951">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-951">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-952">對應通道的事件<xref:System.Windows.ContentElement.PreviewMouseUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-952">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="43995-953">覆寫<xref:System.Windows.ContentElement.OnMouseUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-953">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-954">識別 <see cref="E:System.Windows.ContentElement.MouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-954">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-955">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-955">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-956">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-956">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-957">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-957">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-958">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-958">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-959">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-959">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-960">滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-960">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-961">焦點或滑鼠捕捉優先於滑鼠指標所在位置。因此，如果您收到<xref:System.Windows.ContentElement.MouseWheel>事件從取得焦點或擷取的項目，將滑鼠指標可能實際上是透過另一個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-961">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="43995-962">此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.MouseWheel>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-962">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-963">事件處理常式附加至<xref:System.Windows.ContentElement.MouseWheel>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-963">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-964">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-964">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-965">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-965">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="43995-966">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-966">Routing strategy</span></span>|<span data-ttu-id="43995-967">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-967">Bubbling</span></span>|  
|<span data-ttu-id="43995-968">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-968">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="43995-969">對應通道的事件<xref:System.Windows.ContentElement.PreviewMouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="43995-969">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="43995-970">覆寫<xref:System.Windows.ContentElement.OnMouseWheel%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-970">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-971">識別 <see cref="E:System.Windows.ContentElement.MouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-971">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-972">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-972">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-973">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-973">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-974">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-974">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-975">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-975">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-976">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-976">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="43995-977">包含屬性的周遊要求，該屬性指出在現有定位順序中周遊的模式，或以視覺化方式移動的方向。</span><span class="sxs-lookup"><span data-stu-id="43995-977">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span></span></param>
        <summary><span data-ttu-id="43995-978">嘗試將焦點從這個項目移至另一個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-978">Attempts to move focus from this element to another element.</span></span> <span data-ttu-id="43995-979">移動焦點的方向是由指引方向所指定，該指引方向是在這個項目之視覺化父代的組織內解譯。</span><span class="sxs-lookup"><span data-stu-id="43995-979">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-980">如果已執行要求的周遊則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-980"><see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-981">請確定您檢查此方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="43995-981">Make sure you check the return value of this method.</span></span> <span data-ttu-id="43995-982">傳回值為`false`如果周遊時碰到的定位點由控制項的組合所定義，並周遊要求未包裝要求可能會傳回。</span><span class="sxs-lookup"><span data-stu-id="43995-982">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-983">為 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構傳回類別特定的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</span><span class="sxs-lookup"><span data-stu-id="43995-983">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span></summary>
        <returns><span data-ttu-id="43995-984">因型別而異的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</span><span class="sxs-lookup"><span data-stu-id="43995-984">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-985">這個方法的實作會在呼叫的特定建構函式通常是<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作中，並將其傳回做為傳回值。</span><span class="sxs-lookup"><span data-stu-id="43995-985">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span></span>  
  
 <span data-ttu-id="43995-986">所有<see cref="T:System.Windows.ContentElement" />衍生的類別應該實作這個方法以提供它們自己的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基礎結構。</span><span class="sxs-lookup"><span data-stu-id="43995-986">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span> <span data-ttu-id="43995-987">如需實作此模式的詳細資訊，請參閱<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</span><span class="sxs-lookup"><span data-stu-id="43995-987">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-988">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-988">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-989">當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-989">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-990">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-990">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-991">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-991">This method has no default implementation.</span></span> <span data-ttu-id="43995-992">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-992">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-993">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-993">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-994">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-994">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-995">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-995">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-996">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-996">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-997">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-997">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-998">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-998">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-999">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-999">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1000">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1000">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1001">當未處理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1001">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1002">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1002">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1003">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1003">This method has no default implementation.</span></span> <span data-ttu-id="43995-1004">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1004">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1005">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1005">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1006">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1006">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1007">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1007">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1008">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1008">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1009">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1009">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1010">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1010">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1011">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1011">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1012">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1012">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1013">當未處理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1013">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1014">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1014">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1015">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1015">This method has no default implementation.</span></span> <span data-ttu-id="43995-1016">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1016">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1017">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1017">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1018">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1018">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1019">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1019">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1020">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1020">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1021">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1021">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1022">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1022">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1023">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1023">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1024">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1024">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1025">當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1025">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1026">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1026">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1027">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1027">This method has no default implementation.</span></span> <span data-ttu-id="43995-1028">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1028">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1029">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1029">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1030">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1030">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1031">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1031">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1032">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1032">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1033">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1033">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1034">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1034">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1035">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1035">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1036">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1036">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1037">當未處理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1037">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1038">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1038">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1039">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1039">This method has no default implementation.</span></span> <span data-ttu-id="43995-1040">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1040">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1041">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1041">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1042">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1042">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1043">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1043">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1044">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1044">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1045">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1045">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1046">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1046">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1047">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1047">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1048"><see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1048">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="43995-1049">此事件資料必須包含 <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-1049">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="43995-1050">使用所提供的事件資料引發 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1050">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1051">這個方法中，雖然是虛擬的沒有預設實作會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1051">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="43995-1052">這在 \* 方法實作用來引發事件，這個相同的方法實作會在內部叫用來引發事件時<xref:System.Windows.ContentElement.IsFocused%2A>屬性值變更。</span><span class="sxs-lookup"><span data-stu-id="43995-1052">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="43995-1053"><xref:System.Windows.ContentElement.OnGotFocus%2A>實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 只提供便利的方式來加入類別處理事件的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1053">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-1054">除非您有故意和不尋常的需要，將不會引發焦點事件，請確定您的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1054">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="43995-1055">否則，<see cref="E:System.Windows.ContentElement.GotFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1055">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="43995-1056">如果您不想要您可設定焦點的項目，您可以防止項目可設定焦點設定<see cref="P:System.Windows.ContentElement.Focusable" />至<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1056">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span> <span data-ttu-id="43995-1057">請注意，根據預設<see cref="P:System.Windows.ContentElement.Focusable" />不是可設定焦點，因此設定<see cref="P:System.Windows.ContentElement.Focusable" />刻意可能不是必要。</span><span class="sxs-lookup"><span data-stu-id="43995-1057">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span></span></para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1058">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1058">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1059">當未處理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1059">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1060">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1060">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1061">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1061">This method has no default implementation.</span></span> <span data-ttu-id="43995-1062">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1062">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1063">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1063">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1064">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1064">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1065">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1065">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1066">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1066">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1067">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1067">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1068">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1068">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1069">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1069">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1070">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1070">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1071">當未處理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1071">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1072">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1072">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1073">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1073">This method has no default implementation.</span></span> <span data-ttu-id="43995-1074">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1074">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1075">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1075">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1076">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1076">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1077">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1077">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1078">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1078">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1079">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1079">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1080">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1080">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1081">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1081">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1082">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1082">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1083">當未處理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1083">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1084">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1084">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1085">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1085">This method has no default implementation.</span></span> <span data-ttu-id="43995-1086">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1086">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1087">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1087">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1088">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1088">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1089">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1089">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1090">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1090">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1091">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1091">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1092">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1092">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1093">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1093">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1094"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1094">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1095">提供 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件的類別處理，而這個事件會在擷取到對此項目的觸控時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1095">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1096"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1096">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1097">覆寫<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>處理衍生類別中<xref:System.Windows.ContentElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1097">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="43995-1098">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1098">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1099">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1099">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1100">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1100">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1101">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1101">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1102">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>相依性屬性變更。</span><span class="sxs-lookup"><span data-stu-id="43995-1102">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="43995-1103">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1103">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1104">然後在<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1104">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1105">請注意，<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1105">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="43995-1106">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1106">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1107">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1107">This method has no default implementation.</span></span> <span data-ttu-id="43995-1108">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1108">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1109">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1109">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1110"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1110">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1111">會在 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 事件正要由這個項目引發前被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1111">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span></span> <span data-ttu-id="43995-1112">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1112">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1113">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1113">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1114">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1114">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1115">然後在<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1115">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1116">請注意，<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1116">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="43995-1117">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1117">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1118">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1118">This method has no default implementation.</span></span> <span data-ttu-id="43995-1119">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1119">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1120">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1120">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1121">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1121">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1122">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1122">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1123">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1123">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1124">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1124">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1125">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1125">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1126">然後在<xref:System.Windows.ContentElement.IsMouseCapturedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1126">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1127">請注意，<xref:System.Windows.ContentElement.IsMouseCapturedChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1127">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="43995-1128">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1128">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1129">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1129">This method has no default implementation.</span></span> <span data-ttu-id="43995-1130">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1130">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1131">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1131">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1132"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1132">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1133">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1133">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1134">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1134">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-1135">此虛擬方法，就會引發時的值<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1135">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span></span> <span data-ttu-id="43995-1136">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1136">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1137">然後在<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1137">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1138">請注意，此事件不是路由的事件。因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1138">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1139">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1139">This method has no default implementation.</span></span> <span data-ttu-id="43995-1140">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1140">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1141">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1141">You may call base either before or after your special handling, depending on your requirements.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1142">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1142">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1143">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1143">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1144">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1144">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1145">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1145">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1146">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1146">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1147">然後在<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1147">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1148">請注意，<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1148">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="43995-1149">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1149">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1150">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1150">This method has no default implementation.</span></span> <span data-ttu-id="43995-1151">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1151">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1152">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1152">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1153"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1153">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1154">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1154">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1155">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1155">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1156">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1156">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1157">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1157">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1158">然後在<xref:System.Windows.ContentElement.IsStylusCapturedChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1158">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1159">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1159">Notice that the event is not a routed event.</span></span> <span data-ttu-id="43995-1160">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1160">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1161">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1161">This method has no default implementation.</span></span> <span data-ttu-id="43995-1162">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1162">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1163">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1163">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1164">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1164">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1165">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1165">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1166">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1166">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1167">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1167">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1168">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1168">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1169">然後在<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1169">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1170">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1170">Notice that the event is not a routed event.</span></span> <span data-ttu-id="43995-1171">因此，您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1171">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1172">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1172">This method has no default implementation.</span></span> <span data-ttu-id="43995-1173">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1173">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1174">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1174">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1175">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1175">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1176">會在對這個項目引發未處理的 <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> 事件時被叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1176">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="43995-1177">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1177">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1178">此虛擬方法，就會引發時的值<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>相依性屬性變更其值。</span><span class="sxs-lookup"><span data-stu-id="43995-1178">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="43995-1179">虛擬方法會先引發，並可以操作需要的事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1179">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="43995-1180">然後在<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1180">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="43995-1181">請注意，事件就不會路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1181">Notice that the event is not a routed event.</span></span> <span data-ttu-id="43995-1182">因此您無法將它標示為已處理的類別處理常式中。</span><span class="sxs-lookup"><span data-stu-id="43995-1182">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="43995-1183">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1183">This method has no default implementation.</span></span> <span data-ttu-id="43995-1184">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1184">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1185">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1185">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1186">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1186">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1187">當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1187">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1188">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1188">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1189">按鍵動作是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1189">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1190">依賴按鍵，例如，輸入和命令繫結的其他程式設計功能可能會處理按鍵之前它會公開為一般的按鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1190">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="43995-1191">如果這些輸入系統功能將事件標記為已處理，然後<xref:System.Windows.ContentElement.OnKeyDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1191">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1192">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1192">This method has no default implementation.</span></span> <span data-ttu-id="43995-1193">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1193">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1194">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1194">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1195">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1195">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1196">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1196">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1197">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1197">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1198">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1198">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1199">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1199">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1200">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1200">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1201">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1201">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1202">當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1202">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1203">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1203">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1204">按鍵動作是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1204">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1205">依賴按鍵，例如，輸入和命令繫結的其他程式設計功能可能會處理按鍵之前它會公開為一般的按鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1205">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="43995-1206">如果這些輸入系統功能將事件標記為已處理，然後<xref:System.Windows.ContentElement.OnKeyUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1206">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1207">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1207">This method has no default implementation.</span></span> <span data-ttu-id="43995-1208">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1208">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1209">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1209">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1210">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1210">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1211">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1211">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1212">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1212">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1213">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1213">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1214">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1214">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1215">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1215">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1216"><see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1216">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="43995-1217">此事件資料必須包含 <see cref="E:System.Windows.ContentElement.LostFocus" /> 事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-1217">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="43995-1218">使用所提供的事件資料引發 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1218">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1219">這個方法中，雖然是虛擬的沒有預設實作會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1219">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="43995-1220">這在 \* 方法實作用來引發事件，這個相同的方法實作會在內部叫用來引發事件時<xref:System.Windows.ContentElement.IsFocused%2A>屬性值變更。</span><span class="sxs-lookup"><span data-stu-id="43995-1220">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="43995-1221">這項實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 只提供便利的方式來加入類別處理事件的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1221">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="43995-1222">除非您有故意和不尋常的需要，將不會引發焦點事件，請確定您的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1222">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="43995-1223">否則，<see cref="E:System.Windows.ContentElement.LostFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1223">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="43995-1224">如果您不想要您可設定焦點的項目，您可以防止項目可設定焦點設定<see cref="P:System.Windows.ContentElement.Focusable" />至<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1224">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1225">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1225">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="43995-1226">當未處理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1226">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1227">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1227">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1228">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1228">This method has no default implementation.</span></span> <span data-ttu-id="43995-1229">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1229">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1230">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1230">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1231">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1231">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1232">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1232">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1233">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1233">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1234">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1234">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1235">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1235">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1236">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1236">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1237">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1237">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="43995-1238">當未處理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1238">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1239">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1239">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1240">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1240">This method has no default implementation.</span></span> <span data-ttu-id="43995-1241">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1241">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1242">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1242">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1243">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1243">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1244">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1244">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1245">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1245">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1246">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1246">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1247">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1247">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1248">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1248">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1249">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1249">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="43995-1250">當未處理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1250">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1251">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1251">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1252">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1252">This method has no default implementation.</span></span> <span data-ttu-id="43995-1253">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1253">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1254">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1254">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1255">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1255">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1256">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1256">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1257">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1257">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1258">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1258">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1259">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1259">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1260">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1260">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1261"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1261">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1262">提供 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件的類別處理，而這個事件會在此項目失去觸控擷取時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1262">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1263"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1263">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1264">覆寫<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>處理衍生類別中<xref:System.Windows.ContentElement.LostTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1264">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="43995-1265">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1265">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1266">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1266">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1267">此事件資料會報告有關按下的滑鼠按鈕以及已處理狀態的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="43995-1267">This event data reports details about the mouse button that was pressed and the handled state.</span></span></param>
        <summary><span data-ttu-id="43995-1268">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1268">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1269">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1269">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1270">滑鼠按鈕動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1270">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1271">依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。</span><span class="sxs-lookup"><span data-stu-id="43995-1271">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="43995-1272">如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.ContentElement.OnMouseDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1272">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1273">如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.ContentElement.MouseLeftButtonDown>和<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1273">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="43995-1274">其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="43995-1274">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="43995-1275">如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-1275">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="43995-1276">如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-1276">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="43995-1277">類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-1277">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="43995-1278">藉由處理<xref:System.Windows.ContentElement.OnMouseDown%2A>，您會隱含的類別處理負責執行下的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="43995-1278">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="43995-1279">這種行為可能不想;當您使用此虛擬方法標記為已處理的事件，因此，使用警告。</span><span class="sxs-lookup"><span data-stu-id="43995-1279">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="43995-1280">每個按鈕特定直接事件也有虛擬機器 \* 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。</span><span class="sxs-lookup"><span data-stu-id="43995-1280">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="43995-1281">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1281">This method has no default implementation.</span></span> <span data-ttu-id="43995-1282">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1282">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1283">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1283">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1284">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1284">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1285">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1285">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1286">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1286">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1287">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1287">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1288">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1288">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1289">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1289">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1290">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1290">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1291">當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1291">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span></span> <span data-ttu-id="43995-1292">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1292">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1293">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1293">This method has no default implementation.</span></span> <span data-ttu-id="43995-1294">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1294">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1295">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1295">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="43995-1296">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1296">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1297">在此情況下，符合的事件是具有直接路由策略的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1297">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="43995-1298">將事件標示為已處理仍很有用防止一般的執行個體的處理常式 (這些不指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1298">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1299">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1299">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1300">當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1300">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span></span> <span data-ttu-id="43995-1301">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1301">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1302">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1302">This method has no default implementation.</span></span> <span data-ttu-id="43995-1303">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1303">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1304">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1304">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="43995-1305">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1305">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1306">在此情況下，符合的事件是具有直接路由策略的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1306">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="43995-1307">將事件標示為已處理仍很有用防止一般的執行個體的處理常式 (這些不指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1307">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1308">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1308">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1309">事件資料會報告滑鼠左鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="43995-1309">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="43995-1310">當這個項目上引發未處理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1310">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span></span> <span data-ttu-id="43995-1311">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1311">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1312"><xref:System.Windows.ContentElement.MouseLeftButtonDown>事件反昇路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1312">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="43995-1314">雖然您可以將標記<xref:System.Windows.ContentElement.MouseLeftButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1314">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1315">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1315">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1316">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1316">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1317">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1317">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1318">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1318">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1319">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1319">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="43995-1320">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1320">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="43995-1321">您是否願意呼叫基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="43995-1321">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="43995-1322">無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1322">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="43995-1323">例如，您可以從衍生<xref:System.Windows.Controls.Button>並覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>在您衍生的類別，而不需要呼叫基底實作; 不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1323">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1324">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1324">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1325">事件資料會報告已放開滑鼠左鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1325">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="43995-1326">當未處理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1326">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1327">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1327">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1328"><xref:System.Windows.ContentElement.MouseLeftButtonUp>事件反昇路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1328">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="43995-1330">雖然您可以將標記<xref:System.Windows.ContentElement.MouseLeftButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1330">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1331">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1331">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1332">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1332">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1333">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1333">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1334">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1334">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1335">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1335">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1336">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1336">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1337">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1337">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1338">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1338">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1339">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1339">This method has no default implementation.</span></span> <span data-ttu-id="43995-1340">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1340">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1341">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1341">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1342">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1342">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1343">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1343">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1344">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1344">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1345">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1345">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1346">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1346">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1347">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1347">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1348">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1348">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1349">事件資料會報告滑鼠右鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="43995-1349">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="43995-1350">當未處理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1350">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1351">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1351">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1352"><xref:System.Windows.ContentElement.MouseRightButtonDown>事件反昇路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1352">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="43995-1354">雖然您可以將標記<xref:System.Windows.ContentElement.MouseRightButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1354">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1355">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1355">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1356">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1356">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1357">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1357">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1358">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1358">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1359">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1359">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="43995-1360">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1360">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="43995-1361">您是否願意呼叫基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="43995-1361">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="43995-1362">無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1362">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="43995-1363">例如，您可以從衍生<xref:System.Windows.Controls.Control>並覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>中您的衍生類別，而不呼叫基底; 不過，此覆寫停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。</span><span class="sxs-lookup"><span data-stu-id="43995-1363">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1364">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1364">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1365">事件資料會報告已放開滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1365">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="43995-1366">當未處理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1366">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1367">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1367">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1368"><xref:System.Windows.ContentElement.MouseRightButtonUp>事件反昇路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1368">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="43995-1370">雖然您可以將標記<xref:System.Windows.ContentElement.MouseRightButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1370">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1371">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1371">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1372">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1372">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1373">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1373">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1374">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1374">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1375">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1375">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1376">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1376">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1377">事件資料會報告滑鼠按鈕已釋放。</span><span class="sxs-lookup"><span data-stu-id="43995-1377">The event data reports that the mouse button was released.</span></span></param>
        <summary><span data-ttu-id="43995-1378">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1378">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1379">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1379">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1380">滑鼠按鈕動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1380">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1381">依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。</span><span class="sxs-lookup"><span data-stu-id="43995-1381">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="43995-1382">如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.ContentElement.OnMouseUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1382">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1383">如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.ContentElement.MouseLeftButtonUp>和<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1383">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="43995-1384">其中一個這些事件可能會接收項目上引發時<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="43995-1384">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="43995-1385">如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-1385">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="43995-1386">如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-1386">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="43995-1387">類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-1387">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="43995-1388">藉由處理<xref:System.Windows.ContentElement.OnMouseUp%2A>，您會隱含的類別處理計算在內的所有可能滑鼠動作。</span><span class="sxs-lookup"><span data-stu-id="43995-1388">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="43995-1389">這種行為可能不想;當您使用此虛擬方法標記為已處理的事件，因此，使用警告。</span><span class="sxs-lookup"><span data-stu-id="43995-1389">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="43995-1390">每個按鈕特定直接事件也有虛擬機器 \* 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。</span><span class="sxs-lookup"><span data-stu-id="43995-1390">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="43995-1391">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1391">This method has no default implementation.</span></span> <span data-ttu-id="43995-1392">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1392">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1393">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1393">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1394">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1394">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1395">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1395">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1396">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1396">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1397">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1397">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1398">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1398">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1399">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1399">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1400">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1400">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1401">當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1401">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1402">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1402">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1403">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1403">This method has no default implementation.</span></span> <span data-ttu-id="43995-1404">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1404">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1405">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1405">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1406">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1406">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1407">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1407">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1408">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1408">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1409">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1409">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1410">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1410">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1411">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1411">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1412">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1412">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1413">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1413">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1414">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1414">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1415">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1415">This method has no default implementation.</span></span> <span data-ttu-id="43995-1416">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1416">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1417">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1417">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1418">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1418">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1419">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1419">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1420">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1420">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1421">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1421">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1422">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1422">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1423">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1423">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1424">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1424">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1425">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1425">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1426">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1426">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1427">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1427">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1428">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1428">This method has no default implementation.</span></span> <span data-ttu-id="43995-1429">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1429">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1430">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1430">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1431">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1431">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1432">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1432">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1433">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1433">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1434">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1434">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1435">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1435">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1436">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1436">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1437">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1437">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1438">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1438">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1439">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1439">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1440">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1440">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1441">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1441">This method has no default implementation.</span></span> <span data-ttu-id="43995-1442">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1442">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1443">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1443">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1444">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1444">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1445">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1445">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1446">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1446">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1447">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1447">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1448">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1448">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1449">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1449">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1450">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1450">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1451">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1451">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1452">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1452">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1453">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1453">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1454">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1454">This method has no default implementation.</span></span> <span data-ttu-id="43995-1455">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1455">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1456">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1456">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1457">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1458">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1458">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1459">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1459">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1460">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1460">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1461">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1461">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1462">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1462">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1463">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1463">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1464">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1464">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1465">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1465">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1466">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1466">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1467">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1467">This method has no default implementation.</span></span> <span data-ttu-id="43995-1468">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1468">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1469">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1469">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1470">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1471">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1471">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1472">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1472">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1473">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1473">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1474">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1474">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1475">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1475">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1476">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1476">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1477">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1477">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1478">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1478">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1479">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1479">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1480">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1480">This method has no default implementation.</span></span> <span data-ttu-id="43995-1481">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1481">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1482">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1482">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1483">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1483">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1484">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1484">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1485">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1485">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1486">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1486">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1487">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1487">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1488">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1488">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1489">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1489">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1490">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1490">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1491">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1491">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1492">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1492">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1493">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1493">This method has no default implementation.</span></span> <span data-ttu-id="43995-1494">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1494">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1495">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1495">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1496">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1496">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1497">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1497">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1498">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1498">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1499">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1499">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1500">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1500">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1501">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1501">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1502">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1502">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1503">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1503">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1504">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1504">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1505">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1505">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1506">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1506">This method has no default implementation.</span></span> <span data-ttu-id="43995-1507">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1507">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1508">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1508">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1509">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1509">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1510">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1510">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1511">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1511">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1512">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1512">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1513">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1513">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1514">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1514">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1515">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1515">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1516">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1516">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1517">當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1517">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1518">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1518">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1519">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1519">This method has no default implementation.</span></span> <span data-ttu-id="43995-1520">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1520">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1521">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1521">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1522">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1523">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1523">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1524">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1524">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1525">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1525">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1526">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1526">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1527">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1527">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1528">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1528">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1529">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1529">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1530">事件資料會報告一個或多個滑鼠按鈕已按下。</span><span class="sxs-lookup"><span data-stu-id="43995-1530">The event data reports that one or more mouse buttons were pressed.</span></span></param>
        <summary><span data-ttu-id="43995-1531">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1531">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1532">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1532">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1533">滑鼠按鈕動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1533">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1534">依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。</span><span class="sxs-lookup"><span data-stu-id="43995-1534">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="43995-1535">如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1535">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1536">如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1536">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="43995-1537">其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="43995-1537">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="43995-1538">如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-1538">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="43995-1539">如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-1539">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="43995-1540">類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-1540">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="43995-1541">藉由處理<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>，您會隱含的類別處理負責執行下的所有可能的滑鼠按鈕。</span><span class="sxs-lookup"><span data-stu-id="43995-1541">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="43995-1542">這種行為可能不想;當您使用此虛擬方法標記為已處理的事件，因此，使用警告。</span><span class="sxs-lookup"><span data-stu-id="43995-1542">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="43995-1543">每個按鈕特定直接事件也有虛擬機器 \* 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。</span><span class="sxs-lookup"><span data-stu-id="43995-1543">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="43995-1544">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1544">This method has no default implementation.</span></span> <span data-ttu-id="43995-1545">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1545">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1546">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1546">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1547">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1547">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1548">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1548">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1549">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1549">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1550">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1550">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1551">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1551">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1552">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1552">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1553">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1553">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1554">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1554">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1555">事件資料會報告滑鼠左鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="43995-1555">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="43995-1556">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1556">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1557">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1557">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1558"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件傳輸通道的路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1558">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="43995-1560">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1560">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1561">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1561">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1562">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1562">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1563">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1563">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1564">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1564">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1565">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1565">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="43995-1566">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1566">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="43995-1567">您是否願意呼叫基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="43995-1567">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="43995-1568">無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1568">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="43995-1569">例如，您可以從衍生<xref:System.Windows.Controls.Button>並覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>在您衍生的類別，而不需要呼叫基底實作; 不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1569">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1570">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1570">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1571">事件資料會報告已放開滑鼠左鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1571">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="43995-1572">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1572">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1573">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1573">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1574"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件傳輸通道的路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1574">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="43995-1576">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1576">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1577">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1577">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1578">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1578">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1579">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1579">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1580">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1580">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1581">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1581">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1582">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1582">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1583">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1583">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1584">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1584">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1585">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1585">This method has no default implementation.</span></span> <span data-ttu-id="43995-1586">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1586">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1587">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1587">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1588">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1588">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1589">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1589">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1590">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1590">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1591">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1591">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1592">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1592">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1593">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1593">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1594">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1594">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1595">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1595">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1596">事件資料會報告滑鼠右鍵已按下。</span><span class="sxs-lookup"><span data-stu-id="43995-1596">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="43995-1597">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1597">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1598">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1598">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1599"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件傳輸通道的路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1599">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="43995-1601">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1601">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1602">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1602">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1603">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1603">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1604">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1604">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1605">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1605">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1606">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1606">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="43995-1607">或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1607">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="43995-1608">您是否願意呼叫基底實作，取決於您的案例。</span><span class="sxs-lookup"><span data-stu-id="43995-1608">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="43995-1609">無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1609">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="43995-1610">例如，您可以從衍生<xref:System.Windows.Controls.Control>並覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>中您的衍生類別，而不呼叫基底; 不過，此覆寫停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。</span><span class="sxs-lookup"><span data-stu-id="43995-1610">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1611">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1611">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1612">事件資料會報告已放開滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-1612">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="43995-1613">當未處理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1613">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1614">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1614">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1615"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件傳輸通道的路由會出現但實際上是以間接方式。</span><span class="sxs-lookup"><span data-stu-id="43995-1615">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="43995-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.ContentElement>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="43995-1617">雖然您可以將標記<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。</span><span class="sxs-lookup"><span data-stu-id="43995-1617">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="43995-1618">不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1618">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="43995-1619">一般的滑鼠事件處理中的預設實作<xref:System.Windows.ContentElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1619">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="43995-1620">如果您想要覆寫這個邏輯，您必須建立衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-1620">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="43995-1621">在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="43995-1621">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="43995-1622">您無法變更處理行為的滑鼠<xref:System.Windows.ContentElement>藉由覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-1622">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1623">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1623">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="43995-1624">事件資料會報告一個或多個滑鼠按鈕已釋放。</span><span class="sxs-lookup"><span data-stu-id="43995-1624">The event data reports that one or more mouse buttons were released.</span></span></param>
        <summary><span data-ttu-id="43995-1625">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1625">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1626">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1626">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1627">滑鼠按鈕動作也是由專用的輸入管理員處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1627">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="43995-1628">依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。</span><span class="sxs-lookup"><span data-stu-id="43995-1628">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="43995-1629">如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>不會叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1629">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="43995-1630">如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-1630">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="43995-1631">其中一個這些事件可能會接收項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="43995-1631">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="43995-1632">如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。</span><span class="sxs-lookup"><span data-stu-id="43995-1632">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="43995-1633">如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-1633">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="43995-1634">類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="43995-1634">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="43995-1635">藉由處理<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>，您會隱含的類別處理計算在內的所有可能滑鼠動作。</span><span class="sxs-lookup"><span data-stu-id="43995-1635">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="43995-1636">這種行為可能不想;當您使用此虛擬方法標記為已處理的事件，因此，使用警告。</span><span class="sxs-lookup"><span data-stu-id="43995-1636">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="43995-1637">每個按鈕特定直接事件也有虛擬機器 \* 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。</span><span class="sxs-lookup"><span data-stu-id="43995-1637">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="43995-1638">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1638">This method has no default implementation.</span></span> <span data-ttu-id="43995-1639">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1639">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1640">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1640">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1641">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1641">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1642">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1642">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1643">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1643">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1644">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1644">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1645">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1645">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1646">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1646">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1647">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1647">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1648">當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1648">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1649">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1649">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1650">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1650">This method has no default implementation.</span></span> <span data-ttu-id="43995-1651">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1651">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1652">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1652">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1653">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1653">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1654">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1654">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1655">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1655">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1656">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1656">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1657">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1657">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1658">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1658">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1659">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1659">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1660">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1660">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1661">當未處理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1661">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1662">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1662">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1663">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1663">This method has no default implementation.</span></span> <span data-ttu-id="43995-1664">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1664">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1665">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1665">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1666">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1666">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1667">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1667">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1668">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1668">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1669">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1669">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1670">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1670">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1671">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1671">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1672">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1672">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1673">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1673">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1674">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1674">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1675">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1675">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1676">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1676">This method has no default implementation.</span></span> <span data-ttu-id="43995-1677">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1677">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1678">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1678">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1679">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1679">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1680">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1680">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1681">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1681">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1682">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1682">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1683">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1683">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1684">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1684">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1685">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1685">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1686">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1686">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1687">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1687">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1688">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1688">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1689">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1689">This method has no default implementation.</span></span> <span data-ttu-id="43995-1690">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1690">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1691">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1691">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1692">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1692">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1693">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1693">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1694">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1694">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1695">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1695">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1696">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1696">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1697">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1697">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1698">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1698">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1699">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1699">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1700">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1700">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1701">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1701">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1702">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1702">This method has no default implementation.</span></span> <span data-ttu-id="43995-1703">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1703">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1704">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1704">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1705">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1705">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1706">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1706">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1707">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1707">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1708">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1708">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1709">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1709">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1710">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1710">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1711">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1711">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1712">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1712">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1713">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1713">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1714">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1714">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1715">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1715">This method has no default implementation.</span></span> <span data-ttu-id="43995-1716">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1716">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1717">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1717">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1718">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1718">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1719">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1719">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1720">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1720">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1721">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1721">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1722">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1722">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1723">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1723">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1724">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1724">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1725">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1725">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1726">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1726">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1727">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1727">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1728">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1728">This method has no default implementation.</span></span> <span data-ttu-id="43995-1729">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1729">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1730">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1730">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1731">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1731">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1732">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1732">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1733">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1733">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1734">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1734">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1735">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1735">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1736">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1736">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1737">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1737">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1738">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1738">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1739">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1739">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1740">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1740">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1741">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1741">This method has no default implementation.</span></span> <span data-ttu-id="43995-1742">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1742">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1743">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1743">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1744">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1744">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1745">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1745">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1746">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1746">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1747">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1747">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1748">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1748">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1749">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1749">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1750">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1750">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1751">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1751">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1752">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1752">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1753">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1753">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1754">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1754">This method has no default implementation.</span></span> <span data-ttu-id="43995-1755">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1755">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1756">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1756">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1757">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1757">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1758">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1758">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1759">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1759">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1760">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1760">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1761">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1761">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1762">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1762">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1763">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1763">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1764">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1764">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1765">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1765">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1766">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1766">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1767">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1767">This method has no default implementation.</span></span> <span data-ttu-id="43995-1768">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1768">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1769">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1769">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1770">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1770">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1771">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1771">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1772">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1772">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1773">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1773">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1774">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1774">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1775">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1775">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1776">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1776">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1777">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1777">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1778">當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1778">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1779">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1779">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1780">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1780">This method has no default implementation.</span></span> <span data-ttu-id="43995-1781">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1781">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1782">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1782">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1783">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1783">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1784">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1784">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1785">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1785">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1786">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1786">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1787">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1787">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1788">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1788">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1789">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1789">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1790">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1790">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1791">當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1791">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1792">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1792">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1793">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1793">This method has no default implementation.</span></span> <span data-ttu-id="43995-1794">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1794">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1795">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1795">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1796">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1796">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1797">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1797">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1798">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1798">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1799">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1799">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1800">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1800">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1801">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1801">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="43995-1802">是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。</span><span class="sxs-lookup"><span data-stu-id="43995-1802">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1803"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1803">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1804">提供 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1804">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1805"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1805">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1806">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>處理衍生類別中<xref:System.Windows.ContentElement.PreviewTouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1806">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="43995-1807">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1807">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1808"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1808">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1809">提供 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1809">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1810"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1810">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1811">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>處理衍生類別中<xref:System.Windows.ContentElement.PreviewTouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1811">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="43995-1812">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1812">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1813"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1813">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1814">提供 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1814">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1815"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1815">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1816">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>處理衍生類別中<xref:System.Windows.ContentElement.PreviewTouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1816">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="43995-1817">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1817">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1818">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1818">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1819">當未處理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1819">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1820">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1820">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1821">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1821">This method has no default implementation.</span></span> <span data-ttu-id="43995-1822">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1822">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1823">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1823">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1824">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1824">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1825">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1825">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1826">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1826">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1827">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1827">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1828">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1828">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1829">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1829">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1830">包含事件資料的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1830">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1831">當未處理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1831">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1832">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1832">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1833">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1833">This method has no default implementation.</span></span> <span data-ttu-id="43995-1834">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1834">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1835">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1835">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1836">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1836">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1837">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1837">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1838">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1838">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1839">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1839">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1840">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1840">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1841">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1841">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1842">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1842">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1843">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1843">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1844">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1844">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1845">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1845">This method has no default implementation.</span></span> <span data-ttu-id="43995-1846">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1846">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1847">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1847">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1848">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1848">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1849">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1849">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1850">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1850">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1851">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1851">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1852">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1852">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1853">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1853">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1854">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1854">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1855">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1855">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1856">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1856">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1857">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1857">This method has no default implementation.</span></span> <span data-ttu-id="43995-1858">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1858">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1859">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1859">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1860">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1860">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1861">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1861">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1862">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1862">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1863">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1863">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1864">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1864">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1865">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1865">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1866">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1866">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1867">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1867">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1868">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1868">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1869">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1869">This method has no default implementation.</span></span> <span data-ttu-id="43995-1870">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1870">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1871">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1871">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1872">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1872">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1873">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1873">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1874">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1874">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1875">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1875">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1876">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1876">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1877">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1877">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1878">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1878">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1879">當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1879">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span></span> <span data-ttu-id="43995-1880">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1880">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1881">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1881">This method has no default implementation.</span></span> <span data-ttu-id="43995-1882">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1882">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1883">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1883">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="43995-1884">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1884">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1885">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1885">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1886">將事件標示為已處理仍很有用防止一般的執行個體處理常式 (這些不指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1886">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1887">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1887">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1888">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1888">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1889">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1889">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1890">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1890">This method has no default implementation.</span></span> <span data-ttu-id="43995-1891">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1891">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1892">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1892">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1893">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1893">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1894">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1894">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1895">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1895">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1896">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1896">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1897">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1897">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1898">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1898">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1899">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1899">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1900">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1900">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1901">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1901">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1902">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1902">This method has no default implementation.</span></span> <span data-ttu-id="43995-1903">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1903">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1904">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1904">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1905">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1905">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1906">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1906">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1907">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1907">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1908">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1908">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1909">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1909">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1910">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1910">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1911">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1911">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1912">當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1912">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span></span> <span data-ttu-id="43995-1913">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1913">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1914">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1914">This method has no default implementation.</span></span> <span data-ttu-id="43995-1915">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1915">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="43995-1916">您可能會呼叫基底之前或之後特殊處理，根據您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-1916">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="43995-1917">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1917">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1918">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1918">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1919">將事件標示為已處理仍很有用防止一般的執行個體處理常式 (這些不指定`handledEventsToo`) 叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1919">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1920">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1920">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1921">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1921">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1922">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1922">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1923">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1923">This method has no default implementation.</span></span> <span data-ttu-id="43995-1924">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1924">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1925">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1925">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1926">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1926">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1927">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1927">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1928">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1928">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1929">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1929">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1930">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1930">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1931">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1931">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1932">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1932">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1933">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1933">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1934">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1934">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1935">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1935">This method has no default implementation.</span></span> <span data-ttu-id="43995-1936">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1936">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1937">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1937">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1938">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1938">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1939">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1939">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1940">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1940">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1941">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1941">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1942">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1942">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1943">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1943">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1944">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1944">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1945">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1945">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1946">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1946">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1947">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1947">This method has no default implementation.</span></span> <span data-ttu-id="43995-1948">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1948">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1949">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1949">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1950">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1950">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1951">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1951">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1952">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1952">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1953">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1953">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1954">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1954">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1955">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1955">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1956">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1956">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1957">當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1957">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1958">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1958">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1959">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1959">This method has no default implementation.</span></span> <span data-ttu-id="43995-1960">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1960">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1961">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1961">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1962">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1962">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1963">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1963">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1964">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1964">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1965">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1965">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1966">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1966">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1967">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1967">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1968">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="43995-1968">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1969">當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。</span><span class="sxs-lookup"><span data-stu-id="43995-1969">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="43995-1970">實作這個方法可為此事件加入類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-1970">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1971">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1971">This method has no default implementation.</span></span> <span data-ttu-id="43995-1972">因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1972">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="43995-1973">這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 \* 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1973">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="43995-1974">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1974">In this case the matching event is a routed event.</span></span> <span data-ttu-id="43995-1975">由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On \* 方法的實作模式是不同的路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1975">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="43995-1976">因此，您的實作必須檢查的事件資料來源屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-1976">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="43995-1977">它不應嘗試重新引發此事件在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="43995-1977">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="43995-1978">覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.ContentElement>事件路由上收到事件時，可以呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-1978">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="43995-1979">其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1979">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1980"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1980">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1981">提供 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目內部時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1981">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1982"><xref:System.Windows.ContentElement.OnTouchDown%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1982">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1983">覆寫<xref:System.Windows.ContentElement.OnTouchDown%2A>處理衍生類別中<xref:System.Windows.ContentElement.TouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1983">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="43995-1984">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnTouchDown%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1984">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1985"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1985">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1986">提供 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件的類別處理，而這個事件會在觸控從外面移至此項目範圍內時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1986">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1987"><xref:System.Windows.ContentElement.OnTouchEnter%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1987">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1988">覆寫<xref:System.Windows.ContentElement.OnTouchEnter%2A>處理衍生類別中<xref:System.Windows.ContentElement.TouchEnter>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1988">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="43995-1989">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnTouchEnter%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1989">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1990"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1990">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1991">提供 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件的類別處理，而這個事件會在觸控從此項目內部移至其範圍外時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1991">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1992"><xref:System.Windows.ContentElement.OnTouchLeave%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1992">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1993">覆寫<xref:System.Windows.ContentElement.OnTouchLeave%2A>處理衍生類別中<xref:System.Windows.ContentElement.TouchLeave>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1993">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="43995-1994">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnTouchLeave%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1994">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-1995"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-1995">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-1996">提供 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-1996">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-1997"><xref:System.Windows.ContentElement.OnTouchMove%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-1997">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-1998">覆寫<xref:System.Windows.ContentElement.OnTouchMove%2A>處理衍生類別中<xref:System.Windows.ContentElement.TouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1998">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="43995-1999">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnTouchMove%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-1999">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-2000"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</span><span class="sxs-lookup"><span data-stu-id="43995-2000">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="43995-2001">提供 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2001">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2002"><xref:System.Windows.ContentElement.OnTouchUp%2A>方法有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="43995-2002">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="43995-2003">覆寫<xref:System.Windows.ContentElement.OnTouchUp%2A>處理衍生類別中<xref:System.Windows.ContentElement.TouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2003">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="43995-2004">確定呼叫基底類別的<xref:System.Windows.ContentElement.OnTouchUp%2A>方法的基底類別，接收到事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2004">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="43995-2005">要求的焦點周遊方向。</span><span class="sxs-lookup"><span data-stu-id="43995-2005">The direction of the requested focus traversal.</span></span></param>
        <summary><span data-ttu-id="43995-2006">在衍生類別中覆寫時，傳回會針對指定之焦點周遊方向接收焦點的項目，而不用實際將焦點移至該項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2006">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span></span></summary>
        <returns><span data-ttu-id="43995-2007">如果實際上有叫用 <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，就會取得焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2007">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2008">這個類別中，這個方法的預設實作不完整，且一律會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-2008">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2009">輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2009">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2010">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewDragEnter>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2010">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2011">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewDragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2011">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2012">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2012">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2013">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2013">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="43995-2014">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2014">Routing strategy</span></span>|<span data-ttu-id="43995-2015">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2015">Tunneling</span></span>|  
|<span data-ttu-id="43995-2016">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2016">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-2017">對應的反昇事件<xref:System.Windows.ContentElement.DragEnter>。</span><span class="sxs-lookup"><span data-stu-id="43995-2017">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="43995-2018">覆寫<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2018">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2019">識別 <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2019">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2020">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2020">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2021">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2021">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2022">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2022">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2023">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2023">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2024">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2024">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2025">輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2025">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2026">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewDragLeave>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2026">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2027">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewDragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2027">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2028">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2028">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2029">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2029">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="43995-2030">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2030">Routing strategy</span></span>|<span data-ttu-id="43995-2031">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2031">Tunneling</span></span>|  
|<span data-ttu-id="43995-2032">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2032">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-2033">對應的反昇事件<xref:System.Windows.ContentElement.DragLeave>。</span><span class="sxs-lookup"><span data-stu-id="43995-2033">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="43995-2034">覆寫<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2034">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2035">識別 <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2035">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2036">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2036">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2037">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2037">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2038">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2038">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2039">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2039">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2040">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2040">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2041">在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2041">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2042">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewDragOver>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2042">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2043">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewDragOver>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2043">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2044">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2044">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2045">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2045">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="43995-2046">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2046">Routing strategy</span></span>|<span data-ttu-id="43995-2047">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2047">Tunneling</span></span>|  
|<span data-ttu-id="43995-2048">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2048">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-2049">對應的反昇事件<xref:System.Windows.ContentElement.DragOver>。</span><span class="sxs-lookup"><span data-stu-id="43995-2049">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="43995-2050">覆寫<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2050">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2051">識別 <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2051">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2052">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2052">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2053">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2053">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2054">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2054">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2055">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2055">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2056">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2056">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2057">輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2057">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2058">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewDrop>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2058">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2059">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewDrop>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2059">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2060">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2060">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2061">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2061">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="43995-2062">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2062">Routing strategy</span></span>|<span data-ttu-id="43995-2063">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2063">Tunneling</span></span>|  
|<span data-ttu-id="43995-2064">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2064">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="43995-2065">對應的反昇事件<xref:System.Windows.ContentElement.Drop>。</span><span class="sxs-lookup"><span data-stu-id="43995-2065">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="43995-2066">覆寫<xref:System.Windows.ContentElement.OnPreviewDrop%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2066">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2067">識別 <see cref="E:System.Windows.ContentElement.PreviewDrop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2067">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2068">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2068">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2069">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2069">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2070">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2070">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2071">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2071">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2072">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2072">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2073">拖放操作開始時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2073">Occurs when a drag-and-drop operation is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2074"><xref:System.Windows.ContentElement.PreviewGiveFeedback>事件可讓修改滑鼠指標的外觀，以便將使用者視覺化回應提供拖放作業期間的拖曳事件來源。</span><span class="sxs-lookup"><span data-stu-id="43995-2074">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="43995-2075">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewGiveFeedback>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2075">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2076">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewGiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2076">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2077">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2077">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2078">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2078">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="43995-2079">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2079">Routing strategy</span></span>|<span data-ttu-id="43995-2080">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2080">Tunneling</span></span>|  
|<span data-ttu-id="43995-2081">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2081">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="43995-2082">對應的反昇事件<xref:System.Windows.ContentElement.GiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="43995-2082">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="43995-2083">覆寫<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2083">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2084">識別 <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2084">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2085">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2085">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2086">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2086">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2087">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2087">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2088">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2088">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2089">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2089">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2090">鍵盤以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2090">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2091">這個事件使用通道路由，因為具有焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2091">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-2092">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際具有焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-2092">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="43995-2093">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2093">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2094">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2094">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2095">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2095">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2096">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2096">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="43995-2097">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2097">Routing strategy</span></span>|<span data-ttu-id="43995-2098">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2098">Tunneling</span></span>|  
|<span data-ttu-id="43995-2099">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2099">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="43995-2100">對應的反昇事件<xref:System.Windows.ContentElement.GotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="43995-2100">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="43995-2101">覆寫<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2101">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2102">識別 <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2102">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2103">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2103">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2104">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2104">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2105">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2105">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2106">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2106">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2107">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2107">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2108">鍵盤以此元素為焦點且按下按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2108">Occurs when a key is pressed while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2109">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="43995-2109">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="43995-2110"><xref:System.Windows.ContentElement.KeyDown>是可能無法如預期般特定控制項的較低層級文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2110">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="43995-2111">這是因為有些控制項會有複合控制項，或提供文字的高階版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2111">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="43995-2112">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewKeyDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2112">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2113">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewKeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2113">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2114">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2114">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2115">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2115">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="43995-2116">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2116">Routing strategy</span></span>|<span data-ttu-id="43995-2117">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2117">Tunneling</span></span>|  
|<span data-ttu-id="43995-2118">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2118">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="43995-2119">對應的反昇事件<xref:System.Windows.ContentElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2119">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="43995-2120">覆寫<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2120">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2121">識別 <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2121">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2122">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2122">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2123">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2123">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2124">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2124">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2125">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2125">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2126">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2126">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2127">鍵盤以此元素為焦點且放開按鍵時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2127">Occurs when a key is released while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2128">索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。</span><span class="sxs-lookup"><span data-stu-id="43995-2128">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="43995-2129"><xref:System.Windows.ContentElement.KeyUp>是可能無法如預期般特定控制項的較低層級文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2129">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="43995-2130">這是因為有些控制項會有複合控制項，或提供文字的高階版本的類別處理輸入處理和相關事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2130">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="43995-2131">如需詳細資訊，請檢查個別控制項的文件。</span><span class="sxs-lookup"><span data-stu-id="43995-2131">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="43995-2132">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewKeyUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2132">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2133">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewKeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2133">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2134">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2134">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2135">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2135">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="43995-2136">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2136">Routing strategy</span></span>|<span data-ttu-id="43995-2137">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2137">Tunneling</span></span>|  
|<span data-ttu-id="43995-2138">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2138">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="43995-2139">對應的反昇事件<xref:System.Windows.ContentElement.KeyUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2139">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="43995-2140">覆寫<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2140">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2141">識別 <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2141">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2142">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2142">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2143">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2143">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2144">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2144">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2145">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2145">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2146">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2146">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2147">鍵盤不再以此元素為焦點時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2147">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2148">這個事件使用通道路由，因為失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2148">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="43995-2149">請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。</span><span class="sxs-lookup"><span data-stu-id="43995-2149">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="43995-2150">此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2150">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2151">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2151">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2152">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2152">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2153">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2153">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="43995-2154">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2154">Routing strategy</span></span>|<span data-ttu-id="43995-2155">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2155">Tunneling</span></span>|  
|<span data-ttu-id="43995-2156">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2156">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="43995-2157">對應的反昇事件<xref:System.Windows.ContentElement.LostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="43995-2157">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="43995-2158">覆寫<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2158">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2159">識別 <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2159">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2160">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2160">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2161">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2161">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2162">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2162">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2163">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2163">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2164">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2164">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2165">指標在此元素上方且按下任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2165">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2166">此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewMouseDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2166">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2167">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewMouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2167">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2168"><xref:System.Windows.ContentElement.PreviewMouseDown>通常就會引發事件一起可能<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>，這對應到其中的兩個標準滑鼠按鈕的按下。</span><span class="sxs-lookup"><span data-stu-id="43995-2168">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="43995-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="43995-2170">請參閱備註<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2170">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2171">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2171">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2172">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2172">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="43995-2173">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2173">Routing strategy</span></span>|<span data-ttu-id="43995-2174">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2174">Tunneling</span></span>|  
|<span data-ttu-id="43995-2175">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2175">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2176">對應的反昇事件<xref:System.Windows.ContentElement.MouseDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2176">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="43995-2177">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2177">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2178">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2178">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2179">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2179">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2180">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2180">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2181">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2181">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2182">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2182">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2183">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2183">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2184">滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2184">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2185">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2185">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-2186">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2186">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-2187">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2187">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-2188">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-2188">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-2189">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-2189">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-2190">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-2190">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-2191">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2191">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2192">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2192">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2193">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2193">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="43995-2194">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2194">Routing strategy</span></span>|<span data-ttu-id="43995-2195">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2195">Direct</span></span>|  
|<span data-ttu-id="43995-2196">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2196">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2197">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2197">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2198">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2198">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2199">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2199">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2200">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2200">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2201">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2201">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2202">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2202">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2203">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2203">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2204">滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2204">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2205">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2205">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-2206">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2206">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-2207">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2207">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-2208">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-2208">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-2209">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-2209">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-2210">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-2210">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-2211">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2211">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2212">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2212">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2213">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2213">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="43995-2214">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2214">Routing strategy</span></span>|<span data-ttu-id="43995-2215">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2215">Direct</span></span>|  
|<span data-ttu-id="43995-2216">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2216">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2217">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2217">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2218">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2218">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2219">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2219">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2220">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2220">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2221">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2221">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2222">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2222">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2223">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2223">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2224">滑鼠指標在此元素上方且移動滑鼠指標時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2224">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2225">都會發生這個事件項目界限，第一次進入滑鼠指標時，也會在滑鼠指標移時仍保持項目範圍內。</span><span class="sxs-lookup"><span data-stu-id="43995-2225">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="43995-2226">此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewMouseMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2226">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2227">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2227">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2228">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2228">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2229">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2229">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="43995-2230">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2230">Routing strategy</span></span>|<span data-ttu-id="43995-2231">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2231">Tunneling</span></span>|  
|<span data-ttu-id="43995-2232">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2232">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="43995-2233">對應的反昇事件<xref:System.Windows.ContentElement.MouseMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2233">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="43995-2234">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2234">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2235">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2235">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2236">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2236">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2237">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2237">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2238">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2238">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2239">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2239">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2240">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2240">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2241">滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2241">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2242">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2242">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-2243">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2243">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-2244">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2244">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-2245">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-2245">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-2246">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-2246">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-2247">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-2247">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-2248">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2248">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2249">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2249">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2250">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2250">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="43995-2251">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2251">Routing strategy</span></span>|<span data-ttu-id="43995-2252">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2252">Direct</span></span>|  
|<span data-ttu-id="43995-2253">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2253">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2254">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2254">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2255">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2255">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2256">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2256">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2257">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2257">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2258">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2258">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2259">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2259">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2260">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2260">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2261">滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2261">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2262">雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2262">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="43995-2263">此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2263">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="43995-2264">此事件的引數會公開基礎的引數<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2264">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="43995-2265">如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.ContentElement.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。</span><span class="sxs-lookup"><span data-stu-id="43995-2265">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="43995-2266">在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.ContentElement>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。</span><span class="sxs-lookup"><span data-stu-id="43995-2266">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="43995-2267">這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。</span><span class="sxs-lookup"><span data-stu-id="43995-2267">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="43995-2268">更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2268">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2269">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2270">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2270">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="43995-2271">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2271">Routing strategy</span></span>|<span data-ttu-id="43995-2272">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2272">Direct</span></span>|  
|<span data-ttu-id="43995-2273">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2273">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2274">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2274">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2275">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2275">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2276">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2276">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2277">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2277">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2278">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2278">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2279">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2279">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2280">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2280">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2281">滑鼠指標在此元素上方且放開任何滑鼠按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2281">Occurs when any mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2282">此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewMouseUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2282">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2283">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewMouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2283">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2284"><xref:System.Windows.ContentElement.PreviewMouseUp>通常就會引發事件一起可能<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>，這對應到其中的兩個標準滑鼠按鈕的按下。</span><span class="sxs-lookup"><span data-stu-id="43995-2284">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="43995-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到達事件路由上的這個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="43995-2286">請參閱備註<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2286">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2287">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2287">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2288">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2288">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="43995-2289">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2289">Routing strategy</span></span>|<span data-ttu-id="43995-2290">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2290">Tunneling</span></span>|  
|<span data-ttu-id="43995-2291">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2291">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2292">對應的反昇事件<xref:System.Windows.ContentElement.MouseUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2292">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="43995-2293">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2293">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2294">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2294">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2295">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2295">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2296">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2296">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2297">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2297">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2298">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2298">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2299">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2299">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2300">滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2300">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2301">焦點或滑鼠捕捉優先於滑鼠指標所在位置。因此，如果您收到這個事件與已取得焦點或擷取的項目時，滑鼠指標實際上可能是透過另一個項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2301">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="43995-2302">此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewMouseMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2302">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2303">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2303">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2304">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2305">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2305">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="43995-2306">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2306">Routing strategy</span></span>|<span data-ttu-id="43995-2307">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2307">Tunneling</span></span>|  
|<span data-ttu-id="43995-2308">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2308">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="43995-2309">對應的反昇事件<xref:System.Windows.ContentElement.MouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="43995-2309">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="43995-2310">覆寫<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2310">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2311">識別 <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2311">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2312">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2313">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2314">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2315">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2316">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2317">拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2317">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2318"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件可讓拖曳來源能夠宣告是否應取消拖放作業。</span><span class="sxs-lookup"><span data-stu-id="43995-2318">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="43995-2319">此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2319">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2320">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2320">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2321">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2321">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2322">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2322">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="43995-2323">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2323">Routing strategy</span></span>|<span data-ttu-id="43995-2324">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2324">Tunneling</span></span>|  
|<span data-ttu-id="43995-2325">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2325">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="43995-2326">對應的反昇事件<xref:System.Windows.ContentElement.QueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="43995-2326">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="43995-2327">覆寫<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2327">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2328">識別 <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2328">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2329">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2329">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2330">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2330">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2331">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2331">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2332">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2332">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2333">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2333">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2334">手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2334">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2335">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusButtonDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2335">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2336">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2336">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2337">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2337">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2338">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2338">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2339">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2339">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2340">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2340">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="43995-2341">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2341">Routing strategy</span></span>|<span data-ttu-id="43995-2342">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2342">Tunneling</span></span>|  
|<span data-ttu-id="43995-2343">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2343">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2344">對應的反昇事件<xref:System.Windows.ContentElement.StylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2344">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="43995-2345">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2345">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2346">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2346">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2347">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2347">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2348">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2348">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2349">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2349">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2350">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2350">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2351">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2351">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2352">手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2352">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2353">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusButtonUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2353">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2354">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2354">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2355">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2355">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2356">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2356">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2357">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2357">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2358">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2358">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="43995-2359">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2359">Routing strategy</span></span>|<span data-ttu-id="43995-2360">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2360">Tunneling</span></span>|  
|<span data-ttu-id="43995-2361">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2361">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2362">對應的反昇事件<xref:System.Windows.ContentElement.StylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2362">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="43995-2363">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2363">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2364">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2364">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2365">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2365">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2366">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2366">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2367">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2367">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2368">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2368">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2369">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2369">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2370">手寫筆在此項目上方且碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2370">Occurs when the stylus touches the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2371">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2371">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2372">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2372">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2373">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2373">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2374">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2374">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2375">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2375">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2376">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2376">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="43995-2377">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2377">Routing strategy</span></span>|<span data-ttu-id="43995-2378">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2378">Tunneling</span></span>|  
|<span data-ttu-id="43995-2379">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2379">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="43995-2380">對應的反昇事件<xref:System.Windows.ContentElement.StylusDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2380">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="43995-2381">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2381">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2382">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2382">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2383">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2383">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2384">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2384">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2385">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2385">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2386">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2386">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2387">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2387">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2388">手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2388">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2389">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusInAirMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2389">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2390">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2390">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2391">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2391">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2392">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2392">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2393">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2393">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2394">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2394">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="43995-2395">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2395">Routing strategy</span></span>|<span data-ttu-id="43995-2396">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2396">Tunneling</span></span>|  
|<span data-ttu-id="43995-2397">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2397">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2398">對應的反昇事件<xref:System.Windows.ContentElement.StylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2398">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="43995-2399">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2399">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2400">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2400">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2401">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2401">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2402">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2402">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2403">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2403">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2404">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2404">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2405">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2405">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2406">手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2406">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2407">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusInRange>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2407">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2408">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2408">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2409">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2409">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2410">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2410">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2411">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2411">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2412">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2412">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="43995-2413">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2413">Routing strategy</span></span>|<span data-ttu-id="43995-2414">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2414">Tunneling</span></span>|  
|<span data-ttu-id="43995-2415">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2415">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2416">對應的反昇事件<xref:System.Windows.ContentElement.StylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="43995-2416">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="43995-2417">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2417">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2418">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2418">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2419">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2419">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2420">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2420">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2421">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2421">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2422">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2422">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2423">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2423">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2424">當手寫筆位在項目上方並移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2424">Occurs when the stylus moves while over the element.</span></span> <span data-ttu-id="43995-2425">手寫筆必須在受到數位板偵測時移動才能引發此事件，否則會改為引發 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2425">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2426">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2426">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2427">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2427">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2428">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2428">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2429">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2429">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2430">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2430">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2431">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2431">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="43995-2432">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2432">Routing strategy</span></span>|<span data-ttu-id="43995-2433">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2433">Tunneling</span></span>|  
|<span data-ttu-id="43995-2434">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2434">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2435">對應的反昇事件<xref:System.Windows.ContentElement.StylusMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2435">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="43995-2436">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2436">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2437">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2437">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2438">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2438">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2439">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2439">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2440">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2440">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2441">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2441">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2442">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2442">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2443">手寫筆遠離數位板而無法被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2443">Occurs when the stylus is too far from the digitizer to be detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2444">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2444">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2445">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2445">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2446">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2446">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2447">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2447">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2448">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2448">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2449">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2449">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="43995-2450">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2450">Routing strategy</span></span>|<span data-ttu-id="43995-2451">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2451">Tunneling</span></span>|  
|<span data-ttu-id="43995-2452">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2452">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2453">對應的反昇事件<xref:System.Windows.ContentElement.StylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="43995-2453">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="43995-2454">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2454">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2455">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2455">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2456">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2456">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2457">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2457">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2458">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2458">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2459">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2459">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2460">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2460">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2461">使用者執行其中一種手寫筆筆勢時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2461">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2462">手寫筆筆勢的相關資訊，請參閱<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="43995-2462">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="43995-2463">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2463">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2464">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2464">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2465">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2465">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2466">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2466">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2467">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2467">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2468">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2468">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="43995-2469">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2469">Routing strategy</span></span>|<span data-ttu-id="43995-2470">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2470">Tunneling</span></span>|  
|<span data-ttu-id="43995-2471">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2471">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="43995-2472">對應的反昇事件<xref:System.Windows.ContentElement.StylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="43995-2472">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="43995-2473">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2473">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2474">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2474">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2475">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2475">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2476">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2476">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2477">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2477">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2478">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2478">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2479">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2479">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2480">手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2480">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2481">此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewStylusDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2481">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2482">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2482">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2483">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2483">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2484">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2484">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2485">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2485">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2486">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2486">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="43995-2487">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2487">Routing strategy</span></span>|<span data-ttu-id="43995-2488">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2488">Tunneling</span></span>|  
|<span data-ttu-id="43995-2489">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2489">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2490">對應的反昇事件<xref:System.Windows.ContentElement.StylusUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2490">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="43995-2491">覆寫<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2491">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2492">識別 <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2492">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2493">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2493">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2494">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2494">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2495">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2495">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2496">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2496">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2497">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2497">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2498">此元素以一種與裝置無關的方式取得文字時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2498">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2499"><xref:System.Windows.ContentElement.PreviewTextInput>事件可讓元件或應用程式與裝置無關的方式接聽文字輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-2499">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="43995-2500">鍵盤是的主要方式<xref:System.Windows.ContentElement.PreviewTextInput>; 但也可以產生語音、 手寫，以及其他輸入的裝置<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="43995-2500">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="43995-2501">因為組合 — 在預設鍵盤或輸入的法編輯器透過 — 多個按鍵事件可能會引發一個文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2501">Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="43995-2502">此事件會建立一個別名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.PreviewTextInput>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2502">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2503">事件處理常式附加至<xref:System.Windows.ContentElement.PreviewTextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2503">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2504">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2504">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2505">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2505">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="43995-2506">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2506">Routing strategy</span></span>|<span data-ttu-id="43995-2507">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2507">Tunneling</span></span>|  
|<span data-ttu-id="43995-2508">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2508">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="43995-2509">對應的反昇事件<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="43995-2509">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="43995-2510">覆寫<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2510">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2511">識別 <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2511">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2512">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2512">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2513">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2513">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2514">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2514">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2515">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2515">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2516">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2516">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2517">手指在這個項目上方且在螢幕上觸控時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2517">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2518">根據預設，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指接觸到螢幕，並移動之前不會發生事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2518">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="43995-2519">手指在螢幕上按住不移動的方式會使按下並按住行為<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="43995-2519">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="43995-2520">按住行為相當於按一下滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-2520">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="43995-2521">若要讓<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指接觸到螢幕，因為發生事件設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加屬性`false`這個項目的。</span><span class="sxs-lookup"><span data-stu-id="43995-2521">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2522">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2522">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2523">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2523">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="43995-2524">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2524">Routing strategy</span></span>|<span data-ttu-id="43995-2525">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2525">Tunneling</span></span>|  
|<span data-ttu-id="43995-2526">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2526">Delegate</span></span>|<span data-ttu-id="43995-2527">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2527"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2528">對應的反昇事件<xref:System.Windows.ContentElement.TouchDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2528">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="43995-2529">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2529">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2530">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2530">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2531">手指在這個項目上方且在螢幕上移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2531">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2532">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2532">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2533">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2533">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="43995-2534">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2534">Routing strategy</span></span>|<span data-ttu-id="43995-2535">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2535">Tunneling</span></span>|  
|<span data-ttu-id="43995-2536">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2536">Delegate</span></span>|<span data-ttu-id="43995-2537">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2537"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2538">對應的反昇事件<xref:System.Windows.ContentElement.TouchMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2538">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="43995-2539">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2539">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2540">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2540">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2541">手指在這個項目上方且離開螢幕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2541">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2542">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2542">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2543">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2543">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="43995-2544">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2544">Routing strategy</span></span>|<span data-ttu-id="43995-2545">通道</span><span class="sxs-lookup"><span data-stu-id="43995-2545">Tunneling</span></span>|  
|<span data-ttu-id="43995-2546">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2546">Delegate</span></span>|<span data-ttu-id="43995-2547">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2547"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2548">對應的反昇事件<xref:System.Windows.ContentElement.TouchUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2548">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="43995-2549">覆寫<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2549">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2550">識別 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2550">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2551">拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2551">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2552"><xref:System.Windows.ContentElement.QueryContinueDrag>事件可讓拖曳來源能夠決定是否應取消拖放作業。</span><span class="sxs-lookup"><span data-stu-id="43995-2552">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="43995-2553">此事件會建立一個別名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.QueryContinueDrag>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2553">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2554">事件處理常式附加至<xref:System.Windows.ContentElement.QueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2554">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2555">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2555">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2556">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2556">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="43995-2557">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2557">Routing strategy</span></span>|<span data-ttu-id="43995-2558">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2558">Bubbling</span></span>|  
|<span data-ttu-id="43995-2559">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2559">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="43995-2560">對應通道的事件<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="43995-2560">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="43995-2561">覆寫<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2561">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2562">識別 <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2562">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2563">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2563">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2564">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2564">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2565">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2565">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2566">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2566">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2567">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2567">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2568">要求顯示游標時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2568">Occurs when the cursor is requested to display.</span></span> <span data-ttu-id="43995-2569">每當滑鼠指標移動至新位置時，都會引發此事件，這意謂游標物件可能會根據其新位置而變更。</span><span class="sxs-lookup"><span data-stu-id="43995-2569">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2570">此事件會建立一個別名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.QueryCursor>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2570">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2571">事件處理常式附加至<xref:System.Windows.ContentElement.QueryCursor>事件會附加至基礎<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2571">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2572">這個事件名稱所參考的資料指標不一定是文字游標 （有時稱為插入點）。</span><span class="sxs-lookup"><span data-stu-id="43995-2572">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="43995-2573">相反地，此內容中的資料指標是宣告畫面的圖形化顯示數個可能的輸入相關裝置或在 Windows 程式設計概念相關的物件。</span><span class="sxs-lookup"><span data-stu-id="43995-2573">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="43995-2574">該物件由<xref:System.Windows.Input.Cursor>WPF 中的類別。</span><span class="sxs-lookup"><span data-stu-id="43995-2574">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="43995-2575">WPF 輸入的系統可讓您變更這個資料指標，它代表在螢幕上的滑鼠指標位置時。</span><span class="sxs-lookup"><span data-stu-id="43995-2575">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="43995-2576">您可以使用預先定義的值從<xref:System.Windows.Input.Cursors>列舉型別，或者您可以宣告為影像檔的自訂資料指標。</span><span class="sxs-lookup"><span data-stu-id="43995-2576">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="43995-2577">接聽<xref:System.Windows.ContentElement.QueryCursor>事件就不會針對資料指標管理而有效率的技術。</span><span class="sxs-lookup"><span data-stu-id="43995-2577">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="43995-2578">相反地，每個項目應該定義自己的資料指標行為<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2578">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="43995-2579">您只應依賴<xref:System.Windows.ContentElement.QueryCursor>如果您不想要使用的 WPF 架構層級基底項目，或在異常的情況下，其中定義以每個項目為基礎的資料指標的行為不符合您的需求。</span><span class="sxs-lookup"><span data-stu-id="43995-2579">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="43995-2580">如需有關在回應中實作資料指標行為<xref:System.Windows.ContentElement.QueryCursor>，請參閱<xref:System.Windows.Input.QueryCursorEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="43995-2580">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2581">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2581">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2582">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2582">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="43995-2583">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2583">Routing strategy</span></span>|<span data-ttu-id="43995-2584">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2584">Bubbling</span></span>|  
|<span data-ttu-id="43995-2585">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2585">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="43995-2586">沒有定義對應通道的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2586">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="43995-2587">覆寫<xref:System.Windows.ContentElement.OnQueryCursor%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2587">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2588">識別 <see cref="E:System.Windows.ContentElement.QueryCursor" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2588">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2589">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2589">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2590">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2590">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2591">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2591">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2592">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2592">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2593">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2593">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="43995-2594"><see cref="T:System.Windows.RoutedEventArgs" />，其包含事件資料，也會識別要引發的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2594">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span></span></param>
        <summary><span data-ttu-id="43995-2595">引發特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2595">Raises a specific routed event.</span></span> <span data-ttu-id="43995-2596">要引發的 <see cref="T:System.Windows.RoutedEvent" /> 是在所提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 執行個體內被識別 (該執行個體是提供做為該事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性)。</span><span class="sxs-lookup"><span data-stu-id="43995-2596">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2597">`e`參數的型別做為路由的事件的所有資料的通用基底類型; 不過，應該指定事件資料為最特定的事件資料類型是適用於所引發的事件，因為<xref:System.Windows.RoutedEventArgs>衍生的類別包含實際的特定資料是針對特定事件時引發此事件的屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-2597">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="43995-2598"><xref:System.Windows.RoutedEventArgs> 沒有狀態內容事件。它也會識別要引發哪個路由的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2598"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="43995-2599">此事件引發模式且同時與不同的路由的事件資料[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和資料類別，通常只包含與事件相關的屬性。</span><span class="sxs-lookup"><span data-stu-id="43995-2599">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43995-2600">下列範例會建立事件資料、 將事件的識別項附加至資料，，然後使用 以引發自訂的路由的事件的 事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2600">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-2601">從這個項目釋放所有擷取到的觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2601">Releases all captured touch devices from this element.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-2602">如果這個項目保有滑鼠捕捉，則釋放捕捉。</span><span class="sxs-lookup"><span data-stu-id="43995-2602">Releases the mouse capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2603">如果這個項目按擷取不放，呼叫這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="43995-2603">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="43995-2604">請考慮檢查值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>之前先呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2604">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43995-2605">下列處理常式會擷取或釋放滑鼠按鈕狀態根據滑鼠捕捉。</span><span class="sxs-lookup"><span data-stu-id="43995-2605">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="43995-2606">此範例示範如何擷取的滑鼠移動所使用的替代方案的考量，而不是移動滑鼠指標[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="43995-2606">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-2607">如果這個項目保有手寫筆裝置捕捉，則釋放捕捉。</span><span class="sxs-lookup"><span data-stu-id="43995-2607">Releases the stylus device capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2608">如果這個項目按擷取不放，呼叫這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="43995-2608">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="43995-2609">請考慮檢查值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>之前先呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2609">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="43995-2610">要釋放的裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2610">The device to release.</span></span></param>
        <summary><span data-ttu-id="43995-2611">嘗試從這個項目中釋放指定的觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2611">Attempts to release the specified touch device from this element.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-2612">如果已釋放觸控裝置則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2612"><see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="43995-2613"><paramref name="touchDevice" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2613"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="43995-2614">處理常式附加的路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2614">The identifier of the.routed event for which the handler is attached.</span></span></param>
        <param name="handler"><span data-ttu-id="43995-2615">要從這個項目上的事件處理常式集合中移除的特定處理常式實作。</span><span class="sxs-lookup"><span data-stu-id="43995-2615">The specific handler implementation to remove from the event handler collection on this element.</span></span></param>
        <summary><span data-ttu-id="43995-2616">從這個項目中移除指定的路由事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2616">Removes the specified routed event handler from this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2617">最常見的案例使用這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是當您實作[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自訂路由事件，特別是當您實作在處理常式的 「 移除 」 邏輯時相關聯的 「 包裝函式 」 事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]層級。</span><span class="sxs-lookup"><span data-stu-id="43995-2617">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="43995-2618">這會遵循範例 < 備註 > 一節會說明這種情況。</span><span class="sxs-lookup"><span data-stu-id="43995-2618">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="43995-2619">如果沒有任何處理常式註冊以比對方法呼叫的輸入的參數的準則，則呼叫這個方法任何作用。</span><span class="sxs-lookup"><span data-stu-id="43995-2619">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="43995-2620">如果一個以上的處理常式附加事件處理常式存放區會移除比對準則，第一個處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2620">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="43995-2621">這個行為會與一致[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]行為`-=`運算子。</span><span class="sxs-lookup"><span data-stu-id="43995-2621">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="43995-2622">既不`routedEvent`也`handler`可能`null`。</span><span class="sxs-lookup"><span data-stu-id="43995-2622">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="43995-2623">嘗試在提供做為任一個值`null`會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="43995-2623">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="43995-2624">這個方法會忽略`handledEventsToo`加上參數資訊，如果第一個處理常式提供<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章，可讓已處理事件的處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2624">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="43995-2625">會移除任一類型的處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2625">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-2626">傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 屬性的內容序列化。</span><span class="sxs-lookup"><span data-stu-id="43995-2626">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-2627">如果應序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2627"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2628">這會傳回`true`如果<xref:System.Windows.ContentElement.CommandBindings%2A>本機設定。</span><span class="sxs-lookup"><span data-stu-id="43995-2628">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="43995-2629">這`ShouldSerialize`方法提供，因為<xref:System.Windows.UIElement.CommandBindings%2A>屬性並沒有簡單的預設值。</span><span class="sxs-lookup"><span data-stu-id="43995-2629">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="43995-2630">這個方法會指出屬性是否已變更其預設值。</span><span class="sxs-lookup"><span data-stu-id="43995-2630">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="43995-2631">您通常叫用這個方法如果在開發設計師或開發您自己的控制項加入<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2631">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="43995-2632">如需詳細資訊，請參閱[定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2632">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43995-2633">傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.ContentElement.InputBindings" /> 屬性的內容序列化。</span><span class="sxs-lookup"><span data-stu-id="43995-2633">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span></span></summary>
        <returns>
          <span data-ttu-id="43995-2634">如果應序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2634"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2635">這會傳回`true`如果<xref:System.Windows.ContentElement.InputBindings%2A>本機設定。</span><span class="sxs-lookup"><span data-stu-id="43995-2635">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="43995-2636">這`ShouldSerialize`方法提供，因為<xref:System.Windows.UIElement.InputBindings%2A>屬性並沒有簡單的預設值。</span><span class="sxs-lookup"><span data-stu-id="43995-2636">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="43995-2637">這個方法會指出屬性是否已變更其預設值。</span><span class="sxs-lookup"><span data-stu-id="43995-2637">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="43995-2638">您通常叫用這個方法如果在開發設計師或開發您自己的控制項加入<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="43995-2638">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="43995-2639">如需詳細資訊，請參閱[定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2639">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2640">手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2640">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2641">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusButtonDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2641">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2642">事件處理常式附加至<xref:System.Windows.ContentElement.StylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2642">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2643">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2644">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2645">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2645">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2646">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2646">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="43995-2647">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2647">Routing strategy</span></span>|<span data-ttu-id="43995-2648">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2648">Bubbling</span></span>|  
|<span data-ttu-id="43995-2649">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2649">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2650">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2650">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="43995-2651">覆寫<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2651">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2652">識別 <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2652">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2653">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2653">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2654">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2654">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2655">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2655">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2656">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2656">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2657">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2657">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2658">手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2658">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2659">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusButtonUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2659">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2660">事件處理常式附加至<xref:System.Windows.ContentElement.StylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2660">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2661">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2661">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2662">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2662">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2663">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2663">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2664">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2664">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="43995-2665">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2665">Routing strategy</span></span>|<span data-ttu-id="43995-2666">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2666">Bubbling</span></span>|  
|<span data-ttu-id="43995-2667">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2667">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="43995-2668">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2668">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="43995-2669">覆寫<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2669">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2670">識別 <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2670">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2671">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2671">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2672">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2672">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2673">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2673">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2674">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2674">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2675">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2675">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2676">手寫筆在此項目上方且碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2676">Occurs when the stylus touches the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2677">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusDown>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2677">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2678">事件處理常式附加至<xref:System.Windows.ContentElement.StylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2678">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2679">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2679">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2680">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2680">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2681">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2681">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2682">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2682">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="43995-2683">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2683">Routing strategy</span></span>|<span data-ttu-id="43995-2684">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2684">Bubbling</span></span>|  
|<span data-ttu-id="43995-2685">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2685">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="43995-2686">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2686">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="43995-2687">覆寫<xref:System.Windows.ContentElement.OnStylusDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2687">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2688">識別 <see cref="E:System.Windows.ContentElement.StylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2688">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2689">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2689">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2690">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2690">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2691">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2691">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2692">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2692">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2693">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2693">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2694">手寫筆進入此元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2694">Occurs when the stylus enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2695"><xref:System.Windows.ContentElement.StylusEnter> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="43995-2695"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="43995-2696">直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。</span><span class="sxs-lookup"><span data-stu-id="43995-2696">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="43995-2697">不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。</span><span class="sxs-lookup"><span data-stu-id="43995-2697">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="43995-2698">雖然<xref:System.Windows.ContentElement.StylusEnter>當手寫筆進入範圍的項目，這個多個事件的追蹤依其字面報告<xref:System.Windows.ContentElement.IsStylusOver%2A>屬性值已經從`false`至`true`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="43995-2698">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="43995-2699">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusEnter>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2699">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2700">事件處理常式附加至<xref:System.Windows.ContentElement.StylusEnter>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2700">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2701">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2701">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2702">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2702">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2703">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2703">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2704">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2704">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="43995-2705">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2705">Routing strategy</span></span>|<span data-ttu-id="43995-2706">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2706">Direct</span></span>|  
|<span data-ttu-id="43995-2707">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2707">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2708">覆寫<xref:System.Windows.ContentElement.OnStylusEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2708">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2709">識別 <see cref="E:System.Windows.ContentElement.StylusEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2709">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2710">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2710">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2711">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2711">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2712">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2712">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2713">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2713">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2714">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2714">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2715">手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2715">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2716">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusInAirMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2716">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2717">事件處理常式附加至<xref:System.Windows.ContentElement.StylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2717">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2718">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2718">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2719">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2719">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2720">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2721">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2721">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="43995-2722">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2722">Routing strategy</span></span>|<span data-ttu-id="43995-2723">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2723">Bubbling</span></span>|  
|<span data-ttu-id="43995-2724">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2724">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2725">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2725">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="43995-2726">覆寫<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2726">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2727">識別 <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2727">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2728">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2728">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2729">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2729">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2730">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2730">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2731">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2731">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2732">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2732">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2733">手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2733">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2734">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusInRange>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2734">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2735">事件處理常式附加至<xref:System.Windows.ContentElement.StylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2735">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2736">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2736">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2737">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2737">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2738">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2738">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2739">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2739">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="43995-2740">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2740">Routing strategy</span></span>|<span data-ttu-id="43995-2741">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2741">Bubbling</span></span>|  
|<span data-ttu-id="43995-2742">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2742">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2743">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="43995-2743">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="43995-2744">覆寫<xref:System.Windows.ContentElement.OnStylusInRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2744">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2745">識別 <see cref="E:System.Windows.ContentElement.StylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2745">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2746">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2746">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2747">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2747">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2748">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2748">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2749">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2749">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2750">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2750">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2751">手寫筆離開元素的邊界時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2751">Occurs when the stylus leaves the bounds of the element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2752"><xref:System.Windows.ContentElement.StylusLeave> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。</span><span class="sxs-lookup"><span data-stu-id="43995-2752"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="43995-2753">直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。</span><span class="sxs-lookup"><span data-stu-id="43995-2753">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="43995-2754">不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。</span><span class="sxs-lookup"><span data-stu-id="43995-2754">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="43995-2755">雖然<xref:System.Windows.ContentElement.StylusLeave>時手寫筆離開範圍的項目，此事件的多個追蹤逐字報告<xref:System.Windows.ContentElement.IsStylusOver%2A>屬性值已經從`true`至`false`這個項目上。</span><span class="sxs-lookup"><span data-stu-id="43995-2755">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="43995-2756">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusLeave>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2756">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2757">事件處理常式附加至<xref:System.Windows.ContentElement.StylusLeave>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2757">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2758">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2758">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2759">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2759">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2760">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2761">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2761">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="43995-2762">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2762">Routing strategy</span></span>|<span data-ttu-id="43995-2763">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2763">Direct</span></span>|  
|<span data-ttu-id="43995-2764">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2764">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2765">覆寫<xref:System.Windows.ContentElement.OnStylusLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2765">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2766">識別 <see cref="E:System.Windows.ContentElement.StylusLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2766">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2767">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2767">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2768">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2768">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2769">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2769">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2770">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2770">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2771">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2771">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2772">當手寫筆移至此項目上方時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2772">Occurs when the stylus moves over this element.</span></span> <span data-ttu-id="43995-2773">手寫筆在數位板上必須移動才會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2773">The stylus must move while on the digitizer to raise this event.</span></span> <span data-ttu-id="43995-2774">否則會改為引發 <see cref="E:System.Windows.ContentElement.StylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="43995-2774">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2775">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusMove>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2775">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2776">事件處理常式附加至<xref:System.Windows.ContentElement.StylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2776">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2777">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2777">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2778">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2778">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2779">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2779">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2780">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2780">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="43995-2781">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2781">Routing strategy</span></span>|<span data-ttu-id="43995-2782">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2782">Bubbling</span></span>|  
|<span data-ttu-id="43995-2783">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2783">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2784">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2784">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="43995-2785">覆寫<xref:System.Windows.ContentElement.OnStylusMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2785">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2786">識別 <see cref="E:System.Windows.ContentElement.StylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2786">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2787">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2787">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2788">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2788">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2789">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2789">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2790">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2790">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2791">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2791">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2792">手寫筆在此項目上方，且遠離數位板而無法被偵測到時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2792">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2793">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusOutOfRange>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2793">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2794">事件處理常式附加至<xref:System.Windows.ContentElement.StylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2794">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2795">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2795">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2796">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2796">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2797">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2797">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2798">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2798">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="43995-2799">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2799">Routing strategy</span></span>|<span data-ttu-id="43995-2800">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2800">Bubbling</span></span>|  
|<span data-ttu-id="43995-2801">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2801">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2802">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="43995-2802">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="43995-2803">覆寫<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2803">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2804">識別 <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2804">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2805">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2805">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2806">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2806">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2807">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2807">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2808">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2808">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2809">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2809">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2810">使用者執行其中一種手寫筆筆勢時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2810">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2811">手寫筆筆勢的相關資訊的詳細資訊，請參閱<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="43995-2811">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="43995-2812">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusSystemGesture>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2812">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2813">事件處理常式附加至<xref:System.Windows.ContentElement.StylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2813">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2814">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2814">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2815">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2815">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2816">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2816">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2817">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2817">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="43995-2818">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2818">Routing strategy</span></span>|<span data-ttu-id="43995-2819">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2819">Bubbling</span></span>|  
|<span data-ttu-id="43995-2820">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2820">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="43995-2821">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="43995-2821">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="43995-2822">覆寫<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2822">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2823">識別 <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2823">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2824">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2824">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2825">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2825">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2826">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2826">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2827">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2827">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2828">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2828">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2829">手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2829">Occurs when the user raises the stylus off the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2830">此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.StylusUp>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2830">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2831">事件處理常式附加至<xref:System.Windows.ContentElement.StylusUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2831">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="43995-2832">觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。</span><span class="sxs-lookup"><span data-stu-id="43995-2832">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="43995-2833">如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="43995-2833">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2834">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2834">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2835">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2835">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="43995-2836">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2836">Routing strategy</span></span>|<span data-ttu-id="43995-2837">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2837">Bubbling</span></span>|  
|<span data-ttu-id="43995-2838">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2838">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="43995-2839">對應通道的事件<xref:System.Windows.ContentElement.PreviewStylusUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2839">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="43995-2840">覆寫<xref:System.Windows.ContentElement.OnStylusUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2840">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2841">識別 <see cref="E:System.Windows.ContentElement.StylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2841">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2842">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2842">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2843">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2843">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2844">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2844">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2845">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2845">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2846">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2846">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2847">此元素以一種與裝置無關的方式取得文字時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2847">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="43995-2848">此事件可能已標示為處理複合控制項的內部實作。</span><span class="sxs-lookup"><span data-stu-id="43995-2848">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="43995-2849">請參閱下方的 「 備註。</span><span class="sxs-lookup"><span data-stu-id="43995-2849">See Remark below.</span></span>  
  
 <span data-ttu-id="43995-2850"><xref:System.Windows.ContentElement.TextInput>事件可能已標示為已處理的複合控制項的內部實作。</span><span class="sxs-lookup"><span data-stu-id="43995-2850">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="43995-2851">例如，<xref:System.Windows.Controls.TextBox>是複合控制項其中<xref:System.Windows.ContentElement.TextInput>事件已標示為處理; 在其複合 （compositing）。</span><span class="sxs-lookup"><span data-stu-id="43995-2851">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="43995-2852">控制項執行這項操作，因為控制項必須解譯某些類型的輸入，例如方向鍵，該控制項的特別意義。</span><span class="sxs-lookup"><span data-stu-id="43995-2852">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="43995-2853">如果您使用<xref:System.Windows.ContentElement.PreviewTextInput>您用來附加文字輸入的處理常式的事件，您可能會收到更好的結果。</span><span class="sxs-lookup"><span data-stu-id="43995-2853">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="43995-2854">這項技術規避大部分的情況下，其中已將這個事件標記為已處理控制項撰寫，而防止接收事件路由上的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2854">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="43995-2855"><xref:System.Windows.ContentElement.TextInput>事件可讓元件或應用程式與裝置無關的方式接聽文字輸入。</span><span class="sxs-lookup"><span data-stu-id="43995-2855">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="43995-2856">鍵盤是的主要方式<xref:System.Windows.ContentElement.TextInput>，但也可以引發語音、 手寫，以及其他輸入的裝置<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="43995-2856">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="43995-2857">因為組合 — 在預設鍵盤或輸入的法編輯器透過 — 多個按鍵事件可能會引發一個文字輸入的事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2857">Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="43995-2858">此事件會建立一個別名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.ContentElement.TextInput>屬於類別的成員 清單時<xref:System.Windows.ContentElement>繼承基底的項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2858">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="43995-2859">事件處理常式附加至<xref:System.Windows.ContentElement.TextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。</span><span class="sxs-lookup"><span data-stu-id="43995-2859">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2860">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2860">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2861">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2861">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="43995-2862">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2862">Routing strategy</span></span>|<span data-ttu-id="43995-2863">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2863">Bubbling</span></span>|  
|<span data-ttu-id="43995-2864">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2864">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="43995-2865">對應通道的事件<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="43995-2865">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="43995-2866">覆寫<xref:System.Windows.ContentElement.OnTextInput%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2866">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2867">識別 <see cref="E:System.Windows.ContentElement.TextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2867">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2868">註冊路由事件時，會建立路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="43995-2868">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="43995-2869">這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="43995-2869">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="43995-2870">您可以使用這些識別項來加入類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="43995-2870">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="43995-2871">如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2871">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="43995-2872">如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="43995-2872">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2873">手指在這個項目上方且在螢幕上觸控時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2873">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2874">根據預設，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指接觸到螢幕，並移動之前不會發生事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2874">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="43995-2875">手指在螢幕上按住不移動的方式會使按下並按住行為<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="43995-2875">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="43995-2876">按住行為相當於按一下滑鼠右鍵。</span><span class="sxs-lookup"><span data-stu-id="43995-2876">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="43995-2877">若要讓<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指接觸到螢幕，因為發生事件設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加屬性`false`這個項目的。</span><span class="sxs-lookup"><span data-stu-id="43995-2877">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2878">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2878">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2879">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2879">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="43995-2880">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2880">Routing strategy</span></span>|<span data-ttu-id="43995-2881">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2881">Bubbling</span></span>|  
|<span data-ttu-id="43995-2882">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2882">Delegate</span></span>|<span data-ttu-id="43995-2883">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2883"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2884">對應通道的事件<xref:System.Windows.ContentElement.PreviewTouchDown>。</span><span class="sxs-lookup"><span data-stu-id="43995-2884">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="43995-2885">覆寫<xref:System.Windows.ContentElement.OnTouchDown%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2885">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2886">識別 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2886">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2887">當觸控從這個項目的界限外部移至內部時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2887">Occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43995-2888">一律引發這個事件，或有觸控式裝置擷取至這個 UI 項目。</span><span class="sxs-lookup"><span data-stu-id="43995-2888">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2889">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2890">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2890">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="43995-2891">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2891">Routing strategy</span></span>|<span data-ttu-id="43995-2892">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2892">Direct</span></span>|  
|<span data-ttu-id="43995-2893">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2893">Delegate</span></span>|<span data-ttu-id="43995-2894">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2894"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2895">覆寫<xref:System.Windows.ContentElement.OnTouchEnter%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2895">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2896">識別 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2896">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2897">取得已擷取至這個項目的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2897">Gets all touch devices that are captured to this element.</span></span></summary>
        <value><span data-ttu-id="43995-2898">已擷取至這個項目之 <see cref="T:System.Windows.Input.TouchDevice" /> 物件的列舉。</span><span class="sxs-lookup"><span data-stu-id="43995-2898">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2899">取得已擷取至這個項目或其視覺化樹狀結構中之任何子項目的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2899">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="43995-2900">已擷取至這個項目或其視覺化樹狀結構中之任何子項目的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</span><span class="sxs-lookup"><span data-stu-id="43995-2900">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2901">取得在這個項目上停留的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2901">Gets all touch devices that are over this element.</span></span></summary>
        <value><span data-ttu-id="43995-2902">在這個項目之上的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</span><span class="sxs-lookup"><span data-stu-id="43995-2902">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2903">取得在這個項目或其視覺化樹狀結構中之任何子項目上停留的所有觸控裝置。</span><span class="sxs-lookup"><span data-stu-id="43995-2903">Gets all touch devices that are over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="43995-2904">在這個項目或其視覺化樹狀結構中之任何子項目上停留的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</span><span class="sxs-lookup"><span data-stu-id="43995-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2905">當觸控從這個項目的界限內部移至外部時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2905">Occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2906">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2906">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2907">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2907">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="43995-2908">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2908">Routing strategy</span></span>|<span data-ttu-id="43995-2909">直接</span><span class="sxs-lookup"><span data-stu-id="43995-2909">Direct</span></span>|  
|<span data-ttu-id="43995-2910">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2910">Delegate</span></span>|<span data-ttu-id="43995-2911">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2911"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2912">覆寫<xref:System.Windows.ContentElement.OnTouchLeave%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2912">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2913">識別 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2913">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2914">手指在這個項目上方且在螢幕上移動時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2914">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2915">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2915">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2916">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2916">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="43995-2917">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2917">Routing strategy</span></span>|<span data-ttu-id="43995-2918">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2918">Bubbling</span></span>|  
|<span data-ttu-id="43995-2919">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2919">Delegate</span></span>|<span data-ttu-id="43995-2920">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2920"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2921">對應通道的事件<xref:System.Windows.ContentElement.PreviewTouchMove>。</span><span class="sxs-lookup"><span data-stu-id="43995-2921">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="43995-2922">覆寫<xref:System.Windows.ContentElement.OnTouchMove%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2922">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2923">識別 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2923">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2924">手指在這個項目上方且離開螢幕時發生。</span><span class="sxs-lookup"><span data-stu-id="43995-2924">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="43995-2925">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="43995-2925">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="43995-2926">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="43995-2926">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="43995-2927">路由策略</span><span class="sxs-lookup"><span data-stu-id="43995-2927">Routing strategy</span></span>|<span data-ttu-id="43995-2928">反昇</span><span class="sxs-lookup"><span data-stu-id="43995-2928">Bubbling</span></span>|  
|<span data-ttu-id="43995-2929">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="43995-2929">Delegate</span></span>|<span data-ttu-id="43995-2930">型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="43995-2930"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="43995-2931">對應通道的事件<xref:System.Windows.ContentElement.PreviewTouchUp>。</span><span class="sxs-lookup"><span data-stu-id="43995-2931">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="43995-2932">覆寫<xref:System.Windows.ContentElement.OnTouchUp%2A>實作在衍生類別中這個事件的類別處理。</span><span class="sxs-lookup"><span data-stu-id="43995-2932">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43995-2933">識別 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="43995-2933">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>