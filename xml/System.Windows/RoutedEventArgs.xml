<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="708a1ffe3e315f5d8bcff28cce08c73843f9f63b" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56346222" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含與路由事件相關聯的狀態資訊和事件資料。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同<xref:System.Windows.RoutedEventArgs>可以搭配單一<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>。 這個類別是負責封裝的事件資料<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>，提供額外的事件狀態資訊，而且會由叫用之路由事件相關聯的處理常式的事件系統。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用這個無參數建構函式、 新的所有公用屬性<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>並<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示<xref:System.Windows.RoutedEventArgs>資料不會嘗試指定的來源。 這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>，則<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會填入值的項目引發事件，會傳遞至接聽程式透過路由為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</param>
        <summary>使用提供的路由事件識別項，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用這個多載的建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>並<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>而言只意謂著，這<xref:System.Windows.RoutedEventArgs>不會嘗試指定的來源。 這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>，則<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會填入值的項目引發事件，會傳遞至接聽程式透過路由為基礎。  
  
   
  
## Examples  
 下列範例會建構新<xref:System.Windows.RoutedEventArgs>的呼叫中使用<xref:System.Windows.UIElement.RaiseEvent%2A>。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</param>
        <param name="source">在處理事件時報告的替代來源。 它會預先填入 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性。</param>
        <summary>使用提供的路由事件識別項並提供宣告不同事件來源的機會，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用這個多載的建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會根據項目引發事件，並透過路由傳遞填入，但會讀取`null`之前引動過程。  
  
 傳遞時，請使用此簽章<xref:System.Windows.RoutedEventArgs>至虛擬函式，例如<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>引數會用來呼叫、<xref:System.Windows.UIElement.RaiseEvent%2A>內部。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示路由事件在傳送路由時之事件處理的目前狀態。</summary>
        <value>如果設定，設定為<see langword="true" />如果事件已處理，否則為標示<see langword="false" />。 如果讀取這個值，<see langword="true" />表示類別處理常式或路由中的某個執行個體處理常式已經已標示已處理此事件。 <see langword="false" /> 表示沒有這類處理常式已將事件標記為已處理。  
  
預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 標示已處理的事件會限制此事件路由的接聽程式之路由事件的可見性。 事件仍未出差的路由，其餘部分，但是唯一的處理常式特別加`HandledEventsToo``true`在<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>會叫用方法呼叫，以回應。 預設執行個體接聽程式上的處理常式 (例如那些以表示[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 不會叫用。 處理標記處理的事件不是常見的案例。  
  
 如果您是控制項作者定義您自己的事件，您所做的決策關於事件類別層級的處理會影響控制項的使用者，以及任何使用者衍生的控制項，並為其他項目可能包含您的控制項或者，其中包含您的控制項。 如需詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。  
  
 在極少數的情況下是適用於處理事件其中<xref:System.Windows.RoutedEventArgs.Handled%2A>標示`true`，並修改事件引數變更<xref:System.Windows.RoutedEventArgs.Handled%2A>至`false`。 這可能是必要的控制項，例如金鑰處理的輸入事件的某些方面<xref:System.Windows.UIElement.KeyDown>與<xref:System.Windows.UIElement.TextInput>其中低層級和高層級的輸入的事件會競用處理，以及每個嘗試使用不同的路由策略。  
  
   
  
## Examples  
 下列範例會實作標記為已處理的事件處理常式。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">要叫用的泛型處理常式/委派實作。</param>
        <param name="genericTarget">應該在其上叫用所提供處理常式的目標。</param>
        <summary>在衍生類別中覆寫時，提供以特定類型方式叫用事件處理常式的方式，這可透過基底實作來提高效率。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底實作包含反映來判斷正確的處理常式，只要其中的處理常式並不真的<xref:System.Windows.RoutedEventHandler>，而且此步驟中反映一些效能的後果。 引動過程可更有效率地不依賴反映。 這是這個方法可供選擇覆寫它的任何路由的事件的引數類別會刺激的案例。 實作不應呼叫基底針對這個方法，因為您的實作應該已經很負責叫用型別安全處理常式。  
  
   
  
## Examples  
 以下是說明可用於實作的基本模式的虛擬程式碼。 在這裡，`MyRoutedEventHandler`是子類別的<xref:System.Windows.RoutedEventHandler>。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法被要覆寫衍生的事件資料類別，以提供更有效率的引動過程的委派。 實作應該轉換提供<paramref name="genericHandler" />特定型別的委派，，然後叫用該處理常式。  
  
預設實作會嘗試叫用提供的處理常式，並嘗試將其轉換成<see cref="T:System.Windows.RoutedEventHandler" />。 如果有任一<paramref name="genericHandler" />或<paramref name="genericTarget" />依現狀<see langword="null" />，就會引發例外狀況。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="P:System.Windows.RoutedEventArgs.Source" /> 設定成的新值。</param>
        <summary>在衍生類別中覆寫時，每當執行個體的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性值變更，便會提供通知回呼進入點。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>以程式設計方式變更報告事件的來源可能需要更新事件內的特定類型的資料。 基於這個理由，<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />受保護的虛擬方法，並要加以覆寫的子類別<see cref="T:System.Windows.RoutedEventArgs" />。  
  
這個方法沒有任何預設實作。</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在父類別進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前，取得純點擊測試所判定的原始報告來源。</summary>
        <value>可能已扁平化複合項目樹狀結構的原始報告來源 (在類別處理進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會取得其值，一旦之前的類別事件處理常式或任何執行個體處理常式會叫用，並略過此點會永遠不會進行調整。 就像它會回報在事件資料中，原始的來源資訊便會是唯讀的類別處理常式或類別實作。  
  
 來源可能會調整的常見案例包括控制項的內容模型的內容項目 (清單項目內容，比方說，將會報告清單項目的項目，做為<xref:System.Windows.RoutedEventArgs.Source%2A>和清單項目中的實際項目將會是<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 藉由各種項目和內容模型的來源調整不同類別。 調整事件來源的每個類別會嘗試預測的來源是最有用報告最輸入的案例和案例，是類別，並再設定的來源為<xref:System.Windows.RoutedEventArgs.Source%2A>。 如果此來源不包含您處理事件的相關資訊，請試著檢查<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>改用它是否報告不同的來源，就更適合。 如需輸入事件的詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個 <see cref="T:System.Windows.RoutedEventArgs" /> 執行個體相關聯的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />。</summary>
        <value>已叫用之事件的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法將此值設定在<xref:System.Windows.RoutedEventArgs>，已傳送 （比方說，如果您取得透過處理常式的引數）。 嘗試執行此作業會產生例外狀況。 您只可以設定它尚未使用來產生事件的引動過程的執行個體上。  
  
 值<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>不能是`null`在任何時間。  
  
   
  
## Examples  
 下列範例會建立新的路由的事件資料的初始建構函式，並接著會設定<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>屬性做為後續的作業。 您必須擁有<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>之前引發路由的事件設定。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">嘗試在路由事件時變更 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定引發事件之物件的參考。</summary>
        <value>引發事件的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對任何事件反昇路由已實際周遊至之外引發的項目路由的事件，在任何通道路由事件不具有尚未引發它的值的項目到通道<xref:System.Windows.RoutedEventArgs.Source%2A>會比的值不同`sender`參數的事件引數類別。 這兩個項目參與事件是最重要的任何指定的處理常式 (<xref:System.Windows.RoutedEventArgs.Source%2A>，，引發的項目或`sender`，目前正在處理它的項目) 取決於您的處理常式的應用程式邏輯定址。  
  
 設定這個屬性通常只是在覆寫或實作其他[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，調整事件的來源，例如當處理事件的類別。 不建議從執行個體處理常式的明顯的事件來源正在重設，尤其是處理常式不會為已處理標記事件。  
  
 如果您重設<xref:System.Windows.RoutedEventArgs.Source%2A>報告不同的事件來源、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>做為第一個來源引發所起始的報表將會繼續<xref:System.Windows.UIElement.RaiseEvent%2A>呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>