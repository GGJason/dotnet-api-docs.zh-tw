<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c3508-101">包含與路由事件相關聯的狀態資訊和事件資料。</span><span class="sxs-lookup"><span data-stu-id="c3508-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-102">不同<xref:System.Windows.RoutedEventArgs>可以搭配單一<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c3508-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="c3508-103">這個類別會負責封裝的事件資料<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>，提供額外的事件狀態資訊，，和事件系統用於叫用之路由事件相關聯的處理常式。</span><span class="sxs-lookup"><span data-stu-id="c3508-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3508-104">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c3508-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3508-105">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c3508-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-106">使用此參數建構函式，新的所有公用屬性時<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="c3508-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="c3508-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="c3508-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`</span><span class="sxs-lookup"><span data-stu-id="c3508-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="c3508-109"><xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="c3508-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="c3508-111">Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示<xref:System.Windows.RoutedEventArgs>資料不會嘗試指定來源。</span><span class="sxs-lookup"><span data-stu-id="c3508-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="c3508-112">這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>根據引發事件，且會傳遞至接聽程式，透過路由的項目會填入值。</span><span class="sxs-lookup"><span data-stu-id="c3508-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="c3508-113"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c3508-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="c3508-114">使用提供的路由事件識別項，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c3508-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-115">當使用這個多載建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="c3508-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="c3508-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`</span><span class="sxs-lookup"><span data-stu-id="c3508-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="c3508-117"><xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="c3508-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="c3508-119">Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示這個<xref:System.Windows.RoutedEventArgs>不會嘗試指定來源。</span><span class="sxs-lookup"><span data-stu-id="c3508-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="c3508-120">這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>根據引發事件，且會傳遞至接聽程式，透過路由的項目會填入值。</span><span class="sxs-lookup"><span data-stu-id="c3508-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3508-121">下列範例會建構新<xref:System.Windows.RoutedEventArgs>用於呼叫<xref:System.Windows.UIElement.RaiseEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="c3508-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="c3508-122"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="c3508-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="c3508-123">在處理事件時報告的替代來源。</span><span class="sxs-lookup"><span data-stu-id="c3508-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="c3508-124">它會預先填入 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="c3508-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="c3508-125">使用提供的路由事件識別項並提供宣告不同事件來源的機會，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c3508-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-126">當使用這個多載建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="c3508-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="c3508-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`</span><span class="sxs-lookup"><span data-stu-id="c3508-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="c3508-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="c3508-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="c3508-129">Null 值<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>都會根據引發事件，且透過路由傳遞的項目，但是會讀取`null`叫用之前。</span><span class="sxs-lookup"><span data-stu-id="c3508-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="c3508-130">傳遞時，請使用此簽章<xref:System.Windows.RoutedEventArgs>虛擬函式，例如以<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>、 引數會用來呼叫<xref:System.Windows.UIElement.RaiseEvent%2A>內部。</span><span class="sxs-lookup"><span data-stu-id="c3508-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3508-131">取得或設定值，這個值表示路由事件在傳送路由時之事件處理的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="c3508-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="c3508-132">如果設定，設定為<see langword="true" />如果事件已處理，否則應標記為<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3508-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="c3508-133">如果讀取這個值，<see langword="true" />表示類別處理常式或路由中的某些執行個體處理常式已有標示處理此事件。</span><span class="sxs-lookup"><span data-stu-id="c3508-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="c3508-134"><see langword="false" /> 表示沒有這種處理常式將事件標記為已處理。</span><span class="sxs-lookup"><span data-stu-id="c3508-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
 <span data-ttu-id="c3508-135">預設值是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3508-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-136">標記處理的事件將會限制此事件路由上的接聽程式的路由事件的可見性。</span><span class="sxs-lookup"><span data-stu-id="c3508-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="c3508-137">事件未仍旅行的路由，其餘部分，但只處理常式特別加入與`HandledEventsToo``true`中<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>將回應叫用方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="c3508-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="c3508-138">預設執行個體接聽程式上的處理常式 (例如那些以表示[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 不會叫用。</span><span class="sxs-lookup"><span data-stu-id="c3508-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="c3508-139">處理標記處理的事件不是常見的案例。</span><span class="sxs-lookup"><span data-stu-id="c3508-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="c3508-140">如果您是控制作者定義您自己的事件，您的決策有關事件類別層級的處理會影響控制項的使用者，以及衍生的控制項的所有使用者和其他項目，就是可能包含您的控制項或包含您的控制項。</span><span class="sxs-lookup"><span data-stu-id="c3508-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="c3508-141">如需詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="c3508-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="c3508-142">在極少數的情況下則會適當地處理事件其中<xref:System.Windows.RoutedEventArgs.Handled%2A>標示`true`，並修改事件引數變更<xref:System.Windows.RoutedEventArgs.Handled%2A>至`false`。</span><span class="sxs-lookup"><span data-stu-id="c3508-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="c3508-143">這可能是必要的輸入控制項的事件，例如金鑰處理的特定區域中<xref:System.Windows.UIElement.KeyDown>與<xref:System.Windows.UIElement.TextInput>其中低層級和高層級的輸入的事件會競爭處理，而且每個嘗試使用不同的路由策略。</span><span class="sxs-lookup"><span data-stu-id="c3508-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3508-144">下列範例會實作標記為已處理的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c3508-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="c3508-145">要叫用的泛型處理常式/委派實作。</span><span class="sxs-lookup"><span data-stu-id="c3508-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="c3508-146">應該在其上叫用所提供處理常式的目標。</span><span class="sxs-lookup"><span data-stu-id="c3508-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="c3508-147">在衍生類別中覆寫時，提供以特定類型方式叫用事件處理常式的方式，這可透過基底實作來提高效率。</span><span class="sxs-lookup"><span data-stu-id="c3508-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-148">基底實作結合反映來判斷正確的處理常式的任何狀況，其中此處理常式不是依其字面<xref:System.Windows.RoutedEventHandler>，且此步驟中反映一些帶來效能影響。</span><span class="sxs-lookup"><span data-stu-id="c3508-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="c3508-149">引動過程可更有效率地不依賴反映。</span><span class="sxs-lookup"><span data-stu-id="c3508-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="c3508-150">這是要選擇要覆寫它任何路由的事件的引數類別可以使用這個方法會刺激的案例。</span><span class="sxs-lookup"><span data-stu-id="c3508-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="c3508-151">實作不應呼叫基底，此方法，因為您的實作應該已經很負責叫用型別安全的處理常式。</span><span class="sxs-lookup"><span data-stu-id="c3508-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3508-152">以下是說明可用來實作基本模式的虛擬程式碼。</span><span class="sxs-lookup"><span data-stu-id="c3508-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="c3508-153">在這裡，`MyRoutedEventHandler`是子類別的<xref:System.Windows.RoutedEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="c3508-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c3508-154">這個方法會覆寫所衍生的事件資料類別來提供更有效率的引動過程的委派。</span><span class="sxs-lookup"><span data-stu-id="c3508-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="c3508-155">實作應該轉換提供<paramref name="genericHandler" />特定型別的委派，然後叫用該處理常式。</span><span class="sxs-lookup"><span data-stu-id="c3508-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
 <span data-ttu-id="c3508-156">預設實作會嘗試叫用提供的處理常式，並嘗試將其轉換成<see cref="T:System.Windows.RoutedEventHandler" />。</span><span class="sxs-lookup"><span data-stu-id="c3508-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="c3508-157">如果有任一個<paramref name="genericHandler" />或<paramref name="genericTarget" />依現狀<see langword="null" />，就會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c3508-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="c3508-158"><see cref="P:System.Windows.RoutedEventArgs.Source" /> 設定成的新值。</span><span class="sxs-lookup"><span data-stu-id="c3508-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="c3508-159">在衍生類別中覆寫時，每當執行個體的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性值變更，便會提供通知回呼進入點。</span><span class="sxs-lookup"><span data-stu-id="c3508-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c3508-160">以程式設計方式變更報告事件的來源可能需要更新事件內的特定類型的資料。</span><span class="sxs-lookup"><span data-stu-id="c3508-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="c3508-161">基於這個理由，<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />受保護的虛擬方法，並要加以覆寫的子類別<see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c3508-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
 <span data-ttu-id="c3508-162">這個方法會具有預設的實作。</span><span class="sxs-lookup"><span data-stu-id="c3508-162">This method has no default implementation.</span></span></para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3508-163">在父類別進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前，取得純點擊測試所判定的原始報告來源。</span><span class="sxs-lookup"><span data-stu-id="c3508-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="c3508-164">在類別處理進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前的原始報告來源，類別處理會簡化複合項目樹狀結構的維度。</span><span class="sxs-lookup"><span data-stu-id="c3508-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-165">一旦之前的類別執行個體中的任何處理常式或事件處理常式叫用，且永遠不會進行調整略過此點，這個屬性會取得其值。</span><span class="sxs-lookup"><span data-stu-id="c3508-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="c3508-166">原始的來源資訊是唯讀的類別處理常式或類別實作中，就如同中的事件資料會報告錯誤。</span><span class="sxs-lookup"><span data-stu-id="c3508-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="c3508-167">來源可加以調整的常見案例包括控制項的內容模型的內容項目 (清單項目，比方說，內容會報告清單項目項目，做為<xref:System.Windows.RoutedEventArgs.Source%2A>會清單項目中的實際項目。<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="c3508-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="c3508-168">由各種項目和內容模型的來源調整不同類別。</span><span class="sxs-lookup"><span data-stu-id="c3508-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="c3508-169">調整事件來源的每個類別會嘗試預測的來源是最有用報告最輸入的案例和案例的主要類別，然後集的來源為<xref:System.Windows.RoutedEventArgs.Source%2A>。</span><span class="sxs-lookup"><span data-stu-id="c3508-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="c3508-170">如果此來源不是具有相關性的事件處理，請嘗試檢查<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>改為以查看它如果報表是更適合的不同來源。</span><span class="sxs-lookup"><span data-stu-id="c3508-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="c3508-171">如需有關輸入事件的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="c3508-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3508-172">取得或設定與這個 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 執行個體關聯的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="c3508-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="c3508-173">已叫用之事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="c3508-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-174">您無法設定此值<xref:System.Windows.RoutedEventArgs>，已傳送 （比方說，如果您取得透過處理常式的引數）。</span><span class="sxs-lookup"><span data-stu-id="c3508-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="c3508-175">嘗試這樣做會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c3508-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="c3508-176">您可以只設定尚未用來產生事件的引動過程之執行個體上。</span><span class="sxs-lookup"><span data-stu-id="c3508-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="c3508-177">值<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>不可`null`在任何時間。</span><span class="sxs-lookup"><span data-stu-id="c3508-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3508-178">下列範例使用初始的建構函式建立新的路由的事件資料，並設定<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>屬性做為後續的作業。</span><span class="sxs-lookup"><span data-stu-id="c3508-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="c3508-179">您必須擁有<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>設定之前引發的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="c3508-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c3508-180">嘗試在路由事件時變更 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 值。</span><span class="sxs-lookup"><span data-stu-id="c3508-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3508-181">取得或設定引發事件之物件的參考。</span><span class="sxs-lookup"><span data-stu-id="c3508-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="c3508-182">引發事件的物件。</span><span class="sxs-lookup"><span data-stu-id="c3508-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3508-183">針對任何反昇路由已實際旅行的路由，引發的項目之後的事件，在任何通道路由不具有事件尚未向引發它的值之項目的通道<xref:System.Windows.RoutedEventArgs.Source%2A>不同於值<c3/>事件引數類別的參數。</span><span class="sxs-lookup"><span data-stu-id="c3508-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="c3508-184">這兩個項目事件中相關就最重要中任何指定的處理常式 (<xref:System.Windows.RoutedEventArgs.Source%2A>，引發它的項目或`sender`，目前正在處理它的項目) 取決於您的處理常式是應用程式邏輯定址。</span><span class="sxs-lookup"><span data-stu-id="c3508-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="c3508-185">設定這個屬性通常只是在覆寫或實作其他[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，調整事件來源，例如當類別處理事件。</span><span class="sxs-lookup"><span data-stu-id="c3508-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="c3508-186">不建議重設明顯的事件來源的執行個體的處理常式，特別是當此處理常式不會為已處理標記事件。</span><span class="sxs-lookup"><span data-stu-id="c3508-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="c3508-187">如果您重設<xref:System.Windows.RoutedEventArgs.Source%2A>報告不同的事件來源、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>由起始端引發做為第一個來源的報表會繼續<xref:System.Windows.UIElement.RaiseEvent%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="c3508-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>