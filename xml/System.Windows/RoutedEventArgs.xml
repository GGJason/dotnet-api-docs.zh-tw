<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48756010" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="81815-101">包含與路由事件相關聯的狀態資訊和事件資料。</span><span class="sxs-lookup"><span data-stu-id="81815-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-102">不同<xref:System.Windows.RoutedEventArgs>可以搭配單一<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="81815-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="81815-103">這個類別是負責封裝的事件資料<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>，提供額外的事件狀態資訊，而且會由叫用之路由事件相關聯的處理常式的事件系統。</span><span class="sxs-lookup"><span data-stu-id="81815-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="81815-104">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="81815-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="81815-105">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="81815-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-106">當使用這個無參數建構函式、 新的所有公用屬性<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="81815-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="81815-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="81815-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`</span><span class="sxs-lookup"><span data-stu-id="81815-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="81815-109"><xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="81815-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="81815-111">Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>並<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示<xref:System.Windows.RoutedEventArgs>資料不會嘗試指定的來源。</span><span class="sxs-lookup"><span data-stu-id="81815-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="81815-112">這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>，則<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會填入值的項目引發事件，會傳遞至接聽程式透過路由為基礎。</span><span class="sxs-lookup"><span data-stu-id="81815-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="81815-113"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="81815-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="81815-114">使用提供的路由事件識別項，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="81815-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-115">當使用這個多載的建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="81815-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="81815-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`</span><span class="sxs-lookup"><span data-stu-id="81815-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="81815-117"><xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="81815-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="81815-119">Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>並<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>而言只意謂著，這<xref:System.Windows.RoutedEventArgs>不會嘗試指定的來源。</span><span class="sxs-lookup"><span data-stu-id="81815-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="81815-120">這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>，則<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會填入值的項目引發事件，會傳遞至接聽程式透過路由為基礎。</span><span class="sxs-lookup"><span data-stu-id="81815-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81815-121">下列範例會建構新<xref:System.Windows.RoutedEventArgs>的呼叫中使用<xref:System.Windows.UIElement.RaiseEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="81815-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="81815-122"><see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</span><span class="sxs-lookup"><span data-stu-id="81815-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="81815-123">在處理事件時報告的替代來源。</span><span class="sxs-lookup"><span data-stu-id="81815-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="81815-124">它會預先填入 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="81815-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="81815-125">使用提供的路由事件識別項並提供宣告不同事件來源的機會，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="81815-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-126">當使用這個多載的建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：</span><span class="sxs-lookup"><span data-stu-id="81815-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="81815-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> 預設為 `false`</span><span class="sxs-lookup"><span data-stu-id="81815-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="81815-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="81815-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="81815-129">Null 值<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>會根據項目引發事件，並透過路由傳遞填入，但會讀取`null`之前引動過程。</span><span class="sxs-lookup"><span data-stu-id="81815-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="81815-130">傳遞時，請使用此簽章<xref:System.Windows.RoutedEventArgs>至虛擬函式，例如<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>引數會用來呼叫、<xref:System.Windows.UIElement.RaiseEvent%2A>內部。</span><span class="sxs-lookup"><span data-stu-id="81815-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81815-131">取得或設定值，這個值表示路由事件在傳送路由時之事件處理的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="81815-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="81815-132">如果設定，設定為<see langword="true" />如果事件已處理，否則為標示<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="81815-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="81815-133">如果讀取這個值，<see langword="true" />表示類別處理常式或路由中的某個執行個體處理常式已經已標示已處理此事件。</span><span class="sxs-lookup"><span data-stu-id="81815-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="81815-134"><see langword="false" /> 表示沒有這種處理常式將事件標記為已處理。</span><span class="sxs-lookup"><span data-stu-id="81815-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
<span data-ttu-id="81815-135">預設值是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="81815-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-136">標示已處理的事件會限制此事件路由的接聽程式之路由事件的可見性。</span><span class="sxs-lookup"><span data-stu-id="81815-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="81815-137">事件仍未出差的路由，其餘部分，但是唯一的處理常式特別加`HandledEventsToo``true`在<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>會叫用方法呼叫，以回應。</span><span class="sxs-lookup"><span data-stu-id="81815-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="81815-138">預設執行個體接聽程式上的處理常式 (例如那些以表示[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 不會叫用。</span><span class="sxs-lookup"><span data-stu-id="81815-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="81815-139">處理標記處理的事件不是常見的案例。</span><span class="sxs-lookup"><span data-stu-id="81815-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="81815-140">如果您是控制項作者定義您自己的事件，您所做的決策關於事件類別層級的處理會影響控制項的使用者，以及任何使用者衍生的控制項，並為其他項目可能包含您的控制項或者，其中包含您的控制項。</span><span class="sxs-lookup"><span data-stu-id="81815-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="81815-141">如需詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="81815-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="81815-142">在極少數的情況下是適用於處理事件其中<xref:System.Windows.RoutedEventArgs.Handled%2A>標示`true`，並修改事件引數變更<xref:System.Windows.RoutedEventArgs.Handled%2A>至`false`。</span><span class="sxs-lookup"><span data-stu-id="81815-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="81815-143">這可能是必要的控制項，例如金鑰處理的輸入事件的某些方面<xref:System.Windows.UIElement.KeyDown>與<xref:System.Windows.UIElement.TextInput>其中低層級和高層級的輸入的事件會競用處理，以及每個嘗試使用不同的路由策略。</span><span class="sxs-lookup"><span data-stu-id="81815-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81815-144">下列範例會實作標記為已處理的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="81815-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="81815-145">要叫用的泛型處理常式/委派實作。</span><span class="sxs-lookup"><span data-stu-id="81815-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="81815-146">應該在其上叫用所提供處理常式的目標。</span><span class="sxs-lookup"><span data-stu-id="81815-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="81815-147">在衍生類別中覆寫時，提供以特定類型方式叫用事件處理常式的方式，這可透過基底實作來提高效率。</span><span class="sxs-lookup"><span data-stu-id="81815-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-148">基底實作包含反映來判斷正確的處理常式，只要其中的處理常式並不真的<xref:System.Windows.RoutedEventHandler>，而且此步驟中反映一些效能的後果。</span><span class="sxs-lookup"><span data-stu-id="81815-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="81815-149">引動過程可更有效率地不依賴反映。</span><span class="sxs-lookup"><span data-stu-id="81815-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="81815-150">這是這個方法可供選擇覆寫它的任何路由的事件的引數類別會刺激的案例。</span><span class="sxs-lookup"><span data-stu-id="81815-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="81815-151">實作不應呼叫基底針對這個方法，因為您的實作應該已經很負責叫用型別安全處理常式。</span><span class="sxs-lookup"><span data-stu-id="81815-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81815-152">以下是說明可用於實作的基本模式的虛擬程式碼。</span><span class="sxs-lookup"><span data-stu-id="81815-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="81815-153">在這裡，`MyRoutedEventHandler`是子類別的<xref:System.Windows.RoutedEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="81815-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="81815-154">這個方法被要覆寫衍生的事件資料類別，以提供更有效率的引動過程的委派。</span><span class="sxs-lookup"><span data-stu-id="81815-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="81815-155">實作應該轉換提供<paramref name="genericHandler" />特定型別的委派，，然後叫用該處理常式。</span><span class="sxs-lookup"><span data-stu-id="81815-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
<span data-ttu-id="81815-156">預設實作會嘗試叫用提供的處理常式，並嘗試將其轉換成<see cref="T:System.Windows.RoutedEventHandler" />。</span><span class="sxs-lookup"><span data-stu-id="81815-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="81815-157">如果有任一<paramref name="genericHandler" />或<paramref name="genericTarget" />依現狀<see langword="null" />，就會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="81815-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="81815-158"><see cref="P:System.Windows.RoutedEventArgs.Source" /> 設定成的新值。</span><span class="sxs-lookup"><span data-stu-id="81815-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="81815-159">在衍生類別中覆寫時，每當執行個體的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性值變更，便會提供通知回呼進入點。</span><span class="sxs-lookup"><span data-stu-id="81815-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="81815-160">以程式設計方式變更報告事件的來源可能需要更新事件內的特定類型的資料。</span><span class="sxs-lookup"><span data-stu-id="81815-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="81815-161">基於這個理由，<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />受保護的虛擬方法，並要加以覆寫的子類別<see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="81815-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
<span data-ttu-id="81815-162">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="81815-162">This method has no default implementation.</span></span></para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81815-163">在父類別進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前，取得純點擊測試所判定的原始報告來源。</span><span class="sxs-lookup"><span data-stu-id="81815-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="81815-164">在類別處理進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前的原始報告來源，類別處理會簡化複合項目樹狀結構的維度。</span><span class="sxs-lookup"><span data-stu-id="81815-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-165">這個屬性會取得其值，一旦之前的類別事件處理常式或任何執行個體處理常式會叫用，並略過此點會永遠不會進行調整。</span><span class="sxs-lookup"><span data-stu-id="81815-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="81815-166">就像它會回報在事件資料中，原始的來源資訊便會是唯讀的類別處理常式或類別實作。</span><span class="sxs-lookup"><span data-stu-id="81815-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="81815-167">來源可能會調整的常見案例包括控制項的內容模型的內容項目 (清單項目內容，比方說，將會報告清單項目的項目，做為<xref:System.Windows.RoutedEventArgs.Source%2A>和清單項目中的實際項目將會是<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="81815-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="81815-168">藉由各種項目和內容模型的來源調整不同類別。</span><span class="sxs-lookup"><span data-stu-id="81815-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="81815-169">調整事件來源的每個類別會嘗試預測的來源是最有用報告最輸入的案例和案例，是類別，並再設定的來源為<xref:System.Windows.RoutedEventArgs.Source%2A>。</span><span class="sxs-lookup"><span data-stu-id="81815-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="81815-170">如果此來源不包含您處理事件的相關資訊，請試著檢查<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>改用它是否報告不同的來源，就更適合。</span><span class="sxs-lookup"><span data-stu-id="81815-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="81815-171">如需輸入事件的詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="81815-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81815-172">取得或設定與這個 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 執行個體關聯的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="81815-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="81815-173">已叫用之事件的識別項。</span><span class="sxs-lookup"><span data-stu-id="81815-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-174">您無法將此值設定在<xref:System.Windows.RoutedEventArgs>，已傳送 （比方說，如果您取得透過處理常式的引數）。</span><span class="sxs-lookup"><span data-stu-id="81815-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="81815-175">嘗試執行此作業會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="81815-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="81815-176">您只可以設定它尚未使用來產生事件的引動過程的執行個體上。</span><span class="sxs-lookup"><span data-stu-id="81815-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="81815-177">值<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>不能是`null`在任何時間。</span><span class="sxs-lookup"><span data-stu-id="81815-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="81815-178">下列範例會建立新的路由的事件資料的初始建構函式，並接著會設定<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>屬性做為後續的作業。</span><span class="sxs-lookup"><span data-stu-id="81815-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="81815-179">您必須擁有<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>之前引發路由的事件設定。</span><span class="sxs-lookup"><span data-stu-id="81815-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="81815-180">嘗試在路由事件時變更 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 值。</span><span class="sxs-lookup"><span data-stu-id="81815-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="81815-181">取得或設定引發事件之物件的參考。</span><span class="sxs-lookup"><span data-stu-id="81815-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="81815-182">引發事件的物件。</span><span class="sxs-lookup"><span data-stu-id="81815-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="81815-183">針對任何事件反昇路由已實際周遊至之外引發的項目路由的事件，在任何通道路由事件不具有尚未引發它的值的項目到通道<xref:System.Windows.RoutedEventArgs.Source%2A>會比的值不同`sender`參數的事件引數類別。</span><span class="sxs-lookup"><span data-stu-id="81815-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="81815-184">這兩個項目參與事件是最重要的任何指定的處理常式 (<xref:System.Windows.RoutedEventArgs.Source%2A>，，引發的項目或`sender`，目前正在處理它的項目) 取決於您的處理常式的應用程式邏輯定址。</span><span class="sxs-lookup"><span data-stu-id="81815-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="81815-185">設定這個屬性通常只是在覆寫或實作其他[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，調整事件的來源，例如當處理事件的類別。</span><span class="sxs-lookup"><span data-stu-id="81815-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="81815-186">不建議從執行個體處理常式的明顯的事件來源正在重設，尤其是處理常式不會為已處理標記事件。</span><span class="sxs-lookup"><span data-stu-id="81815-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="81815-187">如果您重設<xref:System.Windows.RoutedEventArgs.Source%2A>報告不同的事件來源、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>做為第一個來源引發所起始的報表將會繼續<xref:System.Windows.UIElement.RaiseEvent%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="81815-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>