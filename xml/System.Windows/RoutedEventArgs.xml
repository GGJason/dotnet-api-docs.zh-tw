<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f6112c09b1f961b689a530d29b65eeca46e3156" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679762" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含與路由事件相關聯的狀態資訊和事件資料。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同<xref:System.Windows.RoutedEventArgs>可以搭配單一<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>。 這個類別會負責封裝的事件資料<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>，提供額外的事件狀態資訊，，和事件系統用於叫用之路由事件相關聯的處理常式。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此參數建構函式，新的所有公用屬性時<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示<xref:System.Windows.RoutedEventArgs>資料不會嘗試指定來源。 這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>根據引發事件，且會傳遞至接聽程式，透過路由的項目會填入值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</param>
        <summary>使用提供的路由事件識別項，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用這個多載建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 預設為`null`。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只表示這個<xref:System.Windows.RoutedEventArgs>不會嘗試指定來源。 這個執行個體的呼叫中使用時<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>根據引發事件，且會傳遞至接聽程式，透過路由的項目會填入值。  
  
   
  
## Examples  
 下列範例會建構新<xref:System.Windows.RoutedEventArgs>用於呼叫<xref:System.Windows.UIElement.RaiseEvent%2A>。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> 類別的此執行個體之路由事件識別項。</param>
        <param name="source">在處理事件時報告的替代來源。 它會預先填入 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性。</param>
        <summary>使用提供的路由事件識別項並提供宣告不同事件來源的機會，初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用這個多載建構函式時，未指定屬性的新<xref:System.Windows.RoutedEventArgs>執行個體假設預設值如下：  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 預設值為 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 預設為`null`。  
  
 Null 值<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>都會根據引發事件，且透過路由傳遞的項目，但是會讀取`null`叫用之前。  
  
 傳遞時，請使用此簽章<xref:System.Windows.RoutedEventArgs>虛擬函式，例如以<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>、 引數會用來呼叫<xref:System.Windows.UIElement.RaiseEvent%2A>內部。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示路由事件在傳送路由時之事件處理的目前狀態。</summary>
        <value>如果設定，設定為<see langword="true" />如果事件已處理，否則應標記為<see langword="false" />。 如果讀取這個值，<see langword="true" />表示類別處理常式或路由中的某些執行個體處理常式已有標示處理此事件。 <see langword="false" /> 表示沒有這種處理常式將事件標記為已處理。  
  
 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 標記處理的事件將會限制此事件路由上的接聽程式的路由事件的可見性。 事件未仍旅行的路由，其餘部分，但只處理常式特別加入與`HandledEventsToo``true`中<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>將回應叫用方法呼叫。 預設執行個體接聽程式上的處理常式 (例如那些以表示[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 不會叫用。 處理標記處理的事件不是常見的案例。  
  
 如果您是控制作者定義您自己的事件，您的決策有關事件類別層級的處理會影響控制項的使用者，以及衍生的控制項的所有使用者和其他項目，就是可能包含您的控制項或包含您的控制項。 如需詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。  
  
 在極少數的情況下則會適當地處理事件其中<xref:System.Windows.RoutedEventArgs.Handled%2A>標示`true`，並修改事件引數變更<xref:System.Windows.RoutedEventArgs.Handled%2A>至`false`。 這可能是必要的輸入控制項的事件，例如金鑰處理的特定區域中<xref:System.Windows.UIElement.KeyDown>與<xref:System.Windows.UIElement.TextInput>其中低層級和高層級的輸入的事件會競爭處理，而且每個嘗試使用不同的路由策略。  
  
   
  
## Examples  
 下列範例會實作標記為已處理的事件處理常式。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">要叫用的泛型處理常式/委派實作。</param>
        <param name="genericTarget">應該在其上叫用所提供處理常式的目標。</param>
        <summary>在衍生類別中覆寫時，提供以特定類型方式叫用事件處理常式的方式，這可透過基底實作來提高效率。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底實作結合反映來判斷正確的處理常式的任何狀況，其中此處理常式不是依其字面<xref:System.Windows.RoutedEventHandler>，且此步驟中反映一些帶來效能影響。 引動過程可更有效率地不依賴反映。 這是要選擇要覆寫它任何路由的事件的引數類別可以使用這個方法會刺激的案例。 實作不應呼叫基底，此方法，因為您的實作應該已經很負責叫用型別安全的處理常式。  
  
   
  
## Examples  
 以下是說明可用來實作基本模式的虛擬程式碼。 在這裡，`MyRoutedEventHandler`是子類別的<xref:System.Windows.RoutedEventHandler>。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會覆寫所衍生的事件資料類別來提供更有效率的引動過程的委派。 實作應該轉換提供<paramref name="genericHandler" />特定型別的委派，然後叫用該處理常式。  
  
 預設實作會嘗試叫用提供的處理常式，並嘗試將其轉換成<see cref="T:System.Windows.RoutedEventHandler" />。 如果有任一個<paramref name="genericHandler" />或<paramref name="genericTarget" />依現狀<see langword="null" />，就會引發例外狀況。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="P:System.Windows.RoutedEventArgs.Source" /> 設定成的新值。</param>
        <summary>在衍生類別中覆寫時，每當執行個體的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 屬性值變更，便會提供通知回呼進入點。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>以程式設計方式變更報告事件的來源可能需要更新事件內的特定類型的資料。 基於這個理由，<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />受保護的虛擬方法，並要加以覆寫的子類別<see cref="T:System.Windows.RoutedEventArgs" />。  
  
 這個方法會具有預設的實作。</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在父類別進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前，取得純點擊測試所判定的原始報告來源。</summary>
        <value>在類別處理進行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 調整之前的原始報告來源，類別處理會簡化複合項目樹狀結構的維度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦之前的類別執行個體中的任何處理常式或事件處理常式叫用，且永遠不會進行調整略過此點，這個屬性會取得其值。 原始的來源資訊是唯讀的類別處理常式或類別實作中，就如同中的事件資料會報告錯誤。  
  
 來源可加以調整的常見案例包括控制項的內容模型的內容項目 (清單項目，比方說，內容會報告清單項目項目，做為<xref:System.Windows.RoutedEventArgs.Source%2A>會清單項目中的實際項目。<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 由各種項目和內容模型的來源調整不同類別。 調整事件來源的每個類別會嘗試預測的來源是最有用報告最輸入的案例和案例的主要類別，然後集的來源為<xref:System.Windows.RoutedEventArgs.Source%2A>。 如果此來源不是具有相關性的事件處理，請嘗試檢查<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>改為以查看它如果報表是更適合的不同來源。 如需有關輸入事件的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 執行個體關聯的 <see cref="T:System.Windows.RoutedEventArgs" />。</summary>
        <value>已叫用之事件的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法設定此值<xref:System.Windows.RoutedEventArgs>，已傳送 （比方說，如果您取得透過處理常式的引數）。 嘗試這樣做會產生例外狀況。 您可以只設定尚未用來產生事件的引動過程之執行個體上。  
  
 值<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>不可`null`在任何時間。  
  
   
  
## Examples  
 下列範例使用初始的建構函式建立新的路由的事件資料，並設定<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>屬性做為後續的作業。 您必須擁有<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>設定之前引發的路由的事件。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">嘗試在路由事件時變更 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定引發事件之物件的參考。</summary>
        <value>引發事件的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對任何反昇路由已實際旅行的路由，引發的項目之後的事件，在任何通道路由不具有事件尚未向引發它的值之項目的通道<xref:System.Windows.RoutedEventArgs.Source%2A>不同於值<c3/>事件引數類別的參數。 這兩個項目事件中相關就最重要中任何指定的處理常式 (<xref:System.Windows.RoutedEventArgs.Source%2A>，引發它的項目或`sender`，目前正在處理它的項目) 取決於您的處理常式是應用程式邏輯定址。  
  
 設定這個屬性通常只是在覆寫或實作其他[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，調整事件來源，例如當類別處理事件。 不建議重設明顯的事件來源的執行個體的處理常式，特別是當此處理常式不會為已處理標記事件。  
  
 如果您重設<xref:System.Windows.RoutedEventArgs.Source%2A>報告不同的事件來源、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>由起始端引發做為第一個來源的報表會繼續<xref:System.Windows.UIElement.RaiseEvent%2A>呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>