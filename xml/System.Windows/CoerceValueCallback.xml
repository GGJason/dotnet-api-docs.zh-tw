<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CoerceValueCallback.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5edddfb39d197bb5c7d9ebb6e4c366a99eae21935.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edddfb39d197bb5c7d9ebb6e4c366a99eae21935</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The object that the property exists on.</source>
          <target state="translated">屬性所在的物件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>When the callback is invoked, the property system will pass this value.</source>
          <target state="translated">當叫用 (Invoke) 回呼時 (Callback)，屬性系統將傳遞這個值。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The new value of the property, prior to any coercion attempt.</source>
          <target state="translated">在嘗試任何強制型轉之前，屬性的新值。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</source>
          <target state="translated">提供方法的範本，該方法會在相依性屬性值重新評估時或特別要求強制型轉 (Coercion) 時被呼叫。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The coerced value (with appropriate type).</source>
          <target state="translated">強制型轉的值 (具有適當的型別)。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Callbacks based on <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.</source>
          <target state="translated">回呼根據<ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>可以指派給透過數種不同技術的相依性屬性。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Each of these techniques requires that you first create a new property metadata object (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</source>
          <target state="translated">這些技術的每個需要您先建立新的屬性中繼資料物件 (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>，或衍生的類別，例如<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Create the metadata object using a constructor signature that takes the <ph id="ph1">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.</source>
          <target state="translated">建立使用會採用的建構函式簽章的中繼資料物件<ph id="ph1">`coerceValueCallback`</ph>參數，並將該參數指派給您的回呼處理常式。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Or construct the metadata by any signature and set the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.</source>
          <target state="translated">建構的任何簽章和集合的中繼資料或<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>屬性，再將中繼資料放在使用中。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>When you have this metadata, you can:</source>
          <target state="translated">當您有這個中繼資料時，您可以：</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Define a new dependency property on a new class, using either signature of  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id="ph2">`typeMetadata`</ph> value.</source>
          <target state="translated">在新的類別，並使用其中一個簽章上定義新的相依性屬性<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>，讓中繼資料當做<ph id="ph2">`typeMetadata`</ph>值。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Override the metadata (call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.</source>
          <target state="translated">覆寫中繼資料 (呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) 針對現有的相依性屬性，當您從擁有相依性屬性的類別衍生。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Add an existing dependency property to a new <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">將現有的相依性屬性加入至新<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>類別，使用新的中繼資料，藉由呼叫<ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Implementations of this callback should check the value in <ph id="ph1">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.</source>
          <target state="translated">此回呼的實作應該檢查值<ph id="ph1">`baseValue`</ph>並判斷這是否需要進一步強制轉型的值為基礎的值或型別。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id="ph4">`dp`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>相依性屬性會叫用屬性系統或其他呼叫端呼叫任何時間<ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>上<ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph>執行個體，並指定該屬性的識別碼，則為<ph id="ph4">`dp`</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Changes to the property value may have come from any possible participant in the property system.</source>
          <target state="translated">屬性值的變更可能會有來自屬性系統中任何可能的參與者。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</source>
          <target state="translated">這包括樣式、 泛型失效，觸發程序、 屬性值繼承，以及本機值設定。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Generally you should avoid specifying more than one <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</source>
          <target state="translated">您通常應該避免指定一個以上的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>針對任何指定的相依性屬性 (覆寫或新增具有新的中繼資料已經有相依性屬性的<ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.</source>
          <target state="translated">只有其中一個回呼會起作用。做回呼將會套用到繼承相較之下中最常衍生的類別的一個<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>呼叫端。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</source>
          <target state="translated">中繼資料遭到覆寫時，會取代其他回呼仍所指派的相依性屬性的中繼資料的擁有者階層更高版本存在。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</source>
          <target state="translated">下列範例包含實作此回呼，強制轉型儲存其他輸入，例如另一個屬性的值為基礎的相依性屬性的值。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>In this case, the callback checks to see whether the <ph id="ph1">`ShirtType`</ph> property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the <ph id="ph2">`ButtonColor`</ph>, if the shirt type has no buttons, it coerces the <ph id="ph3">`ButtonColor`</ph> value back to a starting value, which causes the <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (not shown) to remove that dropdown from the effective choices.</source>
          <target state="translated">在此情況下，回呼會檢查以查看是否<ph id="ph1">`ShirtType`</ph>屬性會對應至一種按鈕的上衣; 如果是的話，它會建立為預設的開始色彩<ph id="ph2">`ButtonColor`</ph>，如果 shirt 類型不具有任何按鈕時，會強制<ph id="ph3">`ButtonColor`</ph>值回到起始值，因而導致<ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>（未顯示） 的下拉式清單中移除的有效選項。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>