<Type Name="LogicalTreeHelper" FullName="System.Windows.LogicalTreeHelper">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f2fd27ad4c537a177069b372af2f1a949e102361" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30678222" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class LogicalTreeHelper" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LogicalTreeHelper extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.LogicalTreeHelper" />
  <TypeSignature Language="VB.NET" Value="Public Class LogicalTreeHelper" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogicalTreeHelper abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="90693-101">提供靜態 Helper 方法來查詢邏輯樹狀中的物件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="90693-101">Provides static helper methods for querying objects in the logical tree.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="90693-102"><xref:System.Windows.LogicalTreeHelper>類別提供方法，您可以使用傳回子物件的集合，或特定物件之邏輯樹狀結構的子節點內。</span><span class="sxs-lookup"><span data-stu-id="90693-102">The <xref:System.Windows.LogicalTreeHelper> class provides methods that you can use to return child collections of objects, or specific objects from within subnodes of the logical tree.</span></span> <span data-ttu-id="90693-103">不過，大部分的通常要執行的物件樹狀目錄作業也會公開類似的方法或屬性上<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="90693-103">However, most of the object tree operations that you typically perform are also exposed by similar methods or properties on <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="90693-104">例如，請嘗試下列各項：</span><span class="sxs-lookup"><span data-stu-id="90693-104">For example, try the following:</span></span>  
  
-   <span data-ttu-id="90693-105">而不是呼叫靜態<xref:System.Windows.LogicalTreeHelper.GetChildren%2A>方法，傳回的列舉值的邏輯子物件，使用專用的集合，該物件的內容模型中公開。</span><span class="sxs-lookup"><span data-stu-id="90693-105">Instead of calling the static <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method, which returns an enumerator for the logical child objects, use the dedicated collection exposed in the content model for that object.</span></span> <span data-ttu-id="90693-106">支援內容模型的幾乎所有物件會都公開一些屬性，其中包含子物件的集合，並在該集合會提供直接集合介面的支援。</span><span class="sxs-lookup"><span data-stu-id="90693-106">Nearly all objects that support a content model expose some property that contains the collection of child objects, and provides collection interface support directly on that collection.</span></span>  
  
-   <span data-ttu-id="90693-107">而不是呼叫靜態<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>方法，以取得所指定名稱： 呼叫的子物件<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>或<xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType>特定物件上的方法。</span><span class="sxs-lookup"><span data-stu-id="90693-107">Instead of calling the static <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> method to obtain a child object by specifying its name, call the <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> method on specific objects.</span></span>  
  
 <span data-ttu-id="90693-108"><xref:System.Windows.LogicalTreeHelper> 是最適合用於分析情況下您向上或向下到多個層級，則邏輯樹狀結構以遞迴方式在出差，想要用於檢查不同的父或子物件一致的方法。</span><span class="sxs-lookup"><span data-stu-id="90693-108"><xref:System.Windows.LogicalTreeHelper> is most useful for analysis scenarios where you are traveling up or down the logical tree recursively through multiple levels, and want to use a consistent approach for examining the various parent or child objects.</span></span> <span data-ttu-id="90693-109">在此情況下，您可能會存取的內容模型，混合，因此使用更多的內容模型特定的應用程式開發介面會太複雜。</span><span class="sxs-lookup"><span data-stu-id="90693-109">In this case, you might be accessing a mixture of content models, and using the more content-model specific APIs would be too complex.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public static void BringIntoView (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BringIntoView(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BringIntoView (current As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BringIntoView(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">
          <span data-ttu-id="90693-110">要帶入檢視的 UI 項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-110">The UI element to bring into view.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-111">嘗試將所要求的 UI 項目帶入檢視，同時對目標引發 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 事件以報告結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-111">Attempts to bring the requested UI element into view and raises the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> event on the target in order to report the results.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="90693-112">呼叫執行個體方法通常較為方便<xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType>或<xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType>而不是此靜態公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="90693-112">It is typically more convenient to call the instance methods <xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType> rather than this static utility method.</span></span> <span data-ttu-id="90693-113">執行個體方法的行為就相當於靜態方法的行為。</span><span class="sxs-lookup"><span data-stu-id="90693-113">The behavior of the instance methods is equivalent to the behavior of the static method.</span></span>  
  
 <span data-ttu-id="90693-114">即使`current`UI 項目提供<xref:System.Windows.FrameworkContentElement>，產生的事件方法仍然相同<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>事件，以起始端<xref:System.Windows.FrameworkContentElement>可識別藉由檢查事件的事件資料。</span><span class="sxs-lookup"><span data-stu-id="90693-114">Even if the `current` UI element provided was a <xref:System.Windows.FrameworkContentElement>, the resulting event is still the same <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> event, with the originating <xref:System.Windows.FrameworkContentElement> identifiable by checking the event data of the event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      </Docs>
    </Member>
    <Member MemberName="FindLogicalNode">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject FindLogicalNode (System.Windows.DependencyObject logicalTreeNode, string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject FindLogicalNode(class System.Windows.DependencyObject logicalTreeNode, string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLogicalNode (logicalTreeNode As DependencyObject, elementName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ FindLogicalNode(System::Windows::DependencyObject ^ logicalTreeNode, System::String ^ elementName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalTreeNode" Type="System.Windows.DependencyObject" />
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logicalTreeNode">
          <span data-ttu-id="90693-115">做為搜尋起點的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-115">The object to start searching from.</span>
          </span>
          <span data-ttu-id="90693-116">這個物件必須是 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-116">This object must be either a <see cref="T:System.Windows.FrameworkElement" /> or a <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </param>
        <param name="elementName">
          <span data-ttu-id="90693-117">要尋找之物件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-117">The name of the object to find.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-118">嘗試尋找並傳回具有指定之名稱的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-118">Attempts to find and return an object that has the specified name.</span>
          </span>
          <span data-ttu-id="90693-119">搜尋將從指定的物件開始，並持續至邏輯樹狀結構的子節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-119">The search starts from the specified object and continues into subnodes of the logical tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="90693-120">具有相符名稱的物件 (如果找到的話)。如果在邏輯樹狀結構中找不到相符名稱，則傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-120">The object with the matching name, if one is found; returns <see langword="null" /> if no matching name was found in the logical tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="90693-121">方法<xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType>和<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>表面上類似於<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>，但運作方式為不同的邏輯：</span><span class="sxs-lookup"><span data-stu-id="90693-121">The methods <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> and <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> are superficially similar to <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>, but operate by different logic:</span></span>  
  
-   <span data-ttu-id="90693-122">搜尋方向<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>朝向 （向下樹狀目錄）; 的子物件的搜尋方向`FindName`方法會向父物件 （向上樹狀目錄）。</span><span class="sxs-lookup"><span data-stu-id="90693-122">The search direction for <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> is toward child objects (down the tree); the search direction for the `FindName` methods is towards parent objects (up the tree).</span></span>  
  
-   <span data-ttu-id="90693-123">`FindName`方法由 XAML 名稱範圍的概念。</span><span class="sxs-lookup"><span data-stu-id="90693-123">The `FindName` methods are governed by the concept of a XAML namescope.</span></span> <span data-ttu-id="90693-124">使用`FindName`保證都只有一個該名稱的物件存在，因為 XAML namescopes 強制執行唯一性。</span><span class="sxs-lookup"><span data-stu-id="90693-124">Using `FindName` you are guaranteed that only one object of that name exists, because XAML namescopes enforce uniqueness.</span></span> <span data-ttu-id="90693-125">相反地，<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>在搜尋期間，會忽略 XAML 名稱範圍和可能會跨 XAML 名稱範圍界限。</span><span class="sxs-lookup"><span data-stu-id="90693-125">In contrast, <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> ignores XAML namescope and might cross XAML namescope boundaries during the search.</span></span> <span data-ttu-id="90693-126">因此，建議您不能保證唯一性的`elementName`名稱一旦越過界限。</span><span class="sxs-lookup"><span data-stu-id="90693-126">As such, there is no guarantee of uniqueness of the `elementName` name once boundaries are crossed.</span></span> <span data-ttu-id="90693-127">如需 XAML 名稱範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。</span><span class="sxs-lookup"><span data-stu-id="90693-127">For more information about XAML namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildren">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="90693-128">藉由處理邏輯樹狀結構，傳回指定之物件的直接子物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-128">Returns the collection of immediate child objects of the specified object by processing the logical tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As DependencyObject) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">
          <span data-ttu-id="90693-129">要從中開始處理邏輯樹狀的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-129">The object from which to start processing the logical tree.</span>
          </span>
          <span data-ttu-id="90693-130">這必須是 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-130">This is expected to be either a <see cref="T:System.Windows.FrameworkElement" /> or <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-131">透過處理邏輯樹狀，傳回所指定物件的立即子物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-131">Returns the collection of immediate child objects of the specified object, by processing the logical tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="90693-132">所指定物件之邏輯樹狀結構中的可列舉立即子物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-132">The enumerable collection of immediate child objects from the logical tree of the specified object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="90693-133">使用此簽章與協助程式方法主要是當您不確定是否`current`是<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>和也是不確定該物件的類別是否支援它自己的內容模型的集合。</span><span class="sxs-lookup"><span data-stu-id="90693-133">Use this signature and helper method primarily when you are unsure whether `current` is a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> and are also unsure whether that object's class supports its own content model collection.</span></span> <span data-ttu-id="90693-134">如果您可以判斷您要查詢之物件的類型，請檢查您知道的特定內容屬性存在於該型別。</span><span class="sxs-lookup"><span data-stu-id="90693-134">If you can determine the type of the object you are querying, check the specific content property that you know exists on that type.</span></span> <span data-ttu-id="90693-135">例如，如果您知道物件查詢的是<xref:System.Windows.Controls.ItemsControl>，檢查<xref:System.Windows.Controls.ItemsControl.Items%2A>屬性來取得強類型的集合，其中具有集合介面的支援，而且可能比更清楚的列舉值。</span><span class="sxs-lookup"><span data-stu-id="90693-135">For example, if you know that the object you are querying is an <xref:System.Windows.Controls.ItemsControl>, check the <xref:System.Windows.Controls.ItemsControl.Items%2A> property to get a strongly typed collection, which has collection interface support and is probably more useful than an enumerator.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkContentElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkContentElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkContentElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkContentElement ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="current">
          <span data-ttu-id="90693-136">要從中開始處理邏輯樹狀的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-136">The object from which to start processing the logical tree.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-137">藉由處理邏輯樹狀結構，傳回指定之 <see cref="T:System.Windows.FrameworkContentElement" /> 的直接子物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-137">Returns the collection of immediate child objects of the specified <see cref="T:System.Windows.FrameworkContentElement" /> by processing the logical tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="90693-138">邏輯樹狀結構中，從 <paramref name="current" /> 開始的直接子物件之可列舉的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-138">The enumerable collection of immediate child objects starting from <paramref name="current" /> in the logical tree.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkElement ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="current">
          <span data-ttu-id="90693-139">要從中開始處理邏輯樹狀的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-139">The object from which to start processing the logical tree.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-140">藉由處理邏輯樹狀結構，傳回指定之 <see cref="T:System.Windows.FrameworkElement" /> 的直接子物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-140">Returns the collection of immediate child objects of the specified <see cref="T:System.Windows.FrameworkElement" /> by processing the logical tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="90693-141">邏輯樹狀結構中，從 <paramref name="current" /> 開始的直接子物件之可列舉的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-141">The enumerable collection of immediate child objects starting from <paramref name="current" /> in the logical tree.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetParent (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetParent(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (current As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetParent(System::Windows::DependencyObject ^ current);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current">
          <span data-ttu-id="90693-142">要尋找父物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-142">The object to find the parent object for.</span>
          </span>
          <span data-ttu-id="90693-143">這個物件應該是 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-143">This is expected to be either a <see cref="T:System.Windows.FrameworkElement" /> or a <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="90693-144">藉由處理邏輯樹狀結構，傳回指定之物件的父物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-144">Returns the parent object of the specified object by processing the logical tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="90693-145">要求的父物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="90693-145">The requested parent object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="90693-146">這個方法是只包裝函式可取得適當的型別版本 (<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>) 的<xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType>或<xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType>屬性，則為，除非您無法判斷`current`您可能想要檢查個別的型別，改為執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="90693-146">This method is merely a wrapper that gets the appropriate type version (<xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>) of the <xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType> property; so unless you are unable to determine the `current` type, you might want to check the respective instance properties instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>