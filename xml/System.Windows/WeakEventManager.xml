<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7c50f8e21321e058314ffb0c59534252db4eb2aa" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52232392" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>為「弱式事件模式」中所使用的事件管理員提供基底類別。 管理員會針對也使用該模式的事件 (或回呼) 加入或移除接聽程式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件來源的物件存留期無關的事件接聽程式時，通常會使用弱式事件模式。 使用中央事件分派功能<xref:System.Windows.WeakEventManager>讓接聽程式的處理常式，即使來源物件保存回收。 相較之下，使用您建立一般事件連結`+=`運算子會使可能中斷連接的來源，以保存到接聽程式的參考。 這可防止接收者進行記憶體回收 neodpověděl včas.。  
  
 一個常見的情形，存留期之間的關聯性來源與接聽程式應該使用的弱式事件模式是來自資料繫結的更新事件的處理。  
  
 弱式事件模式也會用於回呼事件及一般事件中。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>如需自訂的範例<see cref="T:System.Windows.WeakEventManager" />，請參閱 &lt;&lt;c2&gt; [ 弱式事件模式](~/docs/framework/wpf/advanced/weak-event-patterns.md)。</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>由衍生類別的建構函式當做初始設定式使用時，初始化基底類別值。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">正在其上處理事件的物件。</param>
        <param name="args">
          <see cref="T:System.EventArgs" />，包含要傳遞之事件的事件資料。</param>
        <summary>將受管理的事件傳遞給每一個接聽程式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Windows.WeakEventManager.DeliverEvent%2A>方法內新增或移除的事件處理常式<xref:System.Windows.WeakEventManager.StartListening%2A>和<xref:System.Windows.WeakEventManager.StopListening%2A>子類別的實作。  
  
 如果您呼叫<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>方法中的您`AddListener`您類別的實作，接收事件的接聽程式清單會保留在基礎的集合。 (`AddListener`不是介面或類別的合約的一部分。 `AddListener` 是您呼叫的 manager 類別方法的建議的名稱<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>，並將事件的弱式事件模式接聽程式。)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> 將一份清單中的接聽程式。 如果您的管理員實作會維護多個清單中的每個事件的接聽程式，請勿使用<xref:System.Windows.WeakEventManager.DeliverEvent%2A>或<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>。 相反地，您的實作應該建立自己<xref:System.Windows.WeakEventManager.ListenerList>執行個體`AddListener`應該將接聽程式新增至適當的清單中，並且事件應該傳遞至適當的接聽程式清單，藉由呼叫<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">正在其上處理事件的物件。</param>
        <param name="args">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <param name="list">提供的 <see cref="T:System.Windows.WeakEventManager.ListenerList" />。</param>
        <summary>將受管理的事件傳遞給所提供清單中的每一個接聽程式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法時需要您的管理員實作可讓您維護個別的接聽程式會根據事件資料中擷取的資訊。 如果您使用這個進階的技巧，您必須建立並維護不同的清單，做為您的管理員實作的一部分，您必須提供方法，以將特定的清單中的接聽程式。 會接聽原始事件的處理常式實作必須處理條件，您使用，以便區別這些清單中，並將事件傳遞僅對適當的清單或清單。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">要取得其 <see cref="T:System.Windows.WeakEventManager" /> 的型別。</param>
        <summary>傳回用於所提供型別的 <see cref="T:System.Windows.WeakEventManager" /> 實作。</summary>
        <returns>相符的 <see cref="T:System.Windows.WeakEventManager" /> 實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> 實作會呼叫這個方法，使用其通過`managerType`。 傳回<xref:System.Windows.WeakEventManager>接著會做為判斷收到的事件，並叫用哪一個私用類別處理常式的區別指標。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">所要求來源之以零為起始的索引。</param>
        <summary>取得或設定要為指定的來源儲存的資料。</summary>
        <value>管理員為此來源儲存的資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生的類別可以選擇哪些資料和將儲存在這個索引子的型別。 通常這會實作為<xref:System.Windows.WeakEventManager.ListenerList>，這是弱式參考到接聽程式的清單。 您只需要變更此類型，如果<xref:System.Windows.WeakEventManager.ListenerList>類型不能包含您所需的資訊。 因此，您必須覆寫如果<xref:System.Windows.WeakEventManager.Purge%2A>方法，讓所有的清除作業的基礎類型會正確執行。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回新的物件，包含事件的接聽程式。</summary>
        <returns>包含事件之接聽程式的新物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">處理常式委派所訂閱的來源物件。</param>
        <param name="handler">處理 <paramref name="source" /> 引發事件的委派。</param>
        <summary>加入指定的委派做為指定之來源的事件處理常式。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">要附加接聽程式的目標來源。</param>
        <param name="listener">接聽的類別 (必須實作 <see cref="T:System.Windows.IWeakEventListener" />)。</param>
        <summary>將提供的接聽程式加入至所提供的受管理事件來源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您的 manager 類別中呼叫這個方法`AddListener`上的方法<xref:System.Windows.WeakEventManager>實作。 `AddListener` 這是建議的名稱定義管理員類別，讓其他類別加入您的弱式事件模式的接聽程式上的靜態方法。 `AddListener` 應該採用兩個參數：`source`其中附加接聽程式，而`listener`執行個體。 為您`AddListener`實作中，呼叫<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>有關目前管理員傳遞相同的兩個參數的方法。  
  
 如果接聽程式清單是先前空白<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>呼叫<xref:System.Windows.WeakEventManager.StartListening%2A>方法就內部而言，這會呼叫您的特定<xref:System.Windows.WeakEventManager.StartListening%2A>覆寫透過多型。  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> 將接聽程式加入至單一內部<xref:System.Windows.WeakEventManager.ListenerList>每個`source`。 如果您的管理員實作會維護多個清單中的每個事件來源的組合的接聽程式，請勿使用<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>。 相反地，您的實作應該建立自己<xref:System.Windows.WeakEventManager.ListenerList>執行個體`AddListener`應該將接聽程式新增至適當的清單中，並且事件應該傳遞至適當的接聽程式清單，藉由呼叫<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>事件，而不<xref:System.Windows.WeakEventManager.DeliverEvent%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">要從中移除處理常式的來源。</param>
        <param name="handler">要從 <paramref name="source" /> 移除的委派。</param>
        <summary>從指定的來源移除先前新增的處理常式。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">要從中移除接聽程式的來源。</param>
        <param name="listener">接聽的類別 (必須實作 <see cref="T:System.Windows.IWeakEventListener" />)。</param>
        <summary>從提供的來源移除先前加入的接聽程式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您的 manager 類別中呼叫這個方法`RemoveListener`上的方法<xref:System.Windows.WeakEventManager>實作。 `RemoveListener` 這是建議的名稱您定義您的管理員類別，以啟用其他類別，以移除您的弱式事件模式的接聽程式上的靜態方法。 `RemoveListener` 應該採用兩個參數：`source`其中已移除接聽程式，而`listener`類別。 為您`RemoveListener`實作中，呼叫<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>有關目前管理員傳遞相同的兩個參數的方法。  
  
 如果呼叫<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>在清單中，移除最後一個接聽程式<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>呼叫<xref:System.Windows.WeakEventManager.StopListening%2A>方法就內部而言，這會呼叫您的特定<xref:System.Windows.WeakEventManager.StopListening%2A>覆寫透過多型。  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> 移除接聽程式從單一內部<xref:System.Windows.WeakEventManager.ListenerList>每個`source`。 如果您的管理員實作會維護多個清單中的每個事件來源的組合的接聽程式，請勿使用<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>。 相反地，您的實作應該建立自己<xref:System.Windows.WeakEventManager.ListenerList>執行個體`RemoveListener`應該從適當的清單中，移除接聽程式和事件應該傳遞至適當的接聽程式清單，藉由呼叫<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>方法，而非<xref:System.Windows.WeakEventManager.DeliverEvent%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">正在接聽之事件的來源。</param>
        <param name="data">要檢查的資料。 這個物件必須是 <see cref="T:System.Windows.WeakEventManager.ListenerList" /> 實作。</param>
        <param name="purgeAll">
          <see langword="true" /> 表示停止接聽 <paramref name="source" />，並完全移除 <paramref name="data" /> 中的所有項目。</param>
        <summary>從所提供來源的資料清單中移除非現用接聽程式項目。 如果從清單中實際移除了一些項目，則會傳回 <see langword="true" />。</summary>
        <returns>如果已實際移除某些項目則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.WeakEventManager.Purge%2A>方法有資料時，會移除所有項目預設實作<xref:System.Windows.WeakEventManager.ListenerList>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>基礎類型<see cref="P:System.Windows.WeakEventManager.Item(System.Object)" />而不是<see cref="T:System.Windows.WeakEventManager.ListenerList" />，或包含超過資料<see cref="T:System.Windows.WeakEventManager.ListenerList" />，您必須覆寫<see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />方法。 覆寫應該提供的替代類型的項目 清單中的清除行為。 一般而言，覆寫應該提供的行為，而不需要呼叫基底實作。 如果特定<see cref="T:System.Windows.WeakEventManager.ListenerList" />仍然需要清除，呼叫<see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />。</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在基礎資料表上建立讀取鎖定，並傳回 <see cref="T:System.IDisposable" />。</summary>
        <value>物件，可用來在資料表成員上建立鎖定，然後以 <see langword="using" /> 建構適當處置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別中，查詢中所包含的資料表<xref:System.Windows.WeakEventManager.Item%2A>一定要進行內`using (ReadLock) { ... }`子句中，除了已內寫入鎖定的查詢。 這些查詢可能會需要您的類別支援更複雜`AddListener`實作，需要更多的資料超過`source`而`listener`，並使用<xref:System.Windows.WeakEventManager.Item%2A>集合來儲存額外的資訊。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">要移除其接聽程式資訊的來源。</param>
        <summary>移除指定來源的所有接聽程式。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要求在較低優先權執行緒上執行基礎接聽程式清單中未使用項目的清除動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Windows.WeakEventManager.ScheduleCleanup%2A>方法就類似於呼叫<xref:System.Windows.WeakEventManager.Purge%2A>方法在目前的管理員清單中，以較低的執行緒優先權，與`purgeAll`參數設定為`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">要用來設定新事件管理員的型別。</param>
        <param name="manager">新的事件管理員。</param>
        <summary>為指定管理員型別設定目前管理員。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Windows.WeakEventManager.SetCurrentManager%2A>方法來初始化管理員 中，如果所呼叫您`CurrentManager`屬性上的<xref:System.Windows.WeakEventManager>實作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">要開始接聽的來源。</param>
        <summary>在衍生類別中覆寫時，開始接聽受管理的事件。 在最初呼叫 <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> 方法之後，每當處理了所提供來源中的相關事件時，管理員都應處於呼叫 <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> 或 <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> 的狀態。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> 覆寫應該加入處理常式，以提供<paramref name="source" />。 管理員本身所宣告的處理常式。 類別處理常式不應該為公用，並只應該呼叫在受管理的事件回應。 類別處理常式應該呼叫<see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />方法或<see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />方法適當地。</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">要停止接聽的來源。</param>
        <summary>在衍生類別中覆寫時，停止在所提供來源上接聽受管理的事件。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> 實作應該移除的類別處理常式，如新增<see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />方法。 移除接聽程式不應清除的接聽程式清單。 相反地，它應該只中斷 （可能是暫時） 的類別處理常式。 其他方法可供清除整個清單中，這類<see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />方法<paramref name="purgeAll" />參數設為<see langword="true" />。</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在基礎資料表上建立寫入鎖定，並傳回 <see cref="T:System.IDisposable" />。</summary>
        <value>物件，可用來在資料表成員上建立鎖定，然後以 <see langword="using" /> 建構適當處置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別中，基礎資料表的所有修改都應內`using (WriteLock) { ... }`子句。 這些修改都可能有必要，如果您的類別支援更複雜`AddListener`實作，需要更多的資料超過`source`而`listener`，並使用<xref:System.Windows.WeakEventManager.Item%2A>集合來儲存額外的資訊。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>