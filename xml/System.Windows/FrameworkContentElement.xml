<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b6371f460f8b6c0d055ff1e6a06d2b95b363c7c1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39942044" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="5ac11-101">
        <see cref="T:System.Windows.FrameworkContentElement" /> 是 WPF 架構層級實作和 <see cref="T:System.Windows.ContentElement" /> 基底類別的擴充。</span>
      <span class="sxs-lookup">
        <span data-stu-id="5ac11-101">
          <see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span>
      </span>
      <span data-ttu-id="5ac11-102">
        <see cref="T:System.Windows.FrameworkContentElement" /> 新增對其他輸入 API (包括工具提示和操作功能表)、腳本、資料繫結程序的資料內容、樣式，以及邏輯樹狀結構協助程式 API 的支援。</span>
      <span class="sxs-lookup">
        <span data-stu-id="5ac11-102">
          <see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-103"><xref:System.Windows.FrameworkContentElement> 尚未定義自己的轉譯行為。具現化的實際<xref:System.Windows.FrameworkContentElement>可在程式碼或標記的類別執行個體，但會顯示在中為 nothing[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5ac11-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="5ac11-104">必須提供轉譯邏輯的類別，需要<xref:System.Windows.FrameworkContentElement>子項目，其內容的模型，或在<xref:System.Windows.FrameworkContentElement>衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="5ac11-105"><xref:System.Windows.FrameworkContentElement> 刻意平行相同的許多[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]做為<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="5ac11-106">請注意，某些[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>將不會有<xref:System.Windows.FrameworkContentElement>相等。</span><span class="sxs-lookup"><span data-stu-id="5ac11-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="5ac11-107">有幾個<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]有的功能，例如幾何表示法或版面配置，哪些不相關的<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="5ac11-108">大部分的現有<xref:System.Windows.FrameworkContentElement>衍生的類別就會出現在<xref:System.Windows.Documents>命名空間。</span><span class="sxs-lookup"><span data-stu-id="5ac11-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="5ac11-109">許多這些衍生的類別會實作非固定格式文件模型的項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="5ac11-110">特定衍生的類別，例如<xref:System.Windows.Documents.Hyperlink>有一些類似控制項的功能，但衍生自<xref:System.Windows.FrameworkContentElement>，這類控制項類似的項目仍然可以參與非固定格式文件模型。</span><span class="sxs-lookup"><span data-stu-id="5ac11-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-111">初始化 <see cref="T:System.Windows.FrameworkContentElement" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="5ac11-112">要加入的子項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-112">The child element to be added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-113">加入所提供的項目作為這個項目的子項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-113">Adds the provided element as a child of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-114">如果當邏輯樹狀結構會進行逐一查看另一個處理序一次呼叫，則這個方法可以擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5ac11-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="5ac11-115">大部分<xref:System.Windows.FrameworkContentElement>衍生的類別會公開專用的集合負責內含項目 (例如<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="5ac11-116">您通常可以避免任何需要直接操作邏輯樹狀結構，如果您改為衍生自這些類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="5ac11-117">使用內容項目的邏輯樹狀結構是進階的案例，可能需要特殊的剖析器或特製化<xref:System.Windows.FrameworkElement>，做為父轉譯項目 （內容主機）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="5ac11-118">如需有關如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>並<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-119">已在初始化項目之前呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-119">Called before an element is initialized.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="5ac11-120">
            <para>覆寫這個方法，以提供您的項目初始化期間載入程序的項目之前，應該會發生的特殊處理。您的實作應該呼叫基底實作，因為基底 （預設值） 的實作會設定一些內部的旗標，以追蹤的初始化。基底實作會擲回例外狀況，如果<see cref="M:System.Windows.FrameworkContentElement.BeginInit" />之前達到相同的項目上呼叫一次以上<see cref="M:System.Windows.FrameworkContentElement.EndInit" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-120">
              <para>Override this method to provide special handling that should occur before your element is initialized during the element loading process.  Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.  The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-121">開始提供之腳本中包含的動作順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-121">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5ac11-122">要開始的腳本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-122">The storyboard to begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-123">開始提供之腳本中包含的動作順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-123">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-124">請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當它到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-124">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5ac11-125">因此動畫無法重新啟動之後執行一次。</span><span class="sxs-lookup"><span data-stu-id="5ac11-125">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5ac11-126">請注意，控制動畫也需要使用分鏡腳本具名或存取程式碼內的執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ac11-126">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5ac11-127">要開始的腳本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-127">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="5ac11-128">列舉型別的值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-128">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-129">使用若屬性已經顯示動畫時應發生之情形的指定選項，開始提供之腳本中包含的動作順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-129">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-130">請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當它到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-130">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5ac11-131">因此動畫無法重新啟動之後執行一次。</span><span class="sxs-lookup"><span data-stu-id="5ac11-131">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5ac11-132">請注意，控制動畫也需要使用分鏡腳本具名或存取程式碼內的執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ac11-132">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="5ac11-133">使用 Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="5ac11-133">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="5ac11-134">當您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性，以使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>先前該屬性相關聯的物件會繼續耗用系統資源，計時系統會執行不會自動移除時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-134">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="5ac11-135">若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成之後，您應該從動畫屬性移除組成的時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-135">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="5ac11-136">有數種方式可移除時鐘：</span><span class="sxs-lookup"><span data-stu-id="5ac11-136">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="5ac11-137">若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-137">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="5ac11-138">指定的第一個參數，要繪製之屬性和`null`作為第二個。</span><span class="sxs-lookup"><span data-stu-id="5ac11-138">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="5ac11-139">這會從屬性移除所有動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-139">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="5ac11-140">若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>從時鐘清單，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-140">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="5ac11-141">這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-141">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="5ac11-142">請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>的子系時鐘的屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-142">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="5ac11-143">也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-143">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="5ac11-144">在此情況下，使用者必須決定何時要呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-144">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="5ac11-145">這主要是在存留期較長的物件才會發生的動畫問題。</span><span class="sxs-lookup"><span data-stu-id="5ac11-145">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="5ac11-146">回收物件時，其時鐘也會中斷連接，並進行記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="5ac11-146">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="5ac11-147">如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-147">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5ac11-148">要開始的腳本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-148">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="5ac11-149">列舉值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-149">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span>
          </span>
        </param>
        <param name="isControllable">
          <span data-ttu-id="5ac11-150">宣告在動畫啟動後，是否可以控制 (暫停) 該動畫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-150">Declares whether the animation is controllable (can be paused) after it is started.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-151">使用控制啟動後之動畫的指定狀態，開始提供之腳本中包含的動作順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-151">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-152">請勿使用簽章`isControllable`，參數，或指定該參數時`false`，當它到達"Fill"期間，會移除相關聯的動畫的時刻表時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-152">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5ac11-153">因此動畫無法重新啟動之後執行一次。</span><span class="sxs-lookup"><span data-stu-id="5ac11-153">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5ac11-154">請注意，控制動畫也需要使用分鏡腳本具名或存取程式碼內的執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ac11-154">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="5ac11-155">使用 Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="5ac11-155">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="5ac11-156">當您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性，以使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>先前該屬性相關聯的物件會繼續耗用系統資源，計時系統會執行不會自動移除這些時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-156">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="5ac11-157">若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成之後，您應該從動畫屬性移除組成的時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-157">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="5ac11-158">有數種方式可移除時鐘：</span><span class="sxs-lookup"><span data-stu-id="5ac11-158">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="5ac11-159">若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-159">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="5ac11-160">指定的第一個參數，要繪製之屬性和`null`作為第二個。</span><span class="sxs-lookup"><span data-stu-id="5ac11-160">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="5ac11-161">這會從屬性移除所有動畫時鐘。</span><span class="sxs-lookup"><span data-stu-id="5ac11-161">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="5ac11-162">若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>從時鐘清單，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-162">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="5ac11-163">這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-163">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="5ac11-164">請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>的子系時鐘的屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-164">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="5ac11-165">也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-165">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="5ac11-166">在此情況下，使用者必須決定何時要呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-166">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="5ac11-167">這主要是在存留期較長的物件才會發生的動畫問題。</span><span class="sxs-lookup"><span data-stu-id="5ac11-167">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="5ac11-168">回收物件時，其時鐘也會中斷連接，並進行記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="5ac11-168">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="5ac11-169">如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-169">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-170">取得或設定用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-170">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-171">用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-171">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-172">A<xref:System.Windows.Data.BindingGroup>可用於驗證之物件的多個屬性的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-172">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="5ac11-173">例如，假設應用程式會提示使用者輸入的地址，並接著會填入型別的物件`Address`，其中具有屬性`Street`， `City`， `ZipCode`，和`Country`，值的使用者提供。</span><span class="sxs-lookup"><span data-stu-id="5ac11-173">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="5ac11-174">應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-174">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="5ac11-175">您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-175">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="5ac11-176">比方說，<xref:System.Windows.Controls.ValidationRule>可以確保郵遞區號是有效的地址的國家/地區。</span><span class="sxs-lookup"><span data-stu-id="5ac11-176">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="5ac11-177">項目子系繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-177">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-178">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-178">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-179">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-179">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="5ac11-180">中繼資料屬性設定為 **，則為 true**</span><span class="sxs-lookup"><span data-stu-id="5ac11-180">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-181">識別 <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-181">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-182">在內含此項目的任何可捲動區域內，嘗試將此項目帶入檢視。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-182">Attempts to bring this element into view, within any scrollable regions it is contained within.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-183">藉由呼叫這個方法，您實際上會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>在任何父代可捲動區域，其中包含項目 (父系讀者可能<xref:System.Windows.FrameworkElement>，而非<xref:System.Windows.FrameworkContentElement>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-183">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="5ac11-184">如果這個項目不包含在可捲動區域，仍然會引發事件，但會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="5ac11-184">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-185">取得或設定內容功能表項目，該項目應該在每當從這個項目內透過[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要求內容功能表時出現。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-185">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-186">這個項目使用的內容功能表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-186">The context menu that this element uses.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-187">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-187">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-188">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-188">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="5ac11-189">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-189">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-190">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-190">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-191">下列範例上的芳鄰<xref:System.Windows.Controls.ContextMenu>上<xref:System.Windows.Documents.Paragraph>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-191">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-192">在項目上的任何內容功能表正要關閉之前發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-192">Occurs just before any context menu on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-193">若要隱藏關閉快顯功能表，事件處理常式應將其標記為已處理。</span><span class="sxs-lookup"><span data-stu-id="5ac11-193">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="5ac11-194">若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考基礎服務的事件識別項：</span><span class="sxs-lookup"><span data-stu-id="5ac11-194">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="5ac11-195">(這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎服務事件不會正確對應<xref:System.Windows.FrameworkContentElement.ContextMenuClosing>觸發程序中使用的識別項)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-195">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-196">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-196">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-197">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-197">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="5ac11-198">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-198">Routing strategy</span></span>|<span data-ttu-id="5ac11-199">事件反昇</span><span class="sxs-lookup"><span data-stu-id="5ac11-199">Bubbling</span></span>|  
|<span data-ttu-id="5ac11-200">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-200">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-201">下列範例會實作的具名區域內變更資料指標的處理常式`DisplayArea`（未顯示）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-201">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="5ac11-202">註解看出<xref:System.Windows.UIElement>使用量，事實上，此範例就會相同，但如果`DisplayArea`已<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-202">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-203">識別 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-203">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-204">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-204">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-205">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-205">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-206">當項目上的任何內容功能表開啟時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-206">Occurs when any context menu on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-207">若要手動開啟操作功能表，為已處理的事件處理常式時，應該標示相關的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-207">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="5ac11-208">否則，現有的值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性會用來自動開啟操作功能表。</span><span class="sxs-lookup"><span data-stu-id="5ac11-208">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="5ac11-209">標記處理的事件會有效地取消的預設動作，並可能是重設的值有機會<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-209">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="5ac11-210">不過，還有您應該要注意的時間問題。</span><span class="sxs-lookup"><span data-stu-id="5ac11-210">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="5ac11-211">為了完全取代透過操作功能表<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>處理常式中，初始的操作功能表不能為 null 或空白。</span><span class="sxs-lookup"><span data-stu-id="5ac11-211">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="5ac11-212">或者，您可能需要處理的事件，然後以手動方式開啟新的操作功能表。</span><span class="sxs-lookup"><span data-stu-id="5ac11-212">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="5ac11-213">如需詳細資訊，請參閱 <<c0> [ 如何： 處理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-213">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="5ac11-214">若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考基礎服務的事件識別項：</span><span class="sxs-lookup"><span data-stu-id="5ac11-214">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="5ac11-215">(這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎服務事件不會正確對應<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>觸發程序中使用的識別項)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-215">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-216">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-216">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-217">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-217">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="5ac11-218">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-218">Routing strategy</span></span>|<span data-ttu-id="5ac11-219">事件反昇</span><span class="sxs-lookup"><span data-stu-id="5ac11-219">Bubbling</span></span>|  
|<span data-ttu-id="5ac11-220">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-220">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-221">識別 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-221">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-222">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-222">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-223">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-223">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-224">識別 <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-224">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-225">取得或設定滑鼠指標在此元素上方時所顯示的游標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-225">Gets or sets the cursor that displays when the mouse pointer is over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-226">要顯示的游標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-226">The cursor to display.</span>
          </span>
          <span data-ttu-id="5ac11-227">預設值依這個相依性屬性定義為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-227">The default value is defined as <see langword="null" /> per this dependency property.</span>
          </span>
          <span data-ttu-id="5ac11-228">不過，執行階段的實際預設值會受各種因素影響。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-228">However, the practical default at run time will come from a variety of factors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-229">設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，則[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。</span><span class="sxs-lookup"><span data-stu-id="5ac11-229">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="5ac11-230">提供的字串應該評估為<xref:System.Windows.Input.CursorType>值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-230">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="5ac11-231">如需詳細資訊，請參閱<xref:System.Windows.Input.Cursor>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-231">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="5ac11-232">這個屬性所建立的資料指標是否將，或當滑鼠指標位於此項目上方時，不會顯示主要取決於值<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-232">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="5ac11-233">此外，事件相關的考量，例如使用中的拖放、 滑鼠捕捉、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性中的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-233">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="5ac11-234">若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。</span><span class="sxs-lookup"><span data-stu-id="5ac11-234">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="5ac11-235">`null`預設實際上會判斷實際的資料指標的值此處延後和應從別處取得。</span><span class="sxs-lookup"><span data-stu-id="5ac11-235">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="5ac11-236">如果不有任何以程式設計方式的值，從任何來源，預設資料指標，透過[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]應用程式是在箭號。</span><span class="sxs-lookup"><span data-stu-id="5ac11-236">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="5ac11-237">每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.ContentElement.QueryCursor>事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-237">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="5ac11-238">事件反昇和路由中的任何項目有機會處理事件，並設定透過此事件的引數的資料指標的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-238">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="5ac11-239">如果發生這種情況，事件處理，而且引數中已變更的值優先順序高於值<xref:System.Windows.FrameworkContentElement.Cursor%2A>屬性，在任何層級，除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>設定。</span><span class="sxs-lookup"><span data-stu-id="5ac11-239">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="5ac11-240">如果未建立自訂游標，通常您設定此屬性的靜態屬性值<xref:System.Windows.Input.Cursors>類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-240">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="5ac11-241">設定<xref:System.Windows.Input.Cursor>在部分信任中不會啟用為某個自訂值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-241">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="5ac11-242">如需有關自訂的資料指標的詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-242">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-243">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-243">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-244">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-244">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="5ac11-245">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-245">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-246">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-246">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-247">下列範例會設定為某個自訂值的游標。</span><span class="sxs-lookup"><span data-stu-id="5ac11-247">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-248">識別 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-248">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-249">取得或設定項目在參與資料繫結時的資料內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-249">Gets or sets the data context for an element when it participates in data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-250">用做為資料內容的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-250">The object to use as data context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-251">*資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，例如路徑繫結的繫結來源的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="5ac11-251">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="5ac11-252">資料內容可以直接設定[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，並將該物件的屬性評估的繫結。</span><span class="sxs-lookup"><span data-stu-id="5ac11-252">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="5ac11-253">或者，您可以設定資料內容<xref:System.Windows.Data.DataSourceProvider>物件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-253">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="5ac11-254">這個相依性屬性繼承的屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-254">This dependency property inherits property values.</span></span> <span data-ttu-id="5ac11-255">如果有任何其他值的子項目<xref:System.Windows.FrameworkContentElement.DataContext%2A>建立透過本機值或樣式，屬性系統會將值設為可<xref:System.Windows.FrameworkContentElement.DataContext%2A>指派此值最接近的父項目的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-255">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="5ac11-256">或者，您可以使用下列屬性之一<xref:System.Windows.Data.Binding>類別來明確指定繫結來源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-256">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="5ac11-257">如需詳細資訊，請參閱 <<c0> [ 如何： 指定繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-257">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="5ac11-258">在  [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkContentElement.DataContext%2A>做為最常設定為<xref:System.Windows.Data.Binding>宣告。</span><span class="sxs-lookup"><span data-stu-id="5ac11-258">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="5ac11-259">您可以使用屬性元素語法或屬性語法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-259">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="5ac11-260">屬性語法會顯示在此頁面上的範例。</span><span class="sxs-lookup"><span data-stu-id="5ac11-260">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="5ac11-261">您也可以設定<xref:System.Windows.FrameworkContentElement.DataContext%2A>在程式碼中。</span><span class="sxs-lookup"><span data-stu-id="5ac11-261">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5ac11-262">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="5ac11-262">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-263">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-263">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-264">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-264">XAML Values</span></span>  
 <span data-ttu-id="5ac11-265">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="5ac11-265">*dataContextObject*</span></span>  
 <span data-ttu-id="5ac11-266">直接內嵌的物件，用做為父項目中的任何繫結的資料內容。</span><span class="sxs-lookup"><span data-stu-id="5ac11-266">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="5ac11-267">一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>子類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-267">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="5ac11-268">或者，任何未經處理資料[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]物件適用於繫結放在這裡，以實際的繫結稍後定義的類型。</span><span class="sxs-lookup"><span data-stu-id="5ac11-268">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="5ac11-269">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="5ac11-269">*bindingUsage*</span></span>  
 <span data-ttu-id="5ac11-270">評估為不適當的資料內容繫結使用方式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-270">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="5ac11-271">如需詳細資訊，請參閱[Binding 標記延伸模組](~/docs/framework/wpf/advanced/binding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-271">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="5ac11-272">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5ac11-272">*resourceExtension*</span></span>  
 <span data-ttu-id="5ac11-273">下列其中之一： `StaticResource`，或`DynamicResource`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-273">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="5ac11-274">指的定義為資源中之物件的未經處理資料時，會使用這種使用方式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-274">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="5ac11-275">請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-275">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5ac11-276">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5ac11-276">*contextResourceKey*</span></span>  
 <span data-ttu-id="5ac11-277">從所要求之物件的索引鍵識別碼<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-277">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-278">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-278">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-279">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-279">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="5ac11-280">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-280">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-281">下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，藉由建立新的自訂資料物件，建立該物件做為<xref:System.Windows.FrameworkContentElement.DataContext%2A>，並將繫結路徑設定為在其中的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-281">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-282">當這個項目的資料內容變更時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-282">Occurs when this element's data context changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-283">如需資料內容和資料繫結的說明，請參閱 <<c0> [ 資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-283">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5ac11-284">項目時<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影響的變更，這個項目上的所有資料繫結屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-284">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="5ac11-285">這適用於所有項目都會繼承資料內容，目前的項目的子代項目，也是目前的項目本身。</span><span class="sxs-lookup"><span data-stu-id="5ac11-285">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="5ac11-286">所有這類繫結重新解譯新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映在繫結中的新值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-286">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="5ac11-287">相對於引發這些變更的順序不保證<xref:System.Windows.FrameworkContentElement.DataContextChanged>事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-287">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="5ac11-288">事件之後，或以任何混合時，所做的變更可能的事件之前。</span><span class="sxs-lookup"><span data-stu-id="5ac11-288">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-289">識別 <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-289">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-290">取得或設定索引鍵，以用來在佈景主題中尋找這個控制項的樣式樣板。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-290">Gets or sets the key to use to find the style template for this control in themes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-291">樣式索引鍵。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-291">The style key.</span>
          </span>
          <span data-ttu-id="5ac11-292">若要正確運做為佈景主題查詢的一部分，這個值必須是要加上樣式之項目的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-292">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span>
          </span>
          <span data-ttu-id="5ac11-293">
            <see langword="null" /> 是可接受的值，在某些情況下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-293">
              <see langword="null" /> is an accepted value for a certain case.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-294">這個屬性通常是透過任何直接的 setter 不設定。</span><span class="sxs-lookup"><span data-stu-id="5ac11-294">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="5ac11-295">相反地，您會覆寫這個相依性屬性的型別特定中繼資料每次建立新的子類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-295">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="5ac11-296">當您的子類別，呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>針對方法<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>控制項子類別的靜態建構函式中的識別項。</span><span class="sxs-lookup"><span data-stu-id="5ac11-296">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="5ac11-297">比方說，這類的內嵌類別<xref:System.Windows.Documents.Bold>實際上有極少的實作，除了覆寫<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>其靜態建構函式，並公開數個執行個體建構函式中的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="5ac11-297">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="5ac11-298">元素括住的事實<xref:System.Windows.Documents.Bold>標記提升<xref:System.Windows.Documents.TextElement.FontWeight%2A>屬性<xref:System.Windows.FontWeights.Bold%2A>所設定的預設值參考的佈景主題樣式內實作<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>到`typeof(Bold)`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-298">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="5ac11-299">如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>屬性設`true`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-299">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-300">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-300">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-301">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-301">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="5ac11-302">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-302">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-303">識別 <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-303">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-304">在初始化項目之後立即呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-304">Called immediately after an element is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-305">實作這個方法，以提供您的項目初始化期間載入程序的項目時，應該會發生的特殊處理。</span><span class="sxs-lookup"><span data-stu-id="5ac11-305">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="5ac11-306">您的實作應該呼叫基底實作，因為基底 （預設值） 的實作會設定一些內部的旗標，以追蹤的初始化。</span><span class="sxs-lookup"><span data-stu-id="5ac11-306">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="5ac11-307">如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>先前已呼叫，基底實作會引發<xref:System.Windows.FrameworkContentElement.Initialized>事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-307">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="5ac11-308">否則，如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>不會呼叫或可能不是決定是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已呼叫，不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-308">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5ac11-309">要搜尋的項目名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-309">Name of the element to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-310">尋找具有所提供之識別項名稱的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-310">Finds an element that has the provided identifier name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-311">要求的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-311">The requested element.</span>
          </span>
          <span data-ttu-id="5ac11-312">如果找不到相符的項目，則可能為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-312">May be <see langword="null" /> if no matching element was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-313">如果這個項目有子項目，這些子元素會遞迴地搜尋所有要求的具名項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-313">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-314">下列範例中所參考依名稱找到的項目上設定屬性<xref:System.Windows.Documents.FlowDocument>頁面上。</span><span class="sxs-lookup"><span data-stu-id="5ac11-314">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="5ac11-315">要尋找之資源的索引鍵識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-315">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-316">搜尋具有指定索引鍵的資源，並將於找不到要求的資源時擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-316">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-317">找到的資源，如果找不到相符的資源則為 <see langword="null" /> (若為 <see langword="null" /> 時也會擲回例外狀況)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-317">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="5ac11-318">如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5ac11-318">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="5ac11-319">如果您不想處理例外狀況，在此情況下的，您應該呼叫<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-319">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="5ac11-320"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 傳回`null`任何資源時有結果且不擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5ac11-320"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="5ac11-321">如果呼叫的項目上找不到資源，使用邏輯樹狀結構 」 來搜尋 「 父樹狀結構，在樹狀結構的相同方式來搜尋的若資源所要求在執行階段的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5ac11-321">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="5ac11-322">通常您會立即傳回值轉換成您嘗試使用傳回的資源值設定屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-322">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-323">下列範例會尋找在標記中定義的資源，並套用至元素為了回應路由事件的特定屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-323">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <span data-ttu-id="5ac11-324">找不到要求的資源索引鍵。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-324">The requested resource key was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5ac11-325">
            <paramref name="resourceKey" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-325">
              <paramref name="resourceKey" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-326">取得或設定物件，這個物件可自訂外觀、效果或其他樣式特性，以在這個項目捕捉到鍵盤焦點時套用至此項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-326">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-327">要在取得焦點時套用的樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-327">The desired style to apply on focus.</span>
          </span>
          <span data-ttu-id="5ac11-328">相依性屬性中所宣告的預設值是空的靜態 <see cref="T:System.Windows.Style" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-328">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span>
          </span>
          <span data-ttu-id="5ac11-329">不過，執行階段的有效值通常是 (但不一定總是) 佈景主題支援為控制項所提供的樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-329">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-330">設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]樣式幾乎一定會定義為資源，而不是內嵌為項目，且資源通常是當做參考<xref:System.Windows.StaticResourceExtension>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-330">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="5ac11-331">請注意這個屬性會影響視覺外觀，但不會報告，在 中繼資料。</span><span class="sxs-lookup"><span data-stu-id="5ac11-331">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="5ac11-332">這是因為視覺外觀變更事件驅動，隨時可能不適用且因此通常不應該報告中繼資料中的任何視覺效果] 或 [版面配置資訊。</span><span class="sxs-lookup"><span data-stu-id="5ac11-332">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="5ac11-333">就概念而言，套用至控制項的焦點視覺行為應該保持一致項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-333">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="5ac11-334">若要只變更焦點視覺化樣式，當您在撰寫整個佈景主題，是最合理的方式，來強制執行一致性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-334">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="5ac11-335">在個別的樣式，而不是屬於佈景主題，請設定這個屬性不是預定的使用方式，此屬性，因為它可能會導致令人困惑的使用者體驗，關於鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="5ac11-335">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="5ac11-336">如果您打算是刻意不一致整個佈景主題的項目特定行為，更好的方法是使用觸發程序在樣式中個別輸入的狀態屬性，例如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做並不會的方式以視覺化方式會影響任何現有的焦點視覺化樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-336">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="5ac11-337">如需有關的設計用意<xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A>及替代專注屬性，請參閱 <<c2> [ 設定在控制項和 FocusVisualStyle 焦點的樣式](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-337">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-338">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-338">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5ac11-339">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="5ac11-339">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-340">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-340">XAML Values</span></span>  
 <span data-ttu-id="5ac11-341">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5ac11-341">*resourceExtension*</span></span>  
 <span data-ttu-id="5ac11-342">下列其中之一:、 或。</span><span class="sxs-lookup"><span data-stu-id="5ac11-342">One of the following: , or .</span></span> <span data-ttu-id="5ac11-343">請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-343">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5ac11-344">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5ac11-344">*styleResourceKey*</span></span>  
 <span data-ttu-id="5ac11-345">識別所要求的樣式索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5ac11-345">The key that identifies the style being requested.</span></span> <span data-ttu-id="5ac11-346">索引鍵參考中的現有資源<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-346">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ac11-347">屬性元素語法是技術上可行，但不是建議使用。</span><span class="sxs-lookup"><span data-stu-id="5ac11-347">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="5ac11-348">請參閱[內嵌樣式和範本](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-348">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="5ac11-349">使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</span><span class="sxs-lookup"><span data-stu-id="5ac11-349">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-350">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-350">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-351">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-351">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="5ac11-352">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-352">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-353">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-353">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-354">識別 <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-354">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-355">取得或設定值，這個值表示此 <see cref="T:System.Windows.FrameworkContentElement" /> 是否應強制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 呈現游標，如這個執行個體的 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 屬性所宣告。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-355">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-356">如果要在游標位於此項目上方時，強制游標展示使用此執行個體的游標設定 (包括在所有子項目上) 則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-356">
              <see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="5ac11-357">預設值是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-357">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-358">將此屬性設定為`true`會覆寫的子項目所建立的資料指標喜好設定。</span><span class="sxs-lookup"><span data-stu-id="5ac11-358">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="5ac11-359">因此一般應用程式這麼做[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能會造成混淆使用者，特別是如果子元素正嘗試將指定資料指標。</span><span class="sxs-lookup"><span data-stu-id="5ac11-359">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="5ac11-360">設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>在控制項的子類別化或複合 （compositing） 的情況下更適合。</span><span class="sxs-lookup"><span data-stu-id="5ac11-360">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-361">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-361">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-362">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-362">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="5ac11-363">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-363">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-364">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-364">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-365">下列範例會強制資料指標在元素上方。</span><span class="sxs-lookup"><span data-stu-id="5ac11-365">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-366">識別 <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-366">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5ac11-367">要取得繫結的目標 <see cref="T:System.Windows.DependencyProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-367">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-368">取得指定屬性之繫結的 <see cref="T:System.Windows.Data.BindingExpression" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-368">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-369">如果目標已資料繫結則傳回 <see cref="T:System.Windows.Data.BindingExpression" />，否則傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-369">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5ac11-370">下列範例會擷取藉由查詢屬性的繫結。</span><span class="sxs-lookup"><span data-stu-id="5ac11-370">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-371">如果沒有視覺父代，則傳回這個項目的替代邏輯父代。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-371">Returns an alternative logical parent for this element if there is no visual parent.</span>
          </span>
          <span data-ttu-id="5ac11-372">在這個情況下，<see cref="T:System.Windows.FrameworkContentElement" /> 父代一律會與 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 屬性的值相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-372">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-373">每當這個方法的 WPF 架構層級實作具有非視覺父連線時，傳回 <see langword="null" /> 以外的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-373">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-374">預設實作會傳回預期的單一視覺父代。</span><span class="sxs-lookup"><span data-stu-id="5ac11-374">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="5ac11-375">自訂實作可能會傳回替代的父代關聯性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-375">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-376">當這個 <see cref="T:System.Windows.FrameworkContentElement" /> 初始化時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-376">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span>
          </span>
          <span data-ttu-id="5ac11-377">這符合 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 屬性值從 <see langword="false" /> (或未定義) 變更為 <see langword="true" /> 的案例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-377">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-378">此事件時引發<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>方法受到呼叫。</span><span class="sxs-lookup"><span data-stu-id="5ac11-378">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="5ac11-379">這些方法的呼叫可能已刻意的程式碼，或藉由[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]載入程序。</span><span class="sxs-lookup"><span data-stu-id="5ac11-379">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-380">取得或設定這個 <see cref="T:System.Windows.FrameworkContentElement" /> 所用的輸入內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-380">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-381">輸入範圍，可修改替代輸入法之輸入的解譯方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-381">The input scope, which modifies how input from alternative input methods is interpreted.</span>
          </span>
          <span data-ttu-id="5ac11-382">預設值為 <see langword="null" /> (這會導致命令的預設處理)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-382">The default value is <see langword="null" /> (which results in a default handling of commands).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-383">這個相依性屬性繼承的屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-383">This dependency property inherits property values.</span></span> <span data-ttu-id="5ac11-384">如果有任何其他值的子項目<xref:System.Windows.FrameworkElement.InputScope%2A>建立透過本機值或樣式，屬性系統會將值設為可<xref:System.Windows.FrameworkElement.InputScope%2A>指派此值最接近的父項目的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-384">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="5ac11-385">雖然[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法用法列為和語法上允許，設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]不常見。</span><span class="sxs-lookup"><span data-stu-id="5ac11-385">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-386">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-386">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-387">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-387">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="5ac11-388">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-388">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-389">識別 <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-389">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-390">取得值，這個值表示此項目是否已初始化，初始化方式可能是當做[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 載入，或明確地呼叫其 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-390">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-391">如果項目已根據先前提到的載入或方法呼叫來初始化則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-391">
              <see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-392">這個屬性也可能`true`如果此項目已移動項目樹狀結構內，使它有新的父項目，並且因此變成一次重新載入。</span><span class="sxs-lookup"><span data-stu-id="5ac11-392">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-393">取得值，這個值表示此項目是否已載入以供展示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-393">Gets a value indicating whether this element has been loaded for presentation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-394">如果目前項目是附加至項目樹狀結構並已呈現則為 <see langword="true" />，如果項目從未附加至已載入的項目樹狀結構則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-394">
              <see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-395">新建構的執行個體中，此屬性一開始很`false`，且會維持`true`一旦設為`true`，即使程式碼之後移除。</span><span class="sxs-lookup"><span data-stu-id="5ac11-395">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-396">下列範例程式碼會使用<xref:System.Windows.FrameworkContentElement.IsLoaded%2A>做為條件式檢查以確定函式`displayData`（未顯示） 會有有效的項目上載入的頁面，即可運作，視處理常式的一部分。</span><span class="sxs-lookup"><span data-stu-id="5ac11-396">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="5ac11-397">相同的邏輯以事件處理常式執行<xref:System.Windows.FrameworkContentElement.Loaded>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-397">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-398">取得或設定套用至個別項目的當地語系化/全球化語言資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-398">Gets or sets localization/globalization language information that applies to an individual element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-399">這個項目的文化特性資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-399">The culture information for this element.</span>
          </span>
          <span data-ttu-id="5ac11-400">預設值為 <see cref="T:System.Windows.Markup.XmlLanguage" /> 執行個體，且其 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值設定為 "en-US" 字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-400">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-401">字串格式會遵循 RFC 3066 標準。</span><span class="sxs-lookup"><span data-stu-id="5ac11-401">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="5ac11-402">例如，美國英文是"EN-US"。</span><span class="sxs-lookup"><span data-stu-id="5ac11-402">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="5ac11-403">請參閱<xref:System.Windows.Markup.XmlLanguage>如需有關值和格式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-403">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="5ac11-404">這個相依性屬性繼承的屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-404">This dependency property inherits property values.</span></span> <span data-ttu-id="5ac11-405">如果有任何其他值的子項目<xref:System.Windows.FrameworkElement.Language%2A>建立透過本機值或樣式，屬性系統會將值設為可<xref:System.Windows.FrameworkElement.Language%2A>指派此值最接近的父項目的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-405">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-406">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-406">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-407">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-407">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="5ac11-408">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-408">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-409">識別 <see cref="P:System.Windows.FrameworkContentElement.Language" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-409">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-410">當項目已配置版面、呈現以及可以互動時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-410">Occurs when the element is laid out, rendered, and ready for interaction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-411">直接路由的事件不會遵循路由，它們才會處理在相同的項目，其引發。</span><span class="sxs-lookup"><span data-stu-id="5ac11-411">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="5ac11-412">直接路由的事件支援其他路由的事件的行為： 它們支援的可存取的處理常式集合，且可用來當做<xref:System.Windows.EventTrigger>樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-412">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-413">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-413">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-414">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-414">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="5ac11-415">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-415">Routing strategy</span></span>|<span data-ttu-id="5ac11-416">直接</span><span class="sxs-lookup"><span data-stu-id="5ac11-416">Direct</span></span>|  
|<span data-ttu-id="5ac11-417">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-417">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-418">識別 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-418">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-419">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-419">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-420">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-420">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-421">為此項目的邏輯子項目取得列舉值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-421">Gets an enumerator for the logical child elements of this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-422">此項目之邏輯子項目的列舉值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-422">An enumerator for logical child elements of this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-423">如需有關如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>並<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-423">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="5ac11-424">要移動焦點的方向，以列舉型別 (Enumeration) 的值表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-424">The direction that focus is to be moved, as a value of the enumeration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-425">將鍵盤焦點從這個項目移至另一個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-425">Moves the keyboard focus from this element to another element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-426">若成功移動焦點則傳回 <see langword="true" />，若所指定之方向的目標項目不存在則傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-426">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-427">取得或設定項目的識別名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-427">Gets or sets the identifying name of the element.</span>
          </span>
          <span data-ttu-id="5ac11-428">該名稱會提供執行個體參考，以便程式設計程式碼後置 (Code-Behind)，例如事件處理常式程式碼，在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 的剖析期間被建構後便可參考項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-428">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-429">項目的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-429">The name of the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-430">指定時，這個屬性的最常見的用法[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]標記中的項目名稱。</span><span class="sxs-lookup"><span data-stu-id="5ac11-430">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="5ac11-431">這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-431">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="5ac11-432">取得<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼並不常見，因為如果您沒有適當的參考程式碼中，您可以直接呼叫方法，而且項目上的屬性參考，且通常需要<xref:System.Windows.FrameworkContentElement.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-432">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="5ac11-433">例外狀況是發生在字串中具有某些多載意義，例如它是否可顯示該名稱在[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5ac11-433">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5ac11-434">設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼如果原始<xref:System.Windows.FrameworkContentElement.Name%2A>已從標記集也不建議在使用中，並變更屬性並不會變更的物件參考。</span><span class="sxs-lookup"><span data-stu-id="5ac11-434">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="5ac11-435">這類物件參考會建立期間明確地建立基礎的名稱範圍時，才[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]載入。</span><span class="sxs-lookup"><span data-stu-id="5ac11-435">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="5ac11-436">您必須特別呼叫<xref:System.Windows.FrameworkContentElement.RegisterName%2A>上進行有效的變更<xref:System.Windows.FrameworkContentElement.Name%2A>已載入元素的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-436">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="5ac11-437">一個值得注意案例設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼是很重要的命名會分鏡腳本的項目執行。</span><span class="sxs-lookup"><span data-stu-id="5ac11-437">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="5ac11-438">您可以註冊的名稱之前，可能也需要具現化，並將指派<xref:System.Windows.NameScope>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ac11-438">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="5ac11-439">請參閱 < 範例 > 一節中，或是[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-439">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="5ac11-440">設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼具有有限的應用程式，但依名稱查閱項目是更常見，尤其是如果您採用，頁面會重新載入到應用程式和執行階段程式碼不一定是程式碼後置的瀏覽模型個別頁面。</span><span class="sxs-lookup"><span data-stu-id="5ac11-440">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="5ac11-441">公用程式方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkContentElement>，可以找到任何項目<xref:System.Windows.FrameworkContentElement.Name%2A>在該項目邏輯樹狀結構以遞迴方式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-441">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="5ac11-442">或者您可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，也會採用<xref:System.Windows.FrameworkContentElement.Name%2A>做為引數的字串。</span><span class="sxs-lookup"><span data-stu-id="5ac11-442">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="5ac11-443">常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>比方說) 實作介面<xref:System.Windows.Markup.INameScope>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-443">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="5ac11-444">這個介面的實作應該強制執行的名稱是模稜兩可在其範圍內。</span><span class="sxs-lookup"><span data-stu-id="5ac11-444">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-445">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-445">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-446">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-446">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="5ac11-447">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-447">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-448">識別 <see cref="P:System.Windows.FrameworkContentElement.Name" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-448">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-449">提供有關事件的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-449">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-450">當 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-450">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5ac11-451">實作這個方法可為此事件加入類別處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-451">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-452">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-452">This method has no default implementation.</span></span> <span data-ttu-id="5ac11-453">如果在繼承的中繼類別已實作此方法，您仍應該呼叫基底實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-453">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5ac11-454">這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-454">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5ac11-455">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-455">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5ac11-456">On \* 方法的實作模式是不同的路由事件，因為路由的事件可能有子元素，不一定會叫用處理常式的項目所引發。</span><span class="sxs-lookup"><span data-stu-id="5ac11-456">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="5ac11-457">因此，您的實作必須考量的事件引數的來源屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-457">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5ac11-458">子類別<xref:System.Windows.FrameworkContentElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-458">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5ac11-459">一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理，以縮短路由。</span><span class="sxs-lookup"><span data-stu-id="5ac11-459">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-460">事件的事件資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-460">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-461">當 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-461">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5ac11-462">實作這個方法可為此事件加入類別處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-462">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-463">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-463">This method has no default implementation.</span></span> <span data-ttu-id="5ac11-464">如果在繼承的中繼類別已實作此方法，您仍應該呼叫 base （）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-464">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5ac11-465">這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-465">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5ac11-466">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-466">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5ac11-467">On \* 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，讓您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-467">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5ac11-468">子類別<xref:System.Windows.FrameworkContentElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-468">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5ac11-469">一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理，以縮短路由。</span><span class="sxs-lookup"><span data-stu-id="5ac11-469">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-470">事件的事件資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-470">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-471">
            <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的類別處理常式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-471">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-472">這個類別處理常式在這個項目上設定適當的焦點行為，如果從這個項目所產生的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-472">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="5ac11-473">如果事件的來源是在樹狀目錄中的另一個項目，這個處理常式沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="5ac11-473">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="5ac11-474">若要變更這些預設焦點行為，您的項目上，覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-474">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-475">事件的事件資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-475">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-476">引發 <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-476">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span>
          </span>
          <span data-ttu-id="5ac11-477">每當 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 設定為 <see langword="true" /> 時會叫用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-477">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-478">本主題稍早所述，此虛擬方法的預設實作會引發事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-478">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="5ac11-479">覆寫應呼叫 base （），以保留此行為。</span><span class="sxs-lookup"><span data-stu-id="5ac11-479">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="5ac11-480">請注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="5ac11-480">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="5ac11-481">因此，您無法設定，以強制初始化行為的方式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-481">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="5ac11-482">初始化設定要進行只有[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]framework。</span><span class="sxs-lookup"><span data-stu-id="5ac11-482">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-483">描述已變更屬性的事件資料 (包含舊值和新值)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-483">The event data that describes the property that changed, including the old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-484">每當 <see cref="T:System.Windows.FrameworkContentElement" /> 上任何相依性屬性的有效值已更新時叫用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-484">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span>
          </span>
          <span data-ttu-id="5ac11-485">已變更的特定相依性屬性會在引數參數中報告。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-485">The specific dependency property that changed is reported in the arguments parameter.</span>
          </span>
          <span data-ttu-id="5ac11-486">覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-486">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-487">這個方法不是要用於偵測一般的屬性變更或失效。</span><span class="sxs-lookup"><span data-stu-id="5ac11-487">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="5ac11-488">它改為適用於一般失效模式修改如果已知廣泛分類屬性的特定資訊。</span><span class="sxs-lookup"><span data-stu-id="5ac11-488">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="5ac11-489">這個方法是可能被叫用次數物件的存留期間。</span><span class="sxs-lookup"><span data-stu-id="5ac11-489">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="5ac11-490">因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-490">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="5ac11-491">不過，您會使用這個方法如果<xref:System.Windows.FrameworkContentElement>包含大量的值相互關聯的相依性屬性，或者如果它包含邏輯，例如轉譯行為，必須重新執行的許多相關的屬性失效的情況。</span><span class="sxs-lookup"><span data-stu-id="5ac11-491">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="5ac11-492">請注意，有同名`OnPropertyChanged`方法具有不同的簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別上。</span><span class="sxs-lookup"><span data-stu-id="5ac11-492">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="5ac11-493">該`OnPropertyChanged`用於資料物件的通知，而且是合約的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-493">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="5ac11-494">
            <para>務必呼叫基底實作中，在實作中的第一個作業。如果沒有這樣做會大幅停用整個[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統中，這會導致報告不正確的值。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-494">
              <para>Always call the base implementation, as the first operation in your implementation. Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">
          <span data-ttu-id="5ac11-495">舊樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-495">The old style.</span>
          </span>
        </param>
        <param name="newStyle">
          <span data-ttu-id="5ac11-496">新樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-496">The new style.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-497">當這個項目上的使用中樣式變更時叫用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-497">Invoked when the style that is in use on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-498">這個方法已設定內部的旗標，您會看到樣式變更條件的預設實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-498">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="5ac11-499">
            <para>請務必呼叫基底實作，否則會無法套用樣式。如果您的衍生的類別具有特殊的樣式選取器或樣式值會快取，可能包括覆寫這個方法的案例。佈景主題變更可能會叫用這個方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-499">
              <para>Always call the base implementation, otherwise styles cannot be applied. Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values. Theme changes will potentially invoke this method.</para>
            </span>
          </span>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-500">提供有關事件的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-500">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-501">當 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-501">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5ac11-502">實作這個方法可為此事件加入類別處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-502">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-503">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-503">This method has no default implementation.</span></span> <span data-ttu-id="5ac11-504">如果在繼承的中繼類別已實作此方法，您仍應該呼叫 base （）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-504">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5ac11-505">這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-505">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5ac11-506">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-506">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5ac11-507">On \* 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，讓您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-507">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5ac11-508">子類別<xref:System.Windows.FrameworkContentElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-508">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5ac11-509">一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理，以縮短路由。</span><span class="sxs-lookup"><span data-stu-id="5ac11-509">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5ac11-510">提供有關事件的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-510">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-511">當 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-511">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5ac11-512">實作這個方法可為此事件加入類別處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-512">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-513">這個方法沒有任何預設實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-513">This method has no default implementation.</span></span> <span data-ttu-id="5ac11-514">如果在繼承的中繼類別已實作此方法，您仍應該呼叫 base （）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-514">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5ac11-515">這個方法的目的是有點類似[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 它會提供方法來處理從衍生的類別，而不是執行個體處理常式的類別處理常式與相符的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-515">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5ac11-516">在此情況下，符合的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-516">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5ac11-517">On \* 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須接受事件引數的來源項目帳戶屬性 （和不應該嘗試重新引發該事件，在大部分情況下）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-517">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5ac11-518">子類別<xref:System.Windows.FrameworkContentElement>可以選擇在路由收到事件時呼叫私用類別處理常式方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-518">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5ac11-519">一個可能的案例是取得事件的引數，並謹慎地將事件標示為已處理，以縮短路由。</span><span class="sxs-lookup"><span data-stu-id="5ac11-519">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-520">取得或設定值，這個值表示此項目是否會併入佈景主題樣式中的樣式屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-520">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-521">如果這個項目不會使用佈景主題樣式，所有從樣式產生的屬性都來自本機應用程式樣式，且佈景主題樣式屬性不會套用，則為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-521">
              <see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span>
          </span>
          <span data-ttu-id="5ac11-522">如果應用程式樣式先套用，然後針對不是在應用程式樣式中具體設定的屬性套用佈景主題樣式則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-522">
              <see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-523">這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。</span><span class="sxs-lookup"><span data-stu-id="5ac11-523">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-524">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-524">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-525">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-525">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="5ac11-526">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-526">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-527">識別 <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-527">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-528">取得此項目之邏輯樹狀結構中的父代。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-528">Gets the parent in the logical tree for this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-529">此項目的邏輯父代。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-529">The logical parent for this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-530">請注意，根據您的應用程式的功能，有可能變更邏輯父項目保留這個屬性的值並不會反映該變更。</span><span class="sxs-lookup"><span data-stu-id="5ac11-530">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="5ac11-531">您通常應該取得的值之前您需要它。</span><span class="sxs-lookup"><span data-stu-id="5ac11-531">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="5ac11-532">請參閱[WPF 中的樹狀結構](~/docs/framework/wpf/advanced/trees-in-wpf.md)如需有關周遊邏輯樹狀結構，以及的案例適合這種方式來探索項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-532">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="5ac11-533">屬性系統有可能重新計算之元素的所有屬性值時，它會重設父代，因為有些屬性繼承邏輯樹狀結構的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-533">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="5ac11-534"><xref:System.Windows.FrameworkContentElement.DataContext%2A>套用的項目會重設父代時，也可以變更繫結。</span><span class="sxs-lookup"><span data-stu-id="5ac11-534">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="5ac11-535">變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-535">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="5ac11-536">使用的最常見的案例<xref:System.Windows.FrameworkContentElement.Parent%2A>屬性是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkContentElement>從父代的屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-536">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="5ac11-537">如需範本，<xref:System.Windows.FrameworkContentElement.Parent%2A>範本的最終會`null`。</span><span class="sxs-lookup"><span data-stu-id="5ac11-537">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="5ac11-538">取得略過此點，並將延伸至邏輯樹狀結構的範本會實際套用，請使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-538">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-539">下列範例會檢查以查看是否<xref:System.Windows.FrameworkContentElement.Parent%2A>的<xref:System.Windows.Documents.TextPointer>屬於特定型別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-539">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="5ac11-540">應用於決定預期焦點變更的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-540">The direction for which a prospective focus change should be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-541">決定下一個項目，該項目會針對所提供的焦點移動方向，接收相對於此項目的焦點，但是不會實際移動焦點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-541">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span>
          </span>
          <span data-ttu-id="5ac11-542">這是已密封的方法，無法覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-542">This method is sealed and cannot be overridden.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-543">如果焦點實際上有周遊時，焦點會移動到的下一個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-543">The next element that focus would move to if focus were actually traversed.</span>
          </span>
          <span data-ttu-id="5ac11-544">如果無法依所提供的方向相對於此項目移動焦點，則可能傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-544">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-545"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 是沒有實際移動焦點的相關的方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-545"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="5ac11-546">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定下列其中一個方向：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-546">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          </span>
          <span data-ttu-id="5ac11-547">這些方向對 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 而言不是合法的 (但對 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 而言是合法的)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-547">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5ac11-548">要用於指定之「名稱-物件」對應的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-548">Name to use for the specified name-object mapping.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="5ac11-549">對應的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-549">Object for the mapping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-550">提供可簡化對 <see cref="T:System.Windows.NameScope" /> 註冊方法之存取的存取子 (Accessor)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-550">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-551">這個方法是很便利的方法呼叫<xref:System.Windows.NameScope.RegisterName%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-551">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="5ac11-552">實作會檢查後續的父項目，直到它找到適用<xref:System.Windows.NameScope>實作中，找到所尋找的項目，實作<xref:System.Windows.Markup.INameScope>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-552">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="5ac11-553">如需有關命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-553">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="5ac11-554">呼叫<xref:System.Windows.FrameworkContentElement.RegisterName%2A>才能正確地將連結的應用程式程式碼中建立時的動畫分鏡腳本。</span><span class="sxs-lookup"><span data-stu-id="5ac11-554">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="5ac11-555">這是因為其中一個索引鍵屬性，分鏡腳本表現<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，使用執行階段名稱查閱，而不是能夠將目標項目的參考。</span><span class="sxs-lookup"><span data-stu-id="5ac11-555">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="5ac11-556">這是，則為 true，即使該元素是由參考從程式碼存取。</span><span class="sxs-lookup"><span data-stu-id="5ac11-556">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="5ac11-557">如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-557">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="5ac11-558">內容項目的動畫會較不常見，比在控制項上的動畫[分鏡腳本概觀](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)著重在控制案例。</span><span class="sxs-lookup"><span data-stu-id="5ac11-558">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="5ac11-559">要移除的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-559">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-560">從這個項目的邏輯樹狀中移除指定的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-560">Removes the specified element from the logical tree for this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-561">這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]大致上是相關的類別衍生的案例中，新增支援的子集合時。</span><span class="sxs-lookup"><span data-stu-id="5ac11-561">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="5ac11-562">大部分<xref:System.Windows.FrameworkContentElement>衍生的類別會公開專用的集合負責內含項目 (例如<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-562">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="5ac11-563">通常衍生自這些類別可以避免直接操作邏輯樹狀結構的任何需求。</span><span class="sxs-lookup"><span data-stu-id="5ac11-563">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-564">取得或設定目前本機定義的資源字典。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-564">Gets or sets the current locally-defined resource dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-565">目前本機定義的資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-565">The current locally-defined resources.</span>
          </span>
          <span data-ttu-id="5ac11-566">這是資源的字典，字典內的資源是依索引鍵來存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-566">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-567">可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，和通常是在針對任何個別的頁面或應用程式的根項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-567">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="5ac11-568">放置在此層級的資源字典可讓您更輕鬆地尋找從個別的子頁面中的項目 （或從任何頁面上，在應用程式的情況下）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-568">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="5ac11-569">在大部分的應用程式案例中，我們建議樣式定義為物件項目內的資源字典中，或定義為外部的資源，以便讓整個樣式資源可彼此獨立 （這種方法有助於個別設計工具團隊的職責區隔需要加以編輯的實體檔案的開發人員責任）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-569">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="5ac11-570">請注意，這個屬性會傳回該項目內直接宣告的資源字典。</span><span class="sxs-lookup"><span data-stu-id="5ac11-570">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="5ac11-571">這是不同於實際資源查閱程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中定義的資源。</span><span class="sxs-lookup"><span data-stu-id="5ac11-571">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="5ac11-572">資源也可以從集合中的程式碼所參考，但請注意，在建立資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]絕對無法供存取直到之後<xref:System.Windows.FrameworkContentElement.Loaded>宣告字典項目引發。</span><span class="sxs-lookup"><span data-stu-id="5ac11-572">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="5ac11-573">事實上，資源會以非同步方式進行剖析，而且甚至不會<xref:System.Windows.FrameworkContentElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義資源。</span><span class="sxs-lookup"><span data-stu-id="5ac11-573">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="5ac11-574">基於這個理由，您應該通常只能存取[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義為一部分的執行階段程式碼，或透過其他的資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。</span><span class="sxs-lookup"><span data-stu-id="5ac11-574">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="5ac11-575">當您透過程式碼存取資源時，這基本上等於是從進行參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5ac11-575">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="5ac11-576">基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除或使用程式碼來查詢集合內的資源所需的方法。</span><span class="sxs-lookup"><span data-stu-id="5ac11-576">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="5ac11-577"><xref:System.Windows.FrameworkContentElement.Resources%2A>屬性是可為支援的案例是完全取代的項目是一個新的或不同的資源集合<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-577">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="5ac11-578">請注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的語法不包括的項目<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-578">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="5ac11-579">這是隱含的集合語法; 的範例代表集合項目的標記就可以省略。</span><span class="sxs-lookup"><span data-stu-id="5ac11-579">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="5ac11-580">改為指定為項目加入至集合的項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-580">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="5ac11-581">如需有關隱含集合並[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，請參閱 < [XAML 語法詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-581">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="5ac11-582">一種情況其中<xref:System.Windows.ResourceDictionary>仍然明確指定為項目才不會導入合併的字典，在此情況下通常的任何子項目<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-582">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="5ac11-583">如需詳細資訊，請參閱 <<c0> [ 合併的資源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-583">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5ac11-584">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="5ac11-584">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-585">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-585">XAML Values</span></span>  
 <span data-ttu-id="5ac11-586">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="5ac11-586">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="5ac11-587">一或多個物件項目，其中每個定義的資源。</span><span class="sxs-lookup"><span data-stu-id="5ac11-587">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="5ac11-588">每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>必須有唯一的值[X:key 指示詞](~/docs/framework/xaml-services/x-key-directive.md)，從擷取的值時做為唯一的索引鍵<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-588">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-589">下列範例會建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的收集<xref:System.Windows.Documents.FlowDocument>根項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-589">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="5ac11-590"><xref:System.Windows.Documents.FlowDocument> 是典型的選擇，因為它是少數<xref:System.Windows.FrameworkContentElement>根項目，以及資源有意義的類別通常會儲存在頁面根或更高等級例如應用程式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-590"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-591">將繫結附加至指定相依性屬性的這個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-591">Attaches a binding to this element for the specified dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5ac11-592">識別繫結屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-592">Identifies the bound property.</span>
          </span>
        </param>
        <param name="path">
          <span data-ttu-id="5ac11-593">用於繫結之屬性的來源屬性名稱或路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-593">The source property name or the path to the property used for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-594">根據提供給資料來源做為路徑限定性條件的來源屬性名稱，將繫結附加至這個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-594">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-595">記錄繫結的條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-595">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="5ac11-596">這個傳回值對錯誤檢查很有用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-596">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-597">這個方法是很便利的方法呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>根據所提供`path`參數。</span><span class="sxs-lookup"><span data-stu-id="5ac11-597">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="5ac11-598">此簽章會更方便，如果您要建立簡單的預設繫結項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-598">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="5ac11-599">如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或是<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。</span><span class="sxs-lookup"><span data-stu-id="5ac11-599">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-600">下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，藉由建立新的自訂資料物件，建立該物件做為<xref:System.Windows.FrameworkContentElement.DataContext%2A>，並將繫結路徑設定為在其中的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-600">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5ac11-601">識別繫結屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-601">Identifies the bound property.</span>
          </span>
        </param>
        <param name="binding">
          <span data-ttu-id="5ac11-602">表示資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-602">Represents a data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-603">根據提供的繫結物件，將繫結附加至這個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-603">Attaches a binding to this element, based on the provided binding object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-604">記錄繫結的條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-604">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="5ac11-605">這個傳回值對錯誤檢查很有用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-605">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-606">這個方法是很便利的方法呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-606">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-607">下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，藉由建立新<xref:System.Windows.Data.Binding>並將來源設定為新建置`DateTime`物件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-607">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5ac11-608">資源繫結到的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-608">The property to which the resource is bound.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="5ac11-609">資源名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-609">The name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-610">搜尋具有指定名稱的資源，並針對指定的屬性建立該資源的資源參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-610">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-611">資源參考是使用類似[DynamicResource 標記延伸](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)標記中。</span><span class="sxs-lookup"><span data-stu-id="5ac11-611">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="5ac11-612">資源參考會建立內部運算式提供在執行階段延後基準上所指定屬性的值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-612">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="5ac11-613">每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-613">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-614">傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 屬性的內容序列化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-614">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-615">如果應序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-615">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-616">這會傳回`true`只要至少一個索引鍵的資源正在本機<xref:System.Windows.FrameworkContentElement.Resources%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-616">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-617">傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 屬性的內容序列化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-617">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-618">如果應序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-618">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-619">這會傳回`true`如果<xref:System.Windows.Style>本機設定。</span><span class="sxs-lookup"><span data-stu-id="5ac11-619">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-620">當參與這個項目之繫結的任何關聯資料來源變更時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-620">Occurs when any associated data source participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-621">此事件表面<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</span><span class="sxs-lookup"><span data-stu-id="5ac11-621">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-622">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-622">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-623">取得或設定這個項目要使用的樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-623">Gets or sets the style to be used by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-624">如有，則為項目已套用的非預設樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-624">The applied, nondefault style for the element, if present.</span>
          </span>
          <span data-ttu-id="5ac11-625">否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-625">Otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="5ac11-626">預設建構之 <see cref="T:System.Windows.FrameworkContentElement" /> 的預設值為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-626">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-627">從佈景主題，或通常由在網頁或應用程式層級 （隱含樣式） 的資源，以套用至該類型的物件的樣式為預設樣式通常會提供目前的樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-627">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="5ac11-628">這個屬性不會設定或傳回預設 （主題） 樣式，但會傳回隱含樣式或明確的樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-628">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="5ac11-629">在隱含或明確樣式的情況下，樣式是做為資源的存取，或在本機定義並不重要。</span><span class="sxs-lookup"><span data-stu-id="5ac11-629">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="5ac11-630">設定樣式有一些限制。</span><span class="sxs-lookup"><span data-stu-id="5ac11-630">Setting the styles has some restrictions.</span></span> <span data-ttu-id="5ac11-631">您可以重設整個<xref:System.Windows.FrameworkContentElement.Style%2A>屬性，以新<xref:System.Windows.Style>在任何時間，這會強制配置重新撰寫。</span><span class="sxs-lookup"><span data-stu-id="5ac11-631">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="5ac11-632">不過，一旦該樣式會放在使用中所載入的項目，<xref:System.Windows.Style>應視為密封。</span><span class="sxs-lookup"><span data-stu-id="5ac11-632">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="5ac11-633">嘗試變更使用中樣式的任何個別的屬性 (例如集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5ac11-633">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="5ac11-634">標記中定義的樣式會被視為正在使用中，只要載入資源字典中的 （如資源），或包含在頁面載入 （適用於內嵌樣式）。</span><span class="sxs-lookup"><span data-stu-id="5ac11-634">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="5ac11-635"><xref:System.Windows.FrameworkContentElement.Style%2A> 是相依性屬性具有特殊的優先順序。</span><span class="sxs-lookup"><span data-stu-id="5ac11-635"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="5ac11-636">本機設定樣式通常會在運作的最高的優先順序屬性系統中。</span><span class="sxs-lookup"><span data-stu-id="5ac11-636">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="5ac11-637">如果<xref:System.Windows.FrameworkContentElement.Style%2A>為 null，在屬性系統會檢查隱含樣式做為指定該類型的定義資源的載入期間。</span><span class="sxs-lookup"><span data-stu-id="5ac11-637">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="5ac11-638">如果樣式是仍為 null，這個步驟之後，則樣式會來自預設 （主題） 樣式，但中不會傳回預設樣式<xref:System.Windows.FrameworkContentElement.Style%2A>屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ac11-638">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="5ac11-639">請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-639">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-640">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-640">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-641">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-641">XAML Values</span></span>  
 <span data-ttu-id="5ac11-642">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5ac11-642">*resourceExtension*</span></span>  
 <span data-ttu-id="5ac11-643">下列其中之一:、 或。</span><span class="sxs-lookup"><span data-stu-id="5ac11-643">One of the following: , or .</span></span> <span data-ttu-id="5ac11-644">請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-644">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5ac11-645">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5ac11-645">*styleResourceKey*</span></span>  
 <span data-ttu-id="5ac11-646">識別所要求的樣式索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5ac11-646">The key that identifies the style being requested.</span></span> <span data-ttu-id="5ac11-647">索引鍵參考中的現有資源<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-647">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ac11-648">屬性元素語法是技術上可行，但不是建議使用。</span><span class="sxs-lookup"><span data-stu-id="5ac11-648">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="5ac11-649">請參閱[內嵌樣式和範本](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-649">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="5ac11-650">使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</span><span class="sxs-lookup"><span data-stu-id="5ac11-650">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-651">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-651">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-652">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-652">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="5ac11-653">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-653">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-654">下列範例會建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的集合<xref:System.Windows.Documents.FlowDocument>根項目，並再做為特定樣式的資源時參考<xref:System.Windows.Documents.Paragraph>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-654">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-655">識別 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-655">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <span data-ttu-id="5ac11-656">要求之環境屬性 (Ambient Property) 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-656">The name of the requested ambient property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-657">如需這個成員的描述，請參閱 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-657">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-658">如果 <paramref name="propertyName" /> 可用則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-658">
              <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-659">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5ac11-659">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5ac11-660">只有在 <xref:System.Windows.FrameworkContentElement> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5ac11-660">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-661">取得或設定可以用來儲存關於此元素自訂資訊的任意物件值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-661">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-662">所要的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-662">The intended value.</span>
          </span>
          <span data-ttu-id="5ac11-663">此屬性沒有預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-663">This property has no default value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-664">這個屬性相當於其他 Microsoft 程式撰寫模型，例如 Visual Basic 應用程式或 Windows Form 中的標記屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-664">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="5ac11-665">它被要提供一個預先存在的位置，以儲存自訂一些基本的任何項目資訊，而不會強制應用程式開發人員子類別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-665">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-666">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-666">XAML Values</span></span>  
 <span data-ttu-id="5ac11-667">因為這個屬性會採用一個物件，您必須使用屬性的項目使用方式，若要設定<xref:System.Windows.FrameworkContentElement.Tag%2A>到具有已知與內建的類型轉換器，例如字串的物件以外的任何項目中 XAML 屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-667">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="5ac11-668">以這種方式的物件通常不是標準的 WPF 命名空間內，而且因此可能需要外部命名空間的命名空間對應，就會用作 XAML 項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-668">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-669">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-669">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-670">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-670">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="5ac11-671">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-671">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-672">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-672">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-673">識別 <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-673">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-674">任何參與這個項目之繫結的相關目標屬性變更時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-674">Occurs when any associated target property participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-675">此事件表面<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</span><span class="sxs-lookup"><span data-stu-id="5ac11-675">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="5ac11-676">這通常表示有問題的繫結是雙向繫結和繫結的相依性屬性 affirms 的先前的屬性值，任何驗證或屬性支援的快取配置失效。</span><span class="sxs-lookup"><span data-stu-id="5ac11-676">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="5ac11-677">此事件的事件引數會通知您繫結屬性已變更。</span><span class="sxs-lookup"><span data-stu-id="5ac11-677">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-678">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-678">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-679">取得這個項目的範本父代參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-679">Gets a reference to the template parent of this element.</span>
          </span>
          <span data-ttu-id="5ac11-680">若此項目不是透過範本建立，則這個屬性不相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-680">This property is not relevant if the element was not created through a template.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-681">項目其<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />造成要建立此項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-681">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span>
          </span>
          <span data-ttu-id="5ac11-682">這個值通常是<see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-682">This value is frequently <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-683">範本是範本的內容會一次建立的實際共用的物件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-683">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="5ac11-684">因此，如果您取得的項目，是來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。</span><span class="sxs-lookup"><span data-stu-id="5ac11-684">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="5ac11-685">若要連接這類範本參考頁面的邏輯樹狀結構，您應該會看到<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>值，並繼續瀏覽所需的項目樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="5ac11-685">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="5ac11-686"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 通常會`null`一般物件，因為如果您已在您的應用程式，透過一般方式取得從頁面的物件參考，該項目可能不建立從範本。</span><span class="sxs-lookup"><span data-stu-id="5ac11-686"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="5ac11-687">情況<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>可能無法`null`會包括作業，例如點擊測試的事件處理特定的低階輸入事件，或使用列舉值，可能會傳回來自範本的項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-687">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-688">取得或設定工具提示物件，該物件會為[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中的這個項目而顯示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-688">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5ac11-689">工具提示物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-689">The tooltip object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-690">如果這個屬性的值屬於類型<xref:System.Windows.Controls.ToolTip>，就是將用於工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5ac11-690">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="5ac11-691">如果值為任何其他類型的則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。</span><span class="sxs-lookup"><span data-stu-id="5ac11-691">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="5ac11-692">如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-692">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="5ac11-693">服務類別會提供可用來進一步自訂工具提示的附加的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-693">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5ac11-694">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="5ac11-694">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5ac11-695">XAML 屬性項目用法</span><span class="sxs-lookup"><span data-stu-id="5ac11-695">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5ac11-696">XAML 值</span><span class="sxs-lookup"><span data-stu-id="5ac11-696">XAML Values</span></span>  
 <span data-ttu-id="5ac11-697">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="5ac11-697">*toolTipContent*</span></span>  
 <span data-ttu-id="5ac11-698">成為的顯示文字的字串<xref:System.Windows.FrameworkContentElement.ToolTip%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-698">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="5ac11-699">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="5ac11-699">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="5ac11-700">提供物件項目表單，應該做的內容中的某些物件<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-700">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="5ac11-701">通常這會是<xref:System.Windows.FrameworkElement>或其他項目所建立的版面配置複合<xref:System.Windows.FrameworkContentElement.ToolTip%2A>，最後會包含在複合 （compositing） 內的文字內容。</span><span class="sxs-lookup"><span data-stu-id="5ac11-701">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="5ac11-702">這項用法中<xref:System.Windows.Controls.ToolTip>會建立項目會隱含地從剖析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-702">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="5ac11-703"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="5ac11-703"><`ToolTip` .../></span></span>  
 <span data-ttu-id="5ac11-704">請參閱 <xref:System.Windows.Controls.ToolTip>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-704">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5ac11-705">相依性屬性資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-705">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-706">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-706">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="5ac11-707">若要設定的中繼資料屬性 `true`</span><span class="sxs-lookup"><span data-stu-id="5ac11-707">Metadata properties set to `true`</span></span>|<span data-ttu-id="5ac11-708">無</span><span class="sxs-lookup"><span data-stu-id="5ac11-708">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-709">下列範例會設定的值<xref:System.Windows.FrameworkElement.ToolTip%2A>屬性直接設為字串。</span><span class="sxs-lookup"><span data-stu-id="5ac11-709">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-710">在項目上的任何工具提示正要關閉之前發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-710">Occurs just before any tooltip on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-711">若要隱藏關閉工具提示，事件處理常式應將其標記為已處理。</span><span class="sxs-lookup"><span data-stu-id="5ac11-711">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="5ac11-712">此事件不可以是<xref:System.Windows.EventTrigger>樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-712">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="5ac11-713">這是因為此事件的識別項欄位會重複使用從服務不會公開事件的 新增/移除方法的實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-713">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-714">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-714">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-715">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-715">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="5ac11-716">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-716">Routing strategy</span></span>|<span data-ttu-id="5ac11-717">直接</span><span class="sxs-lookup"><span data-stu-id="5ac11-717">Direct</span></span>|  
|<span data-ttu-id="5ac11-718">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-718">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-719">識別 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-719">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-720">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-720">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-721">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-721">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-722">任何元素的工具提示開啟時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-722">Occurs when any tooltip on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-723">若要以手動方式開啟工具提示，為已處理的事件處理常式時，應該標示相關的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-723">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="5ac11-724">否則，值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性會用來自動開啟操作功能表。</span><span class="sxs-lookup"><span data-stu-id="5ac11-724">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="5ac11-725">標記處理的事件會有效地取消的預設動作，並可能是重設的值有機會<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="5ac11-725">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="5ac11-726">請注意，將不會引發此事件是否<xref:System.Windows.FrameworkContentElement.ToolTip%2A>為 null 參考或其他未設定。</span><span class="sxs-lookup"><span data-stu-id="5ac11-726">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="5ac11-727">此事件不可以是<xref:System.Windows.EventTrigger>樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-727">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="5ac11-728">這是因為此事件的識別項欄位會重複使用從服務不會公開事件的 新增/移除方法的實作。</span><span class="sxs-lookup"><span data-stu-id="5ac11-728">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-729">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-729">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-730">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-730">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="5ac11-731">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-731">Routing strategy</span></span>|<span data-ttu-id="5ac11-732">直接</span><span class="sxs-lookup"><span data-stu-id="5ac11-732">Direct</span></span>|  
|<span data-ttu-id="5ac11-733">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-733">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-734">識別 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-734">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-735">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-735">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-736">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-736">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-737">識別 <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-737">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="5ac11-738">要尋找之資源的索引鍵識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-738">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-739">以指定的索引鍵搜尋資源；如果找到，則傳回該資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-739">Searches for a resource with the specified key, and returns that resource if found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ac11-740">找到的資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-740">The found resource.</span>
          </span>
          <span data-ttu-id="5ac11-741">如果找不到資源，就會傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-741">If no resource was found, <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-742">如果呼叫的項目上找不到資源，是父樹狀結構會搜尋樹狀結構的相同方式使用邏輯樹狀結構中，搜尋索引鍵，在執行階段所要求的動態資源參考。</span><span class="sxs-lookup"><span data-stu-id="5ac11-742">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="5ac11-743">通常您會立即傳回值轉換成您嘗試使用傳回的資源值設定屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="5ac11-743">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="5ac11-744"><xref:System.Windows.FrameworkContentElement.FindResource%2A>方法有類似的行為不同之處在於它會擲回例外狀況在不使用提供的索引鍵尋找資源的情況下。</span><span class="sxs-lookup"><span data-stu-id="5ac11-744">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ac11-745">下列範例會尋找在標記中定義的資源，並套用至元素為了回應路由事件的特定屬性。</span><span class="sxs-lookup"><span data-stu-id="5ac11-745">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-746">當項目從已載入項目的項目樹狀結構中移除時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-746">Occurs when the element is removed from an element tree of loaded elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-747">直接路由的事件不會遵循路由，它們才會處理在相同的項目，其引發。</span><span class="sxs-lookup"><span data-stu-id="5ac11-747">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="5ac11-748">直接路由的事件支援其他路由的事件的行為： 它們支援的可存取的處理常式集合，且可用來當做<xref:System.Windows.EventTrigger>樣式。</span><span class="sxs-lookup"><span data-stu-id="5ac11-748">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5ac11-749">路由事件資訊</span><span class="sxs-lookup"><span data-stu-id="5ac11-749">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5ac11-750">識別項欄位</span><span class="sxs-lookup"><span data-stu-id="5ac11-750">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="5ac11-751">路由策略</span><span class="sxs-lookup"><span data-stu-id="5ac11-751">Routing strategy</span></span>|<span data-ttu-id="5ac11-752">直接</span><span class="sxs-lookup"><span data-stu-id="5ac11-752">Direct</span></span>|  
|<span data-ttu-id="5ac11-753">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="5ac11-753">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-754">識別 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-754">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-755">註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，則可用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="5ac11-755">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5ac11-756">識別項物件包含的識別名稱、 擁有者類型、 處理常式的類型、 路由策略和公用程式方法新增擁有者的事件。</span><span class="sxs-lookup"><span data-stu-id="5ac11-756">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5ac11-757">要從目前範圍中移除的「名稱-物件」配對名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-757">Name of the name-object pair to remove from the current scope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ac11-758">簡化對 <see cref="T:System.Windows.NameScope" /> 取消註冊方法的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-758">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ac11-759">您只會要取消註冊名稱，如果您想要重新註冊該相同名稱的另一個項目。</span><span class="sxs-lookup"><span data-stu-id="5ac11-759">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5ac11-760">重新將預設樣式套用至目前 <see cref="T:System.Windows.FrameworkContentElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ac11-760">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>