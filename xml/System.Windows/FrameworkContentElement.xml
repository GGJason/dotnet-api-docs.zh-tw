<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="615425e7a431643682b3286cc26cb17aa80cb9d4" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660302" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" /> 是 WPF 架構層級實作和 <see cref="T:System.Windows.ContentElement" /> 基底類別的擴充。 <see cref="T:System.Windows.FrameworkContentElement" /> 新增對其他輸入 API (包括工具提示和操作功能表)、腳本、資料繫結程序的資料內容、樣式，以及邏輯樹狀結構協助程式 API 的支援。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> 尚未定義自己的轉譯行為。具現化實際<xref:System.Windows.FrameworkContentElement>中程式碼或標記的類別執行個體可能會但會顯示在中為 nothing[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 轉譯邏輯必須採取的類別由提供<xref:System.Windows.FrameworkContentElement>一部分，其內容的模型，或是在子項目<xref:System.Windows.FrameworkContentElement>衍生的類別。  
  
 <xref:System.Windows.FrameworkContentElement> 刻意平行設計很多相同[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]為<xref:System.Windows.FrameworkElement>。 請注意，某些[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>不會有<xref:System.Windows.FrameworkContentElement>相等。 有幾個<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]有的功能，例如幾何表示法或版面配置，哪些不相關的<xref:System.Windows.FrameworkContentElement>。  
  
 大部分的現有<xref:System.Windows.FrameworkContentElement>衍生的類別中將可以找到<xref:System.Windows.Documents>命名空間。 許多這些衍生類別實作非固定格式文件模型項的目。 某些衍生的類別，例如<xref:System.Windows.Documents.Hyperlink>有一些類似的控制項的功能，但衍生自<xref:System.Windows.FrameworkContentElement>，這類控制項類似的項目仍然可以參與非固定格式文件模型。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkContentElement" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要加入的子項目。</param>
        <summary>加入所提供的項目作為這個項目的子項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可以擲回例外狀況，如果呼叫時之邏輯樹狀結構正在反覆執行另一個處理序一次。  
  
 大部分<xref:System.Windows.FrameworkContentElement>衍生的類別會公開專用的集合負責內含項目 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。 您通常可以避免不需要直接操作之邏輯樹狀結構，如果您改為衍生自這些類別。 使用內容項目的邏輯樹狀結構是進階的案例可能需要特殊的剖析器或特殊<xref:System.Windows.FrameworkElement>，可做為父轉譯項目 （內容主機）。  
  
 如需有關如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>已在初始化項目之前呼叫。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>覆寫這個方法以提供您的項目初始化期間載入處理序的項目之前，應該會發生的特殊處理。  
  
 您的實作應該呼叫基底實作，因為基底 （預設值） 實作設定追蹤的初始設定部分內部旗標。  
  
 基底實作將會擲回例外狀況，如果<see cref="M:System.Windows.FrameworkContentElement.BeginInit" />之前達到相同的項目上呼叫一次以上<see cref="M:System.Windows.FrameworkContentElement.EndInit" />。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始提供之腳本中包含的動作順序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <summary>開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <param name="handoffBehavior">列舉型別的值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</param>
        <summary>使用若屬性已經顯示動畫時應發生之情形的指定選項，開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要開始的腳本。</param>
        <param name="handoffBehavior">列舉值，其描述若腳本中描述的屬性已顯示動畫時，所要使用的行為。</param>
        <param name="isControllable">宣告在動畫啟動後，是否可以控制 (暫停) 該動畫。</param>
        <summary>使用控制啟動後之動畫的指定狀態，開始提供之腳本中包含的動作順序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到"填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除這些時鐘。  
  
 若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有數種方式可移除時鐘：  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用於項目的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>可以用來驗證物件的多個屬性的值。 例如，假設應用程式會提示使用者輸入的位址，然後填入型別的物件`Address`，其中具有屬性`Street`， `City`， `ZipCode`，和`Country`，值的使用者提供。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。 例如，<xref:System.Windows.Controls.ValidationRule>可以確保，郵遞區號就是有效的地址的國家/地區。  
  
 子項目會繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|中繼資料屬性設定為 **，則為 true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在內含此項目的任何可捲動區域內，嘗試將此項目帶入檢視。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫這個方法，您實際上會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上任何父可捲動區域包含的項目 (父系很可能是<xref:System.Windows.FrameworkElement>，而非<xref:System.Windows.FrameworkContentElement>)。 如果這個項目不包含在可捲動區域，仍然會引發事件，但會有任何作用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定內容功能表項目，該項目應該在每當從這個項目內透過[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要求內容功能表時出現。</summary>
        <value>這個項目使用的內容功能表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例狀況<xref:System.Windows.Controls.ContextMenu>上<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在項目上的任何內容功能表正要關閉之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要隱藏關閉內容功能表的 事件處理常式應將其標記為已處理。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考的基礎服務的事件識別項：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎的服務事件不會正確對應<xref:System.Windows.FrameworkContentElement.ContextMenuClosing>觸發程序中使用的識別項)。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 下列範例會實作具名區透過變更資料指標的處理常式`DisplayArea`（未顯示）。 註解提示<xref:System.Windows.UIElement>使用量，事實上，此範例就會相同，但如果`DisplayArea`已<xref:System.Windows.FrameworkContentElement>。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目上的任何內容功能表開啟時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手動開啟內容功能表，為已處理的事件處理常式時，應該標記相關的事件。 否則，現有的值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性會用來自動開啟內容功能表。 標記處理事件會有效地取消的預設動作，並可能會重設的值有機會<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。 不過，是您應該注意的時間問題。 為了完全取代透過內容功能表<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>處理常式中，初始的內容功能表必須不是 null 或空白。 或者，您可能需要處理事件，並手動開啟新的內容功能表。 如需詳細資訊，請參閱[如何： 處理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考的基礎服務的事件識別項：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (這種用法是必要的因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎的服務事件不會正確對應<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>觸發程序中使用的識別項)。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定滑鼠指標在此元素上方時所顯示的游標。</summary>
        <value>要顯示的游標。 預設值依這個相依性屬性定義為 <see langword="null" />。 不過，執行階段的實際預設值會受各種因素影響。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。 提供的字串應評估為<xref:System.Windows.Input.CursorType>值。 如需詳細資訊，請參閱<xref:System.Windows.Input.Cursor>。  
  
 這個屬性所建立的資料指標將還是不會顯示當滑鼠指標位在這個項目也是取決於值的<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>屬性。 此外，事件相關的考量，例如使用中拖曳滑鼠擷取、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性的值。  
  
 若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。  
  
 `null`預設真的表示實際的資料指標的值判斷此處延後，應該從別處取得。 如果透過任何程式設計的值，從任何來源，預設資料指標不看到[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]應用程式將會箭號。  
  
 每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.ContentElement.QueryCursor>事件。 事件反昇，且此路由上的任何項目都有機會處理事件，並設定透過此事件的引數的資料指標的值。 如果發生這種情況，事件處理，而且引數中已變更的值優先順序高於值<xref:System.Windows.FrameworkContentElement.Cursor%2A>屬性在任何層級，除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>設定。  
  
 如果未建立自訂游標，通常您設定此屬性的靜態屬性值<xref:System.Windows.Input.Cursors>類別。  
  
 設定<xref:System.Windows.Input.Cursor>自訂值中未啟用部分信任。 如需有關自訂的資料指標的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會設定為某個自訂值的資料指標。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目在參與資料繫結時的資料內容。</summary>
        <value>用做為資料內容的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，例如路徑的繫結的繫結來源的相關資訊。  
  
 資料內容設為直接[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，並將該物件的內容來評估的繫結。 或者，您可以將資料內容設<xref:System.Windows.Data.DataSourceProvider>物件。  
  
 這個相依性屬性會繼承屬性值。 如果有任何其他值作為具有子元素<xref:System.Windows.FrameworkContentElement.DataContext%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkContentElement.DataContext%2A>指派此值與最接近的父項目的值。  
  
 或者，您可以使用的下列屬性的其中一個<xref:System.Windows.Data.Binding>類別來明確指定繫結來源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。 如需詳細資訊，請參閱[How to： 指定的繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkContentElement.DataContext%2A>最常當做設<xref:System.Windows.Data.Binding>宣告。 您可以使用屬性項目語法或屬性語法。 在範例中，此頁面上顯示屬性語法。 您也可以設定<xref:System.Windows.FrameworkContentElement.DataContext%2A>程式碼中。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 直接內嵌的物件做為父項目中的任何繫結的資料內容。 一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>子類別。 或者，任何未經處理資料[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]物件適用於繫結，可能會放在這裡，以實際的繫結稍後所定義的類型。  
  
 *bindingUsage*  
 評估為適當的資料內容繫結使用方式。 如需詳細資訊，請參閱[Binding 標記延伸模組](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 下列其中之一： `StaticResource`，或`DynamicResource`。 定義為資源中之物件的未經處理資料時，就會使用這種使用方式。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 從所要求之物件的金鑰識別碼<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，藉由建立新的自訂資料物件，建立該物件做為<xref:System.Windows.FrameworkContentElement.DataContext%2A>，並將繫結路徑設定為它的屬性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的資料內容變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需資料內容和資料繫結的說明，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  項目時<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影響的變更，這個項目上的所有資料繫結屬性。 這適用於任何項目之子代項目的目前的項目繼承的資料內容，以及目前的項目本身。 所有此類繫結重新解譯新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映新的值繫結中。 進行這些變更，相對於引發的順序不保證<xref:System.Windows.FrameworkContentElement.DataContextChanged>事件。  事件之後，或以任何混合事件之前發生的變更。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定索引鍵，以用來在佈景主題中尋找這個控制項的樣式樣板。</summary>
        <value>樣式索引鍵。 若要正確運做為佈景主題查詢的一部分，這個值必須是要加上樣式之項目的 <see cref="T:System.Type" />。 <see langword="null" /> 在某些案例中可接受的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 透過任何其直接 setter 通常未設定此屬性。 相反地，您會覆寫這個相依性屬性的特定類型的中繼資料每次建立新的子類別。 當您子類別化，此時會呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>針對方法<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>控制項子類別的靜態建構函式識別項。  
  
 比方說，這類的內嵌類別<xref:System.Windows.Documents.Bold>確實具有超過覆寫很少實作<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>其靜態建構函式，而且已公開數個執行個體建構函式中的中繼資料。 項目，以事實<xref:System.Windows.Documents.Bold>標記改善<xref:System.Windows.Documents.TextElement.FontWeight%2A>屬性<xref:System.Windows.FontWeights.Bold%2A>實作內設定的預設值所參考的佈景主題樣式<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>至`typeof(Bold)`。  
  
 如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>屬性`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在初始化項目之後立即呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作這個方法以提供您的項目初始化期間載入處理序的項目時應該發生的特殊處理。  
  
 您的實作應該呼叫基底實作，因為基底 （預設值） 實作設定追蹤的初始設定部分內部旗標。  
  
 如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>之前已呼叫過，基底實作將會引發<xref:System.Windows.FrameworkContentElement.Initialized>事件。 否則，如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>，不會呼叫也不可以是取決於是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已呼叫，不會引發事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要搜尋的項目名稱。</param>
        <summary>尋找具有所提供之識別項名稱的項目。</summary>
        <returns>要求的項目。 如果找不到相符的項目，則可能為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目具有子項目，這些子項目會遞迴搜尋所有要求的具名項目。  
  
   
  
## Examples  
 下列範例會依名稱參考中找到的項目上設定屬性<xref:System.Windows.Documents.FlowDocument>頁面上。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的索引鍵識別項。</param>
        <summary>搜尋具有指定索引鍵的資源，並將於找不到要求的資源時擲回例外狀況。</summary>
        <returns>找到的資源，如果找不到相符的資源則為 <see langword="null" /> (若為 <see langword="null" /> 時也會擲回例外狀況)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。 如果您不想處理例外狀況，此情況下的，您應該呼叫<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>。 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 傳回`null`當找到，任何資源，並不會擲回例外狀況。  
  
 如果呼叫的項目上找不到資源，父樹狀結構會搜尋使用的邏輯樹狀結構，在樹狀結構的相同方式搜尋的若資源所要求在執行階段的金鑰。  
  
 通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。  
  
   
  
## Examples  
 下列範例會尋找標記中所定義的資源並將其套用至特定路由事件的回應中的項目屬性。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到要求的資源索引鍵。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，這個物件可自訂外觀、效果或其他樣式特性，以在這個項目捕捉到鍵盤焦點時套用至此項目。</summary>
        <value>要在取得焦點時套用的樣式。 相依性屬性中所宣告的預設值是空的靜態 <see cref="T:System.Windows.Style" />。 不過，執行階段的有效值通常是 (但不一定總是) 佈景主題支援為控制項所提供的樣式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、 樣式幾乎都資源，而非內嵌的項目，定義和資源通常是當做參考<xref:System.Windows.StaticResourceExtension>。  
  
 請注意，這個屬性會影響視覺外觀，但不會報告，在中繼資料。 這是因為視覺外觀變更是事件驅動和在任何時候，可能不適用，因此通常不應報告中繼資料中的任何視覺效果或版面配置資訊。  
  
 在概念上，套用至控制項的焦點視覺行為應該保持一致項目。 如果您正在撰寫整個佈景主題，只變更焦點視覺化樣式為最實用的方式，來強制執行一致性。 在個別的樣式，而非佈景主題的部分設定這個屬性不是預定的使用方式，這個屬性，因為它可能會造成混淆的使用者經驗，關於鍵盤焦點。 如果您打算是刻意不一致的佈景主題的項目特定行為，更好的方法是使用觸發程序在樣式為個別的輸入的狀態的屬性，例如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做並不會以方式以視覺化方式會影響任何現有的焦點視覺化樣式。 如需有關的設計目的<xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A>及替代專注屬性，請參閱[樣式的焦點在控制項和 FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式的索引鍵。 索引鍵參考中現有的資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示此 <see cref="T:System.Windows.FrameworkContentElement" /> 是否應強制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 呈現游標，如這個執行個體的 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 屬性所宣告。</summary>
        <value>
          如果要在游標位於此項目上方時，強制游標展示使用此執行個體的游標設定 (包括在所有子項目上) 則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性設定為`true`將會覆寫的子項目所建立的資料指標喜好設定。 這樣做，一般應用程式[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能會造成混淆的使用者，特別是如果子元素嘗試以指定資料指標。 設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>中控制項的子類別化或複合 （compositing） 的情況下更適當。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會強制資料指標在元素上方。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要取得繫結的目標 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>取得指定屬性之繫結的 <see cref="T:System.Windows.Data.BindingExpression" />。</summary>
        <returns>如果目標已資料繫結則傳回 <see cref="T:System.Windows.Data.BindingExpression" />，否則傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會擷取藉由查詢屬性的繫結。  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果沒有視覺父代，則傳回這個項目的替代邏輯父代。 在這個情況下，<see cref="T:System.Windows.FrameworkContentElement" /> 父代一律會與 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 屬性的值相同。</summary>
        <returns>每當這個方法的 WPF 架構層級實作具有非視覺父連線時，傳回 <see langword="null" /> 以外的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回預期的單一視覺父代。 自訂實作可能會傳回替代的父代關聯性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個 <see cref="T:System.Windows.FrameworkContentElement" /> 初始化時發生。 這符合 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 屬性值從 <see langword="false" /> (或未定義) 變更為 <see langword="true" /> 的案例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件將在每次引發<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>呼叫的方法。 這些方法無法呼叫由審慎的程式碼，或藉由[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]載入程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個 <see cref="T:System.Windows.FrameworkContentElement" /> 所用的輸入內容。</summary>
        <value>輸入範圍，可修改替代輸入法之輸入的解譯方式。 預設值為 <see langword="null" /> (這會導致命令的預設處理)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個相依性屬性會繼承屬性值。 如果有任何其他值作為具有子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkElement.InputScope%2A>指派此值與最接近的父項目的值。  
  
 雖然[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法使用量列為和語法上允許中, 設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]並不常見。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此項目是否已初始化，初始化方式可能是當做[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 載入，或明確地呼叫其 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 方法。</summary>
        <value>
          如果項目已根據先前提到的載入或方法呼叫來初始化則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性也可能`true`如果這個項目已移動項目樹狀目錄中如有新的父項目，並因此變成一次重新載入。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此項目是否已載入以供展示。</summary>
        <value>
          如果目前項目是附加至項目樹狀結構並已呈現則為 <see langword="true" />，如果項目從未附加至已載入的項目樹狀結構則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新建構的執行個體中，這個屬性一開始`false`，且會維持`true`一旦設為`true`，即使後續程式碼中移除。  
  
   
  
## Examples  
 下列範例程式碼使用<xref:System.Windows.FrameworkContentElement.IsLoaded%2A>條件檢查，以確保函式`displayData`（未顯示） 會有有效項目上載入該頁面正常運作，視處理常式的一部分。 相同的邏輯以事件處理常式執行<xref:System.Windows.FrameworkContentElement.Loaded>。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至個別項目的當地語系化/全球化語言資訊。</summary>
        <value>這個項目的文化特性資訊。 預設值為 <see cref="T:System.Windows.Markup.XmlLanguage" /> 執行個體，且其 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值設定為 "en-US" 字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字串格式會依照 RFC 3066 標準。 例如，美國英文是"EN-US"。 請參閱<xref:System.Windows.Markup.XmlLanguage>如需值和格式。  
  
 這個相依性屬性會繼承屬性值。 如果有任何其他值作為具有子元素<xref:System.Windows.FrameworkElement.Language%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkElement.Language%2A>指派此值與最接近的父項目的值。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.Language" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目已配置版面、呈現以及可以互動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為： 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>為此項目的邏輯子項目取得列舉值。</summary>
        <value>此項目之邏輯子項目的列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">要移動焦點的方向，以列舉型別 (Enumeration) 的值表示。</param>
        <summary>將鍵盤焦點從這個項目移至另一個項目。</summary>
        <returns>若成功移動焦點則傳回 <see langword="true" />，若所指定之方向的目標項目不存在則傳回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的識別名稱。 該名稱會提供執行個體參考，以便程式設計程式碼後置 (Code-Behind)，例如事件處理常式程式碼，在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 的剖析期間被建構後便可參考項目。</summary>
        <value>項目的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的用法時，才能指定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]標記中的項目名稱。  
  
 這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 取得<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼並不常見，因為如果已經在程式碼中有適當的參考，您可以直接呼叫方法，而且項目上的屬性參考並不這麼做通常需要<xref:System.Windows.FrameworkContentElement.Name%2A>。 例外狀況是發生在字串中具有某些多載意義，例如是否要顯示在該名稱很有用[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼如果原始<xref:System.Windows.FrameworkContentElement.Name%2A>已從標記設定也不建議使用，並變更屬性並不會變更的物件參考。 這類物件的參考會建立期間，會明確地建立基礎名稱範圍時，才[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]載入。  
  
 您必須特別呼叫<xref:System.Windows.FrameworkContentElement.RegisterName%2A>有效的變更，以便<xref:System.Windows.FrameworkContentElement.Name%2A>已經載入的項目屬性。  
  
 一個值得注意的大小寫設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼，請務必將分鏡腳本的命名項目執行的。 您可以註冊之前，可能也需要具現化，並指派<xref:System.Windows.NameScope>執行個體。 請參閱 < 範例 > 一節中，或[概觀腳本](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 設定<xref:System.Windows.FrameworkContentElement.Name%2A>從程式碼受到限制的應用程式，但依名稱查閱項目是較常見，特別是如果您採用頁面會重新載入到應用程式，執行階段程式碼不一定是程式碼後置的瀏覽模型個別頁面。 公用程式方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkContentElement>，可以找到任何元素<xref:System.Windows.FrameworkContentElement.Name%2A>中項目邏輯樹狀結構以遞迴方式。 或者您可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，這也會採用<xref:System.Windows.FrameworkContentElement.Name%2A>做為引數的字串。  
  
 常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 實作的介面<xref:System.Windows.Markup.INameScope>。 此介面的實作應該強制執行的名稱是其範圍內模稜兩可。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.Name" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫基底實作。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 由於路由的事件可能有子元素，不一定會叫用處理常式項目所引發，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須列入的事件引數的來源屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkContentElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件資料。</param>
        <summary>當 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫 base （）。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkContentElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件資料。</param>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的類別處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別處理常式這個項目上設定適當的焦點行為，如果從這個項目產生事件。 如果事件的來源是在樹狀目錄中的另一個項目，此處理常式沒有任何作用。  
  
 若要變更這些預設焦點行為，您的項目上，覆寫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 事件。 每當 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 設定為 <see langword="true" /> 時會叫用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法的預設實作會引發事件，如本主題稍早所述。 覆寫應呼叫 base （），以保留此行為。  
  
 請注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>屬性是唯讀的。 因此，您無法設定，如此一來強制初始化行為。 初始化設定旨在只有完成[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]架構。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">描述已變更屬性的事件資料 (包含舊值和新值)。</param>
        <summary>每當 <see cref="T:System.Windows.FrameworkContentElement" /> 上任何相依性屬性的有效值已更新時叫用。 已變更的特定相依性屬性會在引數參數中報告。 覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是偵測一般的屬性變更或失效。 它改為僅供修改的一般失效模式如果已知廣泛分類屬性的特定資訊。  
  
 這可能會叫用方法多次物件的存留期間。 因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。 不過，您會使用這個方法如果<xref:System.Windows.FrameworkContentElement>包含大量的值相互關聯的相依性屬性，或如果它包含邏輯，例如轉譯行為，必須重新執行的幾個相關的屬性失效的情況。  
  
 請注意，相同具名`OnPropertyChanged`方法具有不同簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別。 確認`OnPropertyChanged`用於資料物件通知，而且是合約的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>請務必呼叫基底實作，在實作中的第一個作業。 如果沒有這樣做將會大幅停用整個[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統，這會導致不正確地回報的值。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">舊樣式。</param>
        <param name="newStyle">新樣式。</param>
        <summary>當這個項目上的使用中樣式變更時叫用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有設定注意樣式變更狀況的內部旗標的預設實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>請務必呼叫基底實作，否則無法套用樣式。 如果您的衍生的類別有特殊的樣式選取器，或快取，樣式值，可能包含覆寫這個方法的情況。 佈景主題變更可能會叫用這個方法。</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫 base （）。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkContentElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供有關事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 路由事件到達其路由中的這個類別時，便會叫用此方法。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 萬一中繼類別繼承中的已實作此方法，您仍應該呼叫 base （）。  
  
 這個方法的目的是有點像[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 它會提供方法來處理來自衍生類別的類別處理常式，而不是執行個體處理常式的比對事件。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可能已引發由子項目，不一定會叫用處理常式，因此您的實作必須讓事件引數的來源項目帳戶屬性 （和不應嘗試重新引發該事件，在大部分情況下）。 子類別<xref:System.Windows.FrameworkContentElement>無法選擇此路由上收到事件時呼叫私用類別處理常式方法。 一個可能的情況是取用事件的引數，並謹慎地將事件標示為已處理，以縮短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示此項目是否會併入佈景主題樣式中的樣式屬性。</summary>
        <value>
          如果這個項目不會使用佈景主題樣式，所有從樣式產生的屬性都來自本機應用程式樣式，且佈景主題樣式屬性不會套用，則為 <see langword="true" />。 如果應用程式樣式先套用，然後針對不是在應用程式樣式中具體設定的屬性套用佈景主題樣式則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此項目之邏輯樹狀結構中的父代。</summary>
        <value>此項目的邏輯父代。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，根據您的應用程式功能，有可能變更邏輯父項目，可以保留此屬性的值不會反映該變更。 您通常應該取得的值之前您需要它。  
  
 請參閱[中 WPF 樹狀架構](~/docs/framework/wpf/advanced/trees-in-wpf.md)如需有關周遊邏輯樹狀結構和案例適當項目探索朝向這種方式。  
  
 對屬性系統有可能重新計算項目的所有屬性值時，它會重設父代，因為有些屬性是繼承的處理邏輯樹狀結構的值。 <xref:System.Windows.FrameworkContentElement.DataContext%2A>可套用的項目會重設父代時，也可以變更繫結。  
  
 變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。  
  
 最常見的案例使用<xref:System.Windows.FrameworkContentElement.Parent%2A>屬性是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkContentElement>屬性值從父代。 範本，<xref:System.Windows.FrameworkContentElement.Parent%2A>範本的最終會`null`。 若要取得略過此點，並將延伸至邏輯樹狀結構實際套用的範本，請使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>。  
  
   
  
## Examples  
 下列範例會檢查以查看是否<xref:System.Windows.FrameworkContentElement.Parent%2A>的<xref:System.Windows.Documents.TextPointer>屬於特定型別。  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">應用於決定預期焦點變更的方向。</param>
        <summary>決定下一個項目，該項目會針對所提供的焦點移動方向，接收相對於此項目的焦點，但是不會實際移動焦點。 這是已密封的方法，無法覆寫。</summary>
        <returns>如果焦點實際上有周遊時，焦點會移動到的下一個項目。 如果無法依所提供的方向相對於此項目移動焦點，則可能傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 是實際移動焦點的相關的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定下列其中一個方向：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 這些方向對 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 而言不是合法的 (但對 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 而言是合法的)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要用於指定之「名稱-物件」對應的名稱。</param>
        <param name="scopedElement">對應的物件。</param>
        <summary>提供可簡化對 <see cref="T:System.Windows.NameScope" /> 註冊方法之存取的存取子 (Accessor)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.NameScope.RegisterName%2A>。 實作會檢查後續的父項目，直到找到適用<xref:System.Windows.NameScope>實作，其位於藉由尋找可實作項目<xref:System.Windows.Markup.INameScope>。 如需命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 呼叫<xref:System.Windows.FrameworkContentElement.RegisterName%2A>會需要正確的應用程式程式碼中建立時的動畫分鏡腳本連結。 這是因為其中一個索引鍵的分鏡腳本屬性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，會使用執行階段名稱查詢，而不是能夠充分目標項目的參考。 即使該元素是可供參考從程式碼存取，也是如此。 如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[概觀腳本](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。 表示內容項目會比動畫在控制項上，較不常見[概觀腳本](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)專注於控制案例。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要移除的項目。</param>
        <summary>從這個項目的邏輯樹狀中移除指定的項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]大致上是相關的類別衍生的案例中，加入支援的子集合時。  
  
 大部分<xref:System.Windows.FrameworkContentElement>衍生的類別會公開專用的集合負責內含項目 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。 通常衍生自這些類別可以避免不需要直接操作之邏輯樹狀結構。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前本機定義的資源字典。</summary>
        <value>目前本機定義的資源。 這是資源的字典，字典內的資源是依索引鍵來存取。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，且通常是針對任何個別頁面或應用程式的根項目。 放置在此層級的資源字典，可以更輕鬆地尋找個別的子系中的項目頁面 （或從任何頁面上，在應用程式的情況下）。 在大部分的應用程式案例中，我們建議樣式定義做為物件項目內的資源字典，或定義為外部資源，以便可以是獨立的整個樣式資源 （這種方式有助於個別設計工具責任從開發人員責任分隔需要加以編輯的實體檔案）。  
  
 請注意，這個屬性會傳回直接在該元素中宣告的資源字典。 這是不同於實際資源對應程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中所定義的資源。  
  
 資源也可以從集合中的程式碼所參考，但請注意在中建立資源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]絕對不會之前之後存取<xref:System.Windows.FrameworkContentElement.Loaded>宣告字典的項目就會引發。 事實上，資源會以非同步方式剖析，而且甚至<xref:System.Windows.FrameworkContentElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定義資源。 因此您應該通常只存取[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]資源定義為一部分的執行階段程式碼，或透過其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。 當您透過程式碼存取資源時，它是基本上等同於從進行參考[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除，或使用程式碼來查詢集合中的資源所需的方法。 <xref:System.Windows.FrameworkContentElement.Resources%2A>屬性是可設定為支援完全取代項目是一個新的或不同的資源集合的案例<xref:System.Windows.ResourceDictionary>。  
  
 請注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的語法不包括的項目<xref:System.Windows.ResourceDictionary>。 這是隱含的集合語法; 的範例可以省略標記，表示集合項目。 會改為指定做為項目加入至集合的項目。 如需有關隱含的集合和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，請參閱[XAML 語法的詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 其中一個案例其中<xref:System.Windows.ResourceDictionary>還是明確地指定為項目就是引進的一個合併的字典，在此情況下是否有通常該任何子項目<xref:System.Windows.ResourceDictionary>。 如需詳細資訊，請參閱[合併資源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一或多個物件項目，其中每個定義的資源。 每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>值必須是唯一的[X:key 指示詞](~/docs/framework/xaml-services/x-key-directive.md)，從擷取值時做為唯一索引鍵<xref:System.Windows.ResourceDictionary>。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.FrameworkContentElement.Resources%2A>集合<xref:System.Windows.Documents.FlowDocument>根項目。 <xref:System.Windows.Documents.FlowDocument> 是一般的選擇，因為它是其中一個少數<xref:System.Windows.FrameworkContentElement>於頁面根或更高等級例如在應用程式通常會儲存為根項目和資源有意義的類別。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將繫結附加至指定相依性屬性的這個項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">識別繫結屬性。</param>
        <param name="path">用於繫結之屬性的來源屬性名稱或路徑。</param>
        <summary>根據提供給資料來源做為路徑限定性條件的來源屬性名稱，將繫結附加至這個項目。</summary>
        <returns>記錄繫結的條件。 這個傳回值對錯誤檢查很有用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>依據提供`path`參數。 此簽章是更方便，如果您要建立簡單的預設繫結。 如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。  
  
   
  
## Examples  
 下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，藉由建立新的自訂資料物件，建立該物件做為<xref:System.Windows.FrameworkContentElement.DataContext%2A>，並將繫結路徑設定為它的屬性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">識別繫結屬性。</param>
        <param name="binding">表示資料繫結。</param>
        <summary>根據提供的繫結物件，將繫結附加至這個項目。</summary>
        <returns>記錄繫結的條件。 這個傳回值對錯誤檢查很有用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>。  
  
   
  
## Examples  
 下列範例會設定繫結上<xref:System.Windows.Documents.Paragraph>項目，來建立新<xref:System.Windows.Data.Binding>並將來源設定為新建置`DateTime`物件。  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">資源繫結到的屬性。</param>
        <param name="name">資源名稱。</param>
        <summary>搜尋具有指定名稱的資源，並針對指定的屬性建立該資源的資源參考。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資源參考是可讓您使用類似[DynamicResource 標記延伸](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)標記中。 資源參考建立內部的運算式，提供執行階段的延遲為基礎的指定屬性的值。 每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 屬性的內容序列化。</summary>
        <returns>
          如果應序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`，只要至少一個索引鍵的資源正在本機<xref:System.Windows.FrameworkContentElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 屬性的內容序列化。</summary>
        <returns>
          如果應序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.Style>本機設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當參與這個項目之繫結的任何關聯資料來源變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件介面<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個項目要使用的樣式。</summary>
        <value>如有，則為項目已套用的非預設樣式。 否則為 <see langword="null" />。 預設建構之 <see cref="T:System.Windows.FrameworkContentElement" /> 的預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的樣式，通常是由預設樣式來自主題設定，或從通常由在網頁或應用程式層級 （隱含樣式） 的資源套用至該類型的物件的樣式。 這個屬性不會設定或傳回預設 （佈景主題） 樣式，但會傳回隱含樣式或明確的樣式。 在隱含或明確樣式的情況下，樣式是做為資源的存取，或在本機定義並不重要。  
  
 設定樣式會有一些限制。 您可以重設整個<xref:System.Windows.FrameworkContentElement.Style%2A>屬性至新<xref:System.Windows.Style>在任何時間，這會強制配置重新編輯畫。 不過，一旦該樣式會放在使用中載入的項目，<xref:System.Windows.Style>應該被視為已密封。 嘗試變更的任何個別的使用中樣式屬性 (例如在集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。 標記中定義的樣式會被視為正在使用中，一旦載入時將它從資源字典 （資源），或載入它包含在的頁面 （適用於內嵌樣式）。  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 是具有特殊的優先順序的相依性屬性。 本機設定樣式通常都是在運作的最高的優先順序屬性系統中。 如果<xref:System.Windows.FrameworkContentElement.Style%2A>為 null 此時，對屬性系統會檢查隱含樣式為定義該類型指定的資源的載入期間。 如果樣式時仍然是 null，這個步驟之後，將樣式來自於預設 （佈景主題） 的樣式，但中不會傳回預設樣式<xref:System.Windows.FrameworkContentElement.Style%2A>屬性值。 請參閱[相依性屬性的值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 下列其中之一:、 或。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別所要求的樣式的索引鍵。 索引鍵參考中現有的資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.FrameworkContentElement.Resources%2A>集合<xref:System.Windows.Documents.FlowDocument>根項目，並再做為特定樣式的資源時參考<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求之環境屬性 (Ambient Property) 的名稱。</param>
        <summary>如需這個成員的描述，請參閱 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>
          如果 <paramref name="propertyName" /> 可用則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.FrameworkContentElement> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可以用來儲存關於此元素自訂資訊的任意物件值。</summary>
        <value>所要的值。 此屬性沒有預設值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性相當於其他 Microsoft 程式撰寫模型，例如 Visual Basic 應用程式或 Windows Form 中的標記屬性。 它被用來提供已存在的位置來儲存任何項目相關的一些基本自訂資訊，而不未強制子類別化的應用程式開發人員。  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML 值  
 因為此屬性會接受物件，您必須使用屬性項目用法才能設定<xref:System.Windows.FrameworkContentElement.Tag%2A>屬性在 XAML 中具有已知與內建型別轉換子，例如字串的物件以外的任何項目。 這種方式中使用的物件通常不是在標準 WPF 命名空間內，因此可能也需要命名空間對應至外部命名空間才能引進做為 XAML 項目。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>任何參與這個項目之繫結的相關目標屬性變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件介面<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。 這通常表示有問題的繫結是雙向繫結和繫結的相依性屬性 affirms 的任何驗證或快取的配置屬性支援先前的屬性值失效。  
  
 此事件的事件引數會通知您繫結屬性已變更。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個項目的範本父代參考。 若此項目不是透過範本建立，則這個屬性不相關。</summary>
        <value>項目其<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />造成要建立這個項目。 這個值通常是<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 範本是範本的內容會一次建立的實際共用的物件。 因此，如果您取得的項目，以來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。 若要連接至邏輯樹狀結構頁面的這類的範本參考，您應該取得<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>值，並繼續瀏覽所需的項目樹狀結構。  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 通常會`null`一般物件，因為如果您透過一般方式在應用程式中取得的物件參考，從頁面，該項目可能不建立從範本。 狀況下<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>可能`null`會包含作業，例如點擊測試的事件處理某些低階的輸入事件，或使用列舉值，可能會傳回來自範本的項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定工具提示物件，該物件會為[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中的這個項目而顯示。</summary>
        <value>工具提示物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性的值屬於型別<xref:System.Windows.Controls.ToolTip>，就是將用於工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值為任何其他型別，則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。 如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>。 服務類別提供可用來進一步自訂工具提示的附加的屬性。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 會變成顯示的文字字串<xref:System.Windows.FrameworkContentElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 提供物件項目表單，應該做的內容中的某些物件<xref:System.Windows.FrameworkContentElement>。 通常這會是<xref:System.Windows.FrameworkElement>或其他項目所建立的配置複合<xref:System.Windows.FrameworkContentElement.ToolTip%2A>，最後會包含與撰寫的文字內容。 在這種用法，<xref:System.Windows.Controls.ToolTip>元素建立隱含從已剖析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>屬性。  
  
 <`ToolTip` .../>  
 請參閱 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會設定的值<xref:System.Windows.FrameworkElement.ToolTip%2A>屬性直接設為字串。  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在項目上的任何工具提示正要關閉之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要隱藏關閉工具提示，此事件處理常式應將其標記為已處理。  
  
 此事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用的服務，不會公開事件上的 新增/移除方法中的實作。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>任何元素的工具提示開啟時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要以手動方式開啟工具提示，為已處理的事件處理常式時，應該標記相關的事件。 否則，值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性會用來自動開啟內容功能表。 標記處理事件會有效地取消的預設動作，並可能會重設的值有機會<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性，然後開啟 新<xref:System.Windows.Controls.ContextMenu>。 請注意是否，不會引發這個事件<xref:System.Windows.FrameworkContentElement.ToolTip%2A>為 null 參考或其他未設定。  
  
 此事件不可以是<xref:System.Windows.EventTrigger>樣式。 這是因為此事件的識別項欄位會重複使用的服務，不會公開事件上的 新增/移除方法中的實作。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的索引鍵識別項。</param>
        <summary>以指定的索引鍵搜尋資源；如果找到，則傳回該資源。</summary>
        <returns>找到的資源。 如果找不到資源，就會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果呼叫的項目上找不到資源，父樹狀結構中搜尋樹狀結構的相同方式，使用邏輯樹狀目錄中，如果在執行階段的索引鍵所要求的動態資源參考的搜尋。  
  
 通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A>方法具有類似的行為不同之處在於它將會擲回例外狀況在未使用提供的索引鍵中尋找資源的情況下。  
  
   
  
## Examples  
 下列範例會尋找標記中所定義的資源並將其套用至特定路由事件的回應中的項目屬性。  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目從已載入項目的項目樹狀結構中移除時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為： 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [路由事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要從目前範圍中移除的「名稱-物件」配對名稱。</param>
        <summary>簡化對 <see cref="T:System.Windows.NameScope" /> 取消註冊方法的存取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您只需要取消註冊名稱如果您想要重新註冊該相同名稱的另一個項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新將預設樣式套用至目前 <see cref="T:System.Windows.FrameworkContentElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>