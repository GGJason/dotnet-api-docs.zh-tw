<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd1d7e305ec3d1fa755f07314f69612f0da3ba2a" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39852578" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>封裝 Windows Presentation Foundation 應用程式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 會封裝的類別[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]應用程式特有的功能，包括下列：  
  
-   **應用程式存留期**: <xref:System.Windows.Application.Activated>， <xref:System.Windows.Application.Current%2A>， <xref:System.Windows.Application.Deactivated>， <xref:System.Windows.Application.DispatcherUnhandledException>， <xref:System.Windows.Application.Exit>， <xref:System.Windows.Application.Run%2A>， <xref:System.Windows.Application.SessionEnding>， <xref:System.Windows.Application.Shutdown%2A>， <xref:System.Windows.Application.ShutdownMode%2A>， <xref:System.Windows.Application.Startup>。  
  
-   **應用程式範圍視窗、 屬性和資源管理**: <xref:System.Windows.Application.FindResource%2A>， <xref:System.Windows.Application.GetContentStream%2A>， <xref:System.Windows.Application.GetResourceStream%2A>， <xref:System.Windows.Application.LoadComponent%2A>， <xref:System.Windows.Application.MainWindow%2A>， <xref:System.Windows.Application.Properties%2A>， <xref:System.Windows.Application.Resources%2A>， <xref:System.Windows.Application.StartupUri%2A>， <xref:System.Windows.Application.Windows%2A>。  
  
-   **命令列參數，並結束程式碼處理**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>， <xref:System.Windows.Application.Exit?displayProperty=nameWithType>， <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>。  
  
-   **瀏覽**: <xref:System.Windows.Application.FragmentNavigation>， <xref:System.Windows.Application.LoadCompleted>， <xref:System.Windows.Application.Navigated>， <xref:System.Windows.Application.Navigating>， <xref:System.Windows.Application.NavigationProgress>， <xref:System.Windows.Application.NavigationStopped>， <xref:System.Windows.Application.NavigationFailed>， <xref:System.Windows.Application.SetCookie%2A>， <xref:System.Windows.Application.GetCookie%2A>。  
  
 <xref:System.Windows.Application> 實作單一模式，以提供其視窗、 屬性和資源範圍內的服務的共用的存取。 因此，只有一個執行個體<xref:System.Windows.Application>類別可由每個<xref:System.AppDomain>。  
  
 您可以實作<xref:System.Windows.Application>使用標記、 標記和程式碼後置或程式碼。 如果<xref:System.Windows.Application>都使用實作標記，標記檔案標記或標記和程式碼後置，必須設定為是否[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]`ApplicationDefinition`項目。  
  
> [!NOTE]
>  獨立應用程式不需要<xref:System.Windows.Application>物件，就可以實作自訂`static`進入點方法 (`Main`)，而不需要建立的執行個體中開啟的視窗<xref:System.Windows.Application>。 不過，[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]需要<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例示範的標準應用程式的方式定義只使用標記：  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 下列範例示範如何使用定義標準的應用程式僅限程式碼：  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 下列範例示範的標準應用程式的方式使用標記和程式碼後置的組合所定義。  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用<see langword="static" />(<see langword="Shared" /> Visual Basic 中) 的這種類型的成員都是安全執行緒。 颾魤 ㄛ<see cref="M:System.Windows.Application.FindResource(System.Object)" />並<see cref="M:System.Windows.Application.TryFindResource(System.Object)" />方法並<see cref="P:System.Windows.Application.Properties" />和<see cref="P:System.Windows.Application.Resources" />屬性都是安全執行緒。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Application" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有一個執行個體<xref:System.Windows.Application>類別可由每個<xref:System.AppDomain>，以確保單一資料集的應用程式範圍視窗、 屬性和資源的共用的存取。 因此，預設的建構函式<xref:System.Windows.Application>類別會偵測是否已初始化的執行個體中的第一個執行個體<xref:System.AppDomain>; 如果不是，<xref:System.InvalidOperationException>就會擲回。  
  
 <xref:System.Windows.Application>目前的物件<xref:System.AppDomain>公開靜態<xref:System.Windows.Application.Current%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">每一個 <see cref="T:System.Windows.Application" /> 建立一個以上的 <see cref="T:System.AppDomain" /> 執行個體。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式變成前景應用程式時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟動 Windows Presentation Foundation 應用程式具有一個或多個開啟的視窗 （變成前景應用程式） 當其中一個視窗啟動第一次啟動應用程式，因為或何時啟動其中一個視窗時應用程式處於非使用中： 特別是，啟用，就會發生時：  
  
-   應用程式開啟了第一個視窗。  
  
-   使用 ALT + TAB，或使用 工作管理員，使用者會切換至應用程式。  
  
-   使用者按一下其中一個在應用程式視窗的工作列按鈕。  
  
 要在啟用時，偵測到的應用程式能夠處理<xref:System.Windows.Application.Activated>事件。  
  
 第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟用狀態，它可以處理兩者<xref:System.Windows.Application.Activated>和<xref:System.Windows.Application.Deactivated>的事件，以判斷哪一個啟用狀態，它的。  
  
 一旦應用程式變成使用中<xref:System.Windows.Application.Activated>就不會引發一次之前停用應用程式時，無論應用程式使用中時，會啟動應用程式中的多少 windows。  
  
 <xref:System.Windows.Application.Activated> 不會引發[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下列範例示範如何偵測時的獨立應用程式啟用和停用。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 物件。</summary>
        <value>目前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 為每個-<xref:System.AppDomain>會實作靜態的單一類型<xref:System.Windows.Application.Current%2A>屬性來提供共用的存取權<xref:System.Windows.Application>目前的執行個體<xref:System.AppDomain>。 此設計會保證受該狀態<xref:System.Windows.Application>包括共用的資源和狀態，而且可從單一的共用位置。  
  
 此屬性是安全執行緒，而且可從任何執行緒。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式不再做為前景應用程式時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation 應用程式具有一個或多個開啟的視窗會停用 （停止前景應用程式） 時使用者會進行下列作業：  
  
-   切換至另一個應用程式，使用 ALT + TAB，或使用 工作管理員。  
  
-   按一下 其他應用程式視窗的工作列按鈕。  
  
 應用程式需要偵測它停用可處理<xref:System.Windows.Application.Deactivated>事件。  
  
 第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟用狀態，它可以處理兩者<xref:System.Windows.Application.Deactivated>和<xref:System.Windows.Application.Activated>事件，以判斷其在狀態的。  
  
 <xref:System.Windows.Application.Deactivated> 不會引發[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下列範例示範如何偵測的獨立應用程式會停用，並啟動。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式擲回例外狀況但未處理時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，Windows Presentation Foundation 會攔截未處理的例外狀況、 通知使用者 （從中可以回報例外狀況） 對話方塊中，從例外狀況和自動關閉應用程式。  
  
 不過，如果應用程式需要執行自訂的未處理例外狀況處理，從集中式位置，您應該處理<xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 引發<xref:System.Windows.Application>的每個主要 UI 執行緒上執行的程式碼未處理的例外狀況。  
  
 如果未處理例外狀況在 UI 執行緒的背景 (有自己的執行緒<xref:System.Windows.Threading.Dispatcher>) 或背景工作執行緒 (而不需要執行緒<xref:System.Windows.Threading.Dispatcher>)，例外狀況不會轉送至主要 UI 執行緒。 因此，<xref:System.Windows.Application.DispatcherUnhandledException>就不會引發。 在這些情況下，您必須撰寫程式碼來執行下列作業：  
  
1.  處理背景執行緒上的例外狀況。  
  
2.  分派這些主要 UI 執行緒的例外狀況。  
  
3.  重新擲回它們在主要 UI 執行緒上而不需要處理他們允許<xref:System.Windows.Application.DispatcherUnhandledException>引發。  
  
 如需詳細資訊，請參閱 <<c0> [ 執行緒模型](~/docs/framework/wpf/advanced/threading-model.md)概觀。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>事件處理常式會傳遞<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>引數，其中包含有關例外狀況的內容資訊包括：  
  
-   例外狀況 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。  
  
-   <xref:System.Windows.Threading.Dispatcher>從起源自 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。  
  
 您可以使用這項資訊來判斷例外狀況是否為可復原。 可復原的例外狀況可能是<xref:System.IO.FileNotFoundException>，例如，雖然可能無法復原的例外狀況<xref:System.StackOverflowException>，例如。  
  
 當您處理的未處理例外狀況<xref:System.Windows.Application.DispatcherUnhandledException>，而且您不想[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]若要繼續處理，您需要設定<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>屬性設`true`。  
  
 不同於其他事件，<xref:System.Windows.Application>引發，<xref:System.Windows.Application.DispatcherUnhandledException>不具有相對應的受保護虛擬實作 (OnDispatcherUnhandledException)。 因此，類別衍生自<xref:System.Windows.Application>永遠必須註冊事件處理常式<xref:System.Windows.Application.DispatcherUnhandledException>處理未處理的例外狀況。  
  
   
  
## Examples  
 下列範例示範如何處理未處理的例外狀況處理<xref:System.Windows.Application.DispatcherUnhandledException>事件。  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>只在應用程式關閉之前發生，且無法取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可關閉的其中一個原因如下：  
  
-   <xref:System.Windows.Application.Shutdown%2A>方法<xref:System.Windows.Application>呼叫的物件，以明確或所決定的<xref:System.Windows.Application.ShutdownMode%2A>屬性。  
  
-   使用者透過登出或關機結束工作階段。  
  
 處理應用程式關閉時，您可以偵測<xref:System.Windows.Application.Exit>事件，並執行視需要的任何其他處理。  
  
 您也可以處理<xref:System.Windows.Application.Exit>來檢查或變更應用程式結束代碼，當您不需要呼叫<xref:System.Windows.Application.Shutdown%2A>明確。 結束代碼從公開<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>的屬性<xref:System.Windows.ExitEventArgs>引數傳遞至<xref:System.Windows.Application.Exit>事件處理常式。 當應用程式停止執行時，結束代碼會傳遞至作業系統以進行後續處理。  
  
 如果您的應用程式會處理<xref:System.Windows.Application.SessionEnding>事件，並接著取消，<xref:System.Windows.Application.Exit>就不會引發和應用程式會繼續根據關機模式中執行。  
  
 結束程式碼可以設定從[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]，但會忽略這個值。  
  
 針對[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]，<xref:System.Windows.Application.Exit>引發下列情況：  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]巡覽以外的位置。  
  
-   在  [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]，當裝載 [] 索引標籤[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]已關閉。  
  
-   關閉瀏覽器時。  
  
 在所有情況下，值<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性會被忽略。  
  
   
  
## Examples  
 下列範例示範如何：  
  
-   處理<xref:System.Windows.Application.Exit>事件。  
  
-   檢查並更新<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性<xref:System.Windows.ExitEventArgs>。  
  
-   將項目寫入隔離儲存區中的應用程式記錄檔。  
  
-   應用程式狀態保存至隔離儲存區。  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的名稱。</param>
        <summary>使用指定的索引鍵搜尋[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 資源，例如 <see cref="T:System.Windows.Style" /> 或 <see cref="T:System.Windows.Media.Brush" />，如果找不到要求的資源，則擲回例外狀況 (請參閱 [XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md))。</summary>
        <returns>要求的資源物件。 如果找不到要求的資源，則會擲回 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 會先尋找指定之資源的應用程式範圍資源中。 應用程式範圍的資源由<xref:System.Windows.Application>，並從公開<xref:System.Windows.Application.Resources%2A>屬性。 如果應用程式範圍的資源，集中找不到指定的資源<xref:System.Windows.Application.FindResource%2A>然後下一步 會搜尋系統資源。 系統資源是由使用者定義的殼層資源，並包括色彩、 字型和 shell 設定。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。 若要使用<xref:System.Windows.Application.FindResource%2A>若要取得它們，這些型別也公開資源的索引鍵屬性是設計用來傳遞給<xref:System.Windows.Application.FindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因為<xref:System.Windows.Application.FindResource%2A>傳回的物件，如果找不到資源時，您必須將轉換成適當的類型傳回的值。  
  
> [!IMPORTANT]
>  如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。 如果您不想處理的呼叫會造成例外狀況<xref:System.Windows.Application.FindResource%2A>，呼叫<xref:System.Windows.Application.TryFindResource%2A>在內。<xref:System.Windows.Application.TryFindResource%2A>傳回`null`時要求的資源無法找到，且不會擲回例外狀況參考。  
  
 這個方法是安全執行緒，而且可以從任何執行緒呼叫。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Windows.Application.FindResource%2A>找出資源，以及處理<xref:System.Windows.ResourceReferenceKeyNotFoundException>如果找不到資源。  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到資源。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器開始巡覽至內容片段時發生。如果需要的片段位於目前內容中，則巡覽會立即發生，而如果需要的片段位於不同內容中，則會在載入來源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 內容之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">對應至鬆散資源的相對 <see cref="T:System.Uri" />。</param>
        <summary>傳回內容資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>包含內容資料檔案的 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，這個檔案位於指定的 <see cref="T:System.Uri" />。 如果找不到鬆散資源，則會傳回 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 為絕對 <see cref="T:System.Uri" />。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，指定已建立 Cookie 的位置。</param>
        <summary>擷取 <see cref="T:System.Uri" /> 所指定之位置的 Cookie。</summary>
        <returns>如果 Cookie 存在則為 <see cref="T:System.String" /> 值，否則會擲回 <see cref="T:System.ComponentModel.Win32Exception" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 擷取指定的 cookie <xref:System.Uri>。 如果無法擷取 cookie，<xref:System.ComponentModel.Win32Exception>就會擲回。 您需要撰寫程式碼將 cookie 字串剖析成名稱/值組的清單。  
  
 如需概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，請參閱 <<c2> [ 瀏覽概觀](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">當嘗試擷取指定的 Cookie 時，如果發生問題，則 <see langword="InternetGetCookie" /> 函式會引發 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 錯誤 (由 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> 呼叫)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得 cookie 以檔案為基礎<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">取得 cookie 非檔案型<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">
          <see cref="T:System.Uri" />，對應至來源網站上的鬆散資源。</param>
        <summary>傳回來源網站資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含來源網站資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" />。 如果找不到鬆散資源，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相對，或雖然為絕對但不是 <c>pack://siteoforigin:,,,/</c> 格式。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">對應至內嵌資源的 <see cref="T:System.Uri" />。</param>
        <summary>傳回資源資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含資源資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相對，或雖然為絕對但不是 <c>pack://application:,,,/</c> 格式。</exception>
        <exception cref="T:System.IO.IOException">找不到傳遞至 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器所巡覽的內容已載入、剖析和開始呈現時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>。  
  
> [!NOTE]
>  這類接聽事件的巡覽的內容<xref:System.Windows.FrameworkElement.Loaded>上的事件<xref:System.Windows.Controls.Page>才能存取內容的巡覽的內容。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入位於指定之[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面上的項目) 或應用程式資料檔案 (資源檔、 內容檔案或站台來源檔案，請參閱[WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">對應相對的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的 <see cref="T:System.Uri" />。</param>
        <summary>載入位於指定之[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 檔，並轉換為 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔的根項目所指定之物件的執行個體。</summary>
        <returns>由載入的 XAML 檔所指定之根項目的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須明確轉換成傳回值的根項目相同的型別[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]檔案。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面上的項目) 或應用程式資料檔案 (資源檔、 內容檔案或站台來源檔案，請參閱[WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是絕對 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">檔案不是 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 檔。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">與 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的根項目同類型的物件。</param>
        <param name="resourceLocator">對應相對的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的 <see cref="T:System.Uri" />。</param>
        <summary>載入位於指定的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔案，並將它轉換為 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔案的根項目指定的物件執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面上的項目) 或應用程式資料檔案 (資源檔、 內容檔案或站台來源檔案，請參閱[WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是絕對 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> 的型別和 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的根項目不符。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式的主視窗。</summary>
        <value>指定做為主應用程式視窗的 <see cref="T:System.Windows.Window" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 第一個的參考時，會自動設定<xref:System.Windows.Window>物件中具現化<xref:System.AppDomain>。  
  
 您可以設定來指定不同的主視窗<xref:System.Windows.Application.MainWindow%2A>指派另一個<xref:System.Windows.Application.Windows%2A>物件到<xref:System.Windows.Application.MainWindow%2A>屬性。  
  
 如果<xref:System.Windows.Application.ShutdownMode%2A>的屬性<xref:System.Windows.Application>物件設定為<xref:System.Windows.ShutdownMode.OnMainWindowClose>，關閉主視窗會導致應用程式關閉。  
  
 您可設定<xref:System.Windows.Application.MainWindow%2A>屬性從[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]，如果應用程式的主視窗不會產生藉由設定視窗<xref:System.Windows.Application.StartupUri%2A>屬性中的[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。 兩個限制[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]方法是：  
  
-   您可以指定[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-只<xref:System.Windows.Window>或是[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-僅<xref:System.Windows.Navigation.NavigationWindow>主要視窗。  
  
-   您必須設定<xref:System.Windows.UIElement.Visibility%2A>您所指定視窗的屬性，否則不會顯示。  
  
 第一個參考<xref:System.Windows.Window>要具現化的物件也會加入做為第一個項目<xref:System.Windows.Application.Windows%2A>集合。 如果<xref:System.Windows.Application.MainWindow%2A>後續設定不同的參考<xref:System.Windows.Window>，將會變更主視窗的參考之項目的位置，同時中項目的順序<xref:System.Windows.Application.Windows%2A>維持不變。 因此，一律使用<xref:System.Windows.Application.MainWindow%2A>參考的主視窗，而不是中的第一個項目<xref:System.Windows.Application.Windows%2A>。  
  
> [!NOTE]
>  主視窗是否<xref:System.Windows.Navigation.NavigationWindow>，而且您需要特定的存取權<xref:System.Windows.Navigation.NavigationWindow>成員，您將必須轉型的值<xref:System.Windows.Application.MainWindow%2A>至<xref:System.Windows.Navigation.NavigationWindow>。  
>   
>  這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例顯示如何尋找主應用程式視窗。  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 下列範例示範如何設定<xref:System.Windows.Application.MainWindow%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 下列範例示範如何具現化<xref:System.Windows.Application.MainWindow%2A>應用程式啟動期間的程式碼中。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">從瀏覽器中裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]) 設定 <see cref="P:System.Windows.Application.MainWindow" />。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當找到應用程式中的巡覽器所巡覽的內容時發生，即使可能未完整載入也一樣。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器要求新的巡覽時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器巡覽至要求的內容而發生錯誤時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在應用程式中巡覽器所管理的下載期間定期發生，以提供巡覽進度資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當呼叫應用程式中巡覽器的 <see langword="StopLoading" /> 方法時發生，或當巡覽器在目前巡覽進行中又要求新的巡覽時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 巡覽器已<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> 會引發 <xref:System.Windows.Application.Activated> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnActivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnActivated%2A>基底類別中如果<xref:System.Windows.Application.Activated>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Deactivated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> 會引發 <xref:System.Windows.Application.Deactivated> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnDeactivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnDeactivated%2A>基底類別中如果<xref:System.Windows.Application.Deactivated>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Exit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> 會引發 <xref:System.Windows.Application.Exit> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnExit%2A>方法。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnExit%2A>基底類別中如果<xref:System.Windows.Application.Exit>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.FragmentNavigation" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> 會引發 <xref:System.Windows.Application.FragmentNavigation> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnFragmentNavigation%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnFragmentNavigation%2A>基底類別中如果<xref:System.Windows.Application.FragmentNavigation>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.LoadCompleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> 會引發 <xref:System.Windows.Application.LoadCompleted> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnLoadCompleted%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnLoadCompleted%2A>基底類別中如果<xref:System.Windows.Application.LoadCompleted>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Navigated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> 會引發 <xref:System.Windows.Application.Navigated> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigated%2A>基底類別中如果<xref:System.Windows.Application.Navigated>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Navigating" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> 會引發 <xref:System.Windows.Application.Navigating> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigating%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigating%2A>基底類別中如果<xref:System.Windows.Application.Navigating>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationFailed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> 會引發 <xref:System.Windows.Application.NavigationFailed> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationFailed%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigationFailed%2A>基底類別中如果<xref:System.Windows.Application.NavigationFailed>必須引發。  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationProgress" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> 會引發 <xref:System.Windows.Application.NavigationProgress> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationProgress%2A>。 覆寫的方法必須明確呼叫<xref:System.Windows.Application.OnNavigationProgress%2A>基底類別中如果<xref:System.Windows.Application.NavigationProgress>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationStopped" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> 會引發 <xref:System.Windows.Application.NavigationStopped> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationStopped%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigationStopped%2A>基底類別中如果<xref:System.Windows.Application.NavigationStopped>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.SessionEndingCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.SessionEnding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> 會引發 <xref:System.Windows.Application.SessionEnding> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnSessionEnding%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnSessionEnding%2A>基底類別中如果<xref:System.Windows.Application.SessionEnding>必須引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.StartupEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Startup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> 會引發 <xref:System.Windows.Application.Startup> 事件。  
  
 衍生自類型<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnStartup%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnStartup%2A>基底類別中如果<xref:System.Windows.Application.Startup>必須引發的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式範圍的屬性集合。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" />，包含應用程式範圍的屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 會公開透過字典<xref:System.Windows.Application.Properties%2A>可用來儲存應用程式範圍的屬性。 這可讓您共用中的所有程式碼之間的狀態<xref:System.AppDomain>以執行緒安全的方式，而不需要自行撰寫程式的狀態碼。  
  
 屬性儲存在<xref:System.Windows.Application.Properties%2A>必須轉換成傳回適當的型別。  
  
 <xref:System.Windows.Application.Properties%2A>屬性是安全執行緒，而且可從任何執行緒。  
  
   
  
## Examples  
 下列範例示範如何建立和使用應用程式範圍的屬性使用<xref:System.Windows.Application.Properties%2A>。  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Reflection.Assembly" />，提供 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 應用程式中資源的[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 套件。</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> 的參考，提供 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 應用程式中資源的[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 套件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]資源會在執行階段有關項目組件，以從傳回的值識別解析<xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法。  
  
 進入點組件是該組件由<xref:System.Reflection.Assembly.GetEntryAssembly%2A>和可能是如下所示：  
  
-   預設應用程式定義域中的可執行組件。  
  
-   藉由呼叫要執行的第一個組件<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在下列情況中，不過，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件無法取得項目組件的參考：  
  
-   非受控 （原生） 應用程式主機[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件。  
  
-   受管理的應用程式主機[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]新的應用程式定義域，而不使用的方法將它載入的組件<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在這些情況下，這兩<xref:System.Reflection.Assembly.GetEntryAssembly%2A>會傳回`null`，和[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]無法解析組件的資源。 在這些情況下，<xref:System.Windows.Application.ResourceAssembly%2A>可以設定之後只應該用來解析資源的組件的參考。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 可以 lze nastavit pouze jednou 因為它是不太可能之後, 會變更資源組件[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]已載入組件。  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 無法設定時[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件可探索的項目組件，也就是，當<xref:System.Reflection.Assembly.GetEntryAssembly%2A>傳回組件的參考而非`null`。  
  
 此屬性是安全執行緒，而且可從任何執行緒。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 應用程式具有進入組件，或已設定 <see cref="P:System.Windows.Application.ResourceAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式範圍的資源集合，例如樣式和筆刷。</summary>
        <value>
          <see cref="T:System.Windows.ResourceDictionary" /> 物件，包含零個以上的應用程式範圍資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A>屬性可用來跨 windows 和應用程式的項目共用資源。 此外，<xref:System.Windows.Application.Resources%2A>屬性是否包含在資源查閱路徑、 周遊順序如下：  
  
1.  項目  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  系統  
  
 因此，[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]元素可以繫結至應用程式範圍的資源。 此外，如果變更的資源，資源系統可確保該項目會繫結至這些資源的屬性會自動更新以反映變更。  
  
 應用程式範圍的資源提供簡單的方式，以支援跨應用程式的一致的主題。 您可以輕鬆地建立佈景主題[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]使用`Application.Resources`標記。 不過，如果您的應用程式支援多個主題，其中可能包含大量的佈景主題項目，它可能是您更輕鬆地管理這些使用其中一種<xref:System.Windows.ResourceDictionary>每個佈景主題的執行個體。 如此一來，新的佈景主題可以套用資源屬性設定為適當<xref:System.Windows.ResourceDictionary>。  
  
 有兩個使用時的考量<xref:System.Windows.Application.Resources%2A>。 首先，字典*金鑰*是一個物件，因此您必須使用完全相同物件執行個體時設定和取得屬性值 （請注意使用字串時，索引鍵會區分大小寫）。 其次，字典*值*是一個物件，因此您必須將值轉換成所需的型別，取得屬性值時。  
  
 <xref:System.Windows.Application.Resources%2A> 具備執行緒安全且可從任何執行緒。  
  
   
  
## Examples  
 此範例說明如何使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]連同應用程式範圍的資源，以建立一致的視覺外觀。  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 下列範例示範如何在程式碼和 XAML 中設定應用程式資源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 下列範例會示範如何在程式碼中取得應用程式資源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>啟動 Windows Presentation Foundation 應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動 Windows Presentation Foundation 應用程式。</summary>
        <returns>當應用程式關閉時，傳回至作業系統的 <see cref="T:System.Int32" /> 應用程式結束代碼。 根據預設，結束代碼值為 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 呼叫以啟動[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]應用程式。 如果您定義您<xref:System.Windows.Application>使用標記或標記和程式碼後置<xref:System.Windows.Application.Run%2A>會以隱含方式呼叫。 不過，如果您定義您<xref:System.Windows.Application>使用的程式碼，您必須明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 當<xref:System.Windows.Application.Run%2A>呼叫時，<xref:System.Windows.Application>附加新<xref:System.Windows.Threading.Dispatcher>至 UI 執行緒的執行個體。 下一步<xref:System.Windows.Threading.Dispatcher>物件的<xref:System.Windows.Threading.Dispatcher.Run%2A>呼叫方法時，這會開始處理 windows 訊息的訊息幫浦。 最後，<xref:System.Windows.Threading.Dispatcher>物件會呼叫<xref:System.Windows.Application>物件的<xref:System.Windows.Application.OnStartup%2A>方法以引發<xref:System.Windows.Application.Startup>事件。 因此，您所處理的時間建立的應用程式執行模式<xref:System.Windows.Application.Startup>，此時應用程式會被視為正在執行。  
  
 應用程式停止執行的時機<xref:System.Windows.Application.Shutdown%2A>稱為; 的值<xref:System.Windows.Application.ShutdownMode%2A>屬性會決定當<xref:System.Windows.Application.Shutdown%2A>呼叫時，以及是否會自動發生，或者您需要明確呼叫它。  
  
 <xref:System.Windows.Application.Run%2A> 可以只從建立的執行緒呼叫<xref:System.Windows.Application>物件。 此外，<xref:System.Windows.Application.Run%2A>不能從呼叫[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下列範例示範使用自訂的應用程式<xref:System.Windows.Application>，因此必須明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">從瀏覽器裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) 呼叫 <see cref="M:System.Windows.Application.Run" />。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">當應用程式啟動時自動開啟的 <see cref="T:System.Windows.Window" />。</param>
        <summary>啟動 Windows Presentation Foundation 應用程式並開啟指定的視窗。</summary>
        <returns>當應用程式關閉時，傳回至作業系統的 <see cref="T:System.Int32" /> 應用程式結束代碼。 根據預設，結束代碼值為 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會擴充<xref:System.Windows.Application.Run%2A>方法來開啟指定的視窗之後應用程式開始執行。  
  
 如果您的程式碼定義<xref:System.Windows.Application>這會開啟一個視窗，開始執行時，明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 如果您建立您<xref:System.Windows.Application>使用標記或標記和程式碼後置，您可以自動開啟視窗期間使用的下列技術：  
  
-   以宣告方式，是藉由設定<xref:System.Windows.Application.StartupUri%2A>。  
  
-   以程式設計方式處理<xref:System.Windows.Application.Startup>。  
  
   
  
## Examples  
 下列範例示範使用手動建立靜態進入點方法具現化的應用程式<xref:System.Windows.Application>，然後再呼叫<xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">從瀏覽器裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) 呼叫 <see cref="M:System.Windows.Application.Run" />。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者登出或關閉作業系統而結束 Windows 工作階段時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在應用程式關閉時 Windows 工作階段隨即結束，使用者登出或關閉時，就會發生。 當發生這種情況時，Windows 會要求每個開啟的應用程式關閉。 不過，它是應用程式可能不會準備好關閉當發生這種情況。 例如，應用程式可能處於不一致的狀態，或進行長時間執行的作業資料。 在這些情況下，可能會想要讓工作階段結束，它可能會更想要讓使用者決定要讓結束工作階段選項。  
  
 藉由處理的工作階段結束時，您可以偵測<xref:System.Windows.Application.SessionEnding>事件。 如果應用程式需要結束，導致工作階段<xref:System.Windows.SessionEndingCancelEventArgs>傳遞至事件處理常式的引數會公開<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>，您將設定為`true`(預設值是`false`)。  
  
 如果<xref:System.Windows.Application.SessionEnding>是未處理，或處理而正在取消<xref:System.Windows.Application.Shutdown%2A>稱為和<xref:System.Windows.Application.Exit>就會引發事件。  
  
 若要取得工作階段結束的原因的詳細資訊，應用程式可以檢查<xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，而這也是<xref:System.Windows.ReasonSessionEnding>的值 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType>和<xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Application.SessionEnding> 不會引發主控台應用程式。  
  
 <xref:System.Windows.Application.SessionEnding> 只能在建立的執行緒上引發<xref:System.Windows.Application>物件。  
  
 <xref:System.Windows.Application.SessionEnding> 不會引發 XAML 瀏覽器應用程式 (Xbap)。  
  
   
  
## Examples  
 下列範例示範如何處理<xref:System.Windows.Application.SessionEnding>事件，並讓使用者將其取消即可。  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，指定應該建立 Cookie 的位置。</param>
        <param name="value">包含 Cookie 資料的 <see cref="T:System.String" />。</param>
        <summary>為 <see cref="T:System.Uri" /> 所指定的位置建立 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是任意的應用程式用戶端電腦上的應用程式工作階段 (工作階段 cookie) 時，或跨應用程式工作階段 (持續性 cookie) 可以儲存的資料。 您可以呼叫來建立這兩種 cookie <xref:System.Windows.Application.SetCookie%2A>。  
  
 Cookie 資料通常會以下列格式的名稱/值組的形式：  
  
 `Name=Value`  
  
 您傳遞到此格式字串<xref:System.Windows.Application.SetCookie%2A>，連同<xref:System.Uri>設定 cookie 的位置 （一般而言，應用程式定義域）。  
  
 Cookie 是工作階段 cookie 或永續性 cookie，取決於是否 cookie 的字串，您將傳遞給<xref:System.Windows.Application.SetCookie%2A>包含到期日。 工作階段 cookie 的字串不包含到期日。 有永續性 cookie 的字串，且必須以下列格式：  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 永續性 cookie 儲存在目前[!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)]安裝的 Temporary Internet Files 資料夾，直到過期，在此情況下會刪除它們。 您可以從您的應用程式中刪除永續性 cookie，其到期日設在過去的日期/時間值。  
  
 如需概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，請參閱 <<c2> [ 瀏覽概觀](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">當嘗試建立指定的 Cookie 時，如果發生問題，則 <see langword="InternetSetCookie" /> 函式會引發 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 錯誤 (由 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> 呼叫)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得 cookie 以檔案為基礎<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">取得 cookie 非檔案型<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>關閉應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉應用程式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Application.Shutdown%2A>呼叫時，應用程式停止執行。 您可以處理<xref:System.Windows.Application.Exit>事件來偵測應用程式時若要停止執行，若要執行任何適當的處理。  
  
 <xref:System.Windows.Application.Shutdown%2A> 會以隱含方式呼叫 Windows Presentation Foundation 在下列情況：  
  
-   當<xref:System.Windows.Application.ShutdownMode%2A>設為<xref:System.Windows.ShutdownMode.OnLastWindowClose>。  
  
-   當<xref:System.Windows.Application.ShutdownMode%2A>設為<xref:System.Windows.ShutdownMode.OnMainWindowClose>。  
  
-   當使用者結束工作階段和<xref:System.Windows.Application.SessionEnding>事件未處理，或處理，而取消。  
  
 呼叫<xref:System.Windows.Application.Shutdown%2A>明確地讓應用程式關閉，不論<xref:System.Windows.Application.ShutdownMode%2A>設定。 不過，如果<xref:System.Windows.Application.ShutdownMode%2A>設定為<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，您必須呼叫<xref:System.Windows.Application.Shutdown%2A>來關閉應用程式。  
  
> [!IMPORTANT]
>  當<xref:System.Windows.Application.Shutdown%2A>是呼叫，應用程式將會關閉無論是否<xref:System.Windows.Window.Closing>取消事件的任何開啟的視窗。  
  
 可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">應用程式的整數結束代碼。 預設結束代碼為 0。</param>
        <summary>關閉應用程式，這個應用程式將指定的結束代碼傳回至作業系統。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以處理<xref:System.Windows.Application.Exit>事件設定結束代碼。 不過，如果您明確地呼叫<xref:System.Windows.Application.Shutdown%2A>，而且您處理<xref:System.Windows.Application.Exit>若要設定的結束代碼，您可以呼叫只<xref:System.Windows.Application.Shutdown%2A>改為。  
  
 可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定會導致呼叫 <see cref="M:System.Windows.Application.Shutdown" /> 方法的條件。</summary>
        <value>
          <see cref="T:System.Windows.ShutdownMode" /> 列舉值。 預設值是 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式停止執行時，才<xref:System.Windows.Application.Shutdown%2A>呼叫的應用程式的方法。 隱含或明確地指定的值，可能會發生關機<xref:System.Windows.Application.ShutdownMode%2A>屬性。  
  
 如果您設定<xref:System.Windows.Application.ShutdownMode%2A>要<xref:System.Windows.ShutdownMode.OnLastWindowClose>，Windows Presentation Foundation (WPF) 會隱含呼叫<xref:System.Windows.Application.Shutdown%2A>應用程式的最後一個視窗關閉時，即使任何目前具現化的 windows 設定為在主視窗 (請參閱<xref:System.Windows.Application.MainWindow%2A>)。  
  
 A<xref:System.Windows.Application.ShutdownMode%2A>的<xref:System.Windows.ShutdownMode.OnMainWindowClose>會導致隱含地呼叫 WPF<xref:System.Windows.Application.Shutdown%2A>當<xref:System.Windows.Application.MainWindow%2A>隨即關閉，即使其他視窗目前已開啟。  
  
 某些應用程式的存留期可能相依於當主視窗或最後一個視窗關閉時，或可能不會依存於 windows 完全。 針對這些案例，您需要設定<xref:System.Windows.Application.ShutdownMode%2A>屬性，以<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，而這需要明確<xref:System.Windows.Application.Shutdown%2A>停止應用程式的方法呼叫。 否則，應用程式會繼續在背景中執行。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 可從以宣告方式設定[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]或以程式設計方式從程式碼。  
  
 這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Application.ShutdownMode%2A>來指定應用程式必須明確地關閉。  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼叫 <see cref="M:System.Windows.Application.Run" /> 物件的 <see cref="T:System.Windows.Application" /> 方法時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的 Windows Presentation Foundation 應用程式可能會執行各種初始化工作，當它啟動時，包括：  
  
-   處理命令列參數。  
  
-   開啟主視窗。  
  
-   正在初始化應用程式範圍的資源。  
  
-   正在初始化應用程式範圍的屬性。  
  
 您可以宣告方式指定主視窗與使用的應用程式範圍資源[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)](<xref:System.Windows.Application.StartupUri%2A>和<xref:System.Windows.Application.Resources%2A>分別)。 有時候，不過，資源或您的應用程式的主視窗可以只是以程式設計方式在執行階段決定。 此外，應用程式範圍的屬性和命令列參數僅適用於以程式設計的方式。 以程式設計方式初始化可執行的處理<xref:System.Windows.Application.Startup>事件，包括下列：  
  
-   取得及處理命令列參數，可從<xref:System.Windows.StartupEventArgs.Args%2A>的屬性<xref:System.Windows.StartupEventArgs>類別，會傳遞至<xref:System.Windows.Application.Startup>事件處理常式。  
  
-   初始化應用程式範圍的資源使用<xref:System.Windows.Application.Resources%2A>屬性。  
  
-   初始化應用程式範圍的屬性使用<xref:System.Windows.Application.Properties%2A>屬性。  
  
-   具現化，並顯示一個 （或以上） 的視窗。  
  
> [!NOTE]
>  也可以取得命令列參數呼叫靜態<xref:System.Environment.GetCommandLineArgs%2A>方法的<xref:System.Environment>物件。 不過，<xref:System.Environment.GetCommandLineArgs%2A>需要完全信任才能執行。  
  
 如果您設定<xref:System.Windows.Application.StartupUri%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]，建立主視窗不提供的其中一個<xref:System.Windows.Application.MainWindow%2A>屬性或有<xref:System.Windows.Application.Windows%2A>屬性<xref:System.Windows.Application>物件，直到之後<xref:System.Windows.Application.Startup>處理事件。 如果您在啟動期間需要存取主視窗，您需要手動建立新的視窗物件，從您<xref:System.Windows.Application.Startup>事件處理常式。  
  
> [!NOTE]
>  如果您的應用程式會使用<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>若要指定的認證原則，您需要設定<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>之後<xref:System.Windows.Application.Startup>引發，否則[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]將其設為預設內部原則直接之後<xref:System.Windows.Application.Startup>在引發事件。  
  
 傳遞至命令列引數<xref:System.Windows.Application.Startup>事件處理常式不是相同[!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]查詢字串參數傳遞至[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下列範例示範如何取得並處理從獨立應用程式的命令列選項。 如果 **/StartMinimized**提供命令列參數、 在應用程式開啟主視窗中的最小化狀態。  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 無法擷取及處理命令列引數，因為它們會啟動[!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]部署 (請參閱 <<c2> [ 部署 WPF 應用程式 (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md))。 不過，它們可以透過用來啟動的 URL 擷取及處理查詢字串參數。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定當應用程式啟動時會自動顯示的 UI。</summary>
        <value>A<see cref="T:System.Uri" />參考會自動開啟 應用程式啟動時的 UI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Windows.Application.StartupUri%2A>應用程式啟動時，會自動載入 UI 資源。  
  
 下表顯示可以載入 UI 資源的類型，開啟的視窗類型，可以將設定為這些資源的應用程式類型<xref:System.Windows.Application.StartupUri%2A>。  
  
|類型|視窗|應用程式類型|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|僅限獨立|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|僅限獨立|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
  
 一般而言，您設定<xref:System.Windows.Application.StartupUri%2A>屬性以宣告方式在[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]。 不過，您可以設定<xref:System.Windows.Application.StartupUri%2A>程式設計的方式，這類，於<xref:System.Windows.Application.Startup>事件處理常式，這很適合用於只能在執行階段載入必要的 UI 資源的應用程式如果。 比方說，應用程式可能會等到執行階段，如果 UI 資源的名稱儲存在組態檔載入其資源。  
  
 您的設定是否<xref:System.Windows.Application.StartupUri%2A>之前未載入以宣告方式或以程式設計的方式，在對應的 UI 資源之後<xref:System.Windows.Application.Startup>處理事件。 因此，您就不必存取產生的視窗從其中<xref:System.Windows.Application.Windows%2A>屬性或<xref:System.Windows.Application.MainWindow%2A>屬性時處理<xref:System.Windows.Application.Startup>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> 設定為 null 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求之環境屬性 (Ambient Property) 的名稱。</param>
        <summary>查詢目前範圍中是否有指定的環境屬性。</summary>
        <returns>如果可使用要求的環境屬性則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.Application> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的名稱。</param>
        <summary>搜尋指定的資源。</summary>
        <returns>要求的資源物件。 如果找不到要求的資源，則會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 會先尋找指定之資源的應用程式範圍資源中。 應用程式範圍的資源由<xref:System.Windows.Application>，並從公開<xref:System.Windows.Application.Resources%2A>屬性。 如果應用程式範圍的資源，集中找不到指定的資源<xref:System.Windows.Application.TryFindResource%2A>然後下一步 會搜尋系統資源。 系統資源是由使用者定義的殼層資源，並包括色彩、 字型和 shell 設定。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。 若要使用<xref:System.Windows.Application.TryFindResource%2A>若要取得它們，這些型別也公開資源的索引鍵屬性是設計用來傳遞給<xref:System.Windows.Application.TryFindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因為<xref:System.Windows.Application.TryFindResource%2A>傳回的物件，如果找不到資源時，您必須將轉換成適當的類型傳回的值。  
  
 這個方法是安全執行緒，而且可以從任何執行緒呼叫。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Windows.Application.TryFindResource%2A>取得資源。  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式中已具現化的視窗。</summary>
        <value>
          <see cref="T:System.Windows.WindowCollection" />，包含目前 <see cref="T:System.AppDomain" /> 中所有視窗物件的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Window>參考會自動新增至<xref:System.Windows.Application.Windows%2A>上具現化一個視窗時，立即[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]執行緒; 所建立的背景工作執行緒不會新增的 windows。 A<xref:System.Windows.Window>後，會自動移除參考其<xref:System.Windows.Window.Closing>已處理事件，以及之前其<xref:System.Windows.Window.Closed>就會引發事件。  
  
 根據預設，第一個項目加入至<xref:System.Windows.Application.Windows%2A>屬性會變成<xref:System.Windows.Application.MainWindow%2A>。  
  
 這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例示範如何列舉<xref:System.Windows.Application.Windows%2A>屬性，以建置最上層的 Windows 功能表，而這通用於[!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)]等應用程式[!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]，或是想要的多個執行個體的單一文件介面 (SDI) 應用程式[!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>