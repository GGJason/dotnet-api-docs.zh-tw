<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b524996378b2882f342e465d834a727cafe277d6" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>封裝 Windows Presentation Foundation 應用程式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 是類別，將封裝[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]應用程式專屬功能，包括下列：  
  
-   **應用程式存留期**: <xref:System.Windows.Application.Activated>， <xref:System.Windows.Application.Current%2A>， <xref:System.Windows.Application.Deactivated>， <xref:System.Windows.Application.DispatcherUnhandledException>， <xref:System.Windows.Application.Exit>， <xref:System.Windows.Application.Run%2A>， <xref:System.Windows.Application.SessionEnding>， <xref:System.Windows.Application.Shutdown%2A>， <xref:System.Windows.Application.ShutdownMode%2A>， <xref:System.Windows.Application.Startup>。  
  
-   **應用程式範圍 視窗、 屬性和資源管理**: <xref:System.Windows.Application.FindResource%2A>， <xref:System.Windows.Application.GetContentStream%2A>， <xref:System.Windows.Application.GetResourceStream%2A>， <xref:System.Windows.Application.LoadComponent%2A>， <xref:System.Windows.Application.MainWindow%2A>， <xref:System.Windows.Application.Properties%2A>， <xref:System.Windows.Application.Resources%2A>， <xref:System.Windows.Application.StartupUri%2A>， <xref:System.Windows.Application.Windows%2A>。  
  
-   **命令列參數並結束程式碼處理**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>， <xref:System.Windows.Application.Exit?displayProperty=nameWithType>， <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>。  
  
-   **瀏覽**: <xref:System.Windows.Application.FragmentNavigation>， <xref:System.Windows.Application.LoadCompleted>， <xref:System.Windows.Application.Navigated>， <xref:System.Windows.Application.Navigating>， <xref:System.Windows.Application.NavigationProgress>， <xref:System.Windows.Application.NavigationStopped>， <xref:System.Windows.Application.NavigationFailed>， <xref:System.Windows.Application.SetCookie%2A>， <xref:System.Windows.Application.GetCookie%2A>。  
  
 <xref:System.Windows.Application> 實作單一模式，以提供其視窗、 屬性和資源範圍服務的共用的存取。 因此，只有一個執行個體<xref:System.Windows.Application>類別可由每個<xref:System.AppDomain>。  
  
 您可以實作<xref:System.Windows.Application>使用標記、 標記和程式碼後置或程式碼。 如果<xref:System.Windows.Application>是否標記檔案標記或標記和程式碼後置，必須設定為要使用的標記，實作[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]`ApplicationDefinition`項目。  
  
> [!NOTE]
>  獨立應用程式不需要<xref:System.Windows.Application>物件; 它也可以實作自訂`static`進入點方法 (`Main`)，而不需要建立的執行個體開啟的視窗<xref:System.Windows.Application>。 不過，[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]需要<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例會示範如何在標準的應用程式定義只使用標記：  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 下列範例會示範如何使用定義的標準應用程式僅程式碼：  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 下列範例會示範如何在標準的應用程式標記和程式碼後置的組合來定義。  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用<see langword="static" />(<see langword="Shared" />在 Visual Basic 中) 這種類型的成員都具備執行緒安全。 此外，<see cref="M:System.Windows.Application.FindResource(System.Object)" />和<see cref="M:System.Windows.Application.TryFindResource(System.Object)" />方法和<see cref="P:System.Windows.Application.Properties" />和<see cref="P:System.Windows.Application.Resources" />屬性都是安全執行緒。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Application" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有一個執行個體<xref:System.Windows.Application>類別可由每個<xref:System.AppDomain>，以確保單一資料集的應用程式範圍 視窗、 屬性和資源的共用的存取。 因此，預設的建構函式<xref:System.Windows.Application>類別會偵測是否已初始化的執行個體中的第一個執行個體<xref:System.AppDomain>; 如果不是，<xref:System.InvalidOperationException>就會擲回。  
  
 <xref:System.Windows.Application>物件目前<xref:System.AppDomain>公開靜態<xref:System.Windows.Application.Current%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">每一個 <see cref="T:System.Windows.Application" /> 建立一個以上的 <see cref="T:System.AppDomain" /> 執行個體。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式變成前景應用程式時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有一或多個開啟的視窗，Windows Presentation Foundation 應用程式會啟動 （變成前景應用程式） 當其中一個 windows 啟動時第一次啟動應用程式，因為或其中一個視窗在何時啟用時應用程式為非使用中： 特別是，啟用，就會發生時：  
  
-   應用程式開啟其第一個視窗。  
  
-   使用 ALT + TAB，或使用 工作管理員，使用者會切換至應用程式。  
  
-   使用者按一下其中一個應用程式視窗的工作列按鈕。  
  
 需要偵測當他們所啟動的應用程式能夠處理<xref:System.Windows.Application.Activated>事件。  
  
 第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟動狀態，它可以處理兩者<xref:System.Windows.Application.Activated>和<xref:System.Windows.Application.Deactivated>的事件，以判斷哪一個啟用狀態，它。  
  
 一旦應用程式變成使用中<xref:System.Windows.Application.Activated>將不會再次引發直到應用程式停用時，不論是在應用程式使用中時，會啟動多少 windows 應用程式中的。  
  
 <xref:System.Windows.Application.Activated> 不會引發[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下列範例顯示如何偵測何時的獨立應用程式啟用和停用。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 物件。</summary>
        <value>目前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 為每個-<xref:System.AppDomain>單一型別可實作靜態<xref:System.Windows.Application.Current%2A>屬性提供的共用的存取<xref:System.Windows.Application>目前的執行個體<xref:System.AppDomain>。 此設計會保證受該狀態<xref:System.Windows.Application>包括共用的資源和狀態，而且可從單一的共用位置。  
  
 這個屬性是安全執行緒，可從任何執行緒。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式不再做為前景應用程式時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation 應用程式具有一個或多個開啟的視窗就會停用 （停止前景應用程式） 時使用者會執行下列：  
  
-   切換至另一個應用程式使用 ALT + TAB，或使用 工作管理員。  
  
-   按一下另一個應用程式視窗的工作列按鈕。  
  
 需要偵測停用作業可以處理的應用程式<xref:System.Windows.Application.Deactivated>事件。  
  
 第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟動狀態，它可以處理兩者<xref:System.Windows.Application.Deactivated>和<xref:System.Windows.Application.Activated>的事件，以判斷其狀態它。  
  
 <xref:System.Windows.Application.Deactivated> 不會引發[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下列範例顯示如何偵測時就會停用，並啟動獨立應用程式。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式擲回例外狀況但未處理時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，Windows Presentation Foundation 攔截未處理例外狀況，通知使用者 （從中它們可以回報該例外狀況） 對話方塊中，從例外狀況，自動關閉應用程式。  
  
 不過，如果必須執行自訂的未處理例外狀況處理，從一個集中位置的應用程式，您應該處理<xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 就會引發<xref:System.Windows.Application>的每個主要 UI 執行緒上執行的程式碼未處理的例外狀況。  
  
 如果未處理例外狀況在 UI 執行緒背景 (使用它自己的執行緒<xref:System.Windows.Threading.Dispatcher>) 或背景工作執行緒 (不含執行緒<xref:System.Windows.Threading.Dispatcher>)，例外狀況不會轉送至主要 UI 執行緒。 因此，<xref:System.Windows.Application.DispatcherUnhandledException>就不會引發。 在這些情況下，您必須撰寫程式碼來執行下列作業：  
  
1.  處理背景執行緒上的例外狀況。  
  
2.  分派的主要 UI 執行緒的例外狀況。  
  
3.  重新擲回它們的主要 UI 執行緒上而不處理它們允許<xref:System.Windows.Application.DispatcherUnhandledException>引發。  
  
 如需詳細資訊，請參閱[執行緒模型](~/docs/framework/wpf/advanced/threading-model.md)概觀。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>傳遞事件處理常式<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>引數，其中包含有關例外狀況，內容資訊包括：  
  
-   例外狀況 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。  
  
-   <xref:System.Windows.Threading.Dispatcher>從起源自 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。  
  
 您可以使用這項資訊來判斷例外狀況是否為可復原。 可復原的例外狀況可能是<xref:System.IO.FileNotFoundException>，例如，時間可能會無法復原的例外狀況<xref:System.StackOverflowException>，例如。  
  
 當您處理來自未處理的例外狀況<xref:System.Windows.Application.DispatcherUnhandledException>，而且您不想[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]繼續處理它，您需要設定<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>屬性`true`。  
  
 不同於其他事件，<xref:System.Windows.Application>引發，<xref:System.Windows.Application.DispatcherUnhandledException>不具有相對應的受保護虛擬實作 (OnDispatcherUnhandledException)。 因此，類別衍生自<xref:System.Windows.Application>一律必須註冊事件處理常式和<xref:System.Windows.Application.DispatcherUnhandledException>處理未處理例外狀況。  
  
   
  
## Examples  
 下列範例示範如何處理未處理例外狀況處理<xref:System.Windows.Application.DispatcherUnhandledException>事件。  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>只在應用程式關閉之前發生，且無法取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以關機的原因如下：  
  
-   <xref:System.Windows.Application.Shutdown%2A>方法<xref:System.Windows.Application>物件就會呼叫，以明確或決定<xref:System.Windows.Application.ShutdownMode%2A>屬性。  
  
-   使用者透過登出或關機，結束工作階段。  
  
 處理應用程式關閉時，您可以偵測<xref:System.Windows.Application.Exit>事件，並執行任何所需的額外處理。  
  
 您也可以處理<xref:System.Windows.Application.Exit>來檢查或變更應用程式結束代碼，當您不需要呼叫<xref:System.Windows.Application.Shutdown%2A>明確。 結束代碼從公開<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性<xref:System.Windows.ExitEventArgs>引數傳遞至<xref:System.Windows.Application.Exit>事件處理常式。 當應用程式停止執行時，結束代碼會傳遞給作業系統，供後續處理。  
  
 如果您的應用程式處理<xref:System.Windows.Application.SessionEnding>事件，並接著取消，<xref:System.Windows.Application.Exit>就不會引發和應用程式繼續執行的像素來關機模式。  
  
 可設定結束碼[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]，但是會忽略這個值。  
  
 如[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]，<xref:System.Windows.Application.Exit>引發下列情況：  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]巡覽離開的。  
  
-   在[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]，當 [] 索引標籤裝載[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]已關閉。  
  
-   關閉瀏覽器時。  
  
 在所有情況下，值<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性會被忽略。  
  
   
  
## Examples  
 下列範例會示範如何：  
  
-   處理<xref:System.Windows.Application.Exit>事件。  
  
-   檢查並更新<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性<xref:System.Windows.ExitEventArgs>。  
  
-   隔離儲存區中的應用程式記錄檔中寫入項目。  
  
-   持續隔離儲存區的應用程式狀態。  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的名稱。</param>
        <summary>使用指定的索引鍵搜尋[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 資源，例如 <see cref="T:System.Windows.Style" /> 或 <see cref="T:System.Windows.Media.Brush" />，如果找不到要求的資源，則擲回例外狀況 (請參閱 [XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md))。</summary>
        <returns>要求的資源物件。 如果找不到要求的資源，則會擲回 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 會先尋找在指定的資源的應用程式範圍資源。 應用程式範圍的資源由管理<xref:System.Windows.Application>，而且會公開從<xref:System.Windows.Application.Resources%2A>屬性。 如果應用程式範圍資源集中找不到指定的資源<xref:System.Windows.Application.FindResource%2A>然後搜尋系統資源。 系統資源是由使用者定義的 shell 資源，並且包含色彩、 字型及殼層組態。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。 若要使用<xref:System.Windows.Application.FindResource%2A>取得它們，這些型別也會公開資源的索引鍵屬性是設計成傳遞給<xref:System.Windows.Application.FindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因為<xref:System.Windows.Application.FindResource%2A>傳回的物件，如果找到資源，您必須轉換成適當的類型傳回的值。  
  
> [!IMPORTANT]
>  如果您找不到索引鍵呼叫這個方法，會擲回例外狀況。 如果您不想處理的例外狀況所導致的呼叫<xref:System.Windows.Application.FindResource%2A>，呼叫<xref:System.Windows.Application.TryFindResource%2A>在內。<xref:System.Windows.Application.TryFindResource%2A>傳回`null`時找不到要求的資源，並不會擲回例外狀況參考。  
  
 這個方法是安全執行緒，可以從任何執行緒呼叫。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Windows.Application.FindResource%2A>尋找資源，並處理<xref:System.Windows.ResourceReferenceKeyNotFoundException>如果找不到資源。  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到資源。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器開始巡覽至內容片段時發生。如果需要的片段位於目前內容中，則巡覽會立即發生，而如果需要的片段位於不同內容中，則會在載入來源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 內容之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">對應至鬆散資源的相對 <see cref="T:System.Uri" />。</param>
        <summary>傳回內容資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>包含內容資料檔案的 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，這個檔案位於指定的 <see cref="T:System.Uri" />。 如果找不到鬆散資源，則會傳回 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不具備執行緒安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 為絕對 <see cref="T:System.Uri" />。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，指定已建立 Cookie 的位置。</param>
        <summary>擷取 <see cref="T:System.Uri" /> 所指定之位置的 Cookie。</summary>
        <returns>如果 Cookie 存在則為 <see cref="T:System.String" /> 值，否則會擲回 <see cref="T:System.ComponentModel.Win32Exception" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 擷取指定的 cookie <xref:System.Uri>。 如果無法擷取 cookie，<xref:System.ComponentModel.Win32Exception>就會擲回。 您需要撰寫程式碼將 cookie 字串剖析成名稱/值組的清單。  
  
 如概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，請參閱[巡覽概觀](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">當嘗試擷取指定的 Cookie 時，如果發生問題，則 <see langword="InternetGetCookie" /> 函式會引發 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 錯誤 (由 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> 呼叫)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">以檔案為基礎時，取得 cookie <see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">取得 cookie 非檔案式<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">
          <see cref="T:System.Uri" />，對應至來源網站上的鬆散資源。</param>
        <summary>傳回來源網站資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含來源網站資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" />。 如果找不到鬆散資源，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不具備執行緒安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相對，或雖然為絕對但不是 <c>pack://siteoforigin:,,,/</c> 格式。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">對應至內嵌資源的 <see cref="T:System.Uri" />。</param>
        <summary>傳回資源資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" /> (請參閱 [WPF 應用程式資源、內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md))。</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含資源資料檔案的資源資料流，這個檔案位於指定的 <see cref="T:System.Uri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不具備執行緒安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">傳遞給 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">傳遞給 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相對，或雖然為絕對但不是 <c>pack://application:,,,/</c> 格式。</exception>
        <exception cref="T:System.IO.IOException">找不到傳遞至 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器所巡覽的內容已載入、剖析和開始呈現時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>。  
  
> [!NOTE]
>  這類接聽事件上巡覽內容<xref:System.Windows.FrameworkElement.Loaded>事件<xref:System.Windows.Controls.Page>才能存取內容的巡覽的內容。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入位於指定之[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面項目) 或應用程式資料檔案 (資源檔中，內容檔案或站台的來源檔案，請參閱 < [WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">對應相對的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的 <see cref="T:System.Uri" />。</param>
        <summary>載入位於指定之[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 檔，並轉換為 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔的根項目所指定之物件的執行個體。</summary>
        <returns>由載入的 XAML 檔所指定之根項目的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須明確轉換成相同類型的根項目為傳回值[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]檔案。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面項目) 或應用程式資料檔案 (資源檔中，內容檔案或站台的來源檔案，請參閱 < [WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是絕對 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">檔案不是 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 檔。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">與 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的根項目同類型的物件。</param>
        <param name="resourceLocator">對應相對的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的 <see cref="T:System.Uri" />。</param>
        <summary>載入位於指定的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔案，並將它轉換為 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 檔案的根項目指定的物件執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]頁面項目) 或應用程式資料檔案 (資源檔中，內容檔案或站台的來源檔案，請參閱 < [WPF 應用程式資源、 內容和資料檔案](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  這個方法不是安全執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是絕對 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> 的型別和 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 檔案的根項目不符。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式的主視窗。</summary>
        <value>指定做為主應用程式視窗的 <see cref="T:System.Windows.Window" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 會自動設定的第一個參考<xref:System.Windows.Window>物件具現化中<xref:System.AppDomain>。  
  
 您可以設定來指定不同的主視窗<xref:System.Windows.Application.MainWindow%2A>指派另一個<xref:System.Windows.Application.Windows%2A>物件<xref:System.Windows.Application.MainWindow%2A>屬性。  
  
 如果<xref:System.Windows.Application.ShutdownMode%2A>屬性<xref:System.Windows.Application>物件設定為<xref:System.Windows.ShutdownMode.OnMainWindowClose>，關閉主視窗會關閉應用程式。  
  
 您可設定<xref:System.Windows.Application.MainWindow%2A>屬性從[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]，如果應用程式的主視窗不是由設定視窗<xref:System.Windows.Application.StartupUri%2A>屬性[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。 兩個限制[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]方法是：  
  
-   您可以指定[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-只<xref:System.Windows.Window>或[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-只<xref:System.Windows.Navigation.NavigationWindow>做為主要的視窗。  
  
-   您必須設定<xref:System.Windows.UIElement.Visibility%2A>您所指定視窗的屬性，否則它將不會顯示。  
  
 第一個參考<xref:System.Windows.Window>要具現化物件也會加入做為第一個項目<xref:System.Windows.Application.Windows%2A>集合。 如果<xref:System.Windows.Application.MainWindow%2A>後續將不同的參考<xref:System.Windows.Window>，將會變更主視窗的參考之項目的位置，在順序中的項目時<xref:System.Windows.Application.Windows%2A>維持不變。 因此，一律使用<xref:System.Windows.Application.MainWindow%2A>主視窗而不是中的第一個項目參考<xref:System.Windows.Application.Windows%2A>。  
  
> [!NOTE]
>  如果主視窗已<xref:System.Windows.Navigation.NavigationWindow>，和您需要特定存取<xref:System.Windows.Navigation.NavigationWindow>成員，您將需要的值轉換<xref:System.Windows.Application.MainWindow%2A>至<xref:System.Windows.Navigation.NavigationWindow>。  
>   
>  這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例顯示如何尋找主應用程式視窗。  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 下列範例示範如何設定<xref:System.Windows.Application.MainWindow%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 下列範例示範如何具現化<xref:System.Windows.Application.MainWindow%2A>應用程式啟動期間的程式碼中。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          從瀏覽器中裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]) 設定 <see cref="P:System.Windows.Application.MainWindow" />。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當找到應用程式中的巡覽器所巡覽的內容時發生，即使可能未完整載入也一樣。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器要求新的巡覽時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當應用程式中的巡覽器巡覽至要求的內容而發生錯誤時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在應用程式中巡覽器所管理的下載期間定期發生，以提供巡覽進度資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當呼叫應用程式中巡覽器的 <see langword="StopLoading" /> 方法時發生，或當巡覽器在目前巡覽進行中又要求新的巡覽時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 導覽器是<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 請參閱 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> 會引發 <xref:System.Windows.Application.Activated> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnActivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnActivated%2A>基底類別中如果<xref:System.Windows.Application.Activated>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Deactivated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> 會引發 <xref:System.Windows.Application.Deactivated> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnDeactivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnDeactivated%2A>基底類別中如果<xref:System.Windows.Application.Deactivated>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Exit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> 會引發 <xref:System.Windows.Application.Exit> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnExit%2A>方法。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnExit%2A>基底類別中如果<xref:System.Windows.Application.Exit>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.FragmentNavigation" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> 會引發 <xref:System.Windows.Application.FragmentNavigation> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnFragmentNavigation%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnFragmentNavigation%2A>基底類別中如果<xref:System.Windows.Application.FragmentNavigation>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.LoadCompleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> 會引發 <xref:System.Windows.Application.LoadCompleted> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnLoadCompleted%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnLoadCompleted%2A>基底類別中如果<xref:System.Windows.Application.LoadCompleted>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Navigated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> 會引發 <xref:System.Windows.Application.Navigated> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigated%2A>基底類別中如果<xref:System.Windows.Application.Navigated>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Navigating" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> 會引發 <xref:System.Windows.Application.Navigating> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigating%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigating%2A>基底類別中如果<xref:System.Windows.Application.Navigating>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationFailed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> 會引發 <xref:System.Windows.Application.NavigationFailed> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationFailed%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigationFailed%2A>基底類別中如果<xref:System.Windows.Application.NavigationFailed>需要引發。  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationProgress" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> 會引發 <xref:System.Windows.Application.NavigationProgress> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationProgress%2A>。 覆寫的方法必須明確地呼叫<xref:System.Windows.Application.OnNavigationProgress%2A>基底類別中如果<xref:System.Windows.Application.NavigationProgress>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Navigation.NavigationEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.NavigationStopped" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> 會引發 <xref:System.Windows.Application.NavigationStopped> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnNavigationStopped%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnNavigationStopped%2A>基底類別中如果<xref:System.Windows.Application.NavigationStopped>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.SessionEndingCancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.SessionEnding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> 會引發 <xref:System.Windows.Application.SessionEnding> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnSessionEnding%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnSessionEnding%2A>基底類別中如果<xref:System.Windows.Application.SessionEnding>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.StartupEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Application.Startup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> 會引發 <xref:System.Windows.Application.Startup> 事件。  
  
 從衍生的型別<xref:System.Windows.Application>可能會覆寫<xref:System.Windows.Application.OnStartup%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Application.OnStartup%2A>基底類別中如果<xref:System.Windows.Application.Startup>必須引發的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式範圍的屬性集合。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" />，包含應用程式範圍的屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 會公開透過字典<xref:System.Windows.Application.Properties%2A>可用來儲存應用程式範圍的屬性。 這可讓您共用中的所有程式碼之間的狀態<xref:System.AppDomain>以執行緒安全的方式，而不必自行撰寫程式的狀態碼。  
  
 屬性儲存在<xref:System.Windows.Application.Properties%2A>必須轉換成傳回適當的型別。  
  
 <xref:System.Windows.Application.Properties%2A>屬性是安全執行緒，可從任何執行緒。  
  
   
  
## Examples  
 下列範例會示範如何建立並使用應用程式領域屬性使用<xref:System.Windows.Application.Properties%2A>。  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Reflection.Assembly" />，提供 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 應用程式中資源的[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 套件。</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> 的參考，提供 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 應用程式中資源的[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 套件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]相對於項目組件，從傳回的值由執行階段在解決資源<xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法。  
  
 項目組件是所傳回的組件<xref:System.Reflection.Assembly.GetEntryAssembly%2A>，而且可以是下列：  
  
-   預設應用程式定義域中的可執行組件。  
  
-   要執行之呼叫的第一個組件<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在下列情況中，不過，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件無法取得項目組件的參考：  
  
-   Unmanaged （機器碼） 的應用程式主機[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件。  
  
-   受管理的應用程式主機[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件載入至新的應用程式定義域以外使用方法<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在上述兩種情況，<xref:System.Reflection.Assembly.GetEntryAssembly%2A>傳回`null`，而[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]無法解析組件的資源。 在這些情況下，<xref:System.Windows.Application.ResourceAssembly%2A>可以可設定，一次只應該用來解析資源的組件的參考。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 只能設定一次，所以不太可能，資源組件會在之後變更[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]已載入組件。  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 時不能設定[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]組件可以探索項目組件 — 也就是，當<xref:System.Reflection.Assembly.GetEntryAssembly%2A>傳回組件的參考而非`null`。  
  
 這個屬性是安全執行緒，可從任何執行緒。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 應用程式具有進入組件，或已設定 <see cref="P:System.Windows.Application.ResourceAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式範圍的資源集合，例如樣式和筆刷。</summary>
        <value>
          <see cref="T:System.Windows.ResourceDictionary" /> 物件，包含零個以上的應用程式範圍資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A>屬性可以用來在 windows 和應用程式的項目之間共用資源。 此外，<xref:System.Windows.Application.Resources%2A>屬性包含在資源查閱路徑、 周遊順序如下：  
  
1.  項目  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  系統  
  
 因此，[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]元素可以繫結至應用程式範圍的資源。 此外，如果變更資源，資源系統可確保該元素繫結至這些資源的屬性會自動更新以反映變更。  
  
 應用程式範圍的資源會提供簡單的方式，以支援跨應用程式一致的主題。 您可以輕鬆地建立佈景主題[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]使用`Application.Resources`標記。 不過，如果您的應用程式支援多個主題，其中可能包含大量的佈景主題的項目，可能是您更輕鬆地管理這些使用其中一種<xref:System.Windows.ResourceDictionary>為每個主題的執行個體。 如此一來，可以套用新的佈景主題的資源屬性設定為適當<xref:System.Windows.ResourceDictionary>。  
  
 有兩個使用時的考量<xref:System.Windows.Application.Resources%2A>。 首先，字典*金鑰*不是物件，因此您必須使用完全相同物件執行個體時設定和取得屬性值 （請注意使用字串時，索引鍵是區分大小寫）。 其次，字典*值*不是物件，因此您必須取得的屬性值時，就將值轉換成所需的類型。  
  
 <xref:System.Windows.Application.Resources%2A> 具備執行緒安全，可從任何執行緒。  
  
   
  
## Examples  
 此範例說明如何使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]連同應用程式範圍的資源，以建立一致的視覺外觀。  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 下列範例會示範如何在程式碼和 XAML 的應用程式資源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 下列範例會示範如何在程式碼中取得應用程式的資源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>啟動 Windows Presentation Foundation 應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動 Windows Presentation Foundation 應用程式。</summary>
        <returns>當應用程式關閉時，傳回至作業系統的 <see cref="T:System.Int32" /> 應用程式結束代碼。 根據預設，結束代碼值為 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 呼叫以啟動[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]應用程式。 如果您定義您<xref:System.Windows.Application>使用標記或標記和程式碼後置<xref:System.Windows.Application.Run%2A>會隱含地呼叫。 不過，如果您定義您<xref:System.Windows.Application>使用程式碼，您需要明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 當<xref:System.Windows.Application.Run%2A>呼叫時，<xref:System.Windows.Application>附加新<xref:System.Windows.Threading.Dispatcher>UI 執行緒的執行個體。 下一步<xref:System.Windows.Threading.Dispatcher>物件的<xref:System.Windows.Threading.Dispatcher.Run%2A>呼叫方法，以便啟動訊息幫浦來處理 windows 訊息。 最後，<xref:System.Windows.Threading.Dispatcher>物件會呼叫<xref:System.Windows.Application>物件的<xref:System.Windows.Application.OnStartup%2A>方法，以引發<xref:System.Windows.Application.Startup>事件。 因此，您所處理的時間建立應用程式執行模型<xref:System.Windows.Application.Startup>，此時應用程式會被視為在執行。  
  
 應用程式停止時執行<xref:System.Windows.Application.Shutdown%2A>稱為; 的值<xref:System.Windows.Application.ShutdownMode%2A>屬性會決定何時<xref:System.Windows.Application.Shutdown%2A>呼叫時，與是否自動，或者您需要明確地呼叫它。  
  
 <xref:System.Windows.Application.Run%2A> 可以只從建立的執行緒呼叫<xref:System.Windows.Application>物件。 此外，<xref:System.Windows.Application.Run%2A>無法從呼叫[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下列範例示範使用自訂的應用程式<xref:System.Windows.Application>，因此必須明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          從瀏覽器裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) 呼叫 <see cref="M:System.Windows.Application.Run" />。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">當應用程式啟動時自動開啟的 <see cref="T:System.Windows.Window" />。</param>
        <summary>啟動 Windows Presentation Foundation 應用程式並開啟指定的視窗。</summary>
        <returns>當應用程式關閉時，傳回至作業系統的 <see cref="T:System.Int32" /> 應用程式結束代碼。 根據預設，結束代碼值為 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載擴充<xref:System.Windows.Application.Run%2A>方法來執行的應用程式啟動後開啟指定的視窗。  
  
 如果您的程式碼定義<xref:System.Windows.Application>，會開啟視窗，它會開始執行時，明確地呼叫<xref:System.Windows.Application.Run%2A>。  
  
 如果您建立您<xref:System.Windows.Application>使用標記或標記和程式碼後置，您就可以自動開啟視窗期間使用的下列技術：  
  
-   以宣告方式，是藉由設定<xref:System.Windows.Application.StartupUri%2A>。  
  
-   以程式設計的方式，藉由處理<xref:System.Windows.Application.Startup>。  
  
   
  
## Examples  
 下列範例會顯示應用程式具現化的手動建立靜態進入點方法<xref:System.Windows.Application>，然後再呼叫<xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          從瀏覽器裝載的應用程式 (例如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]) 呼叫 <see cref="M:System.Windows.Application.Run" />。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者登出或關閉作業系統而結束 Windows 工作階段時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，應用程式關閉時 Windows 工作階段隨即結束，使用者登出或關閉時，就會發生。 當發生這種情況時，Windows 會要求每個開啟的應用程式關閉。 不過，它可能會，應用程式可能無法馬上發生此情況時關閉。 例如，應用程式可能處於不一致的狀態，或進行長時間執行的作業資料。 在這些情況下，它可能會想要防止結束，工作階段，並可能比較想要允許使用者決定要讓結束工作階段的選項。  
  
 您可以藉由處理的工作階段結束時偵測到<xref:System.Windows.Application.SessionEnding>事件。 如果應用程式需要阻礙工作階段結束，<xref:System.Windows.SessionEndingCancelEventArgs>傳遞至事件處理常式的引數會公開<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>，您將設定為`true`(預設值是`false`)。  
  
 如果<xref:System.Windows.Application.SessionEnding>未經處理，或處理而被取消，<xref:System.Windows.Application.Shutdown%2A>稱為和<xref:System.Windows.Application.Exit>就會引發事件。  
  
 若要取得工作階段結束的原因的詳細資訊，請檢查應用程式可以<xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，這是其中一個<xref:System.Windows.ReasonSessionEnding>值 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType>和<xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Application.SessionEnding> 不是主控台應用程式所引發。  
  
 <xref:System.Windows.Application.SessionEnding> 只能在建立的執行緒上引發<xref:System.Windows.Application>物件。  
  
 <xref:System.Windows.Application.SessionEnding> 不會引發 XAML 瀏覽器應用程式 (Xbap)。  
  
   
  
## Examples  
 下列範例示範如何處理<xref:System.Windows.Application.SessionEnding>事件，並允許使用者取消它。  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，指定應該建立 Cookie 的位置。</param>
        <param name="value">包含 Cookie 資料的 <see cref="T:System.String" />。</param>
        <summary>為 <see cref="T:System.Uri" /> 所指定的位置建立 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是任意的資料片段都儲存在應用程式工作階段 (工作階段 cookie)，或在應用程式工作階段 (持續性 cookies) 之間的用戶端電腦上應用程式。 您可以藉由呼叫來建立這兩種類型的 cookie <xref:System.Windows.Application.SetCookie%2A>。  
  
 Cookie 資料通常會以下列格式的名稱/值組的格式：  
  
 `Name=Value`  
  
 您傳遞至這個格式的字串<xref:System.Windows.Application.SetCookie%2A>，連同<xref:System.Uri>設定 cookie 的位置 （一般而言，應用程式定義域）。  
  
 您是否 cookie 是工作階段 cookie 或永續性 cookie，取決於是否 cookie 字串傳遞給<xref:System.Windows.Application.SetCookie%2A>包含到期日。 工作階段 cookie 字串沒有包括到期日。 永續性 cookie 字串存在，而且必須以下列格式：  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 永續性 cookie 儲存在目前[!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)]安裝的 Temporary Internet Files 資料夾，直至到期，在此情況下會刪除它們為止。 您可以從您的應用程式刪除永續性 cookie，藉由其到期日設定在過去的日期/時間值。  
  
 如概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，請參閱[巡覽概觀](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">當嘗試建立指定的 Cookie 時，如果發生問題，則 <see langword="InternetSetCookie" /> 函式會引發 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 錯誤 (由 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> 呼叫)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">以檔案為基礎時，取得 cookie <see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">取得 cookie 非檔案式<see cref="T:System.Uri" />。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>關閉應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉應用程式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Application.Shutdown%2A>呼叫時，應用程式停止執行。 您可以處理<xref:System.Windows.Application.Exit>事件來偵測應用程式時即將停止執行，若要執行任何適當的處理。  
  
 <xref:System.Windows.Application.Shutdown%2A> 會隱含地呼叫 Windows Presentation Foundation 在下列情況：  
  
-   當<xref:System.Windows.Application.ShutdownMode%2A>設<xref:System.Windows.ShutdownMode.OnLastWindowClose>。  
  
-   當<xref:System.Windows.Application.ShutdownMode%2A>設<xref:System.Windows.ShutdownMode.OnMainWindowClose>。  
  
-   當使用者結束工作階段和<xref:System.Windows.Application.SessionEnding>事件已處理時，或處理，而取消。  
  
 呼叫<xref:System.Windows.Application.Shutdown%2A>明確會導致應用程式關閉，不論<xref:System.Windows.Application.ShutdownMode%2A>設定。 不過，如果<xref:System.Windows.Application.ShutdownMode%2A>設<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，您必須呼叫<xref:System.Windows.Application.Shutdown%2A>關閉應用程式。  
  
> [!IMPORTANT]
>  當<xref:System.Windows.Application.Shutdown%2A>是呼叫，應用程式將會關閉無論是否<xref:System.Windows.Window.Closing>取消事件的任何開啟的視窗。  
  
 可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">應用程式的整數結束代碼。 預設結束代碼為 0。</param>
        <summary>關閉應用程式，這個應用程式將指定的結束代碼傳回至作業系統。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以處理<xref:System.Windows.Application.Exit>事件設定的結束代碼。 不過，如果您明確地呼叫<xref:System.Windows.Application.Shutdown%2A>，而且您處理<xref:System.Windows.Application.Exit>僅設定結束碼，您可以呼叫<xref:System.Windows.Application.Shutdown%2A>改為。  
  
 可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定會導致呼叫 <see cref="M:System.Windows.Application.Shutdown" /> 方法的條件。</summary>
        <value>
          <see cref="T:System.Windows.ShutdownMode" /> 列舉值。 預設值是 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式停止執行時，才<xref:System.Windows.Application.Shutdown%2A>呼叫應用程式的方法。 隱含或明確地為指定的值，可能會發生關機<xref:System.Windows.Application.ShutdownMode%2A>屬性。  
  
 如果您設定<xref:System.Windows.Application.ShutdownMode%2A>至<xref:System.Windows.ShutdownMode.OnLastWindowClose>，Windows Presentation Foundation (WPF) 會隱含呼叫<xref:System.Windows.Application.Shutdown%2A>應用程式中的上一個視窗關閉時，即使未設定任何目前的具現化的視窗做為主要視窗 (請參閱<xref:System.Windows.Application.MainWindow%2A>)。  
  
 A<xref:System.Windows.Application.ShutdownMode%2A>的<xref:System.Windows.ShutdownMode.OnMainWindowClose>會隱含地呼叫 WPF<xref:System.Windows.Application.Shutdown%2A>時<xref:System.Windows.Application.MainWindow%2A>隨即關閉，即使目前開啟其他視窗。  
  
 某些應用程式的存留期間可能不相依於當主視窗或最後一個視窗已關閉，或可能完全不能相依於 windows。 這些案例，您需要設定<xref:System.Windows.Application.ShutdownMode%2A>屬性<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，這需要明確<xref:System.Windows.Application.Shutdown%2A>停止應用程式的方法呼叫。 否則，應用程式會繼續在背景執行。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 可以從以宣告方式設定[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]或以程式設計方式從程式碼。  
  
 這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Application.ShutdownMode%2A>來指定應用程式必須明確地關閉。  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼叫 <see cref="M:System.Windows.Application.Run" /> 物件的 <see cref="T:System.Windows.Application" /> 方法時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在啟動時，包括一般的 Windows Presentation Foundation 應用程式可能會執行各種不同的初始設定工作：  
  
-   處理命令列參數。  
  
-   開啟主視窗。  
  
-   正在初始化應用程式範圍的資源。  
  
-   正在初始化應用程式範圍的屬性。  
  
 您可以以宣告方式指定的主視窗和使用的應用程式範圍資源[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)](<xref:System.Windows.Application.StartupUri%2A>和<xref:System.Windows.Application.Resources%2A>分別)。 有時候，不過，資源或主視窗的應用程式只能判斷以程式設計方式在執行階段。 此外，應用程式範圍的屬性和命令列參數僅能以程式設計的方式。 以程式設計方式初始化可執行的處理<xref:System.Windows.Application.Startup>事件，包括下列：  
  
-   取得並處理命令列參數，都是從<xref:System.Windows.StartupEventArgs.Args%2A>屬性<xref:System.Windows.StartupEventArgs>類別傳遞給<xref:System.Windows.Application.Startup>事件處理常式。  
  
-   初始化應用程式範圍的資源使用<xref:System.Windows.Application.Resources%2A>屬性。  
  
-   初始化應用程式範圍的屬性是使用<xref:System.Windows.Application.Properties%2A>屬性。  
  
-   具現化，並會顯示一個 （或以上） 的視窗。  
  
> [!NOTE]
>  命令列參數也可以取得藉由呼叫靜態<xref:System.Environment.GetCommandLineArgs%2A>方法<xref:System.Environment>物件。 不過，<xref:System.Environment.GetCommandLineArgs%2A>需要完全信任才能執行。  
  
 如果您設定<xref:System.Windows.Application.StartupUri%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]，就無法使用從主要視窗建立<xref:System.Windows.Application.MainWindow%2A>屬性或<xref:System.Windows.Application.Windows%2A>屬性<xref:System.Windows.Application>之後的物件直到<xref:System.Windows.Application.Startup>處理事件。 如果您在啟動期間需要存取主要視窗中，您需要以手動方式建立新的視窗物件，從您<xref:System.Windows.Application.Startup>事件處理常式。  
  
> [!NOTE]
>  如果您的應用程式使用<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>若要指定認證原則，您需要設定<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>之後<xref:System.Windows.Application.Startup>引發，否則[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]將其設為預設內部原則直接之後<xref:System.Windows.Application.Startup>在引發事件。  
  
 傳遞至命令列引數<xref:System.Windows.Application.Startup>事件處理常式不是相同[!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]查詢字串參數傳遞給[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下列範例會示範如何取得並處理從獨立應用程式的命令列選項。 如果 **/StartMinimized**提供命令列參數，在應用程式開啟主視窗中最小化狀態。  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 無法擷取和處理命令列引數，因為它們會以啟動[!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]部署 (請參閱[部署 WPF 應用程式 (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md))。 不過，它們可以透過用來啟動的 URL 擷取及處理查詢字串參數。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定當應用程式啟動時會自動顯示的 UI。</summary>
        <value>A<see cref="T:System.Uri" />參考應用程式啟動時自動開啟的 UI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Windows.Application.StartupUri%2A>應用程式啟動時，會自動載入 UI 的資源。  
  
 下表顯示 UI 資源，可載入的類型，都會開啟的視窗類型，可以將設定為這些資源的應用程式的類型<xref:System.Windows.Application.StartupUri%2A>。  
  
|類型|視窗|應用程式類型|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|僅限獨立|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|僅限獨立|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載|  
  
 通常您設定<xref:System.Windows.Application.StartupUri%2A>屬性以宣告方式在[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]。 不過，您可以設定<xref:System.Windows.Application.StartupUri%2A>程式設計角度而言，這類在<xref:System.Windows.Application.Startup>事件處理常式，可用於如果只在執行階段載入必要的 UI 資源的應用程式。 例如，應用程式可能會等候直到在載入其資源，如果 UI 資源的名稱儲存在組態檔中的執行階段。  
  
 您是否設定<xref:System.Windows.Application.StartupUri%2A>之前未載入以宣告方式或以程式設計的方式，對應的 UI 資源之後<xref:System.Windows.Application.Startup>處理事件。 因此，您不需要存取結果視窗中從<xref:System.Windows.Application.Windows%2A>屬性或<xref:System.Windows.Application.MainWindow%2A>屬性時處理<xref:System.Windows.Application.Startup>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> 設定為 null 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求之環境屬性 (Ambient Property) 的名稱。</param>
        <summary>查詢目前範圍中是否有指定的環境屬性。</summary>
        <returns>
          如果可使用要求的環境屬性則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.Application> 執行個體轉換成 <xref:System.Windows.Markup.IQueryAmbient> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要尋找之資源的名稱。</param>
        <summary>搜尋指定的資源。</summary>
        <returns>要求的資源物件。 如果找不到要求的資源，則會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 會先尋找在指定的資源的應用程式範圍資源。 應用程式範圍的資源由管理<xref:System.Windows.Application>，而且會公開從<xref:System.Windows.Application.Resources%2A>屬性。 如果應用程式範圍資源集中找不到指定的資源<xref:System.Windows.Application.TryFindResource%2A>然後搜尋系統資源。 系統資源是由使用者定義的 shell 資源，並且包含色彩、 字型及殼層組態。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。 若要使用<xref:System.Windows.Application.TryFindResource%2A>取得它們，這些型別也會公開資源的索引鍵屬性是設計成傳遞給<xref:System.Windows.Application.TryFindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因為<xref:System.Windows.Application.TryFindResource%2A>傳回的物件，如果找到資源，您必須轉換成適當的類型傳回的值。  
  
 這個方法是安全執行緒，可以從任何執行緒呼叫。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Windows.Application.TryFindResource%2A>取得資源。  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式中已具現化的視窗。</summary>
        <value>
          <see cref="T:System.Windows.WindowCollection" />，包含目前 <see cref="T:System.AppDomain" /> 中所有視窗物件的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Window>參考會自動加入至<xref:System.Windows.Application.Windows%2A>上具現化一個視窗時，立即[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]執行緒，則為所建立的背景工作執行緒不會加入 windows。 A<xref:System.Windows.Window>之後，會自動移除參考其<xref:System.Windows.Window.Closing>已處理事件，以及之前其<xref:System.Windows.Window.Closed>就會引發事件。  
  
 根據預設，第一個項目加入至<xref:System.Windows.Application.Windows%2A>屬性變成<xref:System.Windows.Application.MainWindow%2A>。  
  
 這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。  
  
   
  
## Examples  
 下列範例示範如何列舉<xref:System.Windows.Application.Windows%2A>屬性建置最上層的 Windows 功能表上，而這通用於[!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)]應用程式要[!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]，或是想要的多個執行個體的單一文件介面 (SDI) 應用程式[!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>