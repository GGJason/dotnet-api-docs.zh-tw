<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9a12e407bc5345e416145c390f8fcd6f8262c445" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30676972" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>為唯讀相依性屬性的有限寫入權限提供相依性屬性識別項。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey> 取得執行個體做為相依性屬性註冊呼叫使用方法的傳回值<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>或<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。  
  
 註冊相依性屬性的型別可以使用<xref:System.Windows.DependencyPropertyKey>中呼叫<xref:System.Windows.DependencyObject.SetValue%2A>和<xref:System.Windows.DependencyObject.ClearValue%2A>，調整屬性的值做為類別邏輯的一部分。 如果允許索引鍵的存取層級，相關的類別也可以使用索引鍵和相依性屬性。 比方說，您可以宣告為內部，索引鍵和相同的組件內的其他類型也可以設定該相依性屬性。  
  
 <xref:System.Windows.DependencyPropertyKey>傳回以唯讀狀態的相依性屬性登錄不能為公用的因為公開索引鍵會讓此屬性可設定的因此擊敗登錄為唯讀相依性屬性的點。 此外，公開索引鍵會導致不相符的可用的相依性屬性行為和其[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]屬性的包裝函式實作，也就是不正確的類別設計。  
  
 而不是公開本身的索引鍵，您應該改為公開<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A>值<xref:System.Windows.DependencyPropertyKey>為`public static readonly`<xref:System.Windows.DependencyProperty>針對您的類別。 這可讓屬性以傳回特定屬性系統作業，例如列舉本機設定值有效的相依性屬性的識別項。 但是，因此取得的識別項不需要的完整功能<xref:System.Windows.DependencyProperty>許多屬性系統作業。  
  
   
  
## Examples  
 下列範例登錄唯讀相依性屬性和索引鍵也會使用其他類別成員中有兩種用途： 實作 get 「 包裝函式 」，以及設定的值判斷受保護的作業的識別碼為依據的計算其他屬性值。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個特定的相依性屬性識別項關聯的相依性屬性識別項。</summary>
        <value>相關的相依性屬性識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A>值可讓加入共同使用一些相同的介面所使用的讀寫相依性屬性的屬性系統作業的唯讀屬性的識別項。  
  
 若要實作唯讀相依性屬性的 get 屬性存取子，您應該建立及顯示<xref:System.Windows.DependencyProperty>針對您的類別識別項。 這有兩種用途：  
  
-   您自己的類別需要<xref:System.Windows.DependencyProperty>為了實作 get 存取子屬性的包裝函式的識別項。 您使用<xref:System.Windows.DependencyProperty>做為參數的<xref:System.Windows.DependencyObject.GetValue%2A>實作 get 存取子的呼叫。  
  
-   <xref:System.Windows.DependencyProperty> 識別項會公開屬性系統相依性屬性，讓中繼資料所依賴的其他方法可以存取它之標準格式。 比方說，如果您呼叫<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>上某些<xref:System.Windows.DependencyObject>，並且取得列舉型別在本機上設定屬性 （「 值 」 和 「 識別碼 」） 的識別碼傳回唯讀相依性屬性將會是您<xref:System.Windows.DependencyProperty>值而不是索引鍵。 不會公開<xref:System.Windows.DependencyProperty>識別碼不會增加您以任何方式的唯讀相依性屬性的安全性，它只會牽涉到更造成不便同時用於後續的衍生的類別以及類別執行個體屬性的作業。  
  
 若要公開<xref:System.Windows.DependencyProperty>呼叫您的類別識別項，<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A>直接在您的金鑰。 使用此值以建立`public static readonly`<xref:System.Windows.DependencyProperty>平行設計的類別識別項<xref:System.Windows.DependencyPropertyKey>。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A>公開<xref:System.Windows.DependencyProperty>識別項 (`AquariumGraphicProperty`) 的`AquariumGraphic`類別上的唯讀相依性屬性。 此範例也示範<xref:System.Windows.DependencyPropertyKey>（做為內部的成員） 的建立和 get 存取子的`AquariumGraphic`。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">這個相依性屬性所存在以及中繼資料應該覆寫的型別。</param>
        <param name="typeMetadata">為這個型別提供的中繼資料。</param>
        <summary>覆寫由相依性屬性識別項表示之唯讀相依性屬性的中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫唯讀相依性屬性的中繼資料基於相似的原因與覆寫中繼資料讀寫相依性屬性，並僅限於使用索引鍵的層級的存取，因為指定的中繼資料中的行為可能會變更設定的行為 (預設值，執行個體）。  
  
 為具有讀寫相依性屬性，覆寫唯讀相依性屬性的中繼資料應該只有在執行之前屬性系統放在使用該屬性 (這相當於時註冊的物件的該特定執行個體屬性會具現化）。 呼叫<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>執行應該只能在靜態建構函式的類型，提供本身為`forType`這個方法或對等初始化時，該類別的參數。  
  
 這個方法實際上會轉送至<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法，傳遞<xref:System.Windows.DependencyPropertyKey>做為索引鍵參數的執行個體。  
  
   
  
## Examples  
 下列範例會覆寫現有唯讀相依性屬性的類別繼承的中繼資料。 在此情況下，案例目標是要加入基底屬性中繼資料並沒有強制值回呼。 無法覆寫中繼資料通常是其他原因適用也覆寫中繼資料 (變更預設值，加入<xref:System.Windows.FrameworkPropertyMetadataOptions>值等。)  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">嘗試覆寫唯讀相依性屬性的中繼資料 (無法使用這個簽章執行)。</exception>
        <exception cref="T:System.ArgumentException">已為存在於所提供之型別的屬性建立中繼資料。</exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>