<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c70304d7b52b8f4e76c37fd1e35de0928f9619c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680542" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>為相依性屬性回報或套用中繼資料，特別加入架構專屬的屬性系統特性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此類別衍生自<xref:System.Windows.PropertyMetadata>(透過<xref:System.Windows.UIPropertyMetadata>)。 大部分的 WPF 架構層級應用程式開發用途而言，<xref:System.Windows.FrameworkPropertyMetadata>是用於相依性屬性中繼資料的類型，而不是基底中繼資料型別<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>。 這適用於現有的相依性屬性和大部分自訂相依性屬性。  
  
 這個宣告的成員類別該補充<xref:System.Windows.PropertyMetadata>基底類別包含各種布林屬性，可指定或報表 WPF 架構層級屬性的系統行為，例如屬性繼承、 資料繫結和版面配置。  
  
 建立數個建構函式簽章<xref:System.Windows.FrameworkPropertyMetadata>執行個體採用<xref:System.Windows.FrameworkPropertyMetadataOptions>參數。 <xref:System.Windows.FrameworkPropertyMetadataOptions>列舉型別只用於指定初始的行為在建構函式，而且否則不會公開之後<xref:System.Windows.FrameworkPropertyMetadata>建構。 建構的執行個體中，您可以取得或設定共用的建構函式呼叫中使用的列舉值名稱的各種屬性對應的資訊。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別通常不會使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得相依性屬性的中繼資料上的特定擁有者為初始的基底<xref:System.Windows.PropertyMetadata>型別。 中繼資料會轉型為<xref:System.Windows.FrameworkPropertyMetadata>。 如果轉型傳回有效<xref:System.Windows.FrameworkPropertyMetadata>，則各種<xref:System.Windows.FrameworkPropertyMetadata>屬性值會報告透過 （未顯示） 的簡單 UI。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此簽章初始化的所有值<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>為其屬性的預設值。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 將`null`，各種<xref:System.Windows.FrameworkPropertyMetadata>將布林值屬性`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <summary>使用指定的預設值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <summary>使用提供的預設值和架構中繼資料選項，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
 值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 接下來，只要中繼資料尚未套用至特定的屬性系統作業，您可以變更在中繼資料，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用提供的預設值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫處理常式實作的參考。</param>
        <summary>使用指定的回呼初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作會呼叫基底的初始設定式，然後新增`coerceValueCallback`基底的執行個體上設定的屬性。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用提供的預設值和架構中繼資料選項，以及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
 值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <summary>使用提供的預設值和指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <summary>使用提供的預設值和架構中繼資料選項，以及指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
 值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。 如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。 <see langword="false" /> 表示允許建立屬性的動畫。 預設值為 <see langword="false" />。</param>
        <summary>使用提供的預設值和架構中繼資料選項、指定的回呼，以及可用以防止屬性動畫的布林值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
 `isAnimationProhibited`參數設定的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>屬性宣告直接基底<xref:System.Windows.UIPropertyMetadata>類別。  
  
 值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫這個建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。 如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。 預設值為 <see langword="false" />。</param>
        <param name="defaultUpdateSourceTrigger">在套用這個屬性的繫結、且這些繫結的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 是設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 時所使用的 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>使用提供的預設值和架構中繼資料選項、指定的回呼、可用以防止屬性動畫的布林值，以及資料繫結更新觸發程序的預設值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。  
  
 `isAnimationProhibited`參數設定的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>屬性宣告直接基底<xref:System.Windows.UIPropertyMetadata>類別。  
  
 如需繫結的更新來源行為的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響排列傳遞。</summary>
        <value>
          如果這個中繼資料所在的相依性屬性可能會影響排列傳遞則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。 此邏輯的一部分，變更生效的相依性屬性值，並有中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>設`true`會初始化延後的要求，使該元素的視覺效果 (呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>)。 因為此 WPF 架構層級實作已備妥，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>，除非您大幅遭到取代，或修改的 WPF 架構層級配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為相依性屬性變更為其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>是`true`。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不常使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響測量行程。</summary>
        <value>
          如果這個中繼資料所在的相依性屬性可能會影響測量行程，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。 此邏輯的一部分，變更生效的相依性屬性值，並有中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>設`true`會初始化延後的要求，使該元素的視覺效果。 因為此 WPF 架構層級實作已備妥，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>，除非您大幅遭到取代，或修改的 WPF 架構層級配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為相依性屬性變更為其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>是`true`。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的排列傳遞。</summary>
        <value>
          如果這個中繼資料所在的相依性屬性可能會特別影響其父項目的排列傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。 此邏輯的一部分，變更生效的相依性屬性值，並有中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>設`true`會初始化延後的要求，使視覺效果的父項目。  
  
 一般而言，您不需要來報告變更的<xref:System.Windows.FrameworkElement>父項目使用屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>因為項目本身會已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>為`true`。 通常已足夠，因為子元素中的變更通常起始父代排列在適當時。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。 在此情況下，子系項目集合的屬性，但有<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。 比方說的值變更<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>失效附加的屬性的子元素所排列的父代，因為必須變更子系的父系中的位置。 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的屬性的中繼資料位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。 另一個例子是<xref:System.Windows.Controls.Control.Padding%2A>; 當此屬性的變更，父代可能會變更位置的子系，視可用空間而定。  
  
 因為此 WPF 架構層級實作已備妥，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>，除非您大幅遭到取代，或修改的 WPF 架構層級配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為相依性屬性變更為其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。  
  
 任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的測量行程。</summary>
        <value>
          如果這個中繼資料所在的相依性屬性可能會明顯影響父項目的測量行程則為 <see langword="true" />，否則為 <see langword="false" />。預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。 此邏輯的一部分，變更生效的相依性屬性值，並有中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>設`true`會初始化延後的要求，使視覺效果的父項目。 因為此 WPF 架構層級實作已備妥，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>，除非您大幅遭到取代，或修改的 WPF 架構層級配置行為。  
  
 一般而言，您不需要來報告變更的<xref:System.Windows.FrameworkElement>父項目使用屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>因為項目本身會已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>為`true`。 通常已足夠，因為子元素中的變更通常會起始時適當的父量值傳遞。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。 在此情況下，子系項目集合的屬性，但有<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。 比方說的值變更<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>是被子元素的屬性會使量值的父代，因為段落的相對間距可能變更，可能會增加或減少內容主機大小。 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>屬性的中繼資料位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 相依性屬性的變更也經常尋找內容主機項目位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`，內容主機轉譯邏輯的一部分。 比方說，<xref:System.Windows.Controls.TextBox>項目必須回應某些變更可能會要求的文字中的週框方塊<xref:System.Windows.Controls.TextBox>本身變更。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為相依性屬性變更為其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性是否可能影響一般的版面配置，而不會特別影響排列或測量，但可能需要重新繪製。</summary>
        <value>
          如果這個中繼資料所在的相依性屬性會影響呈現，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。 此邏輯的一部分，變更生效的相依性屬性值，並有中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>設`true`會初始化延後的要求，使該元素的視覺效果。 因為此 WPF 架構層級實作已備妥，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>，除非您大幅遭到取代，或修改的 WPF 架構層級配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為相依性屬性變更為其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>是`true`。  
  
 任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出屬性是否預設雙向繫結。</summary>
        <value>
          <see langword="true" /> 如果這個中繼資料所在的相依性屬性預設雙向繫結。否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 沒有這個屬性被`true`，更新繫結預設為單向，根據的預設行為<xref:System.Windows.Data.Binding>建構函式或對等項目[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 在現有的項目，您通常會發現這個屬性設定為`true`同時報告的狀態，並是可修改的使用者動作，例如相依性屬性的中繼資料中<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。  
  
 這個屬性只在一般情況下報告的相依性屬性的預設繫結更新特性。 任何繫結設定為執行個體上的這個屬性可以在本機設定<xref:System.Windows.Data.Binding.Mode%2A>繫結屬性和變更這個預設值。  
  
 任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定當套用具有這個中繼資料 (且 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />) 之屬性的繫結時，所要使用的預設 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</summary>
        <value>列舉型別的值，而非 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">這個屬性已設為 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。當繫結要求時，您所設定的值應該要成為預設值。</exception>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性的值是否為可繼承。</summary>
        <value>
          如果可以繼承這個屬性的值則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性值繼承是一項功能[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統，在 WPF 架構層級，讓特定相依性屬性可以在本機設定的項目或附近的根目錄[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]項目樹狀結構，然後將其繼承的值也會包含該屬性的子項目之邏輯樹狀結構內的所有項目。 根據預設，未啟用屬性值繼承，且啟用一些效能隱含作用。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
> [!NOTE]
>  雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀目錄中的某些物件部門附加屬性的繼承行為是未定義。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出相依性屬性是否支援資料繫結。</summary>
        <value>
          如果套用這個中繼資料的相依性屬性支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會報告`false`其中兩個可能的狀況： 相依性屬性是唯讀的 （如報告相依性屬性的識別項，不是中繼資料中），因為其中一個相依性屬性的資料繫結不允許的值另一個中繼資料屬性<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，設為`true`此中繼資料中。 這個屬性公開為方便起見，讓呼叫端不需要同時檢查<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。  
  
 如果您嘗試建立其他的讀/寫屬性應該不支援資料繫結所指定的中繼資料，請指定此旗標<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(請注意有些微的命名慣例差異與<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得從各種不同的相依性屬性欄位的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性是否支援資料繫結。</summary>
        <value>
          如果屬性不支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，此中繼資料屬性設定為`true`特別針對不支援資料繫結，儘管讀寫屬性的屬性。 預期是，在其中宣告相依性屬性的大部分情況下，資料繫結想要使用，因為資料繫結是其中一個重要的案例，其中的相依性屬性是很有用。 不同於<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，這並不只是變更稍後可變更特定的繫結的預設值。 設定這個屬性`true`相依性屬性的中繼資料中的中繼資料將會停用透過運算式將值套用至該相依性屬性的所有繫結。  
  
 唯讀相依性屬性不支援資料繫結 （因為它們沒有 setter 可套用變更的值），但仍會報告`false`如<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。 這是因為屬性對應到<xref:System.Windows.FrameworkPropertyMetadataOptions>值將會報告使用方式中繼資料已實際建立，而不是一律報告結束結果行為的屬性命名可能會隱含的權限的同位檢查。 若要判斷給定的相依性屬性是否允許資料繫結，您應該通常檢查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>改為。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 同時檢查方便<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>成單一作業，而產生預期的結果。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出此屬性是否包含日誌記錄資訊，其為應用程式可以或應該儲存為日誌記錄實作的一部分。</summary>
        <value>
          如果日誌記錄應該在這個中繼資料所套用的目標相依性屬性上執行，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要合併的基底中繼資料。</param>
        <param name="dp">要套用這個中繼資料的相依性屬性。</param>
        <summary>啟用來源中繼資料與基底中繼資料的合併。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中繼資料覆寫時，為內部使用這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.PropertyMetadata" />（或這特別類別） 應該覆寫這個方法，以針對任何中繼資料屬性，在他們的實作中加入這些帳戶。 比方說，您的實作可能已經加入新旗列舉值，而<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />實作應該可以正確結合這些旗標。  
  
 因為基底實作會處理合併上先前的型別階層架構中已經定義的所有內容，請務必呼叫基底實作您自己的實作之前。  
  
 所加入的行為<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />中的實作<see cref="T:System.Windows.FrameworkPropertyMetadata" />在於特定的 WPF 架構層級屬性中的中繼資料，例如<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />會併入位元或作業。  
  
 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />行為也會實作行為，當您藉由呼叫覆寫現有的相依性屬性的屬性中繼資料<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />。，使用覆寫的中繼資料<see cref="T:System.Windows.FrameworkPropertyMetadata" />。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已套用這個中繼資料的相依性屬性。</param>
        <param name="targetType">如果這是型別特定的中繼資料，則為與這個中繼資料相關聯的型別。 如果這是預設中繼資料，則這個值可能是 <see langword="null" />。</param>
        <summary>在這個中繼資料已套用至屬性時呼叫，表示要密封中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何可變動性的資料結構的<xref:System.Windows.FrameworkPropertyMetadata>執行個體應該標記為當做不變時叫用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" />實作這個方法不超過呼叫基底實作。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示屬性值繼承評估是否應該跨越項目邏輯樹狀中的特定內容界限。</summary>
        <value>
          如果屬性值繼承應跨越特定內容界限則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此中繼資料會報告跨特殊的父項目子系項目界限少見修改屬性值繼承行為。 這類界限的標準範例是內容<xref:System.Windows.Controls.Frame>，其中<xref:System.Windows.Controls.Frame>內容可能會取得獨立的存在重新載入<xref:System.Windows.Controls.Frame>。 所需的屬性系統行為是屬性值繼承應該周遊到的內容<xref:System.Windows.Controls.Frame>，因為這些內容可能會裝載框架的應用程式不會擁有或控制的項目。 指定中繼資料與<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>設`true`，也會為指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>為`true`，將會導致的屬性的中繼資料套用為可繼承即使透過<xref:System.Windows.Controls.Frame>界限或類似的界限。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性的子屬性是否不會影響包含物件的呈現。</summary>
        <value>
          如果子屬性值的變更不會影響變更後的呈現則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此中繼資料的選項是相關的是參考類型，其中該類型有它自己的屬性值的相依性屬性。 一般而言，配置系統邏輯是假設任何具有子屬性的相依性屬性可能會影響配置，因為檢查所有的子屬性的變更會耗用更多時間比實際執行另一個呈現的傳遞。 此選項設為`true`適用於最佳化 WPF 架構層級的版面配置系統實作的效能。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。 這是讓可在執行個體的初始設定之後加以調整。 不過，一旦一部分的呼叫會使用中繼資料<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>