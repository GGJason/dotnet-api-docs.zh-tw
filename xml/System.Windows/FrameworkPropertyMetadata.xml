<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37492929" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="12109-101">為相依性屬性回報或套用中繼資料，特別加入架構專屬的屬性系統特性。</span>
      <span class="sxs-lookup">
        <span data-stu-id="12109-101">Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-102">這個類別衍生自<xref:System.Windows.PropertyMetadata>(透過<xref:System.Windows.UIPropertyMetadata>)。</span><span class="sxs-lookup"><span data-stu-id="12109-102">This class derives from <xref:System.Windows.PropertyMetadata> (through <xref:System.Windows.UIPropertyMetadata>) .</span></span> <span data-ttu-id="12109-103">大部分的 WPF 架構層級的應用程式開發用途而言，<xref:System.Windows.FrameworkPropertyMetadata>是用於相依性屬性中繼資料的型別，而不是基底中繼資料型別<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>。</span><span class="sxs-lookup"><span data-stu-id="12109-103">For most WPF framework-level application development purposes, <xref:System.Windows.FrameworkPropertyMetadata> is the type used for dependency property metadata, rather than the base metadata types <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="12109-104">這是現有相依性屬性中，大部分的自訂相依性屬性案例，則為 true。</span><span class="sxs-lookup"><span data-stu-id="12109-104">This is true both for existing dependency properties and for most custom dependency property scenarios.</span></span>  
  
 <span data-ttu-id="12109-105">宣告此成員類別該資訊補充<xref:System.Windows.PropertyMetadata>基底類別包含各種布林屬性，可指定或報表 WPF 架構層級屬性系統行為，例如屬性繼承、 資料繫結和版面配置。</span><span class="sxs-lookup"><span data-stu-id="12109-105">The members declared by this class that supplement the <xref:System.Windows.PropertyMetadata> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</span></span>  
  
 <span data-ttu-id="12109-106">建立數個建構函式簽章<xref:System.Windows.FrameworkPropertyMetadata>執行個體進行<xref:System.Windows.FrameworkPropertyMetadataOptions>參數。</span><span class="sxs-lookup"><span data-stu-id="12109-106">Several constructor signatures for creating a <xref:System.Windows.FrameworkPropertyMetadata> instance take a <xref:System.Windows.FrameworkPropertyMetadataOptions> parameter.</span></span> <span data-ttu-id="12109-107"><xref:System.Windows.FrameworkPropertyMetadataOptions>列舉型別只用於指定初始的行為，在建構函式，而且否則不會公開之後<xref:System.Windows.FrameworkPropertyMetadata>建構。</span><span class="sxs-lookup"><span data-stu-id="12109-107">The <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <xref:System.Windows.FrameworkPropertyMetadata> is constructed.</span></span> <span data-ttu-id="12109-108">建構的執行個體中，您可以取得或設定對應的資訊，透過共用的建構函式呼叫中使用的列舉值名稱的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="12109-108">From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</span></span>  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-109">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-109">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-110">此類別通常不會使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-110">This class is not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-111">下列範例會取得相依性屬性的中繼資料上的特定擁有者為初始基底<xref:System.Windows.PropertyMetadata>型別。</span><span class="sxs-lookup"><span data-stu-id="12109-111">The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type.</span></span> <span data-ttu-id="12109-112">該中繼資料會轉換成<xref:System.Windows.FrameworkPropertyMetadata>。</span><span class="sxs-lookup"><span data-stu-id="12109-112">That metadata is cast to <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="12109-113">如果將傳回的有效<xref:System.Windows.FrameworkPropertyMetadata>，然後各種<xref:System.Windows.FrameworkPropertyMetadata>屬性值會報告透過一個簡單的 UI （未顯示）。</span><span class="sxs-lookup"><span data-stu-id="12109-113">If the cast returned a valid <xref:System.Windows.FrameworkPropertyMetadata>, then various <xref:System.Windows.FrameworkPropertyMetadata> property values are reported through a simple UI (not shown).</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="12109-114">初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-114">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span>
          </span>
        </summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="12109-115">初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-115">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-116">此簽章初始化的所有值<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>為其屬性的預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-116">This signature initializes all values of <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> to their property defaults.</span></span> <span data-ttu-id="12109-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 將會`null`，和各種<xref:System.Windows.FrameworkPropertyMetadata>布林值屬性會`false`。</span><span class="sxs-lookup"><span data-stu-id="12109-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> will be `null`, and the various <xref:System.Windows.FrameworkPropertyMetadata> Boolean properties will be `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-118">相依性屬性的預設值，通常為特定型別的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-118">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-119">使用指定的預設值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-119">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified default value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-120">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-120">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-121">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-121">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-122">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-122">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-123">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-123">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-124">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-124">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-125">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-125">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-126">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-126">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-127">使用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-127">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12109-128">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-128">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-129">相依性屬性的預設值，通常為特定型別的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-129">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="12109-130">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-130">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="12109-131">這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-131">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-132">使用提供的預設值和架構中繼資料選項，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-132">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework-level metadata options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-133">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-133">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-134">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-134">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-135">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-135">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-136">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-136">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="12109-137">值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-137">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="12109-138">接著，只要中繼資料尚未套用至特定的屬性系統作業，您可以變更的中繼資料中，屬性的值。</span><span class="sxs-lookup"><span data-stu-id="12109-138">You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-139">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-139">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-140">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-140">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-141">相依性屬性的預設值，通常為特定型別的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-141">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-142">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-142">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-143">使用提供的預設值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-143">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-144">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-144">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-145">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-145">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-146">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-146">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-147">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-147">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-148">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-148">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-149">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-149">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-150">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-150">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="12109-151">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-151">A reference to a handler implementation will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-152">使用指定的回呼初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-152">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-153">此實作會呼叫基底的初始設定式，然後新增`coerceValueCallback`基底的執行個體上設定屬性。</span><span class="sxs-lookup"><span data-stu-id="12109-153">This implementation calls a base initializer and then adds the `coerceValueCallback` by setting the property on the base instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-154">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-154">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-155">相依性屬性的預設值，通常為特定型別的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-155">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="12109-156">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-156">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="12109-157">這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-157">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-158">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-158">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-159">使用提供的預設值和架構中繼資料選項，以及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-159">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-160">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-160">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-161">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-161">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-162">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-162">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-163">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-163">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="12109-164">值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-164">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="12109-165">只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。</span><span class="sxs-lookup"><span data-stu-id="12109-165">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-166">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-166">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-167">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-167">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-168">相依性屬性的預設值，通常為特定型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-168">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-169">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-169">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="12109-170">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-170">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-171">使用提供的預設值和指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-171">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-172">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-172">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-173">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-173">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-174">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-174">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-175">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-175">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-176">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-176">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-177">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-177">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-178">相依性屬性的預設值，通常為特定型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-178">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="12109-179">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-179">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="12109-180">這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-180">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-181">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-181">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="12109-182">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-182">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-183">使用提供的預設值和架構中繼資料選項，以及指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-183">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-184">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-184">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-185">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-185">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-186">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-186">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-187">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-187">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="12109-188">值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-188">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="12109-189">只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。</span><span class="sxs-lookup"><span data-stu-id="12109-189">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-190">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-190">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-191">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-191">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-192">相依性屬性的預設值，通常為特定型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-192">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="12109-193">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-193">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="12109-194">這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-194">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-195">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-195">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="12109-196">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-196">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> on this dependency property.</span>
          </span>
        </param>
        <param name="isAnimationProhibited">
          <span data-ttu-id="12109-197">
            <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-197">
              <see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span>
          </span>
          <span data-ttu-id="12109-198">如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-198">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span>
          </span>
          <span data-ttu-id="12109-199">
            <see langword="false" /> 表示允許建立屬性的動畫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-199">
              <see langword="false" /> to permit animating the property.</span>
          </span>
          <span data-ttu-id="12109-200">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-200">The default is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-201">使用提供的預設值和架構中繼資料選項、指定的回呼，以及可用以防止屬性動畫的布林值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-201">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-202">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-202">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-203">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-203">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-204">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-204">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-205">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-205">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="12109-206">`isAnimationProhibited`參數設定初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底宣告的屬性<xref:System.Windows.UIPropertyMetadata>類別。</span><span class="sxs-lookup"><span data-stu-id="12109-206">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="12109-207">值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-207">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="12109-208">只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。</span><span class="sxs-lookup"><span data-stu-id="12109-208">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-209">下列範例會呼叫此建構函式簽章：</span><span class="sxs-lookup"><span data-stu-id="12109-209">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-210">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-210">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="12109-211">相依性屬性的預設值，通常為特定型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-211">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="12109-212">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-212">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="12109-213">這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-213">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="12109-214">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-214">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="12109-215">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-215">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <param name="isAnimationProhibited">
          <span data-ttu-id="12109-216">
            <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-216">
              <see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span>
          </span>
          <span data-ttu-id="12109-217">如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-217">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span>
          </span>
          <span data-ttu-id="12109-218">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-218">The default is <see langword="false" />.</span>
          </span>
        </param>
        <param name="defaultUpdateSourceTrigger">
          <span data-ttu-id="12109-219">在套用這個屬性的繫結、且這些繫結的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 是設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 時所使用的 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-219">The <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for this property are applied that have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-220">使用提供的預設值和架構中繼資料選項、指定的回呼、可用以防止屬性動畫的布林值，以及資料繫結更新觸發程序的預設值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-220">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-221">提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="12109-221">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="12109-222">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。</span><span class="sxs-lookup"><span data-stu-id="12109-222">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="12109-223">屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="12109-223">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="12109-224">值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-224">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="12109-225">`isAnimationProhibited`參數設定初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底宣告的屬性<xref:System.Windows.UIPropertyMetadata>類別。</span><span class="sxs-lookup"><span data-stu-id="12109-225">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="12109-226">如需有關繫結的更新來源行為的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="12109-226">For more information about the update source behavior for bindings, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
 <span data-ttu-id="12109-227">值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-227">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="12109-228">只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。</span><span class="sxs-lookup"><span data-stu-id="12109-228">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-229">
            <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-229">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-230">取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響排列傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-230">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-231">如果這個中繼資料所在的相依性屬性可能會影響排列傳遞則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-231">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-232">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-232">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-233"><xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。</span><span class="sxs-lookup"><span data-stu-id="12109-233"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="12109-234">這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>設定為`true`將會起始要使其失效的視覺效果，該元素的延後的要求 (呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>)。</span><span class="sxs-lookup"><span data-stu-id="12109-234">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element (a call to <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span></span> <span data-ttu-id="12109-235">由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。</span><span class="sxs-lookup"><span data-stu-id="12109-235">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="12109-236">自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-236">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-237">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-237">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-238">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-238">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-239">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-239">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-240">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-240">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-241">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-241">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-242">這個類別的成員不常使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-242">Members of this class are either not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-243">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-243">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-244">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-244">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-245">取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響測量行程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-245">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-246">如果這個中繼資料所在的相依性屬性可能會影響測量行程，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-246">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-247">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-247">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-248"><xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。</span><span class="sxs-lookup"><span data-stu-id="12109-248"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="12109-249">這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>設定為`true`會起始要使其失效的視覺效果，該元素的延遲的要求。</span><span class="sxs-lookup"><span data-stu-id="12109-249">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="12109-250">由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。</span><span class="sxs-lookup"><span data-stu-id="12109-250">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="12109-251">自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-251">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-252">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-252">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-253">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-253">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-254">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-254">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-255">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-255">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-256">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-256">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-257">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-257">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-258">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-258">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-259">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-259">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-260">取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的排列傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-260">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-261">如果這個中繼資料所在的相依性屬性可能會特別影響其父項目的排列傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-261">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-262">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-262">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-263"><xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。</span><span class="sxs-lookup"><span data-stu-id="12109-263"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="12109-264">這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>設定為`true`會起始要使其失效的父元素的視覺效果的延遲的要求。</span><span class="sxs-lookup"><span data-stu-id="12109-264">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span>  
  
 <span data-ttu-id="12109-265">一般而言，您不需要的變更報告<xref:System.Windows.FrameworkElement>父項目使用的屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>因為項目本身就已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>做為`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-265">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true`.</span></span> <span data-ttu-id="12109-266">通常就已足夠，因為通常起始子元素中的變更父代排列適當。</span><span class="sxs-lookup"><span data-stu-id="12109-266">That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</span></span> <span data-ttu-id="12109-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="12109-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="12109-268">在此案例中的子系項目集的屬性，但<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。</span><span class="sxs-lookup"><span data-stu-id="12109-268">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="12109-269">轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。</span><span class="sxs-lookup"><span data-stu-id="12109-269">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="12109-270">比方說的值變更<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的屬性的子項目失效排列之父代，因為必須變更之子系的父系中的位置。</span><span class="sxs-lookup"><span data-stu-id="12109-270">For instance, a change to the value of the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</span></span> <span data-ttu-id="12109-271">因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的屬性的中繼資料所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-271">Therefore, the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span> <span data-ttu-id="12109-272">另一個範例是<xref:System.Windows.Controls.Control.Padding%2A>; 如果這個屬性會變更，父代可能會變更位置的子系，根據可用空間。</span><span class="sxs-lookup"><span data-stu-id="12109-272">Another example is <xref:System.Windows.Controls.Control.Padding%2A>; when this property changes, the parent might change the positioning of the child, depending on available space.</span></span>  
  
 <span data-ttu-id="12109-273">由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。</span><span class="sxs-lookup"><span data-stu-id="12109-273">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="12109-274">自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-274">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-275">任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-275">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-276">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-276">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-277">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-277">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-278">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-278">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-279">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-279">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-280">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-280">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-281">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-281">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-282">取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的測量行程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-282">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-283">如果這個中繼資料所在的相依性屬性可能會明顯影響父項目的測量行程則為 <see langword="true" />，否則為 <see langword="false" />。預設為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-283">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <see langword="false" />.The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-284"><xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。</span><span class="sxs-lookup"><span data-stu-id="12109-284"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="12109-285">這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>設定為`true`會起始要使其失效的父元素的視覺效果的延遲的要求。</span><span class="sxs-lookup"><span data-stu-id="12109-285">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span> <span data-ttu-id="12109-286">由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。</span><span class="sxs-lookup"><span data-stu-id="12109-286">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="12109-287">一般而言，您不需要的變更報告<xref:System.Windows.FrameworkElement>父項目使用的屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>因為項目本身就已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>做為`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-287">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> as `true`.</span></span> <span data-ttu-id="12109-288">這是通常就已足夠，，因為子系項目中的變更通常會起始父量值傳遞適當的時候。</span><span class="sxs-lookup"><span data-stu-id="12109-288">That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</span></span> <span data-ttu-id="12109-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="12109-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="12109-290">在此案例中的子系項目集的屬性，但<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。</span><span class="sxs-lookup"><span data-stu-id="12109-290">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="12109-291">轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。</span><span class="sxs-lookup"><span data-stu-id="12109-291">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="12109-292">比方說的值變更<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>被子元素的屬性失效之父量值，因為相對的段落間距可能會變更，可能會增加或減少內容主機大小。</span><span class="sxs-lookup"><span data-stu-id="12109-292">For instance, a change to the value of the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</span></span> <span data-ttu-id="12109-293">因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>屬性的中繼資料所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-293">Therefore, the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-294">相依性屬性中的變更也經常尋找內容主機項目所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`，內容主機轉譯邏輯的一部分。</span><span class="sxs-lookup"><span data-stu-id="12109-294">Content host elements also frequently look for changes in dependency properties where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`, as part of content host rendering logic.</span></span> <span data-ttu-id="12109-295">比方說，<xref:System.Windows.Controls.TextBox>項目必須回應可能會要求的文字內的特定變更的週框方塊<xref:System.Windows.Controls.TextBox>本身進行變更。</span><span class="sxs-lookup"><span data-stu-id="12109-295">For instance, the <xref:System.Windows.Controls.TextBox> element must respond to certain changes within text that might require that the bounding box of the <xref:System.Windows.Controls.TextBox> itself be changed.</span></span>  
  
 <span data-ttu-id="12109-296">自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-296">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-297">任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-297">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-298">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-298">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-299">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-299">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-300">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-300">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-301">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-301">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-302">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-302">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-303">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-303">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-304">取得或設定值，指出相依性屬性是否可能影響一般的版面配置，而不會特別影響排列或測量，但可能需要重新繪製。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-304">Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-305">如果這個中繼資料所在的相依性屬性會影響呈現，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-305">
              <see langword="true" /> if the dependency property on which this metadata exists affects rendering; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-306">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-306">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-307"><xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。</span><span class="sxs-lookup"><span data-stu-id="12109-307"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="12109-308">這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>設定為`true`會起始要使其失效的視覺效果，該元素的延遲的要求。</span><span class="sxs-lookup"><span data-stu-id="12109-308">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="12109-309">由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。</span><span class="sxs-lookup"><span data-stu-id="12109-309">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="12109-310">自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="12109-310">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> is `true`.</span></span>  
  
 <span data-ttu-id="12109-311">任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-311">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-312">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-312">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-313">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-313">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-314">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-314">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-315">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-315">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-316">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-316">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-317">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-317">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-318">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-318">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-319">取得或設定值，指出屬性是否預設雙向繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-319">Gets or sets a value that indicates whether the property binds two-way by default.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-320">
            <see langword="true" /> 如果這個中繼資料所在的相依性屬性預設雙向繫結;否則， <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-320">
              <see langword="true" /> if the dependency property on which this metadata exists binds two-way by default; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-321">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-321">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-322">這個屬性就是沒有`true`，繫結更新預設為單向，根據的預設行為<xref:System.Windows.Data.Binding>建構函式或同等權限[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。</span><span class="sxs-lookup"><span data-stu-id="12109-322">In absence of this property being `true`, binding updates are one-way by default, based on the default behavior of the <xref:System.Windows.Data.Binding> constructors or equivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="12109-323">在現有的項目，您通常會發現這個屬性設定為`true`同時回報狀態，及是可修改的使用者動作，例如的相依性屬性中繼資料中<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="12109-323">In existing elements, you will usually find this property set to `true` in metadata for dependency properties that both report state and are modifiable by user action, for example <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="12109-324">這個屬性只在一般情況下報告的相依性屬性的預設繫結更新特性。</span><span class="sxs-lookup"><span data-stu-id="12109-324">This property only reports the default binding update characteristics of the dependency property in general.</span></span> <span data-ttu-id="12109-325">設定這個屬性執行個體上的任何繫結可以在本機設定<xref:System.Windows.Data.Binding.Mode%2A>繫結的屬性及變更這個預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-325">Any binding set to this property on an instance can locally set the <xref:System.Windows.Data.Binding.Mode%2A> property of the binding and change this default.</span></span>  
  
 <span data-ttu-id="12109-326">任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-326">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-327">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-327">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-328">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-328">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-329">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-329">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-330">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-330">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-331">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-331">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-332">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-332">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-333">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-333">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-334">取得或設定當套用具有這個中繼資料 (且 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />) 之屬性的繫結時，所要使用的預設 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-334">Gets or sets the default for <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for the property with this metadata are applied, which have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-335">列舉型別的值，而非 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-335">A value of the enumeration, other than <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-336">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-336">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-337">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-337">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-338">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-338">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-339">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-339">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-340">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-340">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-341">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-341">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="12109-342">這個屬性已設為 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。當繫結要求時，您所設定的值應該要成為預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-342">This property is set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; the value you set is supposed to become the default when requested by bindings.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-343">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-343">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-344">取得或設定值，指出相依性屬性的值是否為可繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-344">Gets or sets a value that indicates whether the value of the dependency property is inheritable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-345">如果可以繼承這個屬性的值則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-345">
              <see langword="true" /> if the property value is inheritable; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-346">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-346">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-347">屬性值繼承是一項功能[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]在 WPF 架構層級，藉此特定相依性屬性可以在本機設定或附近的根項目的屬性系統[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]項目樹狀結構，然後將其繼承的值在邏輯樹狀結構中的子項目，也會包含該屬性的所有項目。</span><span class="sxs-lookup"><span data-stu-id="12109-347">Property value inheritance is a feature of the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</span></span> <span data-ttu-id="12109-348">根據預設，未啟用屬性值繼承，並讓它有一些效能隱含作用。</span><span class="sxs-lookup"><span data-stu-id="12109-348">Property value inheritance is not enabled by default, and enabling it does have some performance implications.</span></span> <span data-ttu-id="12109-349">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="12109-349">For details, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12109-350">雖然屬性值繼承似乎適用於非附加相依性屬性，透過在執行階段樹狀目錄中的特定物件部門的非附加屬性繼承行為是未定義。</span><span class="sxs-lookup"><span data-stu-id="12109-350">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</span></span> <span data-ttu-id="12109-351">一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="12109-351">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span>  
  
 <span data-ttu-id="12109-352">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-352">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-353">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-353">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-354">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-354">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-355">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-355">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-356">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-356">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-357">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-357">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-358">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-358">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-359">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-359">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-360">取得值，指出相依性屬性是否支援資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-360">Gets a value that indicates whether data binding is supported for the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-361">如果套用這個中繼資料的相依性屬性支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-361">
              <see langword="true" /> if data binding is supported on the dependency property to which this metadata applies; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-362">預設值為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-362">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-363">這個屬性會報告`false`其中兩個可能的情況： 相依性屬性可能是資料繫結不允許，因為相依性屬性是唯讀的 （如報告相依性屬性識別碼，而不是中繼資料中），或值另一個中繼資料屬性<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，設定為`true`此中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="12109-363">This property reports `false` for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, is set to `true` in this metadata.</span></span> <span data-ttu-id="12109-364">這個屬性會公開為了方便起見，讓呼叫端不需要同時檢查<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。</span><span class="sxs-lookup"><span data-stu-id="12109-364">This property is exposed as a convenience so that callers do not have to check both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span>  
  
 <span data-ttu-id="12109-365">如果您嘗試建立指定，否則為讀取/寫入屬性應該不支援資料繫結的中繼資料，指定旗標<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(請注意有些微的命名慣例差異與<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。</span><span class="sxs-lookup"><span data-stu-id="12109-365">If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (note the slight naming convention difference versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span></span>  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-366">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-366">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-367">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-367">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12109-368">下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。</span><span class="sxs-lookup"><span data-stu-id="12109-368">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-369">取得或設定值，指出相依性屬性是否支援資料繫結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-369">Gets or sets a value that indicates whether the dependency property supports data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-370">如果屬性不支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-370">
              <see langword="true" /> if the property does not support data binding; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-371">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-371">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-372">請注意，此中繼資料屬性設定為`true`專為不會支援資料繫結，但還是讀寫屬性的屬性。</span><span class="sxs-lookup"><span data-stu-id="12109-372">Note that this metadata property is set to `true` specifically for properties that should not support data binding, despite being read-write properties.</span></span> <span data-ttu-id="12109-373">預期是，大部分的情況下宣告相依性屬性的位置，資料繫結需要的因為資料繫結是其中一個相依性屬性，會很實用的重要案例。</span><span class="sxs-lookup"><span data-stu-id="12109-373">The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</span></span> <span data-ttu-id="12109-374">不同於<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，這並不只是變更稍後可以變更特定的繫結的預設值。</span><span class="sxs-lookup"><span data-stu-id="12109-374">Unlike <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, this does not merely change a default that can later be changed on a specific binding.</span></span> <span data-ttu-id="12109-375">設定這個屬性`true`相依性屬性的中繼資料中的中繼資料將會停用透過運算式將值套用至該相依性屬性的所有繫結。</span><span class="sxs-lookup"><span data-stu-id="12109-375">Setting this property `true` in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</span></span>  
  
 <span data-ttu-id="12109-376">唯讀相依性屬性不支援資料繫結 （因為它們有沒有 set 存取子，以套用變更的值），但仍會報告`false`針對<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。</span><span class="sxs-lookup"><span data-stu-id="12109-376">Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report `false` for <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span> <span data-ttu-id="12109-377">這是因為屬性對應到<xref:System.Windows.FrameworkPropertyMetadataOptions>值將會報告使用方式中繼資料都實際建立，而不是一律報告的屬性命名可能暗示結束結果行為的同位檢查。</span><span class="sxs-lookup"><span data-stu-id="12109-377">This is because properties that correspond to a <xref:System.Windows.FrameworkPropertyMetadataOptions> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</span></span> <span data-ttu-id="12109-378">若要判斷指定的相依性屬性是否可將資料繫結，您應該通常檢查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>改。</span><span class="sxs-lookup"><span data-stu-id="12109-378">To determine whether a given dependency property permits data binding, you should usually check <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> instead.</span></span> <span data-ttu-id="12109-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 可讓您輕鬆檢查兩者<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>當做單一作業，進而產生預期的結果。</span><span class="sxs-lookup"><span data-stu-id="12109-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> is a convenience for checking both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> as a single operation, yielding the expected result.</span></span>  
  
 <span data-ttu-id="12109-380">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-380">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-381">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-381">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-382">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-382">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-383">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-383">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-384">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-384">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-385">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-385">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-386">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-386">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-387">取得或設定值，指出此屬性是否包含日誌記錄資訊，其為應用程式可以或應該儲存為日誌記錄實作的一部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-387">Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-388">如果日誌記錄應該在這個中繼資料所套用的目標相依性屬性上執行，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-388">
              <see langword="true" /> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-389">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-389">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-390">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-390">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-391">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-391">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-392">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-392">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-393">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-393">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-394">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-394">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-395">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-395">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-396">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-396">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="12109-397">要合併的基底中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-397">The base metadata to merge.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="12109-398">要套用這個中繼資料的相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-398">The dependency property this metadata is being applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-399">啟用來源中繼資料與基底中繼資料的合併。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-399">Enables a merge of the source metadata with base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-400">中繼資料覆寫時，為內部使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="12109-400">This method is used internally when metadata is being overridden.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="12109-401">
            <para>衍生自類別<see cref="T:System.Windows.PropertyMetadata" />（或這特別類別） 應該覆寫這個方法，以負責他們已在其實作任何中繼資料屬性。比方說，您的實作可能已經加入新的旗標型列舉值，而<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />實作應該可以正確結合這些旗標。因為基底實作會負責合併已在階層中的舊版類型上定義的所有屬性，請務必呼叫基底實作您自己的實作之前。所加入的行為<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />中的實作<see cref="T:System.Windows.FrameworkPropertyMetadata" />是 WPF 架構層級的特定屬性中的中繼資料，例如<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />位元結合或作業。<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />行為也會實作行為，當您呼叫覆寫現有的相依性屬性的屬性中繼資料<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />。，使用覆寫中繼資料<see cref="T:System.Windows.FrameworkPropertyMetadata" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-401">
              <para>Classes that derive from <see cref="T:System.Windows.PropertyMetadata" /> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.  The behavior added by the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> is that specific WPF framework-level properties in the metadata such as <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> are combined in a bitwise or operation.  The <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., using override metadata that is <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="12109-402">已套用這個中繼資料的相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-402">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="12109-403">如果這是型別特定的中繼資料，則為與這個中繼資料相關聯的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-403">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="12109-404">如果這是預設中繼資料，則這個值可能是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-404">If this is default metadata, this value can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="12109-405">在這個中繼資料已套用至屬性時呼叫，表示要密封中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-405">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-406">任何可變動性的資料結構<xref:System.Windows.FrameworkPropertyMetadata>執行個體應該標示為不可變叫用此方法時。</span><span class="sxs-lookup"><span data-stu-id="12109-406">Any mutability of the data structure of a <xref:System.Windows.FrameworkPropertyMetadata> instance should be marked as immutable when this method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="12109-407">
            <para>
              <see cref="T:System.Windows.FrameworkPropertyMetadata" />實作這個方法不超過呼叫基底實作。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-407">
              <para>The <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementation of this method does nothing beyond calling the base implementation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-408">取得或設定值，這個值表示屬性值繼承評估是否應該跨越項目邏輯樹狀中的特定內容界限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-408">Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-409">如果屬性值繼承應跨越特定內容界限則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-409">
              <see langword="true" /> if the property value inheritance should span across certain content boundaries; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-410">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-410">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-411">此中繼資料會報告屬性值繼承行為很少套用修改跨特殊父項目子系項目界限。</span><span class="sxs-lookup"><span data-stu-id="12109-411">This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</span></span> <span data-ttu-id="12109-412">這類界限的標準範例是的內容<xref:System.Windows.Controls.Frame>，其中<xref:System.Windows.Controls.Frame>內容可能會取得獨立的存在重新載入<xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="12109-412">The canonical example of such a boundary is the contents of a <xref:System.Windows.Controls.Frame>, where the <xref:System.Windows.Controls.Frame> content might get reloaded independently of the existence of the <xref:System.Windows.Controls.Frame>.</span></span> <span data-ttu-id="12109-413">所需的屬性系統行為是屬性值繼承應該內容中的周遊<xref:System.Windows.Controls.Frame>，因為這些內容可能是裝載在框架的應用程式不會擁有或控制的項目。</span><span class="sxs-lookup"><span data-stu-id="12109-413">The desired property system behavior is that property value inheritance should not traverse into the contents of the <xref:System.Windows.Controls.Frame>, because these contents might be elements that the application hosting the frame does not own or control.</span></span> <span data-ttu-id="12109-414">指定使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>設定為`true`，以及為指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>做為`true`，會在其為可繼承甚至跨套用中繼資料屬性<xref:System.Windows.Controls.Frame>界限或類似的界限。</span><span class="sxs-lookup"><span data-stu-id="12109-414">Specifying metadata with <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> set to `true`, as well as specifying <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> as `true`, will cause the property on which the metadata is applied to be inheritable even across the <xref:System.Windows.Controls.Frame> boundary or similar boundaries.</span></span>  
  
 <span data-ttu-id="12109-415">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-415">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-416">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-416">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-417">不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-417">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-418">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-418">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-419">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-419">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-420">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-420">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-421">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-421">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="12109-422">取得或設定值，指出相依性屬性的子屬性是否不會影響包含物件的呈現。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-422">Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="12109-423">如果子屬性值的變更不會影響變更後的呈現則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-423">
              <see langword="true" /> if changes to sub-property values do not affect rendering if changed; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="12109-424">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-424">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12109-425">此中繼資料 選項會是參考類型，其中該類型有自己的屬性值的相依性屬性相關。</span><span class="sxs-lookup"><span data-stu-id="12109-425">This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</span></span> <span data-ttu-id="12109-426">一般而言，版面配置系統邏輯會假設具有子屬性的任何相依性屬性可能會影響版面配置，因為檢查所有的子屬性變更為更耗費時間比實際執行另一個呈現階段。</span><span class="sxs-lookup"><span data-stu-id="12109-426">Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</span></span> <span data-ttu-id="12109-427">將此選項設定為`true`適合用來最佳化效能的 WPF 架構層級的版面配置系統實作。</span><span class="sxs-lookup"><span data-stu-id="12109-427">Setting this option to `true` is useful for optimizing performance of the WPF framework level layout system implementation.</span></span>  
  
 <span data-ttu-id="12109-428">在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。</span><span class="sxs-lookup"><span data-stu-id="12109-428">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="12109-429">這是讓它們可以調整執行個體初始化後。</span><span class="sxs-lookup"><span data-stu-id="12109-429">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="12109-430">不過，一旦中繼資料的一部分的呼叫消耗<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="12109-430">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="12109-431">嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="12109-431">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="12109-432">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="12109-432">XAML Text Usage</span></span>  
 <span data-ttu-id="12109-433">這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="12109-433">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="12109-434">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="12109-434">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>