<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37492929" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>為相依性屬性回報或套用中繼資料，特別加入架構專屬的屬性系統特性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別衍生自<xref:System.Windows.PropertyMetadata>(透過<xref:System.Windows.UIPropertyMetadata>)。 大部分的 WPF 架構層級的應用程式開發用途而言，<xref:System.Windows.FrameworkPropertyMetadata>是用於相依性屬性中繼資料的型別，而不是基底中繼資料型別<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>。 這是現有相依性屬性中，大部分的自訂相依性屬性案例，則為 true。  
  
 宣告此成員類別該資訊補充<xref:System.Windows.PropertyMetadata>基底類別包含各種布林屬性，可指定或報表 WPF 架構層級屬性系統行為，例如屬性繼承、 資料繫結和版面配置。  
  
 建立數個建構函式簽章<xref:System.Windows.FrameworkPropertyMetadata>執行個體進行<xref:System.Windows.FrameworkPropertyMetadataOptions>參數。 <xref:System.Windows.FrameworkPropertyMetadataOptions>列舉型別只用於指定初始的行為，在建構函式，而且否則不會公開之後<xref:System.Windows.FrameworkPropertyMetadata>建構。 建構的執行個體中，您可以取得或設定對應的資訊，透過共用的建構函式呼叫中使用的列舉值名稱的各種屬性。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 此類別通常不會使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會取得相依性屬性的中繼資料上的特定擁有者為初始基底<xref:System.Windows.PropertyMetadata>型別。 該中繼資料會轉換成<xref:System.Windows.FrameworkPropertyMetadata>。 如果將傳回的有效<xref:System.Windows.FrameworkPropertyMetadata>，然後各種<xref:System.Windows.FrameworkPropertyMetadata>屬性值會報告透過一個簡單的 UI （未顯示）。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此簽章初始化的所有值<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>為其屬性的預設值。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 將會`null`，和各種<xref:System.Windows.FrameworkPropertyMetadata>布林值屬性會`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <summary>使用指定的預設值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <summary>使用提供的預設值和架構中繼資料選項，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
 值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 接著，只要中繼資料尚未套用至特定的屬性系統作業，您可以變更的中繼資料中，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用提供的預設值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫處理常式實作的參考。</param>
        <summary>使用指定的回呼初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作會呼叫基底的初始設定式，然後新增`coerceValueCallback`基底的執行個體上設定屬性。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別的值。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <summary>使用提供的預設值和架構中繼資料選項，以及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回呼，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
 值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <summary>使用提供的預設值和指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <summary>使用提供的預設值和架構中繼資料選項，以及指定的回呼，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
 值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個相依性屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。 如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。 <see langword="false" /> 表示允許建立屬性的動畫。 預設值為 <see langword="false" />。</param>
        <summary>使用提供的預設值和架構中繼資料選項、指定的回呼，以及可用以防止屬性動畫的布林值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
 `isAnimationProhibited`參數設定初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底宣告的屬性<xref:System.Windows.UIPropertyMetadata>類別。  
  
 值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。  
  
   
  
## Examples  
 下列範例會呼叫此建構函式簽章：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">相依性屬性的預設值，通常為特定型別。</param>
        <param name="flags">中繼資料選項旗標 (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的組合)。 這些選項會指定相依性屬性與系統互動的特性，例如版面配置或資料繫結。</param>
        <param name="propertyChangedCallback">當屬性的有效值變更時，便會呼叫屬性系統之處理常式實作的參考。</param>
        <param name="coerceValueCallback">當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時，便會呼叫之處理常式實作的參考。</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> 表示防止屬性系統為套用這個中繼資料的屬性顯示動畫。 如果嘗試顯示這類屬性的動畫，則屬性系統會發出執行階段例外狀況。 預設值為 <see langword="false" />。</param>
        <param name="defaultUpdateSourceTrigger">在套用這個屬性的繫結、且這些繫結的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 是設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 時所使用的 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>使用提供的預設值和架構中繼資料選項、指定的回呼、可用以防止屬性動畫的布林值，以及資料繫結更新觸發程序的預設值，初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供值的型別`defaultValue`必須與相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。 很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為在編譯期間無法偵測到不相符。 屬性系統不會評估屬性的有效值到執行階段，因此預設值類型/屬性類型不相符的結果是執行階段錯誤。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在屬性系統中，具有特殊意義，也不能做為相依性屬性預設值。  
  
 `isAnimationProhibited`參數設定初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底宣告的屬性<xref:System.Windows.UIPropertyMetadata>類別。  
  
 如需有關繫結的更新來源行為的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 值標示為集合中的旗標`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。 只要中繼資料尚未套用至特定的屬性系統作業，您仍可以變更的中繼資料中，屬性的值。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 設定為 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響排列傳遞。</summary>
        <value>如果這個中繼資料所在的相依性屬性可能會影響排列傳遞則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。 這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>設定為`true`將會起始要使其失效的視覺效果，該元素的延後的要求 (呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>)。 由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>是`true`。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不常使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響測量行程。</summary>
        <value>如果這個中繼資料所在的相依性屬性可能會影響測量行程，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。 這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>設定為`true`會起始要使其失效的視覺效果，該元素的延遲的要求。 由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>是`true`。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的排列傳遞。</summary>
        <value>如果這個中繼資料所在的相依性屬性可能會特別影響其父項目的排列傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。 這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>設定為`true`會起始要使其失效的父元素的視覺效果的延遲的要求。  
  
 一般而言，您不需要的變更報告<xref:System.Windows.FrameworkElement>父項目使用的屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>因為項目本身就已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>做為`true`。 通常就已足夠，因為通常起始子元素中的變更父代排列適當。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。 在此案例中的子系項目集的屬性，但<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。 比方說的值變更<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的屬性的子項目失效排列之父代，因為必須變更之子系的父系中的位置。 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的屬性的中繼資料所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。 另一個範例是<xref:System.Windows.Controls.Control.Padding%2A>; 如果這個屬性會變更，父代可能會變更位置的子系，根據可用空間。  
  
 由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。  
  
 任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性在配置引擎作業期間，是否可能會影響其父項目配置的測量行程。</summary>
        <value>如果這個中繼資料所在的相依性屬性可能會明顯影響父項目的測量行程則為 <see langword="true" />，否則為 <see langword="false" />。預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。 這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>設定為`true`會起始要使其失效的父元素的視覺效果的延遲的要求。 由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。  
  
 一般而言，您不需要的變更報告<xref:System.Windows.FrameworkElement>父項目使用的屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>因為項目本身就已經有它自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>做為`true`。 這是通常就已足夠，，因為子系項目中的變更通常會起始父量值傳遞適當的時候。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有時會用<xref:System.Windows.FrameworkContentElement>衍生的類別。 在此案例中的子系項目集的屬性，但<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。 比方說的值變更<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>被子元素的屬性失效之父量值，因為相對的段落間距可能會變更，可能會增加或減少內容主機大小。 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>屬性的中繼資料所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 相依性屬性中的變更也經常尋找內容主機項目所在<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`，內容主機轉譯邏輯的一部分。 比方說，<xref:System.Windows.Controls.TextBox>項目必須回應可能會要求的文字內的特定變更的週框方塊<xref:System.Windows.Controls.TextBox>本身進行變更。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性是否可能影響一般的版面配置，而不會特別影響排列或測量，但可能需要重新繪製。</summary>
        <value>如果這個中繼資料所在的相依性屬性會影響呈現，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 並<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，以監視所有存在的項目的相依性屬性的有效值變更。 這個邏輯的一部分，變更生效的相依性屬性值，並已使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>設定為`true`會起始要使其失效的視覺效果，該元素的延遲的要求。 由於此 WPF 架構層級實作已在進行中，您通常不需要相依性屬性，以尋找<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>除非本質上被取代或修改的 WPF 架構層級的版面配置行為。  
  
 自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將類似的行為，相依性屬性變更的地方<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>是`true`。  
  
 任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出屬性是否預設雙向繫結。</summary>
        <value>
          <see langword="true" /> 如果這個中繼資料所在的相依性屬性預設雙向繫結;否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性就是沒有`true`，繫結更新預設為單向，根據的預設行為<xref:System.Windows.Data.Binding>建構函式或同等權限[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 在現有的項目，您通常會發現這個屬性設定為`true`同時回報狀態，及是可修改的使用者動作，例如的相依性屬性中繼資料中<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。  
  
 這個屬性只在一般情況下報告的相依性屬性的預設繫結更新特性。 設定這個屬性執行個體上的任何繫結可以在本機設定<xref:System.Windows.Data.Binding.Mode%2A>繫結的屬性及變更這個預設值。  
  
 任何屬性的衍生類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定當套用具有這個中繼資料 (且 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 設為 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />) 之屬性的繫結時，所要使用的預設 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</summary>
        <value>列舉型別的值，而非 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">這個屬性已設為 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。當繫結要求時，您所設定的值應該要成為預設值。</exception>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性的值是否為可繼承。</summary>
        <value>如果可以繼承這個屬性的值則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性值繼承是一項功能[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]在 WPF 架構層級，藉此特定相依性屬性可以在本機設定或附近的根項目的屬性系統[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]項目樹狀結構，然後將其繼承的值在邏輯樹狀結構中的子項目，也會包含該屬性的所有項目。 根據預設，未啟用屬性值繼承，並讓它有一些效能隱含作用。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
> [!NOTE]
>  雖然屬性值繼承似乎適用於非附加相依性屬性，透過在執行階段樹狀目錄中的特定物件部門的非附加屬性繼承行為是未定義。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出相依性屬性是否支援資料繫結。</summary>
        <value>如果套用這個中繼資料的相依性屬性支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會報告`false`其中兩個可能的情況： 相依性屬性可能是資料繫結不允許，因為相依性屬性是唯讀的 （如報告相依性屬性識別碼，而不是中繼資料中），或值另一個中繼資料屬性<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，設定為`true`此中繼資料中。 這個屬性會公開為了方便起見，讓呼叫端不需要同時檢查<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。  
  
 如果您嘗試建立指定，否則為讀取/寫入屬性應該不支援資料繫結的中繼資料，指定旗標<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(請注意有些微的命名慣例差異與<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下列範例會從各種不同的相依性屬性欄位取得的預設中繼資料、 查詢的各種值<xref:System.Windows.FrameworkPropertyMetadata>屬性，並填入資料表，以實作 「 中繼資料瀏覽器 」 中使用的資訊。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性是否支援資料繫結。</summary>
        <value>如果屬性不支援資料繫結則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，此中繼資料屬性設定為`true`專為不會支援資料繫結，但還是讀寫屬性的屬性。 預期是，大部分的情況下宣告相依性屬性的位置，資料繫結需要的因為資料繫結是其中一個相依性屬性，會很實用的重要案例。 不同於<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，這並不只是變更稍後可以變更特定的繫結的預設值。 設定這個屬性`true`相依性屬性的中繼資料中的中繼資料將會停用透過運算式將值套用至該相依性屬性的所有繫結。  
  
 唯讀相依性屬性不支援資料繫結 （因為它們有沒有 set 存取子，以套用變更的值），但仍會報告`false`針對<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。 這是因為屬性對應到<xref:System.Windows.FrameworkPropertyMetadataOptions>值將會報告使用方式中繼資料都實際建立，而不是一律報告的屬性命名可能暗示結束結果行為的同位檢查。 若要判斷指定的相依性屬性是否可將資料繫結，您應該通常檢查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>改。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 可讓您輕鬆檢查兩者<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>當做單一作業，進而產生預期的結果。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出此屬性是否包含日誌記錄資訊，其為應用程式可以或應該儲存為日誌記錄實作的一部分。</summary>
        <value>如果日誌記錄應該在這個中繼資料所套用的目標相依性屬性上執行，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要合併的基底中繼資料。</param>
        <param name="dp">要套用這個中繼資料的相依性屬性。</param>
        <summary>啟用來源中繼資料與基底中繼資料的合併。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中繼資料覆寫時，為內部使用這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>衍生自類別<see cref="T:System.Windows.PropertyMetadata" />（或這特別類別） 應該覆寫這個方法，以負責他們已在其實作任何中繼資料屬性。比方說，您的實作可能已經加入新的旗標型列舉值，而<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />實作應該可以正確結合這些旗標。因為基底實作會負責合併已在階層中的舊版類型上定義的所有屬性，請務必呼叫基底實作您自己的實作之前。所加入的行為<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />中的實作<see cref="T:System.Windows.FrameworkPropertyMetadata" />是 WPF 架構層級的特定屬性中的中繼資料，例如<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />位元結合或作業。<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />行為也會實作行為，當您呼叫覆寫現有的相依性屬性的屬性中繼資料<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />。，使用覆寫中繼資料<see cref="T:System.Windows.FrameworkPropertyMetadata" />。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已套用這個中繼資料的相依性屬性。</param>
        <param name="targetType">如果這是型別特定的中繼資料，則為與這個中繼資料相關聯的型別。 如果這是預設中繼資料，則這個值可能是 <see langword="null" />。</param>
        <summary>在這個中繼資料已套用至屬性時呼叫，表示要密封中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何可變動性的資料結構<xref:System.Windows.FrameworkPropertyMetadata>執行個體應該標示為不可變叫用此方法時。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" />實作這個方法不超過呼叫基底實作。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示屬性值繼承評估是否應該跨越項目邏輯樹狀中的特定內容界限。</summary>
        <value>如果屬性值繼承應跨越特定內容界限則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此中繼資料會報告屬性值繼承行為很少套用修改跨特殊父項目子系項目界限。 這類界限的標準範例是的內容<xref:System.Windows.Controls.Frame>，其中<xref:System.Windows.Controls.Frame>內容可能會取得獨立的存在重新載入<xref:System.Windows.Controls.Frame>。 所需的屬性系統行為是屬性值繼承應該內容中的周遊<xref:System.Windows.Controls.Frame>，因為這些內容可能是裝載在框架的應用程式不會擁有或控制的項目。 指定使用的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>設定為`true`，以及為指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>做為`true`，會在其為可繼承甚至跨套用中繼資料屬性<xref:System.Windows.Controls.Frame>界限或類似的界限。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，中繼資料使用一部分的呼叫之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出相依性屬性的子屬性是否不會影響包含物件的呈現。</summary>
        <value>如果子屬性值的變更不會影響變更後的呈現則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此中繼資料 選項會是參考類型，其中該類型有自己的屬性值的相依性屬性相關。 一般而言，版面配置系統邏輯會假設具有子屬性的任何相依性屬性可能會影響版面配置，因為檢查所有的子屬性變更為更耗費時間比實際執行另一個呈現階段。 將此選項設定為`true`適合用來最佳化效能的 WPF 架構層級的版面配置系統實作。  
  
 在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫的物件模型中。 這是讓它們可以調整執行個體初始化後。 不過，一旦中繼資料的一部分的呼叫消耗<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統會將密封該中繼資料執行個體，傳遞的中繼資料特性的屬性現在會被視為不變。 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文字使用方式  
 這個類別的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">中繼資料已套用至相依性屬性作業，因此中繼資料已密封，而且無法設定中繼資料的屬性。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>