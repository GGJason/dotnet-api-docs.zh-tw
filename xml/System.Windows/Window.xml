<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f805a8dedd189924a31c53379179c725286ba810" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695006" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供建立、設定、顯示和管理視窗與對話方塊存留期的能力。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者與獨立應用程式之間點是互動的一個視窗。 A[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]視窗包含兩個不同區域：  
  
-   非工作區，於裝載 windows 裝飾，包括圖示、 標題、 系統功能表上，最小化按鈕、 最大化按鈕、 [還原] 按鈕、 [關閉] 按鈕和框線。  
  
-   用戶端區域，裝載應用程式特定內容。  
  
 下圖顯示標準的視窗：  
  
 ![視窗項目](~/add/media/windowoverviewfigure1.PNG "視窗項目")  
  
 <xref:System.Windows.Window> 封裝建立、 設定、 顯示，以及管理視窗和對話方塊中的存留期的能力，並提供下列服務：  
  
 **存留期管理**: <xref:System.Windows.Window.Activate%2A>， <xref:System.Windows.Window.Activated>， <xref:System.Windows.Window.Close%2A>， <xref:System.Windows.Window.Closed>， <xref:System.Windows.Window.Closing>， <xref:System.Windows.Window.Deactivated>， <xref:System.Windows.Window.Hide%2A>， <xref:System.Windows.Window.IsActive%2A>， <xref:System.Windows.Window.Show%2A>， <xref:System.Windows.Window.SourceInitialized>。  
  
 **視窗管理**: <xref:System.Windows.Window.GetWindow%2A>， <xref:System.Windows.Window.OwnedWindows%2A>， <xref:System.Windows.Window.Owner%2A>。  
  
 **外觀和行為**: <xref:System.Windows.Window.AllowsTransparency%2A>， <xref:System.Windows.Window.ContentRendered>， <xref:System.Windows.Window.DragMove%2A>， <xref:System.Windows.Window.Icon%2A>， <xref:System.Windows.Window.Left%2A>， <xref:System.Windows.Window.LocationChanged>， <xref:System.Windows.Window.ResizeMode%2A>， <xref:System.Windows.Window.RestoreBounds%2A>， <xref:System.Windows.Window.ShowActivated%2A>， <xref:System.Windows.Window.ShowInTaskbar%2A>， <xref:System.Windows.Window.SizeToContent%2A>，<xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **對話方塊**: <xref:System.Windows.Window.DialogResult%2A>， <xref:System.Windows.Window.ShowDialog%2A>。  
  
 此外，<xref:System.Windows.Application>會公開用於管理所有的 windows 應用程式中的特殊支援：  
  
-   應用程式會維護一份目前具現化應用程式中的所有視窗。 這份清單由<xref:System.Windows.Application.Windows%2A>屬性。  
  
-   根據預設，<xref:System.Windows.Application.MainWindow%2A>會自動設定的第一個參考<xref:System.Windows.Window>，具現化應用程式中。 這藉此讓主應用程式視窗的視窗。  
  
 A<xref:System.Windows.Window>可以使用標記、 標記和程式碼後置或程式碼來實作。  
  
 <xref:System.Windows.Window> 主要用來顯示視窗和對話方塊的獨立應用程式。 不過，應用程式需要瀏覽視窗層級，例如精靈中，您可以使用<xref:System.Windows.Navigation.NavigationWindow>在內。<xref:System.Windows.Navigation.NavigationWindow>衍生自<xref:System.Windows.Window>，並使用瀏覽器樣式瀏覽支援進行擴充。  
  
> [!NOTE]
>  島的可瀏覽內容可以納入使用其他內容與內容容器<xref:System.Windows.Controls.Frame>。  
  
 <xref:System.Windows.Window> 需要`UnmanagedCode`具現化的安全性權限。 這會有下列結果：  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-已部署的獨立應用程式會要求從網際網路或近端內部網路區域啟動時的權限提高權限。  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 所要求的任何項目小於完整權限將無法具現化的視窗和對話方塊。  
  
 獨立應用程式部署和安全性考量的相關資訊，請參閱[WPF 安全性策略-平台安全性](~/docs/framework/wpf/wpf-security-strategy-platform-security.md)。  
  
 A<xref:System.Windows.Window>是<xref:System.Windows.Controls.ContentControl>，這表示它可以包含單一物件的任何類型 （例如字串、 影像或工作面板）。 如需詳細資訊，請參閱 <xref:System.Windows.Controls.ContentControl> 類別。 此外，<xref:System.Windows.Window>是根元素，因此，不能是另一個項目內容的一部分。  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>， <xref:System.Windows.FrameworkElement.Width%2A>， <xref:System.Windows.Window.Top%2A>，和<xref:System.Windows.Window.Left%2A>屬性上設定<xref:System.Windows.Window>透過樣式不會在執行階段套用。  
  
## <a name="customizing-the-window-control"></a>自訂視窗控制項  
 若要套用至多個相同的屬性設定<xref:System.Windows.Window>控制項，可使用<xref:System.Windows.FrameworkElement.Style%2A>屬性。 您可以修改預設<xref:System.Windows.Controls.ControlTemplate>來提供獨特的外觀的控制項。 如需有關建立<xref:System.Windows.Controls.ControlTemplate>，請參閱[自訂現有控制項的外觀，藉由建立 ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)。  若要查看的組件和所特有狀態<xref:System.Windows.Window>，請參閱[視窗樣式和範本](~/docs/framework/wpf/controls/window-styles-and-templates.md)。  
  
 對這個控制項的相依性屬性可能會設定控制項的預設樣式。  如果屬性設定為預設樣式，屬性可能會變更其預設值時該控制項會出現在應用程式中。 預設樣式是由決定由哪個桌面主題時，會使用應用程式正在執行。  如需詳細資訊，請參閱[預設 WPF 佈景主題](http://go.microsoft.com/fwlink/?LinkID=158252)。  
  
> [!NOTE]
>  設定視覺化屬性只會影響該屬性是否存在於這兩<xref:System.Windows.Window>控制項的預設範本，並且使用設定的。 您可以找到的視覺屬性清單中的 「 變更 Visual 結構的控制項 」 一節中[自訂現有控制項的外觀，藉由建立 ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)。  
  
   
  
## Examples  
 下列範例會示範如何以標準視窗定義只使用標記：  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 下列範例會示範如何使用定義標準的視窗僅程式碼：  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 下列範例會示範如何以標準視窗使用標記和程式碼後置的組合定義。  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Window" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建構函式初始化<xref:System.Windows.FrameworkElement.Width%2A>， <xref:System.Windows.FrameworkElement.Height%2A>， <xref:System.Windows.Window.Top%2A>，和<xref:System.Windows.Window.Left%2A>屬性設為預設<xref:System.Windows.Window>值。  
  
 如果在建立視窗<xref:System.AppDomain>具有<xref:System.Windows.Application>物件建構函式加入<xref:System.Windows.Window>物件的集合<xref:System.Windows.Application>-管理透過 windows<xref:System.Windows.Application.Windows%2A>屬性<xref:System.Windows.Application>物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">權限，此物件來呼叫不安全的原生方法。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試將視窗帶到前景並加以啟動。</summary>
        <returns>
          如果已成功啟動 <see cref="T:System.Windows.Window" /> 則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 規則，判斷是否已啟動 視窗會與所使用的相同[!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)]`SetForegroundWindow`函式 (User32.dll)。  
  
 如果不是使用者的前景應用程式，在 Windows Presentation Foundation 應用程式中啟動視窗則<xref:System.Windows.Application.Activated>就會引發事件。  
  
> [!NOTE]
>  裝載在瀏覽器視窗時，無法呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要啟用視窗的使用權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視窗變成前景視窗時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在啟動視窗 （變成前景視窗） 時：  
  
-   第一次開啟的視窗。  
  
-   藉由選取它，使用滑鼠按 ALT + TAB，或從 工作管理員來切換視窗的使用者。  
  
-   使用者按一下視窗的工作列按鈕。  
  
 可以處理需要偵測當它們變成啟動的 Windows<xref:System.Windows.Window.Activated>事件。  
  
 視窗第一次啟動之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟動狀態，它可以檢查<xref:System.Windows.Window.IsActive%2A>來判斷哪一個啟用的狀態。  
  
 應用程式也可以是<xref:System.Windows.Application.Activated>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示視窗的工作區是否支援透明度。</summary>
        <value>
          如果視窗支援透明度則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Controls.Control.Background%2A>視窗的屬性設定為透明色彩時，使用<xref:System.Windows.Media.Brushes.Transparent%2A>比方說，視窗會保留不透明。 這表示無法看到桌面及任何執行中的應用程式"beneath"視窗。 若要啟用這種類型的透明度，<xref:System.Windows.Window.AllowsTransparency%2A>必須設為`true`。  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> 可協助建立非矩形視窗，並進而時<xref:System.Windows.Window.AllowsTransparency%2A>設`true`，視窗的<xref:System.Windows.Window.WindowStyle%2A>屬性必須設定為<xref:System.Windows.WindowStyle.None>。  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">視窗的 <see cref="P:System.Windows.Window.WindowStyle" /> 值不是 <see cref="F:System.Windows.WindowStyle.None" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.AllowsTransparency" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">
          <see cref="T:System.Windows.Size" />，反映視窗排列本身和其子系後應該呈現的最終大小。</param>
        <summary>覆寫這個方法可以調整視窗和其子項目的位置和大小。</summary>
        <returns>
          <see cref="T:System.Windows.Size" />，反映實際呈現的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> 不會呼叫時<xref:System.Windows.UIElement.Visibility%2A>屬性的值為<xref:System.Windows.Visibility.Collapsed>。 如果值<xref:System.Windows.UIElement.Visibility%2A>屬性<xref:System.Windows.Visibility.Hidden>或<xref:System.Windows.Visibility.Visible>，<xref:System.Windows.Window.ArrangeOverride%2A>呼叫。  
  
> [!NOTE]
>  當 <xref:System.Windows.Window.Show%2A>或<xref:System.Windows.Window.ShowDialog%2A>呼叫時，<xref:System.Windows.UIElement.Visibility%2A>屬性<xref:System.Windows.Window>設為<xref:System.Windows.Visibility.Visible>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>手動關閉 <see cref="T:System.Windows.Window" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Window>可以使用其中一種幾個，請關閉已知和系統提供的機制位於標題列，包括：  
  
-   ALT + F4。  
  
-   系統功能表&#124;**關閉**。  
  
-   **關閉** 按鈕。  
  
 A<xref:System.Windows.Window>也可以關閉使用其中一種數種知名機制，用戶端區域內所提供的開發人員，包括：  
  
-   **檔案** &#124; **結束**主視窗上。  
  
-   **檔案** &#124; **關閉**或**關閉**子視窗上的按鈕。  
  
> [!NOTE]
>  **確定**和**取消** 對話方塊上的按鈕也是開發人員提供，雖然會可能集<xref:System.Windows.Window.DialogResult%2A>，這會自動關閉呼叫已開啟的視窗<xref:System.Windows.Window.ShowDialog%2A>。  
  
 這些機制都會要求您明確地呼叫<xref:System.Windows.Window.Close%2A>關閉視窗。  
  
> [!NOTE]
>  藉由呼叫開啟的視窗中，如果<xref:System.Windows.Window.ShowDialog%2A>，與<xref:System.Windows.Controls.Button>具有其<xref:System.Windows.Controls.Button.IsCancel%2A>屬性設為 true，會自動關閉，請按一下按鈕，或按下 esc 鍵時。 如果視窗已開啟使用<xref:System.Windows.Window.Show%2A>，不過<xref:System.Windows.Window.Close%2A>必須明確呼叫，例如在<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件處理常式<xref:System.Windows.Controls.Button>。  
  
 關閉視窗會導致<xref:System.Windows.Window.Closing>會引發事件。 如果<xref:System.Windows.Window.Closing>事件未取消，則發生下列情況：  
  
-   <xref:System.Windows.Window>被移除了<xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType>(如果<xref:System.Windows.Application>物件存在)。  
  
-   <xref:System.Windows.Window>移除擁有者<xref:System.Windows.Window>如果已建立擁有者/擁有關聯性之前擁有<xref:System.Windows.Window>顯示和擁有者之後<xref:System.Windows.Window>已開啟。  
  
-   便會引發 <xref:System.Windows.Window.Closed> 事件。  
  
-   Unmanaged 資源所建立<xref:System.Windows.Window>仍會獲得處置。  
  
-   如果<xref:System.Windows.Window.ShowDialog%2A>已呼叫以顯示<xref:System.Windows.Window>，<xref:System.Windows.Window.ShowDialog%2A>傳回。  
  
 關閉<xref:System.Windows.Window>會使任何其擁有要關閉的視窗。 此外，關閉<xref:System.Windows.Window>可能會導致應用程式停止執行依據<xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType>屬性設定。  
  
> [!NOTE]
>  裝載在瀏覽器視窗時，無法呼叫這個方法。  
  
   
  
## Examples  
 下列範例所示**檔案** &#124; **結束**功能表來明確呼叫處理<xref:System.Windows.Window.Close%2A>。  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視窗即將關閉時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後會引發這個事件，無法防止視窗關閉。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          視窗要關閉時，設定了 <see cref="P:System.Windows.UIElement.Visibility" /> 或是呼叫了 <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" /> 或 <see cref="M:System.Windows.Window.Hide" />。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在呼叫 <see cref="M:System.Windows.Window.Close" /> 後立即發生，可以用來取消視窗關閉動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> 可以處理，以偵測視窗關閉時 (例如，當<xref:System.Windows.Window.Close%2A>稱為)。 此外，<xref:System.Windows.Window.Closing>可用來防止無法關閉視窗。 若要避免關閉視窗，您可以設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>引數`true`。  
  
 <xref:System.Windows.Window.Closing>就會引發事件時<xref:System.Windows.Window.Close%2A>呼叫時，如果按一下視窗的 [關閉] 按鈕，或如果使用者按下 ALT + F4。  
  
 如果擁有的視窗已開啟由其擁有者視窗使用<xref:System.Windows.Window.Show%2A>，且擁有者視窗已關閉，擁有的視窗的<xref:System.Windows.Window.Closing>不會引發事件。 如果已關閉之視窗的擁有者 (請參閱<xref:System.Windows.Window.Owner%2A>)，<xref:System.Windows.Window.Closing>上擁有的視窗不會引發。  
  
 如果<xref:System.Windows.Application.Shutdown%2A>呼叫時，<xref:System.Windows.Window.Closing>就會引發事件，每個視窗。 不過，如果<xref:System.Windows.Window.Closing>已取消，會忽略取消。  
  
 如果工作階段結束，因為使用者登出或關機、<xref:System.Windows.Window.Closing>就不會引發，處理<xref:System.Windows.Application.SessionEnding>實作取消應用程式終止的程式碼。  
  
 如果您想要顯示和隱藏視窗的應用程式的存留期間多次，而且您不希望個體化視窗每次您將其顯示，您可以處理<xref:System.Windows.Window.Closing>事件取消，並呼叫<xref:System.Windows.Window.Hide%2A>方法。 然後，您可以呼叫<xref:System.Windows.Window.Show%2A>相同的執行個體，將它重新開啟。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Windows.Window>，決定是否需要使用者介入以關閉。  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          視窗要關閉時，設定了 <see cref="P:System.Windows.UIElement.Visibility" /> 或是呼叫了 <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" /> 或 <see cref="M:System.Windows.Window.Close" />。</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視窗內容呈現後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視窗沒有任何內容，不會引發這個事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視窗變成背景視窗時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視窗已停用 （變成背景視窗） 時：  
  
-   使用者切換至另一個視窗中目前的應用程式。  
  
-   使用 ALT + TAB，或使用 工作管理員，使用者會切換成另一個應用程式中的視窗。  
  
-   使用者按一下另一個應用程式視窗的工作列按鈕。  
  
 需要偵測當它們變成停用處理的 Windows<xref:System.Windows.Window.Deactivated>事件。  
  
 視窗先停用之後，它可能會重新啟動並在其存留期間多次停用。 如果應用程式的狀態或行為取決於其啟動狀態，它可以檢查<xref:System.Windows.Window.IsActive%2A>來判斷哪一個啟用的狀態。  
  
 應用程式也可以是<xref:System.Windows.Application.Deactivated>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定對話方塊結果值，這個值就是 <see cref="M:System.Windows.Window.ShowDialog" /> 方法傳回的值。</summary>
        <value>
          <see cref="T:System.Nullable`1" /> 型別的 <see cref="T:System.Boolean" /> 值。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> 可從已顯示對話方塊，以判斷使用者是否已接受的程式碼 (`true`) 或已取消 (`false`) 對話方塊。 如果已接受對話方塊中，這表示開啟對話方塊，來擷取使用者所收集的資料，並處理它的程式碼。 如果已取消對話方塊中，不過，這種情況表示呼叫的程式碼應該停止任何進一步處理。  
  
 根據預設，當使用者執行下列其中一種取消對話方塊：  
  
-   PressesALT + F4。  
  
-   按一下**關閉** 按鈕。  
  
-   選取**關閉**從系統功能表。  
  
 在所有這些情況下，<xref:System.Windows.Window.DialogResult%2A>是`false`預設。  
  
 對話方塊通常提供特殊的按鈕，即可取消對話方塊中，這是按鈕其<xref:System.Windows.Controls.Button.IsCancel%2A>屬性設定為`true`。 如果如此設定的按鈕時請按下，或按下 ESC 鍵時，會自動關閉視窗。 在任一情況下，<xref:System.Windows.Window.DialogResult%2A>維持`false`。  
  
 對話方塊通常也會提供 [接受] 按鈕，為按鈕的<xref:System.Windows.Controls.Button.IsDefault%2A>屬性設定為`true`。 如果如此設定的按鈕將會引發其<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件時按下它或 ENTER 鍵。 不過，它將不會自動關閉對話方塊中，也不將它設定<xref:System.Windows.Window.DialogResult%2A>至`true`。 您需要以手動方式撰寫此程式碼，通常從<xref:System.Windows.Controls.Primitives.ButtonBase.Click>預設按鈕的事件處理常式。  
  
 <xref:System.Windows.Window.DialogResult%2A> 是`null`對話方塊會顯示當但未接受或已取消。  
  
 對話框會關閉之後，您可以從所傳回的值取得的對話方塊結果<xref:System.Windows.Window.ShowDialog%2A>方法，或藉由檢查<xref:System.Windows.Window.DialogResult%2A>屬性。  
  
 <xref:System.Windows.Window.DialogResult%2A> 只有時可以設定<xref:System.Windows.Window>開啟藉由呼叫其<xref:System.Windows.Window.ShowDialog%2A>方法。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
   
  
## Examples  
 下列範例示範如何設定 [確定] 按鈕和 [取消] 按鈕返回適當<xref:System.Windows.Window.DialogResult%2A>。  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          藉由呼叫 <see cref="P:System.Windows.Window.DialogResult" /> 開啟視窗之前設定 <see cref="M:System.Windows.Window.ShowDialog" />。  
  
 -或-  
  
 在藉由呼叫 <see cref="P:System.Windows.Window.DialogResult" /> 開啟的視窗上設定 <see cref="M:System.Windows.Window.Show" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於顯示視窗的螢幕 DPI 變更之後。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在視窗變更時用於螢幕 DPI 的 <see cref="T:System.Windows.RoutedEvent" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>允許透過在視窗工作區的公開區域按下滑鼠左鍵來拖曳視窗。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠左的按鈕必須關閉時<xref:System.Windows.Window.DragMove%2A>呼叫。 當按下滑鼠左鍵時偵測到的一種方式為處理<xref:System.Windows.UIElement.MouseLeftButtonDown>事件。  
  
 當<xref:System.Windows.Window.DragMove%2A>呼叫時，左側視窗的工作區的公開區域上方必須按下滑鼠按鈕。  
  
> [!NOTE]
>  裝載在瀏覽器視窗時，無法呼叫這個方法。  
  
   
  
## Examples  
 下列範例示範如何覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>呼叫<xref:System.Windows.Window.DragMove%2A>。  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未按下滑鼠左鍵。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">將視窗拖曳的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">相依性物件。</param>
        <summary>傳回 <see cref="T:System.Windows.Window" /> 物件的參考，這個物件含有相依性物件所在的內容樹狀結構。</summary>
        <returns>對主視窗的 <see cref="T:System.Windows.Window" /> 參考。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> 為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓視窗看不見。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱藏時，無法關閉視窗並沒有<xref:System.Windows.Window.Closing>也<xref:System.Windows.Window.Closed>就會引發事件。 相反地，視窗的<xref:System.Windows.UIElement.Visibility%2A>屬性設定為<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>。  
  
 如果視窗是應用程式的<xref:System.Windows.Application.MainWindow%2A>和應用程式的<xref:System.Windows.Application.ShutdownMode%2A>是<xref:System.Windows.ShutdownMode.OnMainWindowClose>，應用程式不會關機。 同樣地，應用程式不會關機如果視窗是唯一的視窗，而且應用程式的關機模式<xref:System.Windows.ShutdownMode.OnLastWindowClose>。  
  
 如果您想要顯示和隱藏視窗的應用程式的存留期間多次，而且您不想要重新具現化的視窗每次您將其顯示，您可以處理<xref:System.Windows.Window.Closing>事件取消，並呼叫<xref:System.Windows.Window.Hide%2A>方法。 然後，您可以呼叫<xref:System.Windows.Window.Show%2A>即可重新開啟相同的執行個體上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> 的呼叫對象是正在關閉 (<see cref="E:System.Windows.Window.Closing" />) 或已經關閉 (<see cref="E:System.Windows.Window.Closed" />) 的視窗。</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗的圖示。</summary>
        <value>表示圖示的 <see cref="T:System.Windows.Media.ImageSource" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) 獨立應用程式有兩種類型的圖示：  
  
-   使用指定的一個組件圖示`<ApplicationIcon>`檔案建置應用程式的專案中的屬性。 組件做為桌面圖示使用這個圖示。  
  
    > [!NOTE]
    >  偵錯時 Visual Studio 中，由於裝載處理序可能不會出現您的圖示。 如果您執行可執行檔，則會出現圖示。 如需詳細資訊，請參閱[裝載處理序 (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)。  
  
-   每個視窗所設定指定一個圖示<xref:System.Windows.Window.Icon%2A>。 針對每個視窗中，在其標題列，其工作列按鈕，和其 ALT TAB 應用程式選取項目清單項目中使用這個圖示。  
  
 WPF 視窗一律顯示圖示。 當其中一個未提供藉由設定<xref:System.Windows.Window.Icon%2A>，WPF 選擇圖示以顯示根據下列規則：  
  
1.  如果指定，請使用組件圖示。  
  
2.  如果未指定組件圖示，請使用預設的 Microsoft Windows 圖示。  
  
 如果您使用<xref:System.Windows.Window.Icon%2A>若要指定自訂視窗圖示，您可以還原預設應用程式圖示，藉由設定<xref:System.Windows.Window.Icon%2A>至`null`。  
  
 單一圖示可用於各種不同的方式，在 Windows 中，包括標題列的視窗中，視窗中，ALT + TAB 檔案選取清單的工作列中顯示。 每一種顯示使用不同的大小; 圖示ALT + TAB 檔案選取清單中顯示 32 x 32 像素圖示時，視窗標題列中，在工作列上，會顯示 16 x 16 像素圖示。 某些應用程式，例如[!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)]，提供**檢視**功能表，讓您選擇您想要檢視的圖示的大小。  
  
 若要符合不同的顯示大小，其中每一個都代表特定的大小與色彩深度為目標的圖示版本的一或多個實際的圖示被由圖示檔。 例如，一個圖示可能只有單一 16 x 16 像素圖示使用 16 個色彩，而另一個可能包含 16 x 16 像素和 32 x 32 像素 16 個色彩和 256 色圖示。  
  
 如果所有可能的大小和色彩深度圖示存在於內的圖示檔<xref:System.Windows.Window>將使用合適的圖示。 如果圖示檔只包含一部分的所有可能的圖示，<xref:System.Windows.Window>的順序排列，大小與色彩深度會使用下一個最合適的圖示。  
  
 結果是圖示將一律使用由<xref:System.Windows.Window>，但使用的圖示可能不會以目標所需的大小與色彩深度。 例如，使用 16 個色彩 16 x 16 像素圖示都可能會用於顯示為 32 x 32 像素圖示以 256 色彩。 這可能會導致非預期的視覺效果，例如化，但可能會建立對所有目標的大小和色彩深度的圖示來避免。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.IconProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會示範如何設定視窗圖示。  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要設定圖示的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.Icon" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示視窗是否在使用中。</summary>
        <value>
          如果視窗為使用中則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用中視窗是使用者目前的前景視窗，並具有焦點，以作用中的標題列的外觀。 使用中視窗也會是最上層不明確設定的所有最上層視窗<xref:System.Windows.Window.Topmost%2A>屬性。  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.IsActiveProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.IsActive" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗左邊緣相對於桌面的位置。</summary>
        <value>視窗左邊緣的位置，以邏輯單位 (1/96 英吋) 計。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Window>最大化或最小化，左邊的還原點的這個值代表<xref:System.Windows.Window>。  
  
 這個屬性不能透過樣式設定。  
  
 如果您未指定值，<xref:System.Windows.Window.Left%2A>設為系統預設值。 您也可以指定系統的預設值，藉由設定<xref:System.Windows.Window.Left%2A>至<xref:System.Double.NaN>。 既不<xref:System.Double.NegativeInfinity>也<xref:System.Double.PositiveInfinity>是有效的值，如<xref:System.Windows.Window.Left%2A>。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.LeftProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.Left" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視窗的位置變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視窗的位置變更時：  
  
-   使用者將視窗拖曳視窗的標題列。  
  
-   視窗移之後<xref:System.Windows.Window.DragMove%2A>呼叫。  
  
-   可能是<xref:System.Windows.Window.Left%2A>或<xref:System.Windows.Window.Top%2A>屬性以程式設計方式設定。  
  
-   **移動**選擇視窗的 [系統] 功能表的功能表項目。  
  
-   <xref:System.Windows.Window.WindowState%2A>屬性變更。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得列舉值，這個列舉值列出視窗的邏輯子項目。</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" />，列出視窗的邏輯子項目。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">
          <see cref="T:System.Windows.Size" />，反映這個視窗可以提供給子系使用的大小。 您可以指定 Infinity，這個值表示視窗可以隨任何內容大小調整。</param>
        <summary>覆寫這個方法可以測量視窗大小。</summary>
        <returns>
          <see cref="T:System.Windows.Size" />，反映這個視窗在配置期間依據子系大小計算得來的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> 不會呼叫時<xref:System.Windows.UIElement.Visibility%2A>屬性的值為<xref:System.Windows.Visibility.Collapsed>。 如果值<xref:System.Windows.UIElement.Visibility%2A>屬性<xref:System.Windows.Visibility.Hidden>或<xref:System.Windows.Visibility.Visible>，<xref:System.Windows.Window.MeasureOverride%2A>呼叫。  
  
> [!NOTE]
>  當 <xref:System.Windows.Window.Show%2A>或<xref:System.Windows.Window.ShowDialog%2A>呼叫時，<xref:System.Windows.UIElement.Visibility%2A>屬性<xref:System.Windows.Window>設為<xref:System.Windows.Visibility.Visible>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> 會引發 <xref:System.Windows.Window.Activated> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnActivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnActivated%2A>基底類別上如果<xref:System.Windows.Window.Activated>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.Closed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> 會引發 <xref:System.Windows.Window.Closed> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnClosed%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnClosed%2A>基底類別上如果<xref:System.Windows.Window.Closed>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.Closing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> 會引發 <xref:System.Windows.Window.Closing> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnClosing%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnClosing%2A>基底類別上如果<xref:System.Windows.Window.Closing>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">舊內容樹狀結構根項目的參考。</param>
        <param name="newContent">新內容樹狀結構根項目的參考。</param>
        <summary>在 <see cref="P:System.Windows.Controls.ContentControl.Content" /> 屬性變更時呼叫。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.ContentRendered" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> 會引發 <xref:System.Windows.Window.ContentRendered> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnContentRendered%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnContentRendered%2A>基底類別上如果<xref:System.Windows.Window.ContentRendered>需要引發。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立並傳回這個 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> 的 <see cref="T:System.Windows.Window" /> 物件。</summary>
        <returns>這個 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> 的 <see cref="T:System.Windows.Window" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.Deactivated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> 會引發 <xref:System.Windows.Window.Deactivated> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnDeactivated%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnDeactivated%2A>基底類別上如果<xref:System.Windows.Window.Deactivated>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">先前的 DPI 縮放比例設定。</param>
        <param name="newDpi">新的 DPI 縮放比例設定。</param>
        <summary>當轉譯此視窗的 DPI 變更時呼叫。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.LocationChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> 會引發 <xref:System.Windows.Window.LocationChanged> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnLocationChanged%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnLocationChanged%2A>基底類別上如果<xref:System.Windows.Window.LocationChanged>需要引發。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作不會變更處理的狀態 (<xref:System.Windows.RoutedEventArgs.Handled%2A>屬性) 的<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您覆寫<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />，務必呼叫基底實作您<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />實作。 無法呼叫基底實作可防止基底類別處理事件，可能會變更的最終類別的執行階段行為。 您可以呼叫之前或之後，在特殊處理的基底實作，根據您的需求。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.SourceInitialized" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> 會引發 <xref:System.Windows.Window.SourceInitialized> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnSourceInitialized%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnSourceInitialized%2A>基底類別上如果<xref:System.Windows.Window.SourceInitialized>需要引發。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Window.StateChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> 會引發 <xref:System.Windows.Window.StateChanged> 事件。  
  
 從衍生的型別<xref:System.Windows.Window>可能會覆寫<xref:System.Windows.Window.OnStateChanged%2A>。 覆寫的方法必須呼叫<xref:System.Windows.Window.OnStateChanged%2A>基底類別上如果<xref:System.Windows.Window.StateChanged>需要引發。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父代。 如果 <see cref="T:System.Windows.DependencyObject" /> 先前沒有父代，則設為 null。</param>
        <summary>當視窗的父代變更時呼叫。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個視窗主控的視窗集合。</summary>
        <value>
          <see cref="T:System.Windows.WindowCollection" />，包含對這個視窗所主控之視窗的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擁有的視窗是一個其<xref:System.Windows.Window.Owner%2A>屬性設為另一個視窗中，也就是主控視窗的參考。 若要尋找擁有者視窗擁有的所有視窗，您可以列舉<xref:System.Windows.WindowCollection>所傳回<xref:System.Windows.Window.OwnedWindows%2A>屬性。  
  
   
  
## Examples  
 下列範例示範如何列舉<xref:System.Windows.Window.OwnedWindows%2A>。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定主控這個 <see cref="T:System.Windows.Window" /> 的 <see cref="T:System.Windows.Window" />。</summary>
        <value>表示主控這個 <see cref="T:System.Windows.Window" /> 的 <see cref="T:System.Windows.Window" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子視窗開啟時，父視窗呼叫<xref:System.Windows.Window.ShowDialog%2A>，父和子視窗之間建立隱含關聯性。 此關聯性會強制執行特定行為，包括相對於最小化、 最大化，以及還原。  
  
 當子視窗由父視窗呼叫<xref:System.Windows.Window.Show%2A>，不過，子視窗並沒有與父視窗的關聯性。 這表示：  
  
-   子視窗並沒有父視窗的參考。  
  
-   子視窗的行為不會隨著父視窗; 的行為其中一個視窗可以涵蓋，或最小化，以最大化，並還原個別地。  
  
 若要可讓您建立的父視窗，子視窗之間的關聯性<xref:System.Windows.Window>支援擁有權的概念。 建立擁有權時<xref:System.Windows.Window.Owner%2A>視窗 （擁有視窗） 的屬性設為另一個視窗 （擁有者視窗） 的參考。  
  
 一旦建立此關聯性，則會顯示下列行為：  
  
-   如果主控視窗會最小化，其擁有的所有視窗最小都化以及。  
  
-   如果擁有的視窗最小化，其擁有者沒有最小化。  
  
-   如果擁有者視窗最大化，擁有者視窗和其擁有的 windows 會還原。  
  
-   主控視窗可以永遠不會涵蓋擁有的視窗。  
  
-   擁有不使用開啟的 windows<xref:System.Windows.Window.ShowDialog%2A>不會強制回應。 使用者仍然可以互動主控視窗。  
  
-   如果您關閉主控視窗，也會關閉其擁有的 windows。  
  
-   如果擁有的視窗已開啟由其擁有者視窗使用<xref:System.Windows.Window.Show%2A>，且擁有者視窗已關閉，擁有的視窗的<xref:System.Windows.Window.Closing>不會引發事件。  
  
 當您開啟子視窗呼叫<xref:System.Windows.Window.ShowDialog%2A>，您也應該設定<xref:System.Windows.Window.Owner%2A>子視窗的屬性。 如果沒有，您的使用者無法再還原按工作列按鈕的子視窗與父視窗。 相反地，按工作列按鈕，將會產生一份 windows，包括子系和父視窗中的，為其選取。還原選取的視窗。  
  
> [!IMPORTANT]
>  您也應該設定<xref:System.Windows.Window.Owner%2A>屬性，藉由呼叫開啟的視窗<xref:System.Windows.Window.ShowDialog%2A>以確定有正確的行為。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
   
  
## Examples  
 下列範例會示範如何建立擁有者/擁有關聯性。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">有個視窗嘗試主控它自己  
  
 -或-  
  
 兩個視窗嘗試主控對方。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.Owner" /> 屬性是設定在使用 <see cref="M:System.Windows.Window.ShowDialog" /> 顯示的可見視窗上。  
  
 -或-  
  
 <see cref="P:System.Windows.Window.Owner" /> 屬性是設定為先前未顯示過的視窗。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用的所有 windows 和不受限制的使用者輸入的事件的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定調整大小模式。</summary>
        <value>指定調整大小模式的 <see cref="T:System.Windows.ResizeMode" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有四個選項：  
  
-   **NoResize**。 使用者無法調整視窗大小。 不會顯示最大化] 和 [最小化方塊。  
  
-   **CanMinimize**。 使用者只能視窗最小化和還原從工作列。 同時會顯示最小化和最大化方塊，但已啟用最小化方塊。  
  
-   **CanResize**。 使用者能夠完整調整視窗大小的視窗周圍使用的最小化和最大化的方塊，並可拖曳的外框。 最小化和最大化方塊會顯示和啟用狀態。 （預設值）。  
  
-   **CanResizeWithGrip**。 這個選項擁有相同的功能<xref:System.Windows.ResizeMode.CanResize>，但將 「 調整大小底框 」 加入至視窗的右下角。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.ResizeModeProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.ResizeMode" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得視窗在最小化或最大化之前的大小和位置。</summary>
        <value>
          <see cref="T:System.Windows.Rect" />，指定視窗在最小化或最大化之前的大小和位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原矩形是最小化或最大化之前視窗所佔據的區域。 您可以使用<xref:System.Windows.Window.RestoreBounds%2A>之前關閉應用程式時，儲存的最後一個大小和視窗位置和下一次應用程式啟動視窗還原成使用者所保留的方式來擷取這些值。  
  
 如果您查詢<xref:System.Windows.Window.RestoreBounds%2A>在顯示的視窗之前或之後已關閉，<xref:System.Windows.Rect.Empty%2A>傳回。  
  
> [!NOTE]
>  裝載在瀏覽器視窗時，無法取得這個屬性。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.Window.RestoreBounds%2A>和隔離儲存區，以確保的大小和視窗的位置是否與相同的視窗顯示先前的時間。  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要查詢的大小和視窗的位置的權限的週框矩形。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開啟視窗，並且不等新開啟的視窗關閉就返回。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Window>類別具現化，則不是預設為可見。 <xref:System.Windows.Window.Show%2A> 會顯示一個視窗，並立即傳回，而不需等待要關閉視窗。 因此，開啟的視窗不會避免使用者互動與其他 windows 應用程式中。 這類視窗稱為*非強制回應*視窗。 非強制回應視窗的常見範例為 [屬性] 視窗、 工具箱和調色盤。 若要限制使用者與特定的視窗進行互動，必須開啟視窗呼叫<xref:System.Windows.Window.ShowDialog%2A>。  
  
 開啟的視窗，藉由呼叫<xref:System.Windows.Window.Show%2A>並不會自動開啟它的視窗具有的關聯性; 特別是，開啟的視窗不知道哪一個視窗開啟它。 此關聯性可以使用建立<xref:System.Windows.Window.Owner%2A>屬性和 managed 使用<xref:System.Windows.Window.OwnedWindows%2A>屬性。  
  
 呼叫<xref:System.Windows.Window.Show%2A>可達到相同的結果做為設定<xref:System.Windows.UIElement.Visibility%2A>屬性<xref:System.Windows.Window>物件<xref:System.Windows.Visibility.Visible>。 不過，沒有從計時的觀點來看兩者的差異。  
  
 呼叫<xref:System.Windows.Window.Show%2A>是同步作業之後才傳回<xref:System.Windows.FrameworkElement.Loaded>已經引發子視窗上的事件：  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 設定<xref:System.Windows.UIElement.Visibility%2A>，不過，會立即傳回的非同步作業：  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 設定時<xref:System.Windows.UIElement.Visibility%2A>，您先在您設定註冊任何視窗事件<xref:System.Windows.UIElement.Visibility%2A>可能不會在您設定的方法之前引發<xref:System.Windows.UIElement.Visibility%2A>才完成執行。  
  
   
  
## Examples  
 下列範例會示範如何開啟強制回應視窗。  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> 的呼叫對象是正在關閉 (<see cref="E:System.Windows.Window.Closing" />) 或已經關閉 (<see cref="E:System.Windows.Window.Closed" />) 的視窗。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值指出視窗一開始顯示時是否已啟動。</summary>
        <value>
          如果視窗一開始顯示時為已啟動，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當與視窗其<xref:System.Windows.Window.ShowActivated%2A>屬性設定為`false`會開啟，視窗不會啟動和其<xref:System.Windows.Window.Activated>直到使用者手動啟動視窗加以選取，不會引發事件。 已選取視窗之後，它會啟用，並通常會停用。  
  
 若要防止視窗會開啟，當啟動<xref:System.Windows.Window.ShowActivated%2A>屬性必須設定為`false`顯示視窗之前 (藉由呼叫<xref:System.Windows.Window.Show%2A>); 將<xref:System.Windows.Window.ShowActivated%2A>至`false`視窗會顯示沒有任何作用之後。  
  
 設定<xref:System.Windows.Window.ShowActivated%2A>至`false`上開啟的視窗，以強制回應方式，藉由呼叫<xref:System.Windows.Window.ShowDialog%2A>，沒有任何實際的影響。 雖然將不會啟動強制回應視窗，強制回應視窗會防止使用者啟動任何其他開啟的應用程式視窗。  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.ShowActivatedProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例會示範如何使用標記來設定要開啟但不啟動的視窗。  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 下列範例會示範如何使用程式碼來設定但不啟動開啟的視窗。  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.ShowActivated" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開啟視窗，並且只在新開啟的視窗已經關閉時才返回。</summary>
        <returns>
          <see cref="T:System.Nullable`1" /> 型別的 <see cref="T:System.Boolean" /> 值，會指定已接受 (<see langword="true" />) 或取消 (<see langword="false" />) 活動。 傳回值就是在視窗關閉前的 <see cref="P:System.Windows.Window.DialogResult" /> 屬性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Window>類別具現化，則不是預設為可見。 <xref:System.Windows.Window.ShowDialog%2A> 顯示的視窗會停用應用程式中的所有其他視窗和視窗已關閉時，才會傳回。 這類視窗稱為*強制回應*視窗。  
  
 強制回應視窗，主要用對話方塊。 對話方塊是一種特殊類型的應用程式用來與使用者互動以完成工作，例如開啟檔案或列印文件視窗。 對話方塊通常可讓使用者接受或取消其所顯示的對話方塊關閉之前的工作。 <xref:System.Windows.Window.ShowDialog%2A> 傳回<xref:System.Nullable%601><xref:System.Boolean>值，指定是否接受或取消的活動。 傳回值就是在視窗關閉前的 <xref:System.Windows.Window.DialogResult%2A> 屬性值。 如需詳細資訊，請參閱<xref:System.Windows.Window.DialogResult%2A>。  
  
 開啟的視窗，藉由呼叫<xref:System.Windows.Window.ShowDialog%2A>方法自動沒有與它開啟的視窗之間的關係，特別是，開啟的視窗不知道哪一個視窗開啟它。 此關聯性可以使用建立<xref:System.Windows.Window.Owner%2A>屬性和 managed 使用<xref:System.Windows.Window.OwnedWindows%2A>屬性。 若要支援[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]自動化 (請參閱[UI 自動化概觀](~/docs/framework/ui-automation/ui-automation-overview.md))，<xref:System.Windows.Window.Owner%2A>藉由呼叫開啟的視窗必須設定<xref:System.Windows.Window.ShowDialog%2A>。  
  
 當強制回應[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]視窗 (藉由呼叫開啟的視窗<xref:System.Windows.Window.ShowDialog%2A>) 已關閉，先前已啟動 視窗就會重新啟動。 如果強制回應[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]視窗有主控視窗 (請參閱<xref:System.Windows.Window.Owner%2A>)，不是主控視窗會重新啟動時強制回應[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]視窗已關閉，除非它是先前已啟動的視窗。  
  
> [!NOTE]
>  裝載在瀏覽器視窗時，無法呼叫這個方法。  
  
   
  
## Examples  
 下列範例會示範如何開啟強制回應視窗。  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> 的呼叫對象是正在關閉 (<see cref="E:System.Windows.Window.Closing" />) 或已經關閉 (<see cref="E:System.Windows.Window.Closed" />) 的視窗。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">若要啟用視窗的使用權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示視窗是否具有工作列按鈕。</summary>
        <value>
          如果視窗具有工作列按鈕則為 <see langword="true" />，否則為 <see langword="false" />。 不適用於視窗裝載於瀏覽器中時。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Window.ShowInTaskbar%2A>設`true`，視窗也會出現在 ALT + TAB 應用程式選取項目清單。  
  
 使用 ALT + TAB 應用程式選取項目清單和工作列按鈕的圖示是值<xref:System.Windows.Window.Icon%2A>屬性。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.ShowInTaskbar" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示視窗是否會自動隨內容調整本身大小。</summary>
        <value>
          <see cref="T:System.Windows.SizeToContent" /> 值。 預設值為 <see cref="F:System.Windows.SizeToContent.Manual" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Window.SizeToContent%2A>設<xref:System.Windows.SizeToContent.WidthAndHeight>，設定<xref:System.Windows.FrameworkElement.Height%2A>或<xref:System.Windows.FrameworkElement.Width%2A>沒有任何作用，則可以設定這兩個屬性，但它們會以設定的值不會套用至視窗。  
  
 當<xref:System.Windows.Window.SizeToContent%2A>設<xref:System.Windows.SizeToContent.Height>，設定<xref:System.Windows.FrameworkElement.Height%2A>不會變更視窗的高度。  
  
 當<xref:System.Windows.Window.SizeToContent%2A>設<xref:System.Windows.SizeToContent.Width>，設定<xref:System.Windows.FrameworkElement.Width%2A>不會變更視窗的寬度。  
  
 如果<xref:System.Windows.Window.SizeToContent%2A>以外的值<xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> 會自動設為<xref:System.Windows.SizeToContent.Manual>如果使用者將視窗調整使用調整大小底框或拖曳框線。  
  
-   如果會造成視窗本身，調整大小的方式變更內容的大小<xref:System.Windows.FrameworkElement.SizeChanged>，就會引發。  
  
 如果視窗是透明 (請參閱<xref:System.Windows.Window.AllowsTransparency%2A>)，您應考慮設定<xref:System.Windows.Window.SizeToContent%2A>至<xref:System.Windows.SizeToContent.WidthAndHeight>來確定視窗是不能大於其可見的內容。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.SizeToContentProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Window.SizeToContent%2A>指定視窗會調整大小以符合其內容的程式碼中的屬性。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.SizeToContent" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個事件是為了支援與 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 的互通性而引發。 請參閱<see cref="T:System.Windows.Interop.HwndSource" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於視窗的 <see cref="P:System.Windows.Window.WindowState" /> 屬性變更時。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Window" /> 的 [!INCLUDE[win7](~/includes/win7-md.md)] 工作列縮圖。</summary>
        <value>
          <see cref="T:System.Windows.Window" /> 的 [!INCLUDE[win7](~/includes/win7-md.md)] 工作列縮圖。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關如何使用[!INCLUDE[win7](~/includes/win7-md.md)]工作列縮圖，請參閱<xref:System.Windows.Shell.TaskbarItemInfo>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.TaskbarItemInfo" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗的標題。</summary>
        <value>包含視窗標題的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 標題<xref:System.Windows.Window>， <xref:System.Windows.Navigation.NavigationWindow>，或[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]，也可以透過設定<xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>。  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.TitleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.Title" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗上邊緣相對於桌面的位置。</summary>
        <value>視窗上邊緣的位置，以邏輯單位 (1/96 英吋) 計。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Window>最大化或最小化上邊緣的還原點的這個值代表<xref:System.Windows.Window>。  
  
 這個屬性不能透過樣式設定。  
  
 如果您未指定值，<xref:System.Windows.Window.Top%2A>設為系統預設值。 您也可以指定系統的預設值，藉由設定<xref:System.Windows.Window.Top%2A>至<xref:System.Double.NaN>。 既不<xref:System.Double.NegativeInfinity>也<xref:System.Double.PositiveInfinity>是有效的值，如<xref:System.Windows.Window.Top%2A>。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.TopProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示視窗是否要依疊置順序 (Z-order) 出現在最上層。</summary>
        <value>
          如果視窗是最上層視窗則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 視窗的<xref:System.Windows.Window.Topmost%2A>屬性設定為`true`其上方的所有視窗<xref:System.Windows.Window.Topmost%2A>屬性會設為`false`。  
  
 具有 windows 群組中<xref:System.Windows.Window.Topmost%2A>屬性設定為`true`，目前啟動的視窗是最上層視窗。 對於具有 windows 群組<xref:System.Windows.Window.Topmost%2A>屬性設定為`false`。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.TopmostProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.Topmost" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.Top" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗第一次顯示時的位置。</summary>
        <value>
          <see cref="T:System.Windows.WindowStartupLocation" /> 值，指定視窗第一次顯示的上方/左側位置。 預設值為 <see cref="F:System.Windows.WindowStartupLocation.Manual" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Windows.WindowStartupLocation>至<xref:System.Windows.WindowStartupLocation.Manual>致使視窗放置根據其<xref:System.Windows.Window.Left%2A>和<xref:System.Windows.Window.Top%2A>屬性值。 如果有任一個<xref:System.Windows.Window.Left%2A>或<xref:System.Windows.Window.Top%2A>未指定屬性，其值取決於 Windows。  
  
 設定<xref:System.Windows.WindowStartupLocation.CenterScreen>致使視窗位於包含滑鼠游標在螢幕的中央。  
  
 設定<xref:System.Windows.WindowStartupLocation>至<xref:System.Windows.WindowStartupLocation.CenterOwner>致使視窗在其擁有者視窗的中央位於 (請參閱<xref:System.Windows.Window.Owner%2A>)，如果指定。 另一個 WPF 視窗中或非 WPF 視窗，可以是主控視窗。  
  
> [!NOTE]
>  如需與非 WPF 視窗的 WPF 視窗的詳細資訊，請參閱[WPF 和 Win32 互通](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)和<xref:System.Windows.Interop.WindowInteropHelper>。  
  
 如果未指定擁有者視窗，視窗的位置相同的方式決定如同<xref:System.Windows.WindowStartupLocation>設<xref:System.Windows.WindowStartupLocation.Manual>。  
  
> [!NOTE]
>  您無法設定，或裝載在瀏覽器視窗時，取得這個屬性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示視窗為已還原、最小化還是最大化狀態。</summary>
        <value>
          <see cref="T:System.Windows.WindowState" />，決定視窗為已還原、最小化還是最大化狀態。 預設值為 <see cref="F:System.Windows.WindowState.Normal" /> (已還原)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最小化或最大化視窗之前，會將其大小和位置儲存在<xref:System.Windows.Window.RestoreBounds%2A>。 後續還原視窗時，其大小和位置的值從值以還原<xref:System.Windows.Window.RestoreBounds%2A>。  
  
 當<xref:System.Windows.Window.WindowState%2A>屬性變更， <xref:System.Windows.Window.StateChanged> ，就會引發。  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.WindowStateProperty>|  
|中繼資料屬性設定為 `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.WindowState" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗的框線樣式。</summary>
        <value>
          <see cref="T:System.Windows.WindowStyle" />，指定視窗的框線樣式。 預設值為 <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> 可以是其中一個<xref:System.Windows.WindowStyle>列舉值，包括<xref:System.Windows.WindowStyle.None>， <xref:System.Windows.WindowStyle.ToolWindow>， <xref:System.Windows.WindowStyle.SingleBorderWindow> （預設值） 和<xref:System.Windows.WindowStyle.ThreeDBorderWindow>。  
  
 下圖顯示在視窗樣式[!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)]（Windows Vista Aero 佈景主題，以啟用透明玻璃）：  
  
 ![視窗樣式](~/add/media/windowoverviewfigure6.PNG "視窗樣式")  
  
> [!NOTE]
>  您無法設定或瀏覽器中裝載在視窗時，取得這個屬性。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Window.WindowStyleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Window.WindowStyle" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>