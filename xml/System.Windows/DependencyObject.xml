<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyObject.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac593e067f8bf97d79f7e4525a57db08a4a8d5109c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93e067f8bf97d79f7e4525a57db08a4a8d5109c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyObject">
          <source>Represents an object that participates in the dependency property system.</source>
          <target state="translated">代表參與相依性屬性系統的物件。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class enables <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> property system services on its many derived classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>類別可讓<ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>屬性系統服務在其許多衍生的類別。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>The property system's primary function is to compute the values of properties, and to provide system notification about values that have changed.</source>
          <target state="translated">對屬性系統的主要功能是以計算屬性值，並提供系統通知有關已變更的值。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Another key class that participates in the property system is <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">參與屬性系統的另一個索引鍵類別是<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> enables the registration of dependency properties into the property system, and provides identification and information about each dependency property, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> as a base class enables objects to use the dependency properties.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> 進入屬性系統，可讓相依性屬性的註冊，並提供識別與每個相依性屬性的相關資訊，而<ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>為基底類別可讓使用相依性屬性的物件。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> services and characteristics include the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> 服務和特性包括：</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Dependency property hosting support.</source>
          <target state="translated">裝載支援的相依性屬性。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>You register a dependency property by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method, and storing the method's return value as a public static field in your class.</source>
          <target state="translated">您藉由呼叫註冊相依性屬性<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>方法，並將方法的傳回值儲存為您的類別中的公用靜態欄位。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Attached property hosting support.</source>
          <target state="translated">裝載支援的附加的屬性。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>You register an attached property by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, and storing the method's return value as a public static read-only field in your class.</source>
          <target state="translated">您藉由呼叫註冊附加的屬性<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph>方法，並將方法的傳回值儲存為的公用靜態唯讀欄位在您的類別。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>(There are also additional member requirements; note that this represents a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> specific implementation for attached properties.</source>
          <target state="translated">(另外還有其他成員需求; 請注意，這代表<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>為附加屬性的特定實作。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>For details, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.) Your attached property can then be set on any class that derives from <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>附加屬性概觀<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>。)附加的屬性可以設定任何衍生自的類別上<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Get, set, and clear utility methods for values of any dependency properties that exist on the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">Get、 set、，然後清除存在於任何相依性屬性的值的公用程式方法<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Metadata, coerce value support, property changed notification, and override callbacks for  dependency properties or attached properties.</source>
          <target state="translated">中繼資料值支援、 屬性變更通知，以及相依性屬性的覆寫回呼強制轉型，或附加屬性。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>Also, the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class facilitates the per-owner property metadata for a dependency property.</source>
          <target state="translated">此外，<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>類別有助於相依性屬性的每個擁有者屬性中繼資料。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>A common base class for classes derived from <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Visual&gt;</ph>.</source>
          <target state="translated">類別的通用基底類別衍生自<ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.Media.Visual&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>(<ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, another base element class, has a class hierarchy that includes <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph>.)</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>，另一個基底項目類別，已包含的類別階層<ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph>。)</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>The following example derives from <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> to create a new abstract class.</source>
          <target state="translated">下列範例衍生自<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>來建立新的抽象類別。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyObject">
          <source>The class then registers an attached property and includes support members for that attached property.</source>
          <target state="translated">然後，此類別註冊附加的屬性，與包含該附加屬性的支援成員。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyObject">
          <source>Clears the local value of a property.</source>
          <target state="translated">清除屬性的區域數值。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>The dependency property to be cleared, identified by a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> object reference.</source>
          <target state="translated">要清除的相依性屬性，該屬性是由 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> 物件參考所識別。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>Clears the local value of a property.</source>
          <target state="translated">清除屬性的區域數值。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>The property to be cleared is specified by a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier.</source>
          <target state="translated">要清除的屬性是由 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> 識別項所指定。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>Clearing the property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> does not necessarily give a dependency property the default value that is specified in the dependency property metadata.</source>
          <target state="translated">清除屬性值，方法是呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>並不一定表示賦予相依性屬性的相依性屬性中繼資料中指定的預設值。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>Clearing the property only specifically clears whatever local value may have been applied.</source>
          <target state="translated">清除此屬性只會特別清除可能已套用的任何區域數值。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>相依性屬性值優先順序<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>The following example iterates all properties that have local values set on an object, then calls <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> to clear the values of each such property.</source>
          <target state="translated">下列範例會逐一查看所有屬性已設定物件上的本機值然後呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>清除每個這類屬性的值。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)">
          <source>Attempted to call <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /&gt;</ph> on a sealed <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">嘗試在密封的 <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上呼叫 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>The key for the dependency property to be cleared.</source>
          <target state="translated">要清除之相依性屬性的索引鍵。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>Clears the local value of a read-only property.</source>
          <target state="translated">清除唯讀屬性的區域數值。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>The property to be cleared is specified by a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph>.</source>
          <target state="translated">要清除的屬性是由 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> 所指定。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifies a read-only dependency property for property system operations.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>識別唯讀相依性屬性的屬性系統作業。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>Classes that define read-only dependency properties should not expose this key with public access.</source>
          <target state="translated">定義唯讀相依性屬性的類別不應該公開公用存取此金鑰。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>A publicly exposed key would provide a public code pathway that negated the read-only character of the property, if methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> could be called outside the class or assembly, referencing the key.</source>
          <target state="translated">如果公開索引鍵會提供公用程式碼路徑，會否定唯讀字元屬性的方法，如<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>可能呼叫外部組件中，參考索引鍵的類別。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>Clearing the property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> does not necessarily give a dependency property the default value that is specified in the dependency property metadata.</source>
          <target state="translated">清除屬性值，方法是呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>並不一定表示賦予相依性屬性的相依性屬性中繼資料中指定的預設值。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>Clearing the value only specifically clears whatever local value may have been applied.</source>
          <target state="translated">清除值只會特別清除可能已套用的任何區域數值。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>相依性屬性值優先順序<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)">
          <source>Attempted to call <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /&gt;</ph> on a sealed <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">嘗試在密封的 <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上呼叫 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>The identifier for the dependency property to coerce.</source>
          <target state="translated">要強制轉型之相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>Coerces the value of the specified dependency property.</source>
          <target state="translated">強制轉型所指定相依性屬性的值。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>This is accomplished by invoking any <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> function specified in property metadata for the dependency property as it exists on the calling <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">叫用存在於呼叫 <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> 上相依性屬性之屬性中繼資料內所指定的任何 <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 函式，就可以達到這一點。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>In addition to being explicitly invoked through calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> for a dependency property is also invoked internally whenever the dependency property value is being re-evaluated by the <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system.</source>
          <target state="translated">除了明確叫用透過呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>相依性屬性也會叫用內部相依性屬性值會被重新評估每當<ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>屬性系統。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>When you invoke the <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> method, you are ultimately invoking the coerce value callback for the property that you specify.</source>
          <target state="translated">當您叫用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>方法，您最後叫用強制值回呼，您指定的屬性。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>Typically you will invoke <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> only if you know that a coerce value callback exists, and if you know the callback's criteria for coercion.</source>
          <target state="translated">您通常會叫用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>唯一，如果您知道強制值回呼的存在，而且您知道此回呼之準則的強制型轉。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>The most common scenario for calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> is within class handling or property change callbacks of related properties that influence each other's values in a dependent way.</source>
          <target state="translated">最常見的案例，用於呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>內其他的值影響相依的方式的相關屬性的類別處理或為屬性變更回呼。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>相依性屬性回呼和驗證<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> within a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> implementation that is used as the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> for a different dependency properties on the same class.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>內<ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>做為實作<ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph>相同類別上不同的相依性屬性。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>This is a common pattern for introducing true value dependencies between dependency properties.</source>
          <target state="translated">這是常見的簡介，則為 true 的值之間相依性屬性的相依性模式。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)">
          <source>The specified <ph id="ph1">&lt;paramref name="dp" /&gt;</ph> or its value were invalid or do not exist.</source>
          <target state="translated">指定的 <ph id="ph1">&lt;paramref name="dp" /&gt;</ph> 或其值無效或不存在。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObjectType" /&gt;</ph> that wraps the <ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> type of this instance.</source>
          <target state="translated">取得包裝此執行個體之 <ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> 型別的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObjectType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObjectType" /&gt;</ph> that wraps the <ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> type of this instance.</source>
          <target state="translated">包裝此執行個體之 <ph id="ph2">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> 型別的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObjectType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>This property is useful if an object that is returned from a method has a return value type of <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> and you want to perform property system specific operations on it depending on its type.</source>
          <target state="translated">如果從方法傳回的物件有傳回值類型的這個屬性很有用<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>而且您想要執行屬性系統特定作業在其上的根據其類型。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>For example it is more efficient to call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29&gt;</ph> using the <ph id="ph2">&lt;xref:System.Windows.DependencyObjectType&gt;</ph> rather than the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> type.</source>
          <target state="translated">比方說是更有效率的方式呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29&gt;</ph>使用<ph id="ph2">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>而不是<ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph>型別。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph> facilitates faster lookup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph> 有助於更快的查閱。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>In the following pseudocode example, <ph id="ph1">`MySubClass`</ph> anticipates that additional derived classes might change the default value of the <ph id="ph2">`MyCustom`</ph> dependency property.</source>
          <target state="translated">在下列虛擬程式碼範例中，<ph id="ph1">`MySubClass`</ph>會預測其他的衍生的類別可能會變更的預設值<ph id="ph2">`MyCustom`</ph>相依性屬性。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.DependencyObjectType">
          <source>The class implements a default constructor that can determine the actual derived class by taking advantage of polymorphism on the <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph> value whenever that constructor is used as a derived class instantiator.</source>
          <target state="translated">類別會實作可以透過運用多型判斷實際的衍生的類別的預設建構函式<ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>值做為衍生的類別 instantiator 使用該建構函式時。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> to compare to the current instance.</source>
          <target state="translated">要與目前執行個體相比較的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>Determines whether a provided <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> is equivalent to the current <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">判斷提供的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 和目前的 <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 是否相等。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two instances are the same; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果兩個執行個體相等，就是 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則就是 <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>This implementation is reference equality only, and does not attempt to evaluate value equality of the contained properties.</source>
          <target state="translated">這個實作只參考相等且不會評估包含屬性的值相等。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> overrides and then seals two basic <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> methods: <ph id="ph3">&lt;see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /&gt;</ph> and <ph id="ph4">&lt;see cref="M:System.Windows.DependencyObject.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 覆寫，然後根據兩個 basic<ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>方法：<ph id="ph3">&lt;see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /&gt;</ph>和<ph id="ph4">&lt;see cref="M:System.Windows.DependencyObject.GetHashCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>The overrides call the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> implementations, resulting in an object equality behavior.</source>
          <target state="translated">覆寫呼叫<ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>實作中，因而導致物件是否相等的行為。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>The purpose of these deliberate overrides is to prevent derived classes from trying to define a value equality for a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">這些審慎的覆寫的目的是為了防止衍生的類別來定義值是否相等<ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>Value equalities for <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> will never be accurate because of the innate property value-changing capabilities of a <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> and its dependency properties.</source>
          <target state="translated">值的等式<ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>絕對不會精確由於固有的屬性值變更的功能<ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>和其相依性屬性。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.Equals(System.Object)">
          <source>This includes fundamental <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features such as data binding and the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system.</source>
          <target state="translated">這包括基本<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>功能，例如資料繫結和<ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>屬性系統。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>Gets a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">取得這個 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 的雜湊碼。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>A signed 32-bit integer hash code.</source>
          <target state="translated">帶正負號 32 位元整數雜湊碼。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> overrides and then seals two <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> methods: <ph id="ph3">&lt;see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /&gt;</ph> and <ph id="ph4">&lt;see cref="M:System.Windows.DependencyObject.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 覆寫，然後根據兩個<ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>方法：<ph id="ph3">&lt;see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /&gt;</ph>和<ph id="ph4">&lt;see cref="M:System.Windows.DependencyObject.GetHashCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>The overrides call the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> implementations, resulting in an object equality behavior.</source>
          <target state="translated">覆寫呼叫<ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>實作中，因而導致物件是否相等的行為。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>The purpose of these deliberate overrides is to prevent derived classes from trying to define a value equality for a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">這些審慎的覆寫的目的是為了防止衍生的類別來定義值是否相等<ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>Value equalities for <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> will never be accurate because of the innate property value-changing capabilities of a <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> and its dependency properties.</source>
          <target state="translated">值的等式<ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>絕對不會精確由於固有的屬性值變更的功能<ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>和其相依性屬性。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetHashCode">
          <source>This includes fundamental <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features such as data binding and the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system.</source>
          <target state="translated">這包括基本<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>功能，例如資料繫結和<ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>屬性系統。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>Creates a specialized enumerator for determining which dependency properties have locally set values on this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">建立特定的列舉值，以判斷哪些相依性屬性在此 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上具有本機設定的值。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>A specialized local value enumerator.</source>
          <target state="translated">特定的區域數值列舉值。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>A <bpt id="p1">*</bpt>local value<ept id="p1">*</ept> is any dependency property value that was set by <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>, as opposed to other aspects of the property system.</source>
          <target state="translated">A<bpt id="p1">*</bpt>區域數值<ept id="p1">*</ept>是設定的任何相依性屬性值<ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>，與對屬性系統的其他層面。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Windows.LocalValueEnumerator&gt;</ph> obtained by calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> can be used to enumerate properties that have a locally set value on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.LocalValueEnumerator&gt;</ph>藉由呼叫取得<ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph>可以用來列舉具有本機設定的屬性值上<ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>Each such property is represented in the enumerator by a <ph id="ph1">&lt;xref:System.Windows.LocalValueEntry&gt;</ph> object, which has properties that reference the specific <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its values.</source>
          <target state="translated">每一個這類屬性會以列舉值所表示<ph id="ph1">&lt;xref:System.Windows.LocalValueEntry&gt;</ph>物件，其中包含的屬性參考特定<ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>和其值。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>This technique of enumerating over the locally set values can be used for optimization or for other handling of local values, such as to determine which property values of a <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> would change if they were cleared.</source>
          <target state="translated">這項技術的上本機設定列舉值可用於最佳化或其他處理的區域數值，例如判斷哪一個屬性值<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>會變更，如果它們已被清除。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>The returned <ph id="ph1">&lt;xref:System.Windows.LocalValueEnumerator&gt;</ph> might contain <ph id="ph2">&lt;xref:System.Windows.LocalValueEntry&gt;</ph> records for dependency properties that are read-only, or dependency properties where values are calculated by the property system.</source>
          <target state="translated">傳回<ph id="ph1">&lt;xref:System.Windows.LocalValueEnumerator&gt;</ph>可能包含<ph id="ph2">&lt;xref:System.Windows.LocalValueEntry&gt;</ph>記錄的相依性屬性是唯讀的或會計算值的屬性系統的相依性屬性。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>For example, a visual framework element that has an established width through layout will report a local value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph>.</source>
          <target state="translated">例如，透過配置建立的寬度的視覺化架構項目會報告的本機值<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>If you are getting local values in order to reset them, check the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value on the property identifier of each <ph id="ph2">&lt;xref:System.Windows.LocalValueEntry&gt;</ph> to verify that the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> in question is not read-only.</source>
          <target state="translated">如果您要取得區域數值，才能重設它們，請檢查<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph>上每個屬性的識別項值<ph id="ph2">&lt;xref:System.Windows.LocalValueEntry&gt;</ph>可讓您確認<ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>問題不是唯讀狀態。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetLocalValueEnumerator">
          <source>The following example iterates all properties that have local values set on an object, then calls <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> to clear the values of each such property.</source>
          <target state="translated">下列範例會逐一查看所有屬性已設定物件上的本機值然後呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>清除每個這類屬性的值。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier of the property to retrieve the value for.</source>
          <target state="translated">要為其擷取值之屬性的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> 識別項。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>Returns the current effective value of a dependency property on this instance of a <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">傳回 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 的這個執行個體上之相依性屬性的目前有效值。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>Returns the current effective value.</source>
          <target state="translated">傳回目前有效值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>The <bpt id="p1">*</bpt>effective value<ept id="p1">*</ept> is the value of the property that is returned by the property system to any caller that is requesting the value.</source>
          <target state="translated"><bpt id="p1">*</bpt>有效值<ept id="p1">*</ept>屬性系統回到要求值的任何呼叫端之屬性的值。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>The effective value is the result of the property system having evaluated all the possible inputs that participate in the property system value precedence.</source>
          <target state="translated">有效的值是在評估屬性的系統值優先順序所參與的所有可能輸入的屬性系統的結果。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>This includes coercion and animation.</source>
          <target state="translated">這包括強制型轉和動畫。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>相依性屬性值優先順序<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>This method will never return <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>.</source>
          <target state="translated">這個方法永遠不會傳回<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value for the property system that is used in various capacities internally and occasionally also exposed through coercion callbacks.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>是 sentinel 值的屬性系統，用於透過強制型轉回在內部，偶爾會也公開各種容量。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>If you are not sure what the property's type should be, you can query the identifier of the requested dependency property to determine whether there is a more specific <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> that the return value can be converted to.</source>
          <target state="translated">如果您不確定屬性的型別應該是什麼，您可以查詢要判斷是否有更特定之要求的相依性屬性的識別項<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>傳回值可以轉換成。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)">
          <source>The specified <ph id="ph1">&lt;paramref name="dp" /&gt;</ph> or its value was invalid, or the specified <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> does not exist.</source>
          <target state="translated">指定的 <ph id="ph1">&lt;paramref name="dp" /&gt;</ph> 或其值無效，或是指定的 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 不存在。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier of the property to invalidate.</source>
          <target state="translated">要使其失效之屬性的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> 識別項。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>Re-evaluates the effective value for the specified dependency property</source>
          <target state="translated">重新評估指定之相依性屬性的有效值。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>, any associated and applicable <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions registered for that dependency property might be invoked.</source>
          <target state="translated">當您呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>、 任何相關和適用<ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>或<ph id="ph3">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>函式註冊可能叫用該相依性屬性。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> on a property that has its local value set will have no effect, because the local value takes precedence over other property system inputs, except for animations.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>設定其本機值的屬性上會有任何作用，因為本機值優先於其他屬性系統輸入動畫除外。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>However, you could call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>, then call <ph id="ph2">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>.</source>
          <target state="translated">不過，您可以呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>，然後呼叫<ph id="ph2">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>相依性屬性值優先順序<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> is not necessarily applicable for many dependency property scenarios.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>不一定適用於許多相依性屬性。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>If a dependency property becomes invalidated because of value changes in any of the constituents, the property system invalidates and re-evaluates the dependency property automatically.</source>
          <target state="translated">如果因為任何項目中的值變更而失效相依性屬性，對屬性系統失效，並重新評估自動相依性屬性。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>However, there are still some appropriate scenarios where <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> is useful.</source>
          <target state="translated">不過，仍有某些適當的情況下其中<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>很有用。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>In particular, you can use <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> inside the coerce value or property changed callback for a different dependency property.</source>
          <target state="translated">特別是，您可以使用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>強制轉型值或屬性內變更為不同的相依性屬性的回呼。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>You can also use <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> to force re-evaluation of a binding against a data source that is not able to implement the recommended <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph> notification mechanism (perhaps if consuming data classes that cannot be derived from, or where the data is a static member).</source>
          <target state="translated">您也可以使用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>強制對不能實作建議的資料來源繫結的重新評估<ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>通知機制 (或許是如果使用，不能衍生自，或其中資料是靜態的資料類別成員）。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph> on a custom property, whenever properties that are involved in the invalidated property's calculations change.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.InvalidateProperty%2A&gt;</ph>自訂屬性，只要涉及失效的屬性的計算中的屬性變更。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)">
          <source>This is an alternative technique to calling the <ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> method, because invalidating the property will also call any registered <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>.</source>
          <target state="translated">這是替代方法來呼叫<ph id="ph1">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>方法，因為無效的屬性會同時也呼叫任何註冊<ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyObject.IsSealed">
          <source>Gets a value that indicates whether this instance is currently sealed (read-only).</source>
          <target state="translated">取得值，這個值表示此執行個體目前是否已密封 (唯讀)。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this instance is sealed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果這個執行個體已密封則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyObject.IsSealed">
          <source>This value is set internally.</source>
          <target state="translated">這個值是在內部設定。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Event data that will contain the dependency property identifier of interest, the property metadata for the type, and old and new values.</source>
          <target state="translated">將包含重要相依性屬性的識別項、類型之屬性中繼資料，以及新舊值的事件資料。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> has been updated.</source>
          <target state="translated">每當 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上任何相依性屬性的有效值已更新時叫用。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the event data.</source>
          <target state="translated">已變更的特定相依性屬性會在事件資料中報告。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect individual property changes or perform invalidations of properties on a per-case basis.</source>
          <target state="translated">這個方法不是通常偵測個別的屬性變更，或執行每個案例為基礎的屬性的失效。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> is instead intended for modifications of the general invalidation pattern, if certain information is known about wide classifications of properties.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> 改為僅供修改的一般失效模式中，如果已知廣泛分類屬性的特定資訊。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>For example, changes in a <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> might be changes in the value types of the <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph>, or might be subproperties, where the changes are within other <ph id="ph3">&lt;xref:System.Windows.Freezable&gt;</ph> references.</source>
          <target state="translated">例如，在變更<ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>的實值類型中的變更可能要<ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph>，或可能是子屬性，而所做的變更都在其他<ph id="ph3">&lt;xref:System.Windows.Freezable&gt;</ph>參考。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph> override implementation of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> uses internal information to determine whether the properties are subproperties, and provides appropriate base class logic for either case.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>覆寫的實作<ph id="ph2">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>以判斷屬性是否是子屬性，並提供適當的基底類別邏輯以兩種情況下會使用內部的資訊。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> is potentially invoked many times during the life of an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> 物件的存留期間可能呼叫多次。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance for the overall property system if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">因此，達到更佳整體屬性系統的效能，如果您覆寫特定屬性的中繼資料，然後將附加<ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>或<ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>個別屬性的函式。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">不過，您會使用這個方法如果<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>包含大量的值相互關聯的相依性屬性，或如果它包含邏輯，例如轉譯行為，必須重新執行的幾個相關的屬性失效的情況。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation.</source>
          <target state="translated">請務必呼叫基底實作。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, causing incorrect values to be reported.</source>
          <target state="translated">如果沒有這樣做將會大幅停用整個<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>屬性系統，造成不正確地回報的值。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier of the property to retrieve the value for.</source>
          <target state="translated">要為其擷取值之屬性的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> 識別項。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>Returns the local value of a dependency property, if it exists.</source>
          <target state="translated">傳回相依性屬性的區域數值 (如果存在)。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>Returns the local value, or returns the sentinel value <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> if no local value is set.</source>
          <target state="translated">傳回區域數值，若區域數值並未設定，則傳回 Sentinel 值 <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>You should use <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> for most typical "get" operations for a dependency property.</source>
          <target state="translated">您應該使用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>相依性屬性的最常見 「 取得 」 作業。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A&gt;</ph> does not return the effective value for a variety of circumstances where the value was not locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A&gt;</ph> 不會傳回有效的值不同的情況下，未在本機設定值。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>Values that are set by styles, themes, templates, the default value from metadata, or property value inheritance are not considered to be local values.</source>
          <target state="translated">值所設定的樣式、 佈景主題、 範本，從中繼資料或屬性值繼承預設值是不被視為區域數值。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>However, bindings and other expressions are considered to be local values, after they have been evaluated.</source>
          <target state="translated">不過，繫結和其他運算式會被視為區域數值之後已經進行評估。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>When no local value is set, this method returns <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>.</source>
          <target state="translated">當未不設定任何本機的值時，這個方法會傳回<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)">
          <source>If the returned value is other than <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>, you can query the metadata of the requested dependency property to determine whether there is a more specific type that the return value can be converted to.</source>
          <target state="translated">如果傳回的值不是<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>，您可以查詢來判斷是否有更特定的類型傳回值可以轉換成要求的相依性屬性的中繼資料。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>The identifier of the dependency property to set.</source>
          <target state="translated">要設定之相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>The new local value.</source>
          <target state="translated">新的本機值。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>Sets the value of a dependency property without changing its value source.</source>
          <target state="translated">設定相依性屬性的值，而不需要變更其值來源。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>This method is used by a component that programmatically sets the value of one of its own properties without disabling an application's declared use of the property.</source>
          <target state="translated">這個方法是由一種元件，以程式設計方式設定的其中一個它自己的屬性值，而不停用應用程式的宣告的屬性的用法。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> method changes the effective value of the property, but existing triggers, data bindings, and styles will continue to work.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph>方法變更的屬性，但是現有的觸發程序，資料繫結，有效的值和樣式，將會繼續運作。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source>Attempted to modify a read-only dependency property, or a property on a sealed <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">嘗試修改唯讀的相依性屬性，或密封的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上的屬性。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> was not the correct type as registered for the <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 不是如同為 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 屬性所註冊的正確型別。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyObject">
          <source>Sets the local value of a dependency property.</source>
          <target state="translated">設定相依性屬性的區域數值。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>The identifier of the dependency property to set.</source>
          <target state="translated">要設定之相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>The new local value.</source>
          <target state="translated">新的本機值。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>Sets the local value of a dependency property, specified by its dependency property identifier.</source>
          <target state="translated">設定相依性屬性的本機值 (由相依性屬性的識別項所指定)。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>If the provided type does not match the type that is declared for the dependency property as it was originally registered, an exception is thrown.</source>
          <target state="translated">如果提供的類型不符合與原先註冊之相依性屬性宣告的型別，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter should always be provided as the appropriate type.</source>
          <target state="translated"><ph id="ph1">`value`</ph>參數應該提供適當的型別。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>The exception conditions are potentially influenced by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph> callback that exists on the dependency property identifier of the dependency property being set.</source>
          <target state="translated">例外狀況可能會受到<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph>存在於所設定之相依性屬性的相依性屬性的識別項的回呼。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>Otherwise, the value provided might be failing general type-checking conditions (for example, passing a string when the native type is Double).</source>
          <target state="translated">否則，提供的值可能會失敗 （例如，將字串傳遞時的原生類型為 Double） 的一般型別檢查條件。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source>Attempted to modify a read-only dependency property, or a property on a sealed <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">嘗試修改唯讀的相依性屬性，或密封的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> 上的屬性。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> was not the correct type as registered for the <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 不是如同為 <ph id="ph2">&lt;paramref name="dp" /&gt;</ph> 屬性所註冊的正確型別。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> identifier of the property to set.</source>
          <target state="translated">要設定之屬性的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> 識別項。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>The new local value.</source>
          <target state="translated">新的本機值。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>Sets the local value of a read-only dependency property, specified by the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> identifier of the dependency property.</source>
          <target state="translated">設定唯讀相依性屬性的區域數值 (由相依性屬性的 <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> 識別項所指定)。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>This signature is generally used when you set values for read-only dependency properties that are defined by your custom classes.</source>
          <target state="translated">通常在您設定自訂類別所定義的唯讀相依性屬性的值時，會使用此簽章。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>Generally, <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> is called only from the type that registered that dependency property, which implements the internal logic that provides the determined value for the dependency property.</source>
          <target state="translated">一般而言，<ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>只會從已註冊的實作內部邏輯可決定的值的相依性屬性的相依性屬性的型別呼叫。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Read-Only Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>唯讀相依性屬性<ept id="p1">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>If the provided type does not match the type that is declared for the dependency property as it was originally registered, an exception is thrown.</source>
          <target state="translated">如果提供的類型不符合與原先註冊之相依性屬性宣告的型別，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>The <ph id="ph1">`value`</ph> parameter should always be provided as the appropriate type.</source>
          <target state="translated"><ph id="ph1">`value`</ph>參數應該提供適當的型別。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>The exception conditions are potentially influenced by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph> callback that exists on the dependency property identifier of the dependency property being set.</source>
          <target state="translated">例外狀況可能會受到<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ValidateValueCallback%2A&gt;</ph>存在於所設定之相依性屬性的相依性屬性的識別項的回呼。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)">
          <source>The following example defines a read-only dependency property, along with a <ph id="ph1">`public static readonly`</ph> <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> that provides necessary read-only exposure to property consumers, and the get accessor for the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper.</source>
          <target state="translated">下列範例會定義唯讀相依性屬性，連同<ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>提供必要的唯讀暴露於屬性的取用者，而且 get 存取子的<ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph>包裝函式。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)">
          <source>The identifier for the dependency property that should be serialized.</source>
          <target state="translated">應該序列化之相依性屬性的識別項。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)">
          <source>Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.</source>
          <target state="translated">傳回值，這個值表示序列化程序是否應該序列化所提供相依性屬性的值。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property that is supplied should be value-serialized; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果提供之相依性屬性的值應該序列化則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)">
          <source>The default implementation returns <ph id="ph1">`true`</ph> for all cases in which a dependency property had a local value established on the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">預設實作會傳回<ph id="ph1">`true`</ph>相依性屬性必須為區域數值上建立的所有案例<ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)">
          <source>Overrides for this method might handle specific dependency properties differently.</source>
          <target state="translated">覆寫這個方法可能會以不同方式處理特定的相依性屬性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>