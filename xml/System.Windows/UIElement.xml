<Type Name="UIElement" FullName="System.Windows.UIElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="69854c4988a3465fe13653f0b1e971ffe855f5ee" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55347691" /></Metadata><TypeSignature Language="C#" Value="public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement" />
  <TypeSignature Language="VB.NET" Value="Public Class UIElement&#xA;Inherits Visual&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class UIElement : System::Windows::Media::Visual, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type UIElement = class&#xA;    inherit Visual&#xA;    interface IAnimatable&#xA;    interface IInputElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.UidProperty("Uid")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.UIElement" /> 是以 Windows Presentation Foundation (WPF) 項目和基本呈現方式特性為建置基礎之 WPF 核心層級實作的基底類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement> 提供項目配置的特性，以及公開虛擬方法，衍生類別可以覆寫時，可能會影響轉譯行為的項目和其子元素的版面配置的起始點。  
  
 大部分的輸入和焦點行為項目的一般情況下也會定義在<xref:System.Windows.UIElement>類別。 這包括鍵盤、 滑鼠及手寫筆輸入及相關的狀態屬性的事件。 其中許多事件都是路由的事件，且許多的輸入相關的事件都有兩個事件反昇路由版本，以及事件的通道版本。 這些配對的事件通常是控制項作者的最大感興趣的事件。  
  
 <xref:System.Windows.UIElement> 也包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]相關的[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]事件模型，包括可以引發的方法指定路由事件，其源自項目執行個體。  
  
 就架構而言，<xref:System.Windows.UIElement>可以視為大致上相當於視窗控制代碼，以[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]程式設計或中的項目[!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)]程式設計。 <xref:System.Windows.UIElement> 是 WPF 核心層級的基底項目。  
  
 A<xref:System.Windows.UIElement>具有下列功能，特別由定義<xref:System.Windows.UIElement>類別：  
  
-   可以轉譯為子元素 (<xref:System.Windows.UIElement>衍生自<xref:System.Windows.Media.Visual>，高的層級圖形類別)  
  
-   包含大小和位置的可能的子項目使用的邏輯<xref:System.Windows.UIElement>（當解譯由配置系統）  
  
-   可以回應使用者輸入 （包括控制項的輸入取得傳送到何處透過其處理的事件路由，或在命令路由）  
  
-   可以引發邏輯的項目樹狀結構路由的路由的事件  
  
-   支援動畫系統的某些層面  
  
 <xref:System.Windows.FrameworkElement> 是為基礎的 WPF 架構層級實作類別<xref:System.Windows.UIElement>，並將加入 WPF 架構層級的特定互動。 <xref:System.Windows.FrameworkElement> 新增並定義下列功能：  
  
-   額外的架構特定版面配置特性  
  
-   支援更豐富的中繼資料屬性的報告  
  
-   輸入基底類別和其附加的屬性的特定類別的特定實作，或附加事件  
  
-   樣式支援  
  
-   進一步的動畫支援  
  
 另一個相關的類別是<xref:System.Windows.ContentElement>。 <xref:System.Windows.ContentElement>類別會實作許多相同的成員，如同<xref:System.Windows.UIElement>; 已將執行其預定使用的整體內容模型中的這兩個類別之間的差異。 A<xref:System.Windows.UIElement>衍生的類別通常會將相對固定的內容模型，這表示沒有限制哪些項目可能會在標記中的子項目定義。 可能會花較不嚴格的子內容的容量<xref:System.Windows.UIElement>，但該容量通常會集中在指定的內容屬性中。 A<xref:System.Windows.ContentElement>衍生的類別通常不是限制的相關內容，以支援案例，例如流程格式的文件。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement.Visibility%2A> 狀態會影響所有的輸入處理該項目。 不可見的項目不會參與點擊測試，且不會收到輸入的事件，即使在滑鼠位於範圍的項目就是，如果可見。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.UIElement" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立新的執行個體卻是類型<xref:System.Windows.UIElement>是應用程式程式碼中很常見，因為<xref:System.Windows.UIElement>是基底的項目。 請參閱[基底項目概觀](~/docs/framework/wpf/advanced/base-elements-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要處理的路由事件識別項。</param>
        <param name="handler">處理常式實作的參考。</param>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以新增相同的處理常式，相同事件多次，而不會引發例外狀況。 不過，處理常式實際叫用的多次時處理事件。 因此，請考慮如何這種行為可能會有副作用，都應該在自己的處理常式實作。  
  
 您通常使用這個方法來提供的 「 新增 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要處理的路由事件識別項。</param>
        <param name="handler">處理常式實作的參考。</param>
        <param name="handledEventsToo"><see langword="true" /> 登錄處理常式，使得即使路由事件被標記為已處理時，也會被叫用。<see langword="false" /> 登錄處理常式，預設條件為若路由事件被標示為已處理時則不被叫用。  
  
預設為 <see langword="false" />。  
  
請勿定期要求重新處理路由事件。</param>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。 將 <paramref name="handledEventsToo" /> 指定為 <see langword="true" />，為已標示為由事件路由上另一個項目處理的事件叫用提供的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實用的方式處理低階的輸入的事件是一個複雜的工作。 許多控制項實作的行為，其中特定事件標示為已處理，並已由另一個更具直覺性的事件所取代。 一般而言，控制項只會將平台的輸入的事件，為已處理，如果沒有這項操作的一些設計意圖。 在某些情況下，這些設計目的不可能您的輸入事件的特定處理的要求。 針對這些案例是該註冊處理常式`handledEventsToo`做為`true`適合。 但您不應該這麼定期。 叫用處理常式以回應所有的事件，即使處理將會使您自己的應用程式事件處理邏輯更為複雜。 如果處理常式邏輯則相當大，可能會看到效能降低。 您應該保留使用附加的情況下，您已經發現特定控制項所處理的事件，您仍然想要處理的應用程式邏輯在開發程序已經處理的事件處理常式。  
  
 為避免處理行為的某些事件控制項組合的類別的另一個方法是使用該事件預覽替代方案。 例如，如果<xref:System.Windows.UIElement.MouseLeftButtonDown>標示為已處理的類別處理，您可以加入處理常式<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>改為。  
  
 您可以新增相同的處理常式，相同事件多次，而不會引發例外狀況。 不過，處理常式實際叫用的多次時處理事件。 因此，請考慮如何這種行為可能會有副作用，都應該在自己的處理常式實作。  
  
 您通常使用這個方法來提供的 「 新增 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。  
  
   
  
## Examples  
 下列範例會實作上叫用處理常式<xref:System.Windows.FrameworkElement.Initialized>將定義的處理常式附加至其中一個頁面上的具名元素在頁面上的事件`handledEventsToo` `true`。 這個處理常式會叫用，即使路由中的另一個項目會標示為已處理到達路由中的處理項目之前共用的事件資料。  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">加入處理常式的事件路由。</param>
        <param name="e">用於加入處理常式的事件資料。 這個方法會使用事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性來建立處理常式。</param>
        <summary>針對目前的 <see cref="T:System.Windows.EventRoute" /> 事件處理常式集合，將處理常式加入至指定的 <see cref="T:System.Windows.UIElement" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可供內容主機項目 (可能是指實作<xref:System.Windows.IContentHost>或未) 新增為子項目，以處理常式<xref:System.Windows.EventRoute>。 一般情況下，這是不必要的<xref:System.Windows.UIElement>，因為在已完成的邏輯樹狀結構中找到的所有項目會自動加入處理常式。 不過，在某些情況下所在<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>混合樣板化樹狀結構，中間是來自範本必須新增至路由的項目中。 兩者<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>支援這個方法的版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.UIElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定此元素是否可以當做拖放操作目標的值。  這是相依性屬性。</summary>
        <value>如果這個項目可以當做拖放操作目標的值，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 拖放作業不會預設啟用，且必須藉由設定刻意啟用<xref:System.Windows.UIElement.AllowDrop%2A>至`true`。 超過此基本的設定，拖放行為完全是特定的實作並不由定義<xref:System.Windows.UIElement>或任何其他基底元素類別。 某些控制項，例如<xref:System.Windows.Controls.RichTextBox>，沒有預設行為。 如需有關功能的詳細資訊，請參閱[拖放概觀](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。  
  
 <xref:System.Windows.FrameworkElement> 覆寫這個實作中的相依性屬性的中繼資料。 具體而言，<xref:System.Windows.FrameworkElement>指定此屬性，以允許屬性值繼承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`中繼資料中)。 在此內容中的屬性值繼承表示，如果有任何其他值的子項目<xref:System.Windows.UIElement.AllowDrop%2A>指派透過本機值或最接近的父項目的值，與指派 （同樣地，無論是在樣式中，依預設此值的樣式值或本機值），然後從父元素的值會指派給所有先前未指派的子項目，屬性系統。 實際上這表示您可以指定是否要在根項目允許卸除作業，並將它做為值將會傳播至所有子項目具有不是明確地指派`false`。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.AllowDropProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列標記範例會設定<xref:System.Windows.UIElement.AllowDrop%2A>屬性`true`上使用屬性<xref:System.Windows.Controls.TextBox>，以及一些其他設定相關屬性，可彙總，讓<xref:System.Windows.Controls.TextBox>多行文字的資料物件的目標時拖曳。 如需完整的範例，請參閱[載入卸除檔案範例](https://msdn.microsoft.com/library/be90d645-dd61-4f53-93bb-87902d086ef7)。  
  
 [!code-xaml[DragDrop_DropOpenTextFile#UIElementAllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/DragDrop_DropOpenTextFile/CS/window1.xaml#uielementallowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.AllowDrop" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將動畫套用至這個項目上所指定的相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是已密封的方法，無法覆寫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">要繪製的屬性之識別項。</param>
        <param name="clock">控制並宣告動畫的動畫時鐘。</param>
        <summary>將動畫套用至這個項目上所指定的相依性屬性。 任何現有動畫都會停止並取代為新的動畫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要移除屬性的動畫，請指定 做為該屬性的識別項`dp`並指定`clock`做為`null`。 這會移除動畫，動畫的屬性設定為其基底值。 不過，並不會停止原先相關聯的動畫時鐘。 指派給該時鐘的任何其他動畫都會繼續執行。  
  
   
  
## Examples  
 在下列範例中， <xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle`有套用至它所呼叫的特定時間動畫<xref:System.Windows.UIElement.ApplyAnimationClock%2A>。  
  
 [!code-csharp[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]
 [!code-vb[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">要製作動畫的屬性。</param>
        <param name="clock">控制並宣告動畫的動畫時鐘。</param>
        <param name="handoffBehavior">列舉值。 預設值是 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，將停止任何現有的動畫，並以新的動畫取代。</param>
        <summary>將動畫套用至這個項目上所指定的相依性屬性，且可以指定此屬性已經有執行中的動畫時會發生哪種情況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要移除屬性的動畫，請指定 做為該屬性的識別項`dp`並指定`clock`做為`null`。 這會移除動畫，動畫的屬性設定為其基底值。 不過，並不會停止原先相關聯的動畫時鐘。 指派給該時鐘的任何其他動畫都會繼續執行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控擷取至這個項目。</summary>
        <value>如果至少有一個觸控擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目。</summary>
        <value>如果至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控在這個項目上按下。</summary>
        <value>如果至少有一個觸控在這個項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下。</summary>
        <value>如果至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arrange">
      <MemberSignature Language="C#" Value="public void Arrange (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Arrange(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Arrange (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Arrange(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="member this.Arrange : System.Windows.Rect -&gt; unit" Usage="uIElement.Arrange finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父代為子項目計算的最終大小，提供作為 <see cref="T:System.Windows.Rect" /> 執行個體。</param>
        <summary>放置子項目，並且判斷 <see cref="T:System.Windows.UIElement" /> 的大小。 父項目從 <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> 實作 (或 WPF 架構層級對等項目) 中呼叫此方法，以形成遞迴配置更新。 這個方法會構成配置更新的第二個階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 WPF 架構層級項目衍生的案例中，行為<xref:System.Windows.UIElement.Arrange%2A>變更不應該 （而且也無法，除非您陰影）。 相反地，您應該覆寫<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>類別中的實作。 您<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>就會在內部呼叫實作<xref:System.Windows.UIElement.Arrange%2A>預設 WPF 架構層級的配置作業的一部分。 您<xref:System.Windows.UIElement.ArrangeCore%2A>實作也應該呼叫<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>每個子項目，如果它有子系項目上。  
  
 WPF 核心層級項目衍生的行為，案例<xref:System.Windows.UIElement.Arrange%2A>變更不應該 （而且也無法，除非您陰影）。 相反地，您應該覆寫<xref:System.Windows.UIElement.ArrangeCore%2A>在您的類別。 您<xref:System.Windows.UIElement.ArrangeCore%2A>就會在內部呼叫實作<xref:System.Windows.UIElement.Arrange%2A>預設 WPF 架構層級的配置作業的一部分。 不過，這是假設您使用 WPF 架構層級的版面配置和其版面配置系統，通常不是如果您特別衍生項目，在 WPF 核心層級從<xref:System.Windows.UIElement>基底元素類別。 您<xref:System.Windows.UIElement.ArrangeCore%2A>實作也應該呼叫<xref:System.Windows.UIElement.Arrange%2A>每個子項目，如果它有子系項目上。 WPF 核心層級案例表示您未使用的附註<xref:System.Windows.FrameworkElement>衍生類別，因為<xref:System.Windows.FrameworkElement>標誌<xref:System.Windows.FrameworkElement.ArrangeCore%2A>。  
  
 計算中的 WPF 架構層級的版面配置定位[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]組成<xref:System.Windows.UIElement.Measure%2A>呼叫和<xref:System.Windows.UIElement.Arrange%2A>呼叫。 期間<xref:System.Windows.UIElement.Measure%2A>呼叫時，版面配置系統會決定使用所提供的項目大小需求<xref:System.Windows.Size>(`availableSize`) 引數。 期間<xref:System.Windows.UIElement.Arrange%2A>呼叫時，配置系統完成大小和位置的項目週框方塊。  如需詳細資訊，請參閱[配置](~/docs/framework/wpf/advanced/layout.md)。  
  
 `availableSize` 可以是零，為無限大的任何數字。 若要配置的項目傳回最小值<xref:System.Windows.Size>它們需要透過`availableSize`參數。  
  
 當第一次執行個體化的版面配置時，它一律會收到<xref:System.Windows.UIElement.Measure%2A>之前，先呼叫<xref:System.Windows.UIElement.Arrange%2A>。 不過之後第一次的版面配置傳遞，, 它可能會收到<xref:System.Windows.UIElement.Arrange%2A>呼叫，而不<xref:System.Windows.UIElement.Measure%2A>; 這種情形只會影響的屬性時<xref:System.Windows.UIElement.Arrange%2A>變更 （例如對齊），或是當父系收到<xref:System.Windows.UIElement.Arrange%2A>沒有<xref:System.Windows.UIElement.Measure%2A>. A<xref:System.Windows.UIElement.Measure%2A>呼叫會自動失效<xref:System.Windows.UIElement.Arrange%2A>呼叫。  
  
 以非同步方式 （一次由配置系統判定） 通常會進行版面配置更新。 項目可能不會立即反映屬性會影響項目調整大小的變更 (例如<xref:System.Windows.FrameworkElement.Width%2A>)。  
  
> [!NOTE]
>  版面配置更新可以強制使用<xref:System.Windows.UIElement.UpdateLayout%2A>方法; 不過，呼叫此函式不建議，因為它通常不需要而且可能會導致效能不佳。 在許多情況下，呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>可能適當，版面配置系統可能已經在處理更新。 版面配置系統可以處理版面配置變更，可以最佳化所有必要的更新套件的一部分的方式。  
  
 版面配置系統會保留兩個不同的佇列，不正確的版面配置，一個用於<xref:System.Windows.UIElement.Measure%2A>，另一個用於<xref:System.Windows.UIElement.Arrange%2A>。 配置的佇列會根據使用的視覺化樹狀結構中的項目順序來排序。 樹狀結構中較高的項目會在佇列中，頂端，以避免重複的變更，在父代所造成的備援配置。 自動從佇列中移除重複的項目和項目會自動從佇列中移除如果他們已經有效。  
  
 更新配置時<xref:System.Windows.UIElement.Measure%2A>佇列清空第一，後面接著<xref:System.Windows.UIElement.Arrange%2A>佇列。 中的項目<xref:System.Windows.UIElement.Arrange%2A>中的項目時，就永遠不會排列佇列<xref:System.Windows.UIElement.Measure%2A>佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected virtual void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeCore : System.Windows.Rect -&gt; unit&#xA;override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="uIElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父系內該項目應該用來排列本身和其子項目的最終區域。</param>
        <summary>定義 WPF 核心層級排列版面配置定義的範本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  覆寫此方法時，才適用如果您所衍生的 WPF 核心層級，而且您不想要使用 WPF 架構層級配置系統並<xref:System.Windows.FrameworkElement>衍生類別，因為<xref:System.Windows.FrameworkElement>標誌<xref:System.Windows.FrameworkElement.ArrangeCore%2A>。 如果您使用的 WPF 架構層級配置系統，適當的方法，來覆寫特定類別的配置排列行為是<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。  
  
   
  
## Examples  
 <xref:System.Windows.UIElement.ArrangeCore%2A> 實作應該呼叫基底實作傳回的大小，然後呼叫<xref:System.Windows.UIElement.Arrange%2A>每個可見子項目的的方法，並調解這些所傳回的大小<xref:System.Windows.UIElement.Arrange%2A>呼叫基底實作的大小。 對帳層面的邏輯<xref:System.Windows.UIElement.ArrangeCore%2A>實作可能會有所不同，視您的項目配置特性而定。 在下列的範例範本中，`VisualChildren`是假設性的屬性，您的項目可能會定義為了列舉其內容;<xref:System.Windows.UIElement>未定義內容的集合在這個層級中，WPF 架構層級架構會延後內容的行為，例如特定的控制項或控制項基底類別的衍生項目。  
  
 [!code-csharp[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementarrangeoverride)]
 [!code-vb[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementarrangeoverride)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您正在開發的 WPF 核心層級的項目，您應該覆寫此方法，讓您的 WPF 核心層級項目唯一排列版面配置行為，或進行適當的版面配置決策的相關元素的子項目。 覆寫可能會需要這些子項目不是從已定義的模式可辨識這類<see cref="T:System.Windows.Controls.ItemCollection" />。  
  
父項目必須呼叫類別的特定<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上每個子項目，否則這些子項目不會轉譯。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>針對這個項目之指定的動畫屬性，開始播放動畫。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">要顯示動畫的屬性，該屬性會指定為相依性屬性識別項。</param>
        <param name="animation">啟動動畫的時刻表。</param>
        <summary>針對這個項目之指定的動畫屬性，開始播放動畫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您檢查是否建立屬性的動畫時，請注意，動畫會開始被視為轉譯之外的非動畫的起始點的第一個框架時以動畫顯示。  
  
 如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>for`animation`是`null`，然後會移除任何目前動畫，並保留屬性的目前值。  
  
 如果整個`animation`值是`null`、 從屬性中移除所有動畫和屬性值還原為其基底值。 不過，原先相關聯的動畫時間軸不會停止。 指派給該時間軸中的任何其他動畫都會繼續執行。  
  
   
  
## Examples  
 下列範例會建立動畫、 指派，，然後呼叫<xref:System.Windows.UIElement.BeginAnimation%2A>啟動它。  
  
 [!code-csharp[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#beginanimation)]
 [!code-vb[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#beginanimation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">要顯示動畫的屬性，該屬性會指定為相依性屬性識別項。</param>
        <param name="animation">套用動畫的時刻表。</param>
        <param name="handoffBehavior">一個列舉值，這個值指定新的動畫如何與已經影響屬性值的任何目前 (執行中) 動畫互動。</param>
        <summary>針對此項目上指定的動畫屬性啟動特定動畫，且可以選擇指定如果屬性已經有執行中的動畫時會發生何種情況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您檢查是否建立屬性的動畫時，請注意，動畫會開始被視為轉譯之外的非動畫的起始點的第一個框架時以動畫顯示。  
  
 如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>for`animation`是`null`，然後會移除任何目前動畫，並保留屬性的目前值。  
  
 如果整個`animation`值是`null`、 從屬性中移除所有動畫和屬性值還原為其基底值。 不過，原先相關聯的動畫時間軸不會停止。 指派給該時間軸中的任何其他動畫都會繼續執行。  
  
   
  
## Examples  
 下列範例會從一個資源，然後呼叫取得現有動畫的處理常式<xref:System.Windows.UIElement.BeginAnimation%2A>與指定的遞移式行為。  
  
 [!code-csharp[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/csharp/VS_Snippets_Wpf/BrushesIntroduction/CSharp/SampleViewer.xaml.cs#beginanimationhandoff)]
 [!code-vb[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BrushesIntroduction/visualbasic/sampleviewer.xaml.vb#beginanimationhandoff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.UIElement.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定直接套用至此元素呈現內容的點陣圖效果。  這是相依性屬性。</summary>
        <value>要套用的點陣圖效果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Effects.BitmapEffect> 是抽象類型，因此[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用方式必須實作的衍生的類別的<xref:System.Windows.Media.Effects.BitmapEffect>，例如<xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>。 實作一個衍生類別的附註是集合型別，可讓您指定多個循序<xref:System.Windows.Media.Effects.BitmapEffect>，使用巢狀的標記語法。  
  
 目前沒有衍生的類別<xref:System.Windows.Media.Effects.BitmapEffect>支援的型別轉換子，所以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您使用這個屬性的語法通常是屬性元素語法。  
  
<a name="dependencyPropertyInfo_BitmapEffect"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.BitmapEffectProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會設定點陣圖效果，使用<xref:System.Windows.Media.Effects.BlurBitmapEffect>。  
  
 [!code-csharp[EffectsGallery_snip#CodeBehindBlurCodeBehindExampleInline](~/samples/snippets/csharp/VS_Snippets_Wpf/EffectsGallery_snip/CSharp/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.UIElement.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定直接套用至此元素呈現內容的點陣圖效果輸入來源。  這是相依性屬性。</summary>
        <value>點陣圖效果的來源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BitmapEffectInput"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInputProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectInputProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectInputProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectInputProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectInputProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.BitmapEffectInput" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.BitmapEffect" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.UIElement.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.UIElement" /> 的快取表示。</summary>
        <value>保存 <see cref="T:System.Windows.Media.CacheMode" /> 之快取表示的 <see cref="T:System.Windows.UIElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Windows.UIElement.CacheMode%2A>屬性，當您需要增加很多時間來呈現內容的效能。 如需詳細資訊，請參閱<xref:System.Windows.Media.BitmapCache>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Media3D.Viewport2DVisual3D.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="CacheModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.CacheModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.CacheModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.CacheMode" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="uIElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試強制將滑鼠的捕捉給這個項目。</summary>
        <returns>如果成功捕捉到滑鼠則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要擷取項目必須先啟用。 檢查是否<xref:System.Windows.UIElement.IsEnabled%2A>已`true`之前先呼叫<xref:System.Windows.UIElement.CaptureMouse%2A>。  
  
 如果呼叫<xref:System.Windows.UIElement.CaptureMouse%2A>會傳回`true`，然後<xref:System.Windows.UIElement.IsMouseCaptured%2A>也是`true`。  
  
 如果呼叫<xref:System.Windows.UIElement.CaptureMouse%2A>傳回`true`，則<xref:System.Windows.UIElement.GotMouseCapture>並<xref:System.Windows.UIElement.IsMouseCapturedChanged>引發事件，與<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>事件中的項目報告資料其中<xref:System.Windows.UIElement.CaptureMouse%2A>呼叫方法。 如果您強制擷取時，您可能會干擾現有的擷取-特別是使用與拖曳和置放滑鼠的擷取。  
  
 若要清除滑鼠捕捉，從所有的項目，請呼叫<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>具有`element`提供的參數`null`。  
  
   
  
## Examples  
 下列範例會實作一組處理常式的滑鼠和輸入的按鍵組合的滑鼠捕捉 （和釋放），並啟用檢視 3D 模型的特殊滑鼠模式。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="uIElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試強制將手寫筆的捕捉給這個項目。</summary>
        <returns>如果成功捕捉到手寫筆則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一律根據基礎的預設手寫筆裝置的預設實作會傳回`true`。 不過，如果您要擴充提供輸入系統的裝置實作的輸入的裝置，就可以建立一個系統可能會傳回不同結果的替代的手寫筆裝置實作。  
  
 元素擷取手寫筆，當它收到手寫筆輸入，即使手寫筆位於其範圍外也一樣。 要捕捉手寫筆通常只會在拖放作業期間。  
  
 呼叫這個方法會呼叫基礎靜態<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。 實際擷取行為被藉由使用中的手寫筆裝置實作。  
  
 若要擷取項目必須先啟用。 檢查是否<xref:System.Windows.UIElement.IsEnabled%2A>已`true`傳回才能呼叫<xref:System.Windows.UIElement.CaptureStylus%2A>。  
  
 如果呼叫<xref:System.Windows.UIElement.CaptureStylus%2A>會傳回`true`，<xref:System.Windows.UIElement.IsStylusCaptured%2A>也是`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要擷取的裝置。</param>
        <summary>嘗試強制將觸控擷取至這個項目。</summary>
        <returns>如果指定的觸控已擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.CaptureTouch%2A> 會傳回`false`如果<xref:System.Windows.Input.TouchDevice>目前擷取至另一個項目。  
  
 如果<xref:System.Windows.UIElement.CaptureTouch%2A>會傳回`true`，然後在<xref:System.Windows.UIElement.GotTouchCapture>就會引發事件。  
  
 若要釋放的單一觸控從這個項目擷取，請使用<xref:System.Windows.UIElement.ReleaseTouchCapture%2A>方法並指定要釋放的觸控裝置。 若要釋放所有修飾，從這個項目，請使用<xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.UIElement.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來定義項目內容外框的幾何。  這是相依性屬性。</summary>
        <value>用於裁剪區域大小的幾何。 預設值為 null <see cref="T:System.Windows.Media.Geometry" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呈現的版面配置中，會以視覺化方式裁剪幾何以外的項目。 幾何沒有為矩形。  
  
<a name="dependencyPropertyInfo_Clip"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ClipProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 此範例示範如何定義架構元素<xref:System.Windows.UIElement.Clip%2A>區域。 若要定義剪輯，請使用<xref:System.Windows.Media.Geometry>(例如<xref:System.Windows.Media.EllipseGeometry>若要設定的項目<xref:System.Windows.UIElement.Clip%2A>屬性。 在幾何區域內的區域會顯示。  
  
 下列範例所示<xref:System.Windows.Controls.Image>元素若沒有定義之裁剪區域。 因為未不定義任何的裁剪區域，則會顯示整個影像。  
  
 [!code-xaml[ClipPathExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#2)]  
  
 ![套用裁剪區域之前的物件](~/add/media/mil-task-clip-region-noclip.png "之前套用裁剪區域的物件")  
使用任何的裁剪區域的映像  
  
 在下一個範例中，會建立相同的映像，不同之處在於其定義之裁剪區域。 只有在區域內的影像部分<xref:System.Windows.Media.EllipseGeometry>隨即出現。  
  
 [!code-xaml[ClipPathExample#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#4)]  
  
 ![裁剪後的物件](~/add/media/mil-task-clip-region-ellispe.PNG "裁剪後的物件")  
橢圓形的裁剪區域的映像  
  
 下列範例示範如何以動畫顯示架構元素的<xref:System.Windows.UIElement.Clip%2A>區域。 在此範例中，<xref:System.Windows.Media.EllipseGeometry>用來定義橢圓形的裁剪區域<xref:System.Windows.Controls.Image>項目。 A<xref:System.Windows.Media.Animation.PointAnimation>繪製橢圓形幾何<xref:System.Windows.Media.EllipseGeometry.Center%2A>屬性從 （0，0） 到 （200，150）。 動畫開始播放後的映像載入，並不斷重複。  
  
 [!code-xaml[ClipPathExample#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#5)]  
  
 如需完整的範例，請參閱[裁剪區域範例](https://msdn.microsoft.com/library/83043a0b-f824-445f-9675-103280c5ca67)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="ClipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Clip" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBounds">
      <MemberSignature Language="C#" Value="public bool ClipToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipToBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.ClipToBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property ClipToBounds As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ClipToBounds { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ClipToBounds : bool with get, set" Usage="System.Windows.UIElement.ClipToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定是否裁剪此元素 (或來自此元素的子元素) 的內容，以符合容器元素大小的值。   這是相依性屬性。</summary>
        <value>如果應該裁剪內容即為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子項目的<xref:System.Windows.UIElement.ClipToBounds%2A>有不同的效果，在版面配置行為，取決於是否的高度和寬度的父項目也就決定所<xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A>或是<xref:System.Windows.FrameworkElement.MaxHeight%2A>  /  <xref:System.Windows.FrameworkElement.MaxWidth%2A>. <xref:System.Windows.FrameworkElement.MaxHeight%2A> / <xref:System.Windows.FrameworkElement.MaxWidth%2A> 父元素的值為何會一律遵守<xref:System.Windows.UIElement.ClipToBounds%2A>和有效的裁剪一律會裁剪內容，根據這些最大值。 家長<xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A>設定將不會裁剪內容時<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`，但會將裁剪內容 if<xref:System.Windows.UIElement.ClipToBounds%2A>是`true`。  
  
 請注意，預設為`false`是一般的行為，因為在實作<xref:System.Windows.UIElement>類別。 您可針對任何指定的項目衍生自<xref:System.Windows.UIElement>覆寫這個屬性預設為該執行個體中的相依性屬性中繼資料`true`改。 數個現有的衍生的類別覆寫此中繼資料及/或調整相依性屬性預設值。  
  
 <xref:System.Windows.Controls.InkCanvas><xref:System.Windows.Controls.InkPresenter>，並<xref:System.Windows.Controls.Primitives.Popup>每個覆寫這個預設值為`true`。  
  
 <xref:System.Windows.FrameworkElement> 覆寫這個相依性屬性的中繼資料。 具體而言，<xref:System.Windows.FrameworkElement>指定此屬性，以允許屬性值繼承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`中繼資料中)。 在此內容中的屬性值繼承表示，如果有任何其他值的子項目<xref:System.Windows.UIElement.ClipToBounds%2A>指派透過本機值或最接近的父項目的值，與指派 （同樣地，無論是在樣式中，依預設此值的樣式值，或在本機值)，然後從父元素的值會指派給所有未指派的子項目，屬性系統。 實際上這表示您可以指定是否要在根項目，允許裁剪界限，並將它做為值將會傳播至所有子項目具有不是明確地指派`false`。  
  
<a name="dependencyPropertyInfo_ClipToBounds"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ClipToBoundsProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ClipToBoundsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipToBoundsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipToBoundsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipToBoundsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipToBoundsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.ClipToBounds" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.UIElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個項目關聯的 <see cref="T:System.Windows.Input.CommandBinding" /> 物件集合。 <see cref="T:System.Windows.Input.CommandBinding" /> 會啟用此項目的命令處理，並宣告命令、其事件及此項目所附加之處理常式之間的連結。</summary>
        <value>所有 <see cref="T:System.Windows.Input.CommandBinding" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的另一種方式填入<xref:System.Windows.UIElement.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以程式設計的方式。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  
  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreCommandBindings*  
 一或多個<xref:System.Windows.Input.CommandBinding>項目。 每一種應有<xref:System.Windows.Input.CommandBinding.Command%2A>屬性設為已知的命令，並針對設定屬性<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>處理常式實作。 如需詳細資訊，請參閱<xref:System.Windows.Input.CommandBinding>。  
  
   
  
## Examples  
 下列範例會將<xref:System.Windows.Input.CommandBinding>使用標記的視窗。 請注意，在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，則<xref:System.Windows.Input.CommandBindingCollection>當做項目; 標記中未宣告的集合物件由屬性接受的類型推斷並填入屬性項目，一或多個<xref:System.Windows.Input.CommandBinding>項目：  
  
 [!code-xaml[commandWithHandler#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 如需詳細資訊[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法的集合，請參閱[XAML 語法詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。  
  
 下列範例會執行程式碼基本上是相同的動作：  
  
 [!code-csharp[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DesiredSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size DesiredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size DesiredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.DesiredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DesiredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size DesiredSize { System::Windows::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DesiredSize : System.Windows.Size" Usage="System.Windows.UIElement.DesiredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個項目在版面配置處理序的測量傳遞期間所計算的大小。</summary>
        <value>成為排列傳遞所需大小的計算大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值才會有效度量如果的值<xref:System.Windows.UIElement.IsMeasureValid%2A>屬性是`true`。  
  
 <xref:System.Windows.UIElement.DesiredSize%2A> 當其中一個度量因素，當您實作版面配置行為覆寫這類，通常會檢查<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>， <xref:System.Windows.FrameworkElement.MeasureOverride%2A>，或<xref:System.Windows.UIElement.OnRender%2A>(在<xref:System.Windows.UIElement.OnRender%2A>情況下，您可以檢查<xref:System.Windows.UIElement.RenderSize%2A>相反的但這取決於您實作）。 根據案例中，<xref:System.Windows.UIElement.DesiredSize%2A>可能會完全遵守您的實作邏輯，條件約束上<xref:System.Windows.UIElement.DesiredSize%2A>可能會套用，以及這類條件約束也可能會變更其他特性的父項目或子項目。 例如，支援可捲動區域 （卻選擇不是衍生自已經啟用 可捲動區域的 WPF 架構層級控制項） 的控制項無法比較可用的大小，以<xref:System.Windows.UIElement.DesiredSize%2A>。 控制項接著可以將設定內部狀態的啟用中的捲軸[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]該控制項。 或者，<xref:System.Windows.UIElement.DesiredSize%2A>可能會造成在某些情況下也會忽略。  
  
   
  
## Examples  
 下列範例所示<xref:System.Windows.UIElement.DesiredSize%2A>一部分<xref:System.Windows.FrameworkElement.MeasureOverride%2A>實作。 請注意如何<xref:System.Windows.UIElement.Measure%2A>呼叫之前取得<xref:System.Windows.UIElement.DesiredSize%2A>。 這可確保<xref:System.Windows.UIElement.DesiredSize%2A>保留的合法值。  
  
 [!code-cpp[PlotPanel#2](~/samples/snippets/cpp/VS_Snippets_Wpf/PlotPanel/CPP/PlotPanel.cpp#2)]
 [!code-csharp[PlotPanel#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PlotPanel/CSharp/PlotPanel.cs#2)]
 [!code-vb[PlotPanel#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PlotPanel/VisualBasic/PlotPanel.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.DragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.DragEnterEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewDragEnter>。  
  
-   覆寫<xref:System.Windows.UIElement.OnDragEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.DragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本項目中建立的別名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.DragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.DragLeaveEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.DragDrop.PreviewDragLeave>。  
  
-   覆寫<xref:System.Windows.UIElement.OnDragLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.DragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使拖曳來源中項目範圍，就會發生此事件。 如果拖曳開始界限之外，然後將移內，也會引發這個事件，以及<xref:System.Windows.UIElement.DragEnter>和相關預覽事件。  
  
 本項目中建立的別名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.DragOver>事件會附加至基礎<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.DragOverEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.DragDrop.PreviewDragOver>。  
  
-   覆寫<xref:System.Windows.UIElement.OnDragOver%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.DragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本項目中建立的別名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.Drop?displayProperty=nameWithType>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.Drop>事件會附加至基礎<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.DropEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewDrop>。  
  
-   覆寫<xref:System.Windows.UIElement.OnDrop%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.Drop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.UIElement.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要套用至 <see cref="T:System.Windows.UIElement" /> 的點陣圖效果。 這是相依性屬性。</summary>
        <value>表示點陣圖效果的 <see cref="T:System.Windows.Media.Effects.Effect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.UIElement.Effect%2A>屬性，將套用至點陣圖效果<xref:System.Windows.UIElement>。  
  
<a name="dependencyPropertyInfo_Effect"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.EffectProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列 XAML 示範如何指派自訂<xref:System.Windows.Media.Effects.ShaderEffect>至<xref:System.Windows.UIElement.Effect%2A>屬性。  
  
 [!code-xaml[System.Windows.Media.Effects.ShaderEffect#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="EffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.EffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.EffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Effect" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="uIElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試將焦點設定至此項目。</summary>
        <returns>如果邏輯與鍵盤焦點設定至此項目，則為 <see langword="true" />，如果只有邏輯焦點設為此項目，或是呼叫此方法並未強制焦點變更，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要可設定焦點，<xref:System.Windows.UIElement.Focusable%2A>並<xref:System.Windows.UIElement.IsEnabled%2A>兩者都必須是`true`。  
  
 即使項目是可設定焦點且有效的`Focus`預覽事件可能會處理在特定的樹狀目錄中，並著重於該項目可能不允許 （例如，在複合控制項）。
在此情況下，這個方法會傳回`false`。
 
 一般情況下，焦點會受到兩個不同的概念︰ 鍵盤焦點和邏輯焦點。 這兩個概念並不一定相同。 如需詳細資訊，請參閱 <<c0> [ 焦點摘要](~/docs/framework/wpf/advanced/focus-overview.md)並[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。
 
 如果呼叫<xref:System.Windows.UIElement.Focus%2A>會傳回`true`，<xref:System.Windows.UIElement.IsKeyboardFocused%2A>並<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>還有`true`。  
  
 如果相關的屬性尚未存在`true`，當您呼叫<xref:System.Windows.UIElement.Focus%2A>，以下列順序引發一或多個下列事件： <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>， <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> （來源為新的焦點目標）， <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>， <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>，<xref:System.Windows.UIElement.LostKeyboardFocus>， <xref:System.Windows.UIElement.GotKeyboardFocus> （來源為新的焦點目標）。  
  
 為了讓這個呼叫才會成功，應用程式中的某個其他項目需要先前擁有焦點。  
  
   
  
## Examples  
 下列範例會將焦點設<xref:System.Windows.Controls.TextBox>所參考<xref:System.Windows.FrameworkElement.Name%2A>，然後調整游標的位置內<xref:System.Windows.Controls.TextBox>。  
  
 [!code-csharp[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBox_CursorToEnd/CSharp/Window1.xaml.cs#uielementfocus)]
 [!code-vb[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBox_CursorToEnd/VisualBasic/Window1.xaml.vb#uielementfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.UIElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素是否能夠接收焦點的值。  這是相依性屬性。</summary>
        <value>如果這個項目為可設定焦點，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有具有焦點的項目收到鍵盤輸入。  
  
 <xref:System.Windows.UIElement.Focusable%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]屬性存取子是相依性屬性。 這個特定的相依性屬性很通常會有衍生的項目類別，尤其是在控制項中以不同方式設定其明顯的 「 預設 」 值。 這通常是在兩種方式之一：  
  
-   相依性屬性繼承自特定的衍生類別，但是，衍生類別覆寫相依性屬性中繼資料，並變更屬性的預設值。  
  
-   樣式或範本套用到元素，它會以不同的方式設定該相依性屬性值。  
  
 比方說，明顯 「 預設 」 的<xref:System.Windows.UIElement.Focusable%2A>for<xref:System.Windows.Controls.Button>控制項將會是`true`，即使<xref:System.Windows.Controls.Button>繼承<xref:System.Windows.UIElement.Focusable%2A>作為[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]屬性，直接從<xref:System.Windows.UIElement>。 這是因為套用的中繼資料值<xref:System.Windows.UIElement.Focusable%2A>內的靜態建構函式已遭覆寫相依性屬性<xref:System.Windows.Controls.Control>基底類別，之間平均分攤工作量<xref:System.Windows.Controls.Button>和<xref:System.Windows.UIElement>類別階層架構中。  
  
 當繼承<xref:System.Windows.Controls.Control>或其衍生的類別，<xref:System.Windows.Controls.Control>重新定義預設值，這個屬性是`true`。  
  
 當繼承<xref:System.Windows.Controls.Label>(即<xref:System.Windows.Controls.Control>衍生類別)，預設值一次重新定義為`false`。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.FocusableProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例程式碼說明特定的自訂控制項，它會設定控制項樣板<xref:System.Windows.UIElement.Focusable%2A>`false`上其中一個範本內的項目。  
  
 [!code-xaml[RichTextBox_NoScrollViewer#_ControlTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/CS/window1.xaml#_controltemplate)]
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當衍生自<see cref="T:System.Windows.UIElement" />直接 (而不是從<see cref="T:System.Windows.Controls.Control" />)，請考慮您是否希望是可設定焦點，因為預設項目可焦點化項目。 如果您希望您可設定焦點的項目時，覆寫此屬性類型的靜態建構函式內的中繼資料，如下所示： 
[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)] 
其中<paramref name="myElement" />應該是您會在覆寫中繼資料值類型的類別名稱。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.UIElement.Focusable" /> 屬性的值變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Focusable" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="uIElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要檢查的相依性屬性。</param>
        <summary>傳回這個項目上指定屬性的基底屬性值，不管任何執行中的可能動畫值，或停止動畫。</summary>
        <returns>屬性值，就好像指定的相依性屬性未附加任何動畫。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未不附加任何動畫屬性，則<xref:System.Windows.UIElement.GetAnimationBaseValue%2A>傳回值一定是相同<xref:System.Windows.DependencyObject.GetValue%2A>傳回值。 如果有附加的動畫，然後所有可能的動畫衍生值包括 開始和停止值會被忽略，而且屬性的值取決於所有可能的輸入。 如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
   
  
## Examples  
 下列範例會報告動畫的基底值的處理常式<xref:System.Windows.FrameworkElement.Width%2A>屬性上的<xref:System.Windows.Controls.Button>，以及轉換的基底值。  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalue)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="abstract member GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry&#xA;override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="uIElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">由項目提供的可用大小。</param>
        <summary>如果 <see cref="P:System.Windows.UIElement.ClipToBounds" /> 設定為 <see langword="true" />，則傳回表示所要裁剪之區域的替代裁剪幾何。</summary>
        <returns>可能的裁剪幾何。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回合法的值，但不會使用`layoutSlotSize`其計算中的參數。 它會改為使用值<xref:System.Windows.UIElement.RenderSize%2A>。  
  
 本質上覆寫此方法由立即衍生<xref:System.Windows.FrameworkElement>類別，而<xref:System.Windows.FrameworkElement>覆寫會產生更複雜的行為，一般的 WPF 架構層級項目。 如需詳細資訊，請參閱 <xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="uIElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>當在衍生類別中覆寫時，如果沒有視覺化父項目存在，則會為這個項目傳回替代的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父項目。</summary>
        <returns>一個物件，如果衍生類別的實作有替代父代連接要報告。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設虛擬實作這個方法會傳回`null`。 <xref:System.Windows.FrameworkElement> 提供實用的實作。  
  
 替代的父代是用於事件的路由，在其中項目會建立替代父結構，讓它的事件會路由傳送分離至標準的父代，則視覺樹狀結構路由傳送的標準模式的方式的情況下則會在向下預覽路由策略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下牽涉此元素的拖放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.GiveFeedback>事件允許來源修改滑鼠指標外觀，以便將使用者的視覺化回饋提供拖放作業期間的拖曳事件。 視覺化回饋強調拖放作業正在處理中。  
  
 本項目中建立的別名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.GiveFeedback>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.GiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GiveFeedbackEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewGiveFeedback>。  
  
-   覆寫<xref:System.Windows.UIElement.OnGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素取得邏輯焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的方法呼叫刻意強制焦點，但存在於不同範圍的上一個鍵盤焦點，則邏輯焦點與鍵盤焦點。 在此案例中，鍵盤焦點會維持其所在和項目其中<xref:System.Windows.UIElement.Focus%2A>方法呼叫仍取得邏輯焦點。  
  
 此事件的更精確地解譯時，就是引發時間的值<xref:System.Windows.UIElement.IsFocused%2A>路由的項目屬性變更時，從`false`來`true`。  
  
 此事件會使用事件反昇的路由，因為接收焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GotFocusEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
-   沒有任何對應的通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnGotFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 是類似的事件追蹤會維護項目中; 的焦點狀態的屬性中的狀態變更<xref:System.Windows.UIElement.GotKeyboardFocus>的許多相同的情況下，就會引發事件。  
  
 此事件會使用事件反昇的路由，因為具有焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際擁有焦點的項目中。  
  
 本項目中建立的別名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.GotKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.GotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement.OnGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素擷取滑鼠時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素擷取滑鼠，當它收到滑鼠輸入，即使滑鼠指標位於其範圍外也一樣。 滑鼠通常只會在拖放作業期間擷取，直到擷取拖放作業的拖放動作，就會發生。  
  
 此事件會使用事件反昇的路由，因為已擷取的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>在事件資料，以判斷實際項目具有滑鼠擷取。  
  
 本項目中建立的別名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.GotMouseCapture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.GotMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   沒有任何已定義的對應通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnGotMouseCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GotMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素擷取手寫筆時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素擷取手寫筆，當它收到手寫筆輸入，即使在指標位於其範圍外也一樣。 手寫筆通常只會在拖放作業期間擷取，並且保持擷取，直到拖放作業的拖放動作發生為止。  
  
 此事件會使用事件反昇的路由，因為已擷取的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷已擷取的實際項目中。  
  
 此事件會建立這個類別的附加事件的別名，讓<xref:System.Windows.UIElement.GotStylusCapture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.GotStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   沒有任何已定義的對應通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnGotStylusCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GotStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控擷取至這個項目時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement.OnGotTouchCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.GotTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.UIElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此項目是否有任何動畫屬性。</summary>
        <value>如果這個項目有附加至其任一屬性的動畫則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`持續性 （unclocked，一律執行） 的動畫，或有特定的時間軸的動畫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property HasEffectiveKeyboardFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HasEffectiveKeyboardFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEffectiveKeyboardFocus : bool" Usage="System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Windows.UIElement" /> 是否具有焦點。</summary>
        <value>如果 <see cref="T:System.Windows.UIElement" /> 具有焦點，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子類別可以覆寫這個屬性來指定項目有鍵盤焦點時。  這很有用，當您<xref:System.Windows.UIElement>包含可以有鍵盤焦點的項目和您希望它具有焦點的報表項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>實作 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> 以提供基底項目點擊測試行為。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">描述要執行的點擊測試，包括初始點擊點。</param>
        <summary>實作 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />以提供基底項目點擊測試行為 (傳回 <see cref="T:System.Windows.Media.GeometryHitTestResult" />)。</summary>
        <returns>測試的結果，包括已評估的幾何。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱原始虛擬方法<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>有關進一步覆寫這個方法在衍生類別。 請注意，數個特定的控制項 (<xref:System.Windows.Controls.TextBlock>，例如) 有不同的實作，覆寫它。  
  
 這個方法不是從您的應用程式程式碼呼叫。 這個方法支援 （不論項目，例如滑鼠指標位於），由輸入系統的各個層面的內部點擊測試行為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">描述要執行的點擊測試，包括初始點擊點。</param>
        <summary>實作 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />以提供基底項目點擊測試行為 (傳回 <see cref="T:System.Windows.Media.HitTestResult" />)。</summary>
        <returns>測試結果，包括受評估的點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱原始虛擬方法<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>有關進一步覆寫這個方法在衍生類別。 請注意，數個特定的控制項 (<xref:System.Windows.Controls.TextBlock>，例如) 有不同的實作，覆寫<xref:System.Windows.UIElement.HitTestCore%2A>所定義<xref:System.Windows.UIElement>。  
  
 這個方法不是從您的應用程式程式碼呼叫。 這個方法支援 （不論項目，例如滑鼠指標位於），由輸入系統的各個層面的內部點擊測試行為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.UIElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與此元素關聯的輸入繫結集合。</summary>
        <value>輸入繫結的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入繫結支援命令與輸入裝置繫的結。 比方說，<xref:System.Windows.Input.MouseBinding>實作輸入繫結包含滑鼠裝置特定的屬性。  
  
 輸入繫結的集合會包含屬於此類型的輸入繫結以及宣告執行個體的輸入繫結。  
  
 相關的屬性， <xref:System.Windows.UIElement.CommandBindings%2A>，維護命令繫結的集合。 這些不同於輸入繫結，因為它們代表的下一個層級的命令處理動作繫結至已知的命令所示。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  
  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreInputBindings*  
 一或多個<xref:System.Windows.Input.InputBinding>項目 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>衍生的類別)。 每一種應該要有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>屬性設定。  
  
   
  
## Examples  
 下列範例會填入這個屬性上<xref:System.Windows.Window>，以單一<xref:System.Windows.Input.KeyBinding>。  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 如需詳細資訊[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法的集合，請參閱[XAML 語法詳細資料](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InputHitTest">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.IInputElement InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::IInputElement ^ InputHitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.InputHitTest : System.Windows.Point -&gt; System.Windows.IInputElement" Usage="uIElement.InputHitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">這個項目內的位移 (Offset) 座標。</param>
        <summary>在目前項目範圍中傳回的輸入項目，輸入項目位在相對於目前項目原點的指定座標。</summary>
        <returns>位在指定位置的項目子系。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IInputElement> 因為該型別是兩者的通用介面，會將傳回的型別，以傳回<xref:System.Windows.UIElement>和<xref:System.Windows.ContentElement>。 您可以再適當地轉型傳回型別或用於特定成員所定義的介面執行個體<xref:System.Windows.IInputElement>介面。  
  
 呼叫這個方法通常是未從您的應用程式程式碼。 呼叫這個方法才適用，如果您想要重新實作大量的低層級的輸入功能已存在，例如重新建立滑鼠裝置的邏輯。  
  
 <xref:System.Windows.IContentHost> 合約<xref:System.Windows.IContentHost.InputHitTest%2A>具有相同的簽章，某些項目選擇明確實作的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateArrange">
      <MemberSignature Language="C#" Value="public void InvalidateArrange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateArrange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateArrange" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateArrange ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateArrange();" />
      <MemberSignature Language="F#" Value="member this.InvalidateArrange : unit -&gt; unit" Usage="uIElement.InvalidateArrange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使項目的排列狀態 (配置) 失效。 失效之後，項目將更新其配置，而且，除非之後由 <see cref="M:System.Windows.UIElement.UpdateLayout" /> 強制執行，否則這項作業會以非同步方式發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 經常呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>或在特定<xref:System.Windows.UIElement.UpdateLayout%2A>有顯著的效能結果。 因此，除非您絕對需要精確的配置狀態的其他後續呼叫，呼叫這個方法來避免[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]程式碼中。 進階的案例中，您可能會呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>是如果您要建立<xref:System.Windows.PropertyChangedCallback>相依性屬性不是在<xref:System.Windows.Freezable>或<xref:System.Windows.FrameworkElement>衍生類別，可變更時，仍會影響版面配置的排列傳遞。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateMeasure">
      <MemberSignature Language="C#" Value="public void InvalidateMeasure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateMeasure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateMeasure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateMeasure();" />
      <MemberSignature Language="F#" Value="member this.InvalidateMeasure : unit -&gt; unit" Usage="uIElement.InvalidateMeasure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使項目的測量狀態 (配置) 失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法也呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>就內部而言，就不需要呼叫<xref:System.Windows.UIElement.InvalidateMeasure%2A>和<xref:System.Windows.UIElement.InvalidateArrange%2A>連續。 失效之後的項目會有更新，這會以非同步的方式，除非其配置<xref:System.Windows.UIElement.UpdateLayout%2A>呼叫以強制變更同步的配置。  
  
 WPF 架構層級配置系統會執行它自己的處理項目的視覺化樹狀結構中的變更，並在最常見的版面配置失效的情況下版面配置系統會呼叫這個方法時所需的對應項。 如果您要產生完整的版面配置實作，可直接操作或類似的項目樹狀目錄中，進階的案例，才應該呼叫這個方法。 這類進階的案例之一是如果您要建立<xref:System.Windows.PropertyChangedCallback>不在相依性屬性<xref:System.Windows.Freezable>或<xref:System.Windows.FrameworkElement>衍生類別，可變更時，仍會影響版面配置的測量傳遞。  
  
 經常呼叫<xref:System.Windows.UIElement.InvalidateMeasure%2A>或在特定<xref:System.Windows.UIElement.UpdateLayout%2A>有顯著的效能結果。 因此，除非您絕對需要精確的配置狀態的其他後續呼叫，呼叫這個方法來避免[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]程式碼中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateVisual">
      <MemberSignature Language="C#" Value="public void InvalidateVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateVisual() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateVisual" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateVisual ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateVisual();" />
      <MemberSignature Language="F#" Value="member this.InvalidateVisual : unit -&gt; unit" Usage="uIElement.InvalidateVisual " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓項目的呈現失效，並強制全新的配置傳遞。 完成配置循環之後，會呼叫 <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>內部。  
  
 從您的應用程式程式碼不通常呼叫這個方法。 WPF 架構層級配置系統它自己的變更項目的視覺化樹狀結構中的處理作業，並會呼叫這個方法時所需的對等項目已經。 呼叫這個方法就只需要進階的案例。 這類進階的案例之一是如果您要建立<xref:System.Windows.PropertyChangedCallback>不在相依性屬性<xref:System.Windows.Freezable>或<xref:System.Windows.FrameworkElement>衍生的變更時，仍會影響版面配置的類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
      </Docs>
    </Member>
    <Member MemberName="IsArrangeValid">
      <MemberSignature Language="C#" Value="public bool IsArrangeValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArrangeValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsArrangeValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArrangeValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArrangeValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArrangeValid : bool" Usage="System.Windows.UIElement.IsArrangeValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示在此項目之配置中子項目的計算大小和位置是有效的。</summary>
        <value>如果配置的大小和位置有效則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以強制透過呼叫是即將失效的排列方式<xref:System.Windows.UIElement.InvalidateArrange%2A>這個項目 （或其父代）。 At 次例如版面配置系統決定，這會標幟重新撰寫的配置。 或者，若要立即呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>無法進行，但這應該只完成當確定任何進一步的失效是暫止 （大量不必要地強制更新會影響效能）。  
  
 <xref:System.Windows.UIElement.IsArrangeValid%2A> 不能`true`除非<xref:System.Windows.UIElement.IsMeasureValid%2A>還有`true`（版面配置處理序中的排列方式不能有效而不需要先在 有效的度量單位）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
        <altmember cref="P:System.Windows.UIElement.IsMeasureValid" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.UIElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中是否已啟用這個項目。  這是相依性屬性。</summary>
        <value>如果啟用這個項目，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意這個屬性會受到特定類別的實作<xref:System.Windows.UIElement.IsEnabledCore%2A>上特定的項目，通常在執行階段。 因此，此處所列的預設值有時不是有效。 比方說，<xref:System.Windows.Controls.Primitives.ScrollBar>將會<xref:System.Windows.UIElement.IsEnabled%2A>`false`只要確定沒有不需要支援捲軸。 嘗試設定這個值會也可能會覆寫所傳回的值<xref:System.Windows.UIElement.IsEnabledCore%2A>。  
  
 未啟用的項目不會參與點擊測試或焦點，因此不可能會輸入事件的來源。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsEnabledProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例顯示處理常式上一個 按鈕時執行將會設定<xref:System.Windows.UIElement.IsEnabled%2A>`false`另一個具名的按鈕上`b1`。  
  
 [!code-csharp[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/CSharp/default.xaml.cs#handler)]
 [!code-vb[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/VisualBasic/default.xaml.vb#handler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsEnabled" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.UIElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會成為衍生類別中 <see cref="P:System.Windows.UIElement.IsEnabled" /> 的傳回值。</summary>
        <value>如果啟用這個項目，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>這個屬性的預設實作會快取的值，並也會計算這個項目的父項目是否已啟用。 (如果未啟用父代，不能在實際有效地啟用的子項目[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果您選擇覆寫這個實作，請確定您呼叫以保留此行為的基底實作。  
  
<see cref="T:System.Windows.Controls.Primitives.ScrollBar" />類別會提供這個屬性的現有覆寫實作。 此覆寫會決定內容的呈現區域內的內容是否超過可用的區域。 如果內容未超出區域，已啟用捲軸的部分。 否則，不會啟用捲軸。</para></block>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsEnabled" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.UIElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，決定這個項目是否具有邏輯焦點。  這是相依性屬性。</summary>
        <value>如果這個項目具有邏輯焦點，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某個應用程式多個焦點分區，例如功能表內容和應用程式的其餘部分之間，可能會與鍵盤焦點不同邏輯焦點。 在此案例中，鍵盤焦點都只能有一個應用程式的 UI 項目上，不過，其他焦點分割中的特定項目可能仍會保有邏輯焦點。 如需有關邏輯焦點的詳細資訊，請參閱 <<c0> [ 焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)。  
  
 您未設定這個屬性 （它是唯讀） 設定焦點。 這個屬性的一般用法是做為相依性屬性<xref:System.Windows.Setter>或<xref:System.Windows.EventTrigger>。 若要以程式設計方式設定焦點，呼叫<xref:System.Windows.UIElement.Focus%2A>。 由使用者動作或控制項實作，可能會包含滑鼠捕捉的行為，也可以設定焦點。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsFocusedProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會變更控制項的背景，當它為焦點時的程式碼處理常式。  
  
 [!code-csharp[PopupSimple#IsFocused](~/samples/snippets/csharp/VS_Snippets_Wpf/PopupSimple/CSharp/Window1.xaml.cs#isfocused)]  
  
 若要達成此相同的效果的另一個常見方法是將放<xref:System.Windows.Trigger>在<xref:System.Windows.Style>控制項之這種方法不需要處理程式碼後置的特定事件，而且可讓設計工具的互動式和圖形化性質更大的存取[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 如需範例，請參閱[如何：建立外光暈效果](https://msdn.microsoft.com/library/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsFocused" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsHitTestVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHitTestVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHitTestVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisible : bool with get, set" Usage="System.Windows.UIElement.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定宣告此元素是否可以從其呈現內容的某些部分傳回，作為點擊測試結果的值。 這是相依性屬性。</summary>
        <value>如果無法從至少一個點將這個項目作為點擊測試結果傳回，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 點擊測試的項目邏輯樹狀結構中的相對位置會影響這個屬性的有效值。 比方說，如果某個元素的子元素的項目，不進行點擊測試顯示，有效子系上的屬性值將會維持`false`，即使試圖將該值設為在本機。 基於這個理由，是很重要，您未設定<xref:System.Windows.UIElement.IsHitTestVisible%2A>至`false`複合控制項上，除非您不想要的任何輸入或點擊測試的控制項。 如需點擊測試的詳細資訊，請參閱[視覺分層中的點擊測試](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsHitTestVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsHitTestVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 相依性屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHitTestVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHitTestVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHitTestVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出輸入法系統 (例如 [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]) 是否已為處理這個項目的輸入而啟用。</summary>
        <value>如果輸入法為使用中，則為 <see langword="true" />；否則為 <see langword="false" />。 基礎附加屬性的預設值為 <see langword="true;" />，不過這會受到輸入法在執行階段的實際狀態所影響。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回值，該附加屬性由<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>針對目前已啟用輸入法 （鍵盤、 語音和其他輸入的裝置）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.UIElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個項目是否具有鍵盤焦點。  這是相依性屬性。</summary>
        <value>如果這個項目具有鍵盤焦點，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 決定的值，這個屬性的變更可能會伴隨著焦點相關的事件。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>常用類別事件處理常式內的其他輸入相關的事件，例如來判斷項目已經有鍵盤焦點，還是要決定當滑鼠事件和鍵盤事件一起出現。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
        <altmember cref="E:System.Windows.UIElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示鍵盤焦點是否在項目或其視覺化樹狀子項目內的任何位置。  這是相依性屬性。</summary>
        <value>如果鍵盤焦點在項目或其子項目上，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性值的變更通常會引發<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>事件，除非在衍生的類別已覆寫<xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A>隱藏的事件。  
  
 您未設定此屬性直接，但您也可以呼叫的項目設定焦點<xref:System.Windows.UIElement.Focus%2A>，或藉由<xref:System.Windows.UIElement.MoveFocus%2A>要求。 這些方法會呼叫其中一種方法可能會變更這個屬性值。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>通常用於類別事件處理常式內其他輸入相關的事件，例如來判斷項目已經有鍵盤焦點，還是要決定當滑鼠事件和鍵盤事件一起出現。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabled">
      <MemberSignature Language="C#" Value="public bool IsManipulationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsManipulationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsManipulationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsManipulationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsManipulationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsManipulationEnabled : bool with get, set" Usage="System.Windows.UIElement.IsManipulationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否在此 <see cref="T:System.Windows.UIElement" /> 上啟用操作事件。</summary>
        <value>如果在這個 <see cref="T:System.Windows.UIElement" /> 上啟用操作事件則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定此屬性設定為 true，如果您想<xref:System.Windows.UIElement>接收<xref:System.Windows.UIElement.ManipulationStarting>， <xref:System.Windows.UIElement.ManipulationStarted>， <xref:System.Windows.UIElement.ManipulationDelta>， <xref:System.Windows.UIElement.ManipulationInertiaStarting>， <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>，和<xref:System.Windows.UIElement.ManipulationCompleted>事件。 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
   
  
## Examples  
 下列範例會建立具有以紅色矩形的應用程式。  <xref:System.Windows.UIElement.IsManipulationEnabled%2A>矩形的屬性設定為 true，且應用程式的視窗訂閱<xref:System.Windows.UIElement.ManipulationStarting>， <xref:System.Windows.UIElement.ManipulationDelta>，和<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。 這個範例是在較大範例的一部分[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
 [!code-xaml[BasicManipulation#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsManipulationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsManipulationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsManipulationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsManipulationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsManipulationEnabled" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMeasureValid">
      <MemberSignature Language="C#" Value="public bool IsMeasureValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMeasureValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMeasureValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMeasureValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMeasureValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMeasureValid : bool" Usage="System.Windows.UIElement.IsMeasureValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示配置測量所傳回的目前大小是否有效。</summary>
        <value>如果配置的測量傳遞傳回有效的目前值則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以強制測量和排列方式是藉由呼叫即將失效<xref:System.Windows.UIElement.InvalidateMeasure%2A>這個項目 （或在視覺樹狀結構的任何父項目）。 這會指定配置重新撰寫以非同步的方式，取決於配置系統一次發生。 或者，您可以在這裡進行的立即呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>。 不過，您應該只呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>如果很可能沒有進一步的失效是暫止 （大量不必要地強制更新會有影響效能）。  
  
 如果<xref:System.Windows.UIElement.IsMeasureValid%2A>已`false`，<xref:System.Windows.UIElement.IsArrangeValid%2A>也必須是`false`（版面配置程序，強制執行邏輯，排列方式不能有效而不需要先在 有效的度量單位）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.UIElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否將滑鼠擷取至這個項目。  這是相依性屬性。</summary>
        <value>如果項目具有滑鼠擷取，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠捕捉狀態與相關程序中的拖放作業。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會根據是否已捕捉滑鼠的項目，開啟或關閉滑鼠捕捉狀態。  
  
 如果滑鼠捕捉是其他位置、 滑鼠捕捉設定為該元素。 如果項目具有滑鼠捕捉時，會藉由呼叫中清除<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>null 輸入。  
  
 [!code-csharp[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseSnippetSample/CSharp/Window1.xaml.cs#ismousecaptured)]
 [!code-vb[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseSnippetSample/visualbasic/window1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值決定滑鼠擷取是由這個項目持有，還是由其視覺化樹狀結構中的子項目持有。 這是相依性屬性。</summary>
        <value>如果這個項目或包含的項目具有滑鼠擷取，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /> 值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出滑鼠指標位置是否與點擊測試結果對應，該結果會將複合項目納入考量。  這是相依性屬性。</summary>
        <value>如果滑鼠指標位於與點擊測試相同的項目結果上方，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Windows.UIElement.IsMouseOver%2A>，這個屬性才`true`如果滑鼠指標位在常值的項目-以用於點擊測試。 如果滑鼠指標位於子系項目上方，特別是項目的一部分的項目更深入的範本和複合 （compositing），這個屬性會是`false`。 除非您知道控制項的複合 （比方說，您使用這個屬性的自訂控制項範本中的控制項，您所定義），這個屬性可能會傳回非預期的結果。 大部分的情況下，您不撰寫控制項，使用<xref:System.Windows.UIElement.IsMouseOver%2A>改。  
  
 如果將滑鼠擷取由這個項目，而且這個屬性為`true`次擷取的詳細資訊，此屬性會繼續傳回`true`直到遺失滑鼠捕捉並的指標不是透過其範圍。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.UIElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出滑鼠指標是否在這個項目上方 (包括視覺化樹狀中的子項目)。  這是相依性屬性。</summary>
        <value>如果滑鼠指標位在這個項目或其子項目上方，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，控制項是複合，使得控制項 （視覺化樹狀結構） 內的各種項目都會報告包含控制項的滑鼠狀態。 例如，<xref:System.Windows.Controls.ListBox>樣式控制項將會報告<xref:System.Windows.UIElement.IsMouseOver%2A>作為`true`如果在滑鼠位於任何地方網格的幾何，包括任何<xref:System.Windows.Controls.ListBoxItem>。  
  
 雖然類似"IsMouseOverChanged 」 事件不存在，便會執行數個類似的事件。 例如，您可以處理<xref:System.Windows.UIElement.MouseEnter>， <xref:System.Windows.UIElement.MouseMove>，和<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>。  
  
 如果此元素擷取滑鼠，這個屬性會保持`true`直到遺失滑鼠捕捉並滑鼠指標離開項目範圍。  
  
 有些控制項刻意擷取將滑鼠停在特定似乎未直接涉及滑鼠的動作。 這可能會導致<xref:System.Windows.UIElement.IsMouseOver%2A>正在`true`即使滑鼠已移動不明顯。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsMouseOverProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會參考這個屬性的屬性型別<xref:System.Windows.Trigger>屬於\<Style.Triggers > 區塊。 如果滑鼠停留在控制項中，控制項的文字會變成藍色，游標會變成手的形狀。  
  
 [!code-xaml[ListViewChkBox#Trigger](~/samples/snippets/csharp/VS_Snippets_Wpf/ListViewChkBox/CS/window1.xaml#trigger)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsMouseOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.UIElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個項目是否擷取手寫筆。  這是相依性屬性。</summary>
        <value>如果項目具有手寫筆擷取，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值決定手寫筆擷取是由這個項目持有，還是由項目範圍及其視覺化樹狀中的項目持有。 這是相依性屬性。</summary>
        <value>如果這個項目或包含的項目具有手寫筆擷取，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 觸控輸入支援在 Windows Vista](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)並[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出手寫筆位置是否與點擊測試結果相對應，該結果會將複合項目納入考量。  這是相依性屬性。</summary>
        <value>如果手寫筆指標的項目結果與點擊測試相同，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Windows.UIElement.IsStylusOver%2A>，這個屬性才`true`如果手寫筆在元素上方。 如果手寫筆改為透過子項目或項目的更深入的複合 （視覺化樹狀結構） 的一部分的項目，這個屬性會是`false`。  
  
 除非您知道控制項的複合 （比方說，您使用這個屬性的自訂控制項範本中的控制項，您所定義），這個屬性可能會傳回非預期的結果。 大部分的情況下，您不撰寫控制項，使用<xref:System.Windows.UIElement.IsStylusOver%2A>改。  
  
 如果這個項目具有手寫筆擷取，而且這個屬性就`true`擷取時，這個屬性會保持`true`直到手寫筆擷取遺失，且其範圍不是手寫筆。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.UIElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出手寫筆游標是否位在這個項目上方 (包括視覺子項目)。  這是相依性屬性。</summary>
        <value>如果手寫筆游標位在項目或其子項目上方，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目具有手寫筆擷取，這個屬性會繼續傳回`true`直到遺失手寫筆捕捉並指標超出其範圍。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsStylusOverProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsStylusOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Windows.UIElement.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個項目在 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中是否可見。  這是相依性屬性。</summary>
        <value>如果項目可見，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 判斷<xref:System.Windows.UIElement.IsVisible%2A>值會將所有版面配置的因素列入考量。 相反地， <xref:System.Windows.UIElement.Visibility%2A>，這是可設定的屬性，只表示可見或不可見，以程式設計的方式讓元素。  
  
 項目所在<xref:System.Windows.UIElement.IsVisible%2A>是`false`參與輸入的事件 （或命令），請執行不影響量值或排列傳遞的版面配置、 不是可設定焦點、 不是在索引標籤順序中，和將不會報告在點擊測試。 相較之下，項目所在<xref:System.Windows.UIElement.IsEnabled%2A>是`false`仍要參與的事件和命令，以及點擊測試，但也不是可設定焦點。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.IsVisibleProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement.IsVisible" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果項目不會呈現由配置系統的值以外的原因，不會引發這個事件<xref:System.Windows.UIElement.IsVisible%2A>屬性。 例如，項目可能沒有相關聯的視覺效果。  
  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.IsVisible" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>焦點在這個項目上方且按下按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。 <xref:System.Windows.UIElement.KeyDown>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。 這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。  
  
 本項目中建立的別名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.KeyDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.KeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.KeyDownEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewKeyDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnKeyDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.KeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>焦點在這個項目上方且放開按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本項目中建立的別名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，此類別，讓<xref:System.Windows.UIElement.KeyUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.KeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.KeyUpEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewKeyUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnKeyUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.KeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler LayoutUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LayoutUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LayoutUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LayoutUpdated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LayoutUpdated;" />
      <MemberSignature Language="F#" Value="member this.LayoutUpdated : EventHandler " Usage="member this.LayoutUpdated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當目前 <see cref="T:System.Windows.Threading.Dispatcher" /> 的數個關聯視覺化項目的配置變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 版面配置更新可能會發生屬性變更、 視窗大小調整或明確的使用者要求的結果。  
  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，不是路由的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去邏輯焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同範圍中，則邏輯焦點會與鍵盤焦點不同。 在此案例中，鍵盤焦點會維持其所在位置和項目其中<xref:System.Windows.UIElement.Focus%2A>方法呼叫仍取得邏輯焦點。  
  
 此事件的更精確地解譯時，就是引發時間的值<xref:System.Windows.UIElement.IsFocused%2A>路由的項目屬性變更時從`true`至`false`。  
  
 因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.LostFocusEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
-   沒有任何對應的通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnLostFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤不再以此項目為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件建立的別名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.LostKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.LostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement.OnLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.LostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去滑鼠擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目捕捉到滑鼠時，它收到滑鼠輸入，即使在指標位於其範圍外。 是通常只有在捕捉滑鼠拖放作業。  
  
 因為此事件會使用事件反昇的路由，失去擷取的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際遺失擷取的項目中。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.LostMouseCapture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.LostMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   沒有任何已定義的對應通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnLostMouseCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.LostMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去手寫筆擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素擷取手寫筆，當它收到手寫筆輸入，即使在指標位於其範圍外也一樣。 要捕捉手寫筆通常只會在拖放作業期間。  
  
 因為此事件會使用事件反昇的路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件建立的別名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.LostStylusCapture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.LostStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   沒有任何已定義的對應通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnLostStylusCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.LostStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目失去觸控擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement.OnLostTouchCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.LostTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationBoundaryFeedback As EventHandler(Of ManipulationBoundaryFeedbackEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^&gt; ^ ManipulationBoundaryFeedback;" />
      <MemberSignature Language="F#" Value="member this.ManipulationBoundaryFeedback : EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " Usage="member this.ManipulationBoundaryFeedback : System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當操作遇到界限時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ManipulationBoundaryFeedback"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationBoundaryFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationBoundaryFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationCompleted As EventHandler(Of ManipulationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationCompletedEventArgs ^&gt; ^ ManipulationCompleted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationCompleted : EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " Usage="member this.ManipulationCompleted : System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當對 <see cref="T:System.Windows.UIElement" /> 物件進行的操作和慣性完成時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得操作的相關資訊，完成時，您可以使用此事件。  例如，您可以使用<xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType>屬性來判斷總量操作位置變更。  
  
 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
<a name="routedEventInfo_ManipulationCompleted"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationCompletedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompletedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationCompletedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationCompletedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationCompletedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationCompletedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDelta">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationDelta" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationDelta As EventHandler(Of ManipulationDeltaEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationDeltaEventArgs ^&gt; ^ ManipulationDelta;" />
      <MemberSignature Language="F#" Value="member this.ManipulationDelta : EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " Usage="member this.ManipulationDelta : System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入裝置在操作期間變更位置時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationDelta>事件會發生多次，當使用者拖曳手指螢幕於操作期間，另一次慣性發生時。  您可以使用<xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A>來檢查是否在慣性期間發生事件的屬性。  
  
 使用的項目<xref:System.Windows.UIElement.ManipulationDelta>發生的事件會在事件發生時不以任何方式影響。  您必須提供的邏輯可操作的項目。  <xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A>並<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>屬性，這些型別的屬性<xref:System.Windows.Input.ManipulationDelta>，包含有關如何變更操作的位置資料，而解譯為移動、 調整其大小或旋轉物件。  您會將該資訊套用至可操作的項目中。  
  
 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
<a name="routedEventInfo_ManipulationDelta"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationDeltaEventArgs>。|  
  
   
  
## Examples  
 下列範例顯示的事件處理常式<xref:System.Windows.UIElement.ManipulationDelta>事件。 此範例會使用<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>屬性來移動、 調整大小和輪替<xref:System.Windows.Shapes.Rectangle>。  此範例也會檢查是否<xref:System.Windows.UIElement.ManipulationDelta>慣性和矩形會觸碰視窗邊緣期間發生的事件。  如果這些情況下，則為 true，應用程式會停止操作，若要防止將應用程式的可見區域的矩形。 這個範例是在較大範例的一部分[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
 [!code-csharp[BasicManipulation#ManipulationDelta](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationdelta)]
 [!code-vb[BasicManipulation#ManipulationDelta](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationdelta)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDeltaEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationDeltaEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationDeltaEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationDeltaEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationDeltaEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationDelta" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationInertiaStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationInertiaStarting As EventHandler(Of ManipulationInertiaStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationInertiaStartingEventArgs ^&gt; ^ ManipulationInertiaStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationInertiaStarting : EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " Usage="member this.ManipulationInertiaStarting : System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當輸入裝置在操作期間失去和 <see cref="T:System.Windows.UIElement" /> 物件的通訊以及慣性開始時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationInertiaStarting>使用者拿起所有從畫面的指於操作期間，就會發生事件。 例如，如果使用者 「 擲回 」<xref:System.Windows.UIElement>介面，使用者會觸及<xref:System.Windows.UIElement>若要開始的動作，將手指移過螢幕的一小段距離，並再放開<xref:System.Windows.UIElement>。 當使用者放開項目時，會開始慣性和<xref:System.Windows.UIElement.ManipulationInertiaStarting>就會發生事件。  <xref:System.Windows.UIElement>會繼續接收<xref:System.Windows.UIElement.ManipulationDelta>表示慣性的項目上發生的事件。  
  
 若要指定慣性的行為，您可以使用此事件。  例如，您可以設定慣性開始時使用的初始速度。  藉由設定所需的減速程度，或藉由設定所需的位置，您也可以指定慣性的數量。  您可以分別設定這些值，每種類型的操作 （平移、 擴充或旋轉）。  如需詳細資訊，請參閱<xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。  
  
 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
<a name="routedEventInfo_ManipulationInertiaStarting"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。|  
  
   
  
## Examples  
 下列範例所示<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件處理常式，並設定為平移、 擴充和旋轉在慣性期間所需的減速程度。 這個範例是在較大範例的一部分[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
 [!code-csharp[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationinertiastarting)]
 [!code-vb[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationinertiastarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationInertiaStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationInertiaStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationInertiaStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarted As EventHandler(Of ManipulationStartedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartedEventArgs ^&gt; ^ ManipulationStarted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarted : EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " Usage="member this.ManipulationStarted : System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當輸入裝置開始對 <see cref="T:System.Windows.UIElement" /> 物件進行操作時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationStarted>事件發生之後<xref:System.Windows.UIElement.ManipulationStarting>事件。  您可以依下列方式使用<xref:System.Windows.Input.ManipulationStartedEventArgs>:  
  
-   取得操作的位置是相對於使用的項目<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A>屬性。  
  
-   使用取得操作的原點<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A>屬性。  
  
-   藉由呼叫取消操作<xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A>方法。  
  
 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
<a name="routedEventInfo_ManipulationStarted"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationStartedEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationStartedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationStarted" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarting As EventHandler(Of ManipulationStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartingEventArgs ^&gt; ^ ManipulationStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarting : EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " Usage="member this.ManipulationStarting : System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於第一次建立操作處理器時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationStarting>具有的項目上發生事件時<xref:System.Windows.UIElement.IsManipulationEnabled%2A>屬性設定為`true`當使用者將手指放在其上。 根據預設，後續的操作事件會報告的位置相對於擁有的項目操作<xref:System.Windows.UIElement.IsManipulationEnabled%2A>設定為`true`。  您可以指定的位置必須是相對於另一個項目，藉由設定<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>屬性。 例如，您可以進行相對於父項目的操作。  
  
 您也可以執行的事件處理常式中的下列<xref:System.Windows.UIElement.ManipulationStarting>:  
  
-   指定使用者是否需要一個以上的手指，藉由設定執行操作<xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType>屬性。  
  
-   指定藉由設定啟用何種類型的操作<xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType>屬性設<xref:System.Windows.Input.ManipulationModes>列舉型別。  
  
-   藉由設定指定單指的旋轉中心的<xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType>屬性。  
  
-   藉由呼叫取消操作<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType>方法。  
  
 如需有關操作的詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  如需回應操作的應用程式的範例，請參閱[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
<a name="routedEventInfo_ManipulationStarting"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.ManipulationStartingEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.ManipulationStartingEventArgs>。|  
  
   
  
## Examples  
 下列範例顯示的事件處理常式<xref:System.Windows.UIElement.ManipulationStarting>事件，並將<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>接收操作事件，讓操作的座標是相對於父項目的父項目。  這個範例是在較大範例的一部分[逐步解說：建立您的第一個觸控應用程式](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)。  
  
 [!code-csharp[BasicManipulation#ManipulationStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationstarting)]
 [!code-vb[BasicManipulation#ManipulationStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationstarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.ManipulationStarting" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Measure">
      <MemberSignature Language="C#" Value="public void Measure (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Measure(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Measure (availableSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Measure(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="member this.Measure : System.Windows.Size -&gt; unit" Usage="uIElement.Measure availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">可供父項目用來配置子項目的空間。 子項目可以要求比可用空間更大的空間；如果在目前項目的內容模型中能夠捲動，就可能容納提供的大小。</param>
        <summary>更新 <see cref="T:System.Windows.UIElement" /> 的 <see cref="P:System.Windows.UIElement.DesiredSize" />。 父項目從本身的 <see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /> 實作中呼叫此方法，以形成遞迴配置更新。 呼叫此方法即構成配置更新的第一次傳遞 (「量值」傳遞)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算版面配置定位[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]組成<xref:System.Windows.UIElement.Measure%2A>呼叫和<xref:System.Windows.UIElement.Arrange%2A>呼叫。 期間<xref:System.Windows.UIElement.Measure%2A>呼叫時，項目決定其大小需求使用`availableSize`輸入。 期間<xref:System.Windows.UIElement.Arrange%2A>完成呼叫時，項目大小。  
  
 `availableSize` 可為任何介於 0 到無限。 參與配置的項目應該會傳回最小<xref:System.Windows.Size>他們需要指定`availableSize`。  
  
 當第一次執行個體化的版面配置時，它一律會收到<xref:System.Windows.UIElement.Measure%2A>之前，先呼叫<xref:System.Windows.UIElement.Arrange%2A>。 不過之後第一次的版面配置傳遞，, 它可能會收到<xref:System.Windows.UIElement.Arrange%2A>呼叫，而不<xref:System.Windows.UIElement.Measure%2A>; 這種情形只會影響的屬性時<xref:System.Windows.UIElement.Arrange%2A>變更 （例如對齊），或是當父系收到<xref:System.Windows.UIElement.Arrange%2A>沒有<xref:System.Windows.UIElement.Measure%2A>. A<xref:System.Windows.UIElement.Measure%2A>呼叫會自動失效<xref:System.Windows.UIElement.Arrange%2A>呼叫。  
  
 如此主執行緒沒有在等待每個可能的配置變更，會以非同步方式發生配置更新。 查詢透過程式碼後置檢查屬性值的項目可能不會立即反映變更互動的調整大小或版面配置特性的屬性 (<xref:System.Windows.FrameworkElement.Width%2A>內容，例如)。  
  
> [!NOTE]
>  版面配置更新可以強制使用<xref:System.Windows.UIElement.UpdateLayout%2A>方法。 不過，呼叫這個方法通常不需要而且可能會導致效能不佳。  
  
 版面配置系統會保留兩個不同的佇列，不正確的版面配置，一個用於<xref:System.Windows.UIElement.Measure%2A>，另一個用於<xref:System.Windows.UIElement.Arrange%2A>。 配置的佇列會根據執行配置; 元素的視覺化樹狀結構中的項目順序排序在樹狀結構中較高的項目是佇列的頂端，以避免重複的變更，在父代所造成的備援配置。 自動從佇列中移除重複的項目，如果他們已驗證配置的項目會自動會從佇列移除。  
  
 更新配置時<xref:System.Windows.UIElement.Measure%2A>佇列清空第一，後面接著<xref:System.Windows.UIElement.Arrange%2A>佇列。 中的項目<xref:System.Windows.UIElement.Arrange%2A>中的項目時，就永遠不會排列佇列<xref:System.Windows.UIElement.Measure%2A>佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureCore : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="uIElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父項目可以配置給子項目使用的大小。</param>
        <summary>任一項目在衍生類別中被覆寫時，會提供可以正確調整該項目的度量邏輯，並且也會同時考慮所有子項目內容的大小。</summary>
        <returns>這個項目在配置中需要的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生的項目，從較常見<xref:System.Windows.FrameworkElement>而非<xref:System.Windows.UIElement>。 如果您衍生自<xref:System.Windows.FrameworkElement>，請注意，覆寫<xref:System.Windows.UIElement.MeasureCore%2A>上<xref:System.Windows.FrameworkElement>標誌<xref:System.Windows.UIElement.MeasureCore%2A>方法。 因此，您只能覆寫<xref:System.Windows.UIElement.MeasureCore%2A>做為改變配置量值的特性，如果您衍生自<xref:System.Windows.UIElement>透過不包含繼承<xref:System.Windows.FrameworkElement>。 如果您嘗試上建置您自己的實作，這可能是大小寫[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]核心層級。 否則，如果您衍生自<xref:System.Windows.FrameworkElement>，則量值的行為的實作範本<xref:System.Windows.FrameworkElement>實作.<xref:System.Windows.FrameworkElement.MeasureOverride%2A>。  
  
 父項目具有子元素必須呼叫<xref:System.Windows.UIElement.Measure%2A>上每個子系，否則這些子元素不調整大小或排列配置就會有效地消失。  
  
   
  
## Examples  
 典型的覆寫<xref:System.Windows.UIElement.MeasureCore%2A>遵循這個近似的模式 (沒有內建集合，稱為`VisualChildren`;`VisualChildren`是一個預留位置，表示您的項目會維護任何子系集合)。  
  
 [!code-csharp[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementmeasureoverride)]
 [!code-vb[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementmeasureoverride)]  
  
-   您必須呼叫<xref:System.Windows.UIElement.Measure%2A>每個子項目上。  
  
-   一般而言，您的實作應該快取之間的度量資訊<xref:System.Windows.UIElement.MeasureCore%2A>和<xref:System.Windows.UIElement.ArrangeCore%2A>方法會呼叫相同的項目中。  
  
-   呼叫的基底實作<xref:System.Windows.UIElement.MeasureCore%2A>並非必要，但可能適用的基底實作會提供所需的版面配置功能。  
  
-   呼叫<xref:System.Windows.UIElement.Measure%2A>子系上項目應該傳遞相同`availableSize`身為其父代或區域的子集，根據的配置類型的父項目支援。 比方說，它會有效移除項目專用框線或邊框距離、 捲軸，或自訂控制項的區域。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>實作必須能夠處理提供給值<paramref name="availableSize" />，為無限。 無限值表示沒有所要求的條件約束，而實際上會延遲到父項目，透過遞迴呼叫量值的度量選擇。  
  
實作可以考慮針對提供的值<paramref name="availableSize" />是軟式條件約束。 子元素可能會指定較大的大小，即使應用程式程式碼的其他層面能夠判斷目前的實際大小的父項目。 大型要求是指出子項目會查詢父元素是否可以支援顯示內容區域內的內容捲動的慣例。</para></block>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指標在此元素上方且按下任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement.MouseDown>通常就會引發事件一起<xref:System.Windows.UIElement.MouseLeftButtonDown>或<xref:System.Windows.UIElement.MouseRightButtonDown>，對應到其中的兩個標準的滑鼠按鈕按下。 <xref:System.Windows.UIElement.MouseLeftButtonDown> 並<xref:System.Windows.UIElement.MouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。 請參閱備註<xref:System.Windows.UIElement.MouseLeftButtonDown>或<xref:System.Windows.UIElement.MouseRightButtonDown>。  
  
> [!IMPORTANT]
>  某些控制項可能會繼承類別處理滑鼠按鈕的事件。 滑鼠左的按鈕向下事件是最可能的事件，讓控制項中的類別處理。 類別處理，通常會將標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。 一旦被標示為已處理，通常無法引發另一個執行個體處理常式附加至該項目。 也不通常會引發任何其他類別或執行個體處理常式附加至事件反昇方向朝向 UI 樹狀目錄中的根項目。  
  
 您可以解決的問題，在上述的重要概述，並仍收到<xref:System.Windows.UIElement.MouseDown>滑鼠左的按鈕向下事件已處理就使用任一這些方案的類別衍生類別上的事件：  
  
-   附加的處理常式<xref:System.Windows.UIElement.PreviewMouseDown>未標示為已由控制項所處理的事件。 請注意，因為這是預覽事件，路由從根目錄開始，並向下控制項。  
  
-   藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.UIElement.AddHandler%2A>，然後選擇 [簽章] 選項，可讓處理常式來接聽事件，即使它們已經標示為已處理路由的事件資料中。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseDownEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewMouseDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標進入此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseEnter> 是，會使用直接的事件處理路由策略。 直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。 不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。  
  
 雖然<xref:System.Windows.UIElement.MouseEnter>播放軌，當滑鼠指標進入範圍的項目，這個事件更多解譯為常值回報<xref:System.Windows.UIElement.IsMouseOver%2A>屬性值已從`false`至`true`這個項目上。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseEnter>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseEnter>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 A <xref:System.Windows.Controls.Button> (或任何<xref:System.Windows.Controls.Primitives.ButtonBase>衍生類別) 可原生處理<xref:System.Windows.UIElement.KeyDown>按鈕具有焦點，並按下的按鍵是空格鍵時的事件。 原生處理引發<xref:System.Windows.Controls.Primitives.ButtonBase.Click>作為來源，按鈕的事件，即使將滑鼠指標似乎未移動，也會擷取滑鼠。 因滑鼠捕捉，而<xref:System.Windows.UIElement.MouseEnter>與做為來源按鈕也會引發事件。 一般而言，如果項目捕捉滑鼠，然後<xref:System.Windows.UIElement.MouseEnter>就會引發，以及<xref:System.Windows.UIElement.GotMouseCapture>和可能是其他控制項特定事件。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標離開此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeave> 是，會使用直接的事件處理路由策略。 直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。 不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。  
  
 雖然<xref:System.Windows.UIElement.MouseLeave>播放軌，當滑鼠離開項目，這個事件更多解譯為常值回報<xref:System.Windows.UIElement.IsMouseOver%2A>屬性值已從`true`至`false`這個項目上。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseLeave>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseLeave>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能會遵循事件反昇路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.MouseLeftButtonDown>處理，您基本上將標示<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。 這可能包含的類別處理常式產生事件這類<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
> [!IMPORTANT]
>  某些控制項類別可能具有固有處理按鈕的滑鼠事件的類別。 滑鼠左的按鈕向下事件是最可能的事件，讓控制項中的類別處理。 類別處理，通常會將標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。 一旦被標示為已處理，通常無法引發另一個執行個體處理常式附加至該項目。 也不通常會引發任何其他類別或執行個體處理常式附加至事件反昇方向朝向 UI 樹狀目錄中的根項目。  
  
 您可以解決的問題，在上述的重要概述，並仍收到<xref:System.Windows.UIElement.MouseLeftButtonDown>滑鼠左的按鈕向下事件已處理就使用任一這些方案的類別衍生類別上的事件：  
  
-   附加的處理常式<xref:System.Windows.UIElement.PreviewMouseDown>未標示為已由控制項所處理的事件。 請注意，因為這是預覽事件，路由從根目錄開始，並向下控制項。  
  
-   藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.UIElement.AddHandler%2A>，然後選擇 [簽章] 選項，可讓處理常式來接聽事件，即使它們已經標示為已處理路由的事件資料中。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能會遵循事件反昇路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.MouseLeftButtonUp>處理，您基本上將標示<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseMoveEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewMouseMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能會遵循事件反昇路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.MouseRightButtonDown>處理，您基本上將標示<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。 這可能包含的類別處理常式產生事件這類<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
 向右按鈕的滑鼠事件中通常會有原生處理的應用程式案例。 比方說，向下的滑鼠右按鈕可能會顯示內容功能表。 請參閱[ContextMenu 概觀](~/docs/framework/wpf/controls/contextmenu-overview.md)。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能會遵循事件反昇路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.MouseRightButtonUp>處理，您基本上將標示<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素上方放開任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement.MouseUp>通常就會引發事件一起<xref:System.Windows.UIElement.MouseLeftButtonUp>或<xref:System.Windows.UIElement.MouseRightButtonUp>，對應至其中的兩個標準的滑鼠按鈕的版本。 <xref:System.Windows.UIElement.MouseLeftButtonUp> 並<xref:System.Windows.UIElement.MouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。 請參閱備註<xref:System.Windows.UIElement.MouseLeftButtonUp>或<xref:System.Windows.UIElement.MouseRightButtonUp>。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseUpEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewMouseUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦點或滑鼠捕捉會優先於滑鼠指標的所在;因此，如果您收到<xref:System.Windows.UIElement.MouseWheel>焦點或擷取的項目中的事件，將滑鼠指標可能實際上是透過另一個項目。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.MouseWheel>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.MouseWheel>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.MouseWheelEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewMouseWheel>。  
  
-   覆寫<xref:System.Windows.UIElement.OnMouseWheel%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.MouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="uIElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">包含屬性的周遊要求，該屬性指出在現有定位順序中周遊的模式，或以視覺化方式移動的方向。</param>
        <summary>嘗試將焦點從這個項目移至另一個項目。 移動焦點的方向是由指引方向所指定，該指引方向是在這個項目之視覺化父代的組織內解譯。</summary>
        <returns>如果已執行要求的周遊則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請確定您檢查傳回的值，這個方法。 傳回值為`false`如果周遊時碰到控制項的組合所定義的定位停駐點，並周遊要求並未要求要包裝，可能會傳回。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit&#xA;override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="uIElement.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">便捷鍵事件的事件資料。 該事件資料會報告叫用哪個便捷鍵，並指出控制這些事件之傳送的 <see cref="T:System.Windows.Input.AccessKeyManager" /> 物件，是否也會將這個便捷鍵引動過程傳送至其他項目。</param>
        <summary>當叫用對這個項目有意義的便捷鍵 (Access Key) 時，為其提供類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在任何實際 AccessKey 事件<xref:System.Windows.UIElement>類別，或其他位置，您可以引發，或附加的處理常式。 相反地，透過專用的管理員類別，產生事件<xref:System.Windows.Input.AccessKeyManager>後, 置處理所有的輸入来搜尋適用於整個輸入模型的存取金鑰。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在這個方法的預設實作<see cref="T:System.Windows.UIElement" />設定鍵盤焦點設定至這個項目 (藉由呼叫<see cref="M:System.Windows.UIElement.Focus" />)。 如果它們是可設定焦點，因為它是針對協助工具案例的預期的行為，實作應永久保存此行為。 請注意，基底實作不使用傳遞的事件資料執行任何動作，而且會引發任何進一步的事件;它只會將焦點。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChanged (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChanged(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit&#xA;override this.OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit" Usage="uIElement.OnChildDesiredSizeChanged child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">正在調整大小的子項目。</param>
        <summary>會在調整子項目的大小時支援配置行為。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您的應用程式程式碼通常不呼叫這個方法。 它會公開讓衍生的類別可以進行進一步的項目檢查其本身可能是無效的配置狀態。 類別可能也會嘗試最佳化，以根據子項目大小變更版面配置階段的處理時間降至最低。 範例衍生項目類別可實作<xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A>是<xref:System.Windows.Controls.Grid>控制項。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />方法具有呼叫的預設實作<see cref="M:System.Windows.UIElement.InvalidateMeasure" />本身。 一般實作會是： 執行任何最佳化您自己的項目支援，並接著通常呼叫基底<see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />至少其中一個程式碼分支 （表示 「 中途 」 的狀態，每個快取邏輯自己的量值的一個）。  
  
這個方法只會呼叫在版面配置，處理時的子系本身發出大小變更。 否則，如果父項目會起始<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />傳遞，版面配置系統規則，根據父代會重新計算版面配置已。 版面配置系統會處理子系的父系，順序的版面配置，因此是必要的子元素的版面配置呼叫沒有傳回父項目調整大小。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="uIElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構傳回類別特定的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</summary>
        <returns>因型別而異的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>此方法的實作會在呼叫特定的建構函式通常是<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作，並將它傳回為傳回值。  
  
所有<see cref="T:System.Windows.UIElement" />衍生的類別應該實作這個方法，以提供自己的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基礎結構。 如需實作此模式的詳細資訊，請參閱<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件資料必須包含 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件的識別項。</param>
        <summary>使用所提供的事件資料引發 <see cref="E:System.Windows.UIElement.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中，雖然是虛擬的沒有預設實作會引發事件。  
  
 這在 * 方法實作用來引發事件，這個相同的方法實作是在內部叫用來引發事件時<xref:System.Windows.UIElement.IsFocused%2A>屬性值變更。 <xref:System.Windows.UIElement.OnGotFocus%2A>實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 只提供便利的方式來加入類別處理該事件的實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非您有不會引發焦點事件變成故意或不尋常的需要，請確定您的實作會呼叫基底實作。 否則，<see cref="E:System.Windows.UIElement.GotFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。 如果您不想要您可設定焦點的項目，您可以防止項目設定成為可設定焦點<see cref="P:System.Windows.UIElement.Focusable" />至<see langword="false" />。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.GotTouchCapture" /> 路由事件的類別處理，而這個事件會在擷取到對此項目的觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnGotTouchCapture%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnGotTouchCapture%2A>衍生類別來處理在<xref:System.Windows.UIElement.GotTouchCapture>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnGotTouchCapture%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsKeyboardFocused%2A>相依性屬性變更。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>在此項目引發 <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> 事件前叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>相依性屬性變更。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsMouseCaptured%2A>相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsMouseCapturedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement.IsMouseCapturedChanged>事件就不會是路由的事件。因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>這個虛擬方法，就會引發時的值<see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" />相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />與該相同的事件資料執行個體就會引發事件。 請注意，事件不是路由的事件。因此，您無法將它標示為已處理的類別處理常式中。  
  
這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsMouseDirectlyOver%2A>相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsStylusCaptured%2A>相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsStylusCapturedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsStylusCaptureWithin%2A>相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsStylusCaptureWithinChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /> 事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個虛擬方法，就會引發時的值<xref:System.Windows.UIElement.IsStylusDirectlyOver%2A>相依性屬性變更其值。 虛擬方法會先引發，並可以操作為必要的事件資料。 則<xref:System.Windows.UIElement.IsStylusDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此您無法將它標示為已處理的類別處理常式中。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按鍵輸入是由專用的輸入管理員處理。 其他可依賴按鍵，例如，輸入和命令繫結的程式設計功能可能會處理按鍵之前它會公開為一般的按鍵輸入。 如果這些輸入系統功能將事件標示為已處理，然後<xref:System.Windows.UIElement.OnKeyDown%2A>不會叫用。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按鍵輸入是由專用的輸入管理員處理。 其他可依賴按鍵，例如，輸入和命令繫結的程式設計功能可能會處理按鍵之前它會公開為一般的按鍵輸入。 如果這些輸入系統功能將事件標示為已處理，然後<xref:System.Windows.UIElement.OnKeyUp%2A>不會叫用。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件資料必須包含 <see cref="E:System.Windows.UIElement.LostFocus" /> 事件的識別項。</param>
        <summary>使用所提供的事件資料引發 <see cref="E:System.Windows.UIElement.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中，雖然是虛擬的沒有預設實作會引發事件。  
  
 這在 * 方法實作用來引發事件，這個相同的方法實作是在內部叫用來引發事件時<xref:System.Windows.UIElement.IsFocused%2A>屬性值變更。 這項實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 只提供便利的方式來加入類別處理該事件的實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非您有不會引發焦點事件變成故意或不尋常的需要，請確定您的實作會呼叫基底實作。 否則，<see cref="E:System.Windows.UIElement.LostFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。 如果您不想要您可設定焦點的項目，您可以防止項目設定成為可設定焦點<see cref="P:System.Windows.UIElement.Focusable" />至<see langword="false" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.LostTouchCapture" /> 路由事件的類別處理，而這個事件會在此項目失去觸控擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnLostTouchCapture%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnLostTouchCapture%2A>衍生類別來處理在<xref:System.Windows.UIElement.LostTouchCapture>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnLostTouchCapture%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit&#xA;override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="uIElement.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件。 請務必呼叫<xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>方法，因此，基底類別的基底類別的接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationCompleted (e As ManipulationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationCompleted(System::Windows::Input::ManipulationCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit&#xA;override this.OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit" Usage="uIElement.OnManipulationCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationCompleted%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationCompleted%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationCompleted>事件。 請務必呼叫<xref:System.Windows.UIElement.OnManipulationCompleted%2A>方法，因此，基底類別的基底類別的接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationDelta (e As ManipulationDeltaEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationDelta(System::Windows::Input::ManipulationDeltaEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit&#xA;override this.OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit" Usage="uIElement.OnManipulationDelta e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationDelta" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationDelta%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationDelta%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationDelta>事件。 請務必呼叫<xref:System.Windows.UIElement.OnManipulationDelta%2A>方法，因此，基底類別的基底類別的接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationInertiaStarting (e As ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationInertiaStarting(System::Windows::Input::ManipulationInertiaStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit&#xA;override this.OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationInertiaStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。 請務必呼叫<xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>方法，因此，基底類別的基底類別的接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarted(class System.Windows.Input.ManipulationStartedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarted (e As ManipulationStartedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarted(System::Windows::Input::ManipulationStartedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit&#xA;override this.OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>當 <see cref="E:System.Windows.UIElement.ManipulationStarted" /> 事件發生時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarted%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationStarted%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationStarted>事件。 請務必呼叫<xref:System.Windows.UIElement.OnManipulationStarted%2A>方法，因此，基底類別的基底類別的接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarting (e As ManipulationStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarting(System::Windows::Input::ManipulationStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit&#xA;override this.OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.ManipulationStartingEventArgs" />，其中包含事件資料。</param>
        <summary>提供當第一次建立操作處理器時，所發生 <see cref="E:System.Windows.UIElement.ManipulationStarting" /> 路由事件的類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarting%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnManipulationStarting%2A>衍生類別來處理在<xref:System.Windows.UIElement.ManipulationStarting>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnManipulationStarting%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 此事件資料會報告有關按下的滑鼠按鈕以及已處理狀態的詳細資訊。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕的動作也是由專用的輸入管理員處理。 其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。 如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.UIElement.OnMouseDown%2A>不會叫用。  
  
 如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.UIElement.MouseLeftButtonDown>和<xref:System.Windows.UIElement.MouseRightButtonDown>。 其中一個這些事件可能會發生在接收端的項目上時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。  
  
 如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。 如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement.OnMouseDown%2A>，當其中隱含類別處理負責動作下的所有可能的滑鼠按鈕。 此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。  
  
 每個特定按鈕的直接事件也有虛擬機器 * 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件，提供直接的路由策略。 將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件，提供直接的路由策略。 將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠左鍵已按下。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> 路由事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonDown>似乎事件反昇路由事件，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.MouseLeftButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement.MouseLeftButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 不論您選擇呼叫的基底實作，取決於您的案例。 無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Button>，並覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>在您的衍生類別，而不需要呼叫基底實作中，不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠左鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonUp>似乎事件反昇路由事件，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.MouseLeftButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement.MouseLeftButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠右鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonDown>似乎事件反昇路由事件，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.MouseRightButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement.MouseRightButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 不論您選擇呼叫的基底實作，取決於您的案例。 無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Control>，並覆寫<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>在您的衍生類別，而不需要呼叫基底; 不過，此覆寫會停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠右鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonUp>似乎事件反昇路由事件，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.MouseRightButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement.MouseRightButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠按鈕已釋放。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕的動作也是由專用的輸入管理員處理。 其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。 如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.UIElement.OnMouseUp%2A>不會叫用。  
  
 如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.UIElement.MouseLeftButtonUp>和<xref:System.Windows.UIElement.MouseRightButtonUp>。 其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。  
  
 如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。 如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement.OnMouseUp%2A>，當其中隱含類別處理負責處理動作的所有可能的滑鼠按鈕。 此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。  
  
 每個特定按鈕的直接事件也有虛擬機器 * 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告一個或多個滑鼠按鈕已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕的動作也是由專用的輸入管理員處理。 其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。 如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>不會叫用。  
  
 如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>和<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。 其中一個這些事件可能會發生在接收端的項目上時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。  
  
 如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。 如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>，當其中隱含類別處理負責動作下的所有可能的滑鼠按鈕。 此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。  
  
 每個特定按鈕的直接事件也有虛擬機器 * 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠左鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 不論您選擇呼叫的基底實作，取決於您的案例。 無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Button>，並覆寫<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>在您的衍生類別，而不需要呼叫基底實作中，不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠左鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠右鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.MouseRightButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 不論您選擇呼叫的基底實作，取決於您的案例。 無法呼叫基底會停用該也預期要叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Control>，並覆寫<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>在您的衍生類別，而不需要呼叫基底; 不過，此覆寫會停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠右鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>事件似乎旅遊通道的路由，但實際上會以間接方式傳送。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement>沿著事件路由會使用相同的處理結果來引發直接路由的事件<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>事件為已處理的這個項目的用途，已處理的狀態不保存事件路由中的其他項目。 不過，您可能想要將事件標示為已處理，以避免一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫此邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement>藉由覆寫<xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告一個或多個滑鼠按鈕已釋放。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕的動作也是由專用的輸入管理員處理。 其他可依賴滑鼠按鈕的動作，例如輸入和命令繫結的程式設計功能可能會叫用動作的處理常式之前它會公開為一般的滑鼠按鈕動作。 如果這些輸入系統功能 mark<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>為已處理的事件<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>不會叫用。  
  
 如果您使用這個類別處理常式將事件標示為已處理時，可能會影響下列事件：<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>和<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。  
  
 如果您將標示為已處理的類別中處理這個事件時，仍然會引發子;不過，它們會傳遞事件資料中的處理的狀態。 如果類別處理在處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用除非那些類別處理常式向<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>，當其中隱含類別處理負責處理動作的所有可能的滑鼠按鈕。 此行為可能會不必要的;因此，小心時將事件標記為已處理的情況下，您在使用這個虛擬方法。  
  
 每個特定按鈕的直接事件也有虛擬機器 * 方法;請考慮是否覆寫這些特定按鈕的類別處理常式可能更適合。  
  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。 是專門針對預覽事件的另一個案例是將它們加以處理，因此不會叫用比對的事件反昇類別處理常式標示。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>衍生類別來處理在<xref:System.Windows.UIElement.PreviewTouchDown>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>衍生類別來處理在<xref:System.Windows.UIElement.PreviewTouchMove>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>衍生類別來處理在<xref:System.Windows.UIElement.PreviewTouchUp>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="uIElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRender(class System.Windows.Media.DrawingContext drawingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRender(System::Windows::Media::DrawingContext ^ drawingContext);" />
      <MemberSignature Language="F#" Value="abstract member OnRender : System.Windows.Media.DrawingContext -&gt; unit&#xA;override this.OnRender : System.Windows.Media.DrawingContext -&gt; unit" Usage="uIElement.OnRender drawingContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="drawingContext">特定項目的繪圖指令。 此內容會提供給配置系統。</param>
        <summary>在衍生類別中覆寫時，參與由配置系統導向的呈現作業。 這個項目的呈現指令不會在叫用此方法時直接使用，而是會加以保留，以便稍後由配置和繪圖做非同步使用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法有預設的實作<xref:System.Windows.UIElement>類別。  
  
   
  
## Examples  
 下列程式碼範例顯示的面板衍生類別可能的實作。  
  
 [!code-csharp[LightWeightCustomPanel#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LightWeightCustomPanel/CSharp/OffsetPanel.cs#1)]
 [!code-vb[LightWeightCustomPanel#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LightWeightCustomPanel/visualbasic/offsetpanel.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />方法可以覆寫上新增更多 （先前未定義邏輯樹狀結構中） 的圖形化元素要呈現的項目，例如效果或裝飾項。 A<see cref="T:System.Windows.Media.DrawingContext" />物件會傳遞做為引數會提供方法來繪製圖形、 文字、 影像或影片。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRenderSizeChanged (info As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ info);" />
      <MemberSignature Language="F#" Value="abstract member OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit&#xA;override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="uIElement.OnRenderSizeChanged info" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="info">封裝的參數 (<see cref="T:System.Windows.SizeChangedInfo" />)，其中包含舊和新的大小，而且其中的維度實際上會變更。</param>
        <summary>在衍生類別中覆寫時，參與由配置系統導向的呈現作業。 如果項目的 <see cref="P:System.Windows.UIElement.RenderSize" /> 因配置更新而改變，則會在版面配置更新之後，並在呈現前叫用這個方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 典型的 WPF 架構層級項目會使用從覆寫實作<xref:System.Windows.FrameworkElement>。 <xref:System.Windows.FrameworkElement>實作失效<xref:System.Windows.FrameworkElement.Width%2A>和<xref:System.Windows.FrameworkElement.Height%2A>屬性和控制代碼的改造版面配置的基本概念。 覆寫<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>在<xref:System.Windows.UIElement>層級意味著，您的項目實作故意不使用的 WPF 架構層級實作，因此您的項目必須配置邏輯更直接處理，通常是藉由撰寫替代版面配置系統。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。 您可能會呼叫基底之前或之後您的特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 將事件標示為已處理時仍適用於防止一般的執行個體處理常式 (未指定的指`handledEventsToo`) 叫用。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法沒有任何預設實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在實作中呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 這個方法會提供方法來處理從衍生類別相符的事件所建立的類別處理常式，而不是執行個體處理常式。 在此情況下，符合的事件是路由的事件。 On * 方法的實作模式是不同的路由事件，因為路由的事件可以引發由子項目，不一定會叫用處理常式的項目。 因此，您的實作必須檢查的事件資料的來源屬性。 它不應該嘗試重新引發此事件，在大部分情況下。  
  
 藉由覆寫這個方法，或藉由註冊類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement>收到此事件路由事件時，可以呼叫私用類別處理常式方法。 其中的類別處理是適當的一個案例是操作事件資料，並將路由的事件標示為已處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.TouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目內部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchDown%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnTouchDown%2A>衍生類別來處理在<xref:System.Windows.UIElement.TouchDown>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnTouchDown%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.TouchEnter" /> 路由事件的類別處理，而這個事件會在觸控從外面移至此項目範圍內時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchEnter%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnTouchEnter%2A>衍生類別來處理在<xref:System.Windows.UIElement.TouchEnter>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnTouchEnter%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.TouchLeave" /> 路由事件的類別處理，而這個事件會在觸控輸入從此 <see cref="T:System.Windows.UIElement" /> 內移至其範圍外時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchLeave%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnTouchLeave%2A>衍生類別來處理在<xref:System.Windows.UIElement.TouchLeave>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnTouchLeave%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.TouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchMove%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnTouchMove%2A>衍生類別來處理在<xref:System.Windows.UIElement.TouchMove>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnTouchMove%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement.TouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchUp%2A>方法有沒有預設的實作。 覆寫<xref:System.Windows.UIElement.OnTouchUp%2A>衍生類別來處理在<xref:System.Windows.UIElement.TouchUp>事件。 請務必呼叫基底類別<xref:System.Windows.UIElement.OnTouchUp%2A>方法的基底類別，因此可接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="uIElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父代。 如果 <see cref="T:System.Windows.DependencyObject" /> 先前沒有父項目，這可提供為 <see langword="null" />。</param>
        <summary>當這個 <see cref="T:System.Windows.UIElement" /> 的父項目報告其基礎視覺化父項目的變更時叫用。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>如果您覆寫這個方法，請務必呼叫基底實作。 預設的基底實作會執行反向繼承的屬性狀態的某些內部維護。 無法呼叫基底實作，會導致無效此狀態。  
  
這個方法會覆寫 <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />。 <see cref="T:System.Windows.FrameworkElement" /> 並<see cref="T:System.Windows.Window" />同時也會覆寫<see cref="T:System.Windows.UIElement" />實作<see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />，和<see cref="T:System.Windows.Window" />密封它。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.UIElement.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至整個 <see cref="T:System.Windows.UIElement" /> (在 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中呈現時) 的不透明度因數。  這是相依性屬性。</summary>
        <value>不透明度因素。 預設不透明度為 1.0。 值必須介於 0.0 到 1.0 之間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1.0 的預設值是提供初始的中繼資料，在此相依性屬性的預設值<xref:System.Windows.UIElement>類別。 其他衍生的類別可能可以藉由覆寫其類別建構函式內的中繼資料變更此預設值。  
  
 值<xref:System.Windows.UIElement.Opacity%2A>不會套用至實際的配置中，除非也是可見的項目 (<xref:System.Windows.UIElement.IsVisible%2A>是`true`)。  
  
 <xref:System.Windows.UIElement.Opacity%2A> 會套用至從父項目在元素樹狀結構子項目，但巢狀的不透明度設定並不表示在個別的子元素的屬性值的顯示效果。 比方說，如果清單有 50%(0.5) 的不透明度，其中一個清單項目有其本身設為 20%(0.2) 的不透明度，net 可見的不透明度，該清單項目將呈現如同它是 10%(0.1)，但屬性值的清單項目<xref:System.Windows.UIElement.Opacity%2A>屬性仍會是 0.2 查詢時。  
  
 即使宣告或評估的不透明度為 0，項目仍參與輸入的事件和命令，並可能可設定焦點。 這方面很有用，例如您可以使用不透明度為零的物件 （例如圖形），加上遮罩時以透明的項目基礎物件。 不透明度為零的物件，然後可處理所有輸入的事件處理基礎的區域。 不過，`Background`或是`Fill`之物件的圖形應該設定為值，即使它是<xref:System.Windows.Media.Brushes.Transparent%2A>，否則為未啟用點擊測試，並沒收到任何事件。  
  
<a name="dependencyPropertyInfo_Opacity"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.OpacityProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.OpacityMask" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.UIElement.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用至任何 Alpha 色板遮罩 (用來遮住此項目的呈現內容) 時實作 <see cref="T:System.Windows.Media.Brush" /> 的不透明度遮罩。  這是相依性屬性。</summary>
        <value>用於不透明度遮罩的筆刷。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性只會使用 alpha 色頻值會提供任何<xref:System.Windows.Media.Brush>。 其他通道的<xref:System.Windows.Media.Brush>的呈現的內容 （紅色、 綠色或藍色） 會被忽略。  
  
 最常見<xref:System.Windows.Media.Brush>針對此目的，是<xref:System.Windows.Media.ImageBrush>，它可以用於各種不同的遮罩的技術，例如插文的相片。 但任何已定義<xref:System.Windows.Media.Brush>(例如<xref:System.Windows.Media.LinearGradientBrush>) 可用。  
  
 在  [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]，這個屬性值可以使用的每個實作特有的內嵌語法<xref:System.Windows.Media.Brush>抽象類別。 如需詳細資訊，請參閱 <<c0> [ 使用純色和漸層概觀繪製](~/docs/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview.md)。  
  
<a name="dependencyPropertyInfo_OpacityMask"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.OpacityMaskProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列標記範例示範<xref:System.Windows.Media.ImageBrush>套用至另一個的不透明度遮罩<xref:System.Windows.Controls.Image>。  
  
 [!code-xaml[OpacityMasksSnippet#UIElementOpacityMask](~/samples/snippets/csharp/VS_Snippets_Wpf/OpacityMasksSnippet/CS/ImageBrushExample.xaml#uielementopacitymask)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMaskProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityMaskProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityMaskProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityMaskProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityMaskProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityMaskProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityMaskProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityMaskProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.OpacityMask" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Opacity" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistId">
      <MemberSignature Language="C#" Value="public int PersistId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PersistId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.PersistId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PersistId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PersistId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PersistId : int" Usage="System.Windows.UIElement.PersistId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值可唯一識別此項目。</summary>
        <value>這個項目的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PersistId%2A> 可唯一識別每個項目。 項目不會改變<xref:System.Windows.UIElement.PersistId%2A>每次相同[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]載入 （包括二進位表示法）。 這個識別碼用於內部的載入、 剖析和序列化需求。 它不是可供您的應用程式程式碼。  
  
 這個屬性沒有任何關聯性<xref:System.Object.GetHashCode%2A>任何給定的執行個體的結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="uIElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求的焦點周遊方向。</param>
        <summary>在衍生類別中覆寫時，傳回會針對指定之焦點周遊方向接收焦點的項目，而不用實際將焦點移至該項目。</summary>
        <returns>如果實際上有叫用 <see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，就會取得焦點的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別中，這個方法的預設實作不完整，且一律會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewDragEnter>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewDragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.DragEnter>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewDragEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewDragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewDragLeave>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewDragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.DragLeave>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewDragLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewDragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewDragOver>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewDragOver>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewDragOverEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.DragOver>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewDragOver%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewDragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewDrop>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewDrop>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewDropEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.Drop>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewDrop%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewDrop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作開始時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewGiveFeedback>事件可讓使用者視覺化回饋提供拖放作業期間修改滑鼠指標的外觀的拖曳事件的來源。  
  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewGiveFeedback>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewGiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.GiveFeedback>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件會使用通道路由，因為具有焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際擁有焦點的項目中。  
  
 此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.GotKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>焦點在這個項目上方且按下按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。 <xref:System.Windows.UIElement.KeyDown>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。 這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。  
  
 此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewKeyDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewKeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.KeyDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewKeyDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewKeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>焦點在這個項目上方且放開按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。 <xref:System.Windows.UIElement.KeyUp>事件是較低層級文字的輸入的事件，可能無法如預期般部分控制項上。 這是文字的因為有些控制項具有複合控制項，或提供較高層級版本的類別處理輸入處理和相關事件。 如需詳細資訊，請檢查個別控制項的文件。  
  
 此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewKeyUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewKeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.KeyUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewKeyUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewKeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤不再以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由於這個事件會使用通道路由，失去焦點的項目可能的子項目，而非項目實際附加事件處理常式。 檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件建立的別名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.LostKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指標在此元素上方且按下任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewMouseDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewMouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement.PreviewMouseDown>通常就會引發事件一起<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>，對應到其中的兩個標準的滑鼠按鈕按下。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 並<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到達事件路由中的此項目。 請參閱備註<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.MouseDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能遵循通道的路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>處理，您基本上將標示<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。 這可能包含的類別處理常式產生事件這類<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能遵循通道的路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>處理，您基本上將標示<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且移動滑鼠指標時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當發生這個事件都將滑鼠指標第一次進入項目的範圍中，也當滑鼠指標移動同時仍保有的項目範圍內。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewMouseMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.MouseMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能遵循通道的路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>處理，您基本上將標示<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。 這可能包含的類別處理常式產生事件這類<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這種現象可能遵循通道的路由項目樹狀結構，實際上是直接路由的事件的引發並由每個項目樹狀結構中沿著 reraised <xref:System.Windows.UIElement>。  
  
 此事件會報告滑鼠按鈕的細節有基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由的每個項目。  
  
 此事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由，仍然會引發滑鼠按鈕的特定事件;不過，必須新增的滑鼠按鈕的特定事件的處理常式藉由明確呼叫<xref:System.Windows.UIElement.AddHandler%2A>，選項來處理已標示為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>處理，您基本上將標示<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>處理路由中的所有進一步的接聽程式和所有相關事件。  
  
 就概念而言，將此事件 (和其他的滑鼠按鍵事件，對於<xref:System.Windows.UIElement>) 是滑鼠 「 服務 」 (使用所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 事件會新增不需要檢查原始的滑鼠事件，事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 針對更進階的案例，例如檢查狀態的標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別，而這些非上<xref:System.Windows.UIElement>。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewMouseUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewMouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement.PreviewMouseUp>通常就會引發事件一起<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>，對應到其中的兩個標準的滑鼠按鈕按下。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 並<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，並適當按鈕特有的事件引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到達事件路由中的此項目。 請參閱備註<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.MouseUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦點或滑鼠捕捉會優先於滑鼠指標的所在;因此，如果您接收這個事件的焦點或擷取的項目時，滑鼠指標實際上可能是透過另一個項目。  
  
 此事件建立的別名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewMouseMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.MouseWheel>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewMouseWheel%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewMouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewQueryContinueDrag>事件可讓拖曳來源，來宣告是否應取消拖放作業。  
  
 此事件建立的別名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewQueryContinueDrag>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewQueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.QueryContinueDrag>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusButtonDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 觸控輸入支援在 Windows Vista](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)並[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusButtonDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusButtonUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusButtonUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方且碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusInAirMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusInAirMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusInRange>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusInRange>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusInRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當手寫筆位在項目上方並移動時發生。 手寫筆必須在受到數位板偵測時移動才能引發此事件，否則會改為引發 <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆遠離數位板而無法被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusOutOfRange>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusOutOfRange>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者執行其中一種手寫筆筆勢時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 手寫筆筆勢的相關資訊，請參閱<xref:System.Windows.Input.SystemGesture>。  
  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusSystemGesture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusSystemGesture>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewStylusDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.StylusUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewStylusUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewStylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素以一種與裝置無關的方式取得文字時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewTextInput>事件可讓元件或應用程式以與裝置無關的方式接聽文字輸入。 鍵盤是主要的方法<xref:System.Windows.UIElement.PreviewTextInput>; 不過也可以產生語音、 手寫和其他輸入的裝置<xref:System.Windows.UIElement.PreviewTextInput>。  
  
 因為索引鍵組合-在預設鍵盤或輸入的法編輯器-透過多個索引鍵的事件可能會引發一個文字輸入的事件。  
  
 此事件建立的別名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.PreviewTextInput>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.PreviewTextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewTextInputEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.TextInput>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewTextInput%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewTextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，<xref:System.Windows.UIElement.PreviewTouchDown>和<xref:System.Windows.UIElement.TouchDown>手指觸控螢幕，並移動之前不會發生的事件。 手指在螢幕上按住卻不必移動它會使用按下並按住行為<xref:System.Windows.Input.Stylus>。 按住不放的行為相當於按一下滑鼠右鍵。  
  
 會造成<xref:System.Windows.UIElement.PreviewTouchDown>並<xref:System.Windows.UIElement.TouchDown>事件發生在手指觸控螢幕，如設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>; 附加屬性`false`此元素。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.TouchDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.TouchMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且離開螢幕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的事件反昇事件是<xref:System.Windows.UIElement.TouchUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.QueryContinueDrag>事件可讓拖曳來源能夠決定是否應取消拖放作業。  
  
 此事件建立的別名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.QueryContinueDrag>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.QueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.QueryContinueDragEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewQueryContinueDrag>。  
  
-   覆寫<xref:System.Windows.UIElement.OnQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.QueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求顯示游標時發生。 每當滑鼠指標移動至新位置時，都會引發此事件，這意謂游標物件可能會根據其新位置而變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.QueryCursor>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.QueryCursor>事件會附加至基礎<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 此事件名稱所參考的資料指標不一定是文字游標 （有時稱為插入點）。 相反地，此內容中的資料指標是宣告螢幕上的圖形化顯示數個可能的輸入相關的裝置或在 Windows 程式設計的概念相關的物件。 該物件由<xref:System.Windows.Input.Cursor>在 WPF 中的類別。 WPF 輸入的系統可讓您變更這個資料指標，當它表示滑鼠指標的螢幕上的位置。 您可以使用預先定義的值從<xref:System.Windows.Input.Cursors>列舉型別，或者您可以宣告為影像檔的自訂游標。  
  
 接聽<xref:System.Windows.UIElement.QueryCursor>事件就不會針對資料指標管理而有效率的技術。 相反地，每個項目應該定義自己的資料指標行為<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。 您只應依賴<xref:System.Windows.UIElement.QueryCursor>如果您不使用 WPF 架構層級基底項目，或在異常的情況下，其中定義每個項目為基礎的資料指標的行為不符合您的需求。 如需有關實作資料指標行為，以回應<xref:System.Windows.UIElement.QueryCursor>，請參閱<xref:System.Windows.Input.QueryCursorEventHandler>。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.QueryCursorEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   沒有任何已定義的對應通道事件。  
  
-   覆寫<xref:System.Windows.UIElement.OnQueryCursor%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.QueryCursor" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料，也會識別要引發的事件。</param>
        <summary>引發特定路由事件。 要引發的 <see cref="T:System.Windows.RoutedEvent" /> 是在所提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 執行個體內識別 (作為該事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`參數的型別為路由的事件的所有資料的通用基底類型; 不過，事件資料應該被授與為最特定的事件資料類型，可供所引發的事件，因為<xref:System.Windows.RoutedEventArgs>衍生的類別包含實際的特定資料是針對特定的事件時，會引發這個事件的屬性。  
  
 <xref:System.Windows.RoutedEventArgs> 不是狀態屬性事件;它也會識別要引發哪個路由的事件。 此事件引發的模式和路由的事件資料，同時與不同[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和資料類別，通常只包含事件相關的屬性。  
  
   
  
## Examples  
 下列範例會建立事件資料、 將事件識別碼附加至資料，然後引發自訂的路由的事件使用事件資料執行個體。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="uIElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從這個項目釋放所有擷取到的觸控裝置。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="uIElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果這個項目保有滑鼠捕捉，則釋放捕捉。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目未存放擷取，呼叫這個方法沒有任何作用。 請考慮檢查值<xref:System.Windows.UIElement.IsMouseCaptured%2A>之前先呼叫這個方法。  
  
   
  
## Examples  
 下列範例是範例給平行<xref:System.Windows.UIElement.CaptureMouse%2A>： 它會處理版本滑鼠捕捉到滑鼠按鈕，然後再重新啟用 移動滑鼠。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="uIElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果這個項目保有手寫筆裝置捕捉，則釋放捕捉。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目未存放擷取，呼叫這個方法沒有任何作用。 請考慮檢查值<xref:System.Windows.UIElement.IsStylusCaptured%2A>之前先呼叫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要釋放的裝置。</param>
        <summary>嘗試從這個項目中釋放指定的觸控裝置。</summary>
        <returns>如果已釋放觸控裝置則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要附加處理常式之路由事件的識別項。</param>
        <param name="handler">要從這個項目上的事件處理常式集合中移除的特定處理常式實作。</param>
        <summary>從這個項目中移除指定的路由事件處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的案例，使用這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是您實作時會[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自訂路由事件，特別是當您實作在處理常式的 「 移除 」 邏輯時相關聯的 「 包裝函式 」 事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]層級。 這個接下來的範例 < 備註 > 一節將說明此案例。  
  
 如果沒有任何處理常式註冊以比對方法呼叫的輸入的參數的準則，則呼叫這個方法任何作用。  
  
 如果多個處理常式已連結的事件處理常式存放區中，比對準則，也就是第一個處理常式。 此行為是配合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]行為`-=`運算子。  
  
 既不`routedEvent`也`handler`可能是`null`。 嘗試提供其中一個值做為`null`會引發例外狀況。  
  
 這個方法會忽略`handledEventsToo`加上第一個處理常式是否提供的參數資訊<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章，可讓已處理事件的處理。 任一種類型的處理常式會移除。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.UIElement.RemoveHandler%2A>事件包裝函式定義的一部分。  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="RenderSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size RenderSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size RenderSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderSize" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size RenderSize { System::Windows::Size get(); void set(System::Windows::Size value); };" />
      <MemberSignature Language="F#" Value="member this.RenderSize : System.Windows.Size with get, set" Usage="System.Windows.UIElement.RenderSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 (或設定) 這個項目的最終呈現大小。</summary>
        <value>這個項目的呈現大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  請勿嘗試設定這個屬性，在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]或在程式碼，如果使用 WPF 架構層級配置系統。 幾乎所有的一般應用程式案例會使用此版面配置系統。 版面配置系統將不會使用在設定的大小<xref:System.Windows.UIElement.RenderSize%2A>直接屬性。 <xref:System.Windows.UIElement.RenderSize%2A>屬性宣告為可寫入才能啟用特定 WPF 核心層級的橋接刻意避免一般版面配置通訊協定，例如支援的情況下<xref:System.Windows.Documents.Adorner>類別。  
  
 這個屬性可以用來檢查版面配置系統內適用的呈現大小會覆寫這類<xref:System.Windows.UIElement.OnRender%2A>或<xref:System.Windows.UIElement.GetLayoutClip%2A>。  
  
 更常見的案例處理<xref:System.Windows.FrameworkElement.SizeChanged>事件的類別處理常式覆寫或<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>事件。  
  
## Examples  
 下列範例示範如何使用自訂裝飾項<xref:System.Windows.UIElement.RenderSize%2A>值，以便建立及調整大小的矩形圖形一部分中定義的裝飾項，其<xref:System.Windows.UIElement.OnRender%2A>實作。  
  
 [!code-csharp[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/csharp/VS_Snippets_Wpf/AdornersMiscCode/CSharp/Window1.xaml.cs#uielementdesiredsize)]
 [!code-vb[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AdornersMiscCode/visualbasic/window1.xaml.vb#uielementdesiredsize)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform RenderTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform RenderTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ RenderTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.UIElement.RenderTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定影響這個項目呈現位置的轉換資訊。  這是相依性屬性。</summary>
        <value>描述所需呈現轉換的特性。 預設為 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呈現轉換不會重新產生配置大小或呈現大小資訊。 呈現轉換通常是針對顯示動畫，或套用暫時效果的項目。 例如，項目可能會縮放已取得焦點或移轉，將滑鼠指標放或可能會在載入繪製該部分的眼睛抖動時[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。  
  
<a name="dependencyPropertyInfo_RenderTransform"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.RenderTransformProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOrigin">
      <MemberSignature Language="C#" Value="public System.Windows.Point RenderTransformOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point RenderTransformOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransformOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransformOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point RenderTransformOrigin { System::Windows::Point get(); void set(System::Windows::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransformOrigin : System.Windows.Point with get, set" Usage="System.Windows.UIElement.RenderTransformOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="P:System.Windows.UIElement.RenderTransform" /> (相對於項目邊界) 宣告任何可能呈現轉換的中心點。  這是相依性屬性。</summary>
        <value>宣告呈現轉換的值。 預設值是 <see cref="T:System.Windows.Point" /> 且座標為 (0,0)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> 有多少非標準方式使用<xref:System.Windows.Point>結構中的值，<xref:System.Windows.Point>不代表座標系統中的絕對位置。 相反地，介於 0 和 1 之間的值會解譯為目前的項目，在每個 x，y 軸範圍的因素。 例如，(0.5，0.5) 會呈現轉換至元素上置中或 (1，1) 會將呈現轉換底端右下角的項目。 <xref:System.Double.NaN> 不是可接受的值。  
  
 0 和 1 以外的值也已被接受，並會導致更多的非傳統的轉換效果。 比方說，如果您設定<xref:System.Windows.UIElement.RenderTransformOrigin%2A>(5,5)，並接著套用<xref:System.Windows.Media.RotateTransform>，項目本身的範圍之外，也會旋轉的點。 轉換會旋轉您的項目源自右下角之外的大圓形。 來源可能會在其父項目內的某處，並可能超出範圍或檢視表可能是。 負數的點值類似，會產生超出左上方的界限。  
  
 呈現轉換不會影響版面配置，且通常用於動畫，或將暫存的效果套用至項目。  
  
<a name="xamlAttributeUsage_RenderTransformOrigin"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object RenderTransformOrigin="xOrigin, yOrigin"/>  
```  
  
<a name="xamlPropertyElementUsage_RenderTransformOrigin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.RenderTransformOrigin>  
    <Point X=" xOrigin " Y=" yOrigin "/>  
  </object.RenderTransformOrigin>  
</object>  
```  
  
<a name="xamlValues_RenderTransformOrigin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *xOrigin*  
 水平的原始比例。 這通常是指定為介於 0 和 1 之間的值。 請參閱＜備註＞。  
  
 *yOrigin*  
 垂直的原始比例。 這通常是指定為介於 0 和 1 之間的值。 請參閱＜備註＞。  
  
<a name="dependencyPropertyInfo_RenderTransformOrigin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會建立在程式碼中的項目，適用於<xref:System.Windows.UIElement.RenderTransformOrigin%2A>，然後再套用<xref:System.Windows.UIElement.RenderTransform%2A>。  
  
 [!code-csharp[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/csharp/VS_Snippets_Wpf/transformanimations_snip/CSharp/RotateAboutCenterExample.cs#uielementrendertransformorigin)]
 [!code-vb[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/visualbasic/VS_Snippets_Wpf/transformanimations_snip/visualbasic/rotateaboutcenterexample.vb#uielementrendertransformorigin)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.RenderTransform" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOriginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformOriginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformOriginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformOriginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformOriginProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.RenderTransformOrigin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.RenderTransform" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.UIElement.CommandBindings" /> 屬性的內容序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.Windows.UIElement.CommandBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.UIElement.CommandBindings%2A>本機設定。  
  
 這`ShouldSerialize`提供方法，因為<xref:System.Windows.UIElement.CommandBindings%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果在開發設計工具或開發您自己的控制項併入<xref:System.Windows.UIElement>。  
  
 如需詳細資訊，請參閱 <<c0> [ 定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.UIElement.InputBindings" /> 屬性的內容序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.Windows.UIElement.InputBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.UIElement.InputBindings%2A>本機設定。  
  
 這`ShouldSerialize`提供方法，因為<xref:System.Windows.UIElement.InputBindings%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果在開發設計工具或開發您自己的控制項併入<xref:System.Windows.UIElement>。  
  
 如需詳細資訊，請參閱 <<c0> [ 定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberSignature Language="VB.NET" Value="Public Property SnapsToDevicePixels As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SnapsToDevicePixels { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SnapsToDevicePixels : bool with get, set" Usage="System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，該值判斷這個項目的呈現在呈現期間是否該使用裝置特定像素的設定。  這是相依性屬性。</summary>
        <value>如果此項目應該根據裝置像素來呈現，則為 <see langword="true" />；否則為 <see langword="false" />。 如 <see cref="T:System.Windows.UIElement" /> 上所宣告的預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以將此屬性設定為`true`在您的根項目，若要啟用像素貼齊呈現整個 UI。 適用於裝置以大於 96 操作[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]，像素貼齊呈現可以最小化元件單一單位實線附近的消除鋸齒視覺成品。  
  
 當繼承<xref:System.Windows.FrameworkElement>任何可能衍生的類別，或<xref:System.Windows.FrameworkElement>覆寫來設定此相依性屬性的中繼資料<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料屬性來`true`。 這種做法是只最外層項目的子樹狀目錄中的必須指定<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>做為`true`，然後將會報告該樹狀子目錄的所有子項目<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>作為`true`，而且必須<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>視覺效果。  
  
<a name="dependencyPropertyInfo_SnapsToDevicePixels"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/aa970908(v=vs.90)">WPF 應用程式中貼齊像素</related>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SnapsToDevicePixelsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SnapsToDevicePixelsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusButtonDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusButtonDownEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusButtonDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusButtonUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusButtonUpEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusButtonUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方且碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusDown>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusDownEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆進入此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusEnter> 是，會使用直接的事件處理路由策略。 直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。 不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。  
  
 雖然<xref:System.Windows.UIElement.StylusEnter>手寫筆輸入的項目，這個事件更多的界限時的追蹤記錄解譯為常值回報<xref:System.Windows.UIElement.IsStylusOver%2A>屬性值已從`false`至`true`這個項目上。  
  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusEnter>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusEnter>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusInAirMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusInAirMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusInRange>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusInRangeEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusInRange>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusInRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆離開元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusLeave> 是，會使用直接的事件處理路由策略。 直接路由的事件不會引發路由;相反地，它們會以處理相同的項目引發的狀況。 不過，它們會啟用路由的事件的行為，例如樣式中的事件觸發程序的其他層面。  
  
 雖然<xref:System.Windows.UIElement.StylusLeave>追蹤何時手寫筆離開元素，此事件的邊界更多解譯為常值回報<xref:System.Windows.UIElement.IsStylusOver%2A>屬性值已從`true`至`false`這個項目上。  
  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusLeave>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusLeave>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當手寫筆移至此項目上方時發生。 手寫筆在數位板上必須移動才會引發這個事件。 否則，會改為引發 <see cref="E:System.Windows.UIElement.StylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusMove>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusMoveEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且遠離數位板而無法被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusOutOfRange>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusOutOfRange>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPlugIns">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.StylusPlugIns" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property StylusPlugIns As StylusPlugInCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ StylusPlugIns { System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StylusPlugIns : System.Windows.Input.StylusPlugIns.StylusPlugInCollection" Usage="System.Windows.UIElement.StylusPlugIns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.StylusPlugInCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個項目關聯的所有手寫筆外掛程式 (自訂) 物件集合。</summary>
        <value>手寫筆外掛程式集合，做為特定的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會填入這個集合的控制項範例是<xref:System.Windows.Controls.InkCanvas>。 <xref:System.Windows.Controls.InkCanvas> 新增<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>做為集合項目，可讓<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>手寫筆輸入與互動，並產生唯一的呈現方式，以驅動事件的手寫筆的回應。  
  
 如需建立自訂外掛程式，可以接收及解譯手寫筆輸入，請參閱 <<c0> [ 自手寫筆的 輸入攔截](~/docs/framework/wpf/advanced/intercepting-input-from-the-stylus.md)。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>執行個體，並將它加入至<xref:System.Windows.UIElement.StylusPlugIns%2A>處理控制項的自訂筆墨的集合。  
  
 [!code-csharp[StylusPluginSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StylusPluginSamples/CSharp/StylusControl.cs#3)]
 [!code-vb[StylusPluginSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StylusPluginSamples/VisualBasic/StylusControl.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPlugIns.DynamicRenderer" />
        <altmember cref="T:System.Windows.Controls.InkCanvas" />
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者執行其中一種手寫筆筆勢時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 手寫筆筆勢的相關資訊的詳細資訊，請參閱<xref:System.Windows.Input.SystemGesture>。  
  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusSystemGesture>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusSystemGesture>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件建立的別名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.StylusUp>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.StylusUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱 <<c0> [ 輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.StylusUpEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewStylusUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnStylusUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.StylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素以一種與裝置無關的方式取得文字時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此事件可能已被標示為已處理的複合控制項的內部實作。 請參閱下方的備註。  
  
 <xref:System.Windows.UIElement.TextInput>事件可能已被標示為已處理的複合控制項的內部實作。 例如，<xref:System.Windows.Controls.TextBox>是複合控制項，<xref:System.Windows.UIElement.TextInput>事件已標示為已處理，其複合 （compositing） 內。 控制項執行這項操作，因為控制項必須解譯某些類型的輸入，例如方向鍵，該控制項的特殊意義。 如果您使用<xref:System.Windows.UIElement.PreviewTextInput>做為您用來附加文字輸入的處理常式的事件，您可能會收到更好的結果。 這項技術會規避大部分的情況下，其中已將這個事件標記為已處理控制項組合，而收到此事件路由事件時，防止您的處理常式。  
  
 <xref:System.Windows.UIElement.TextInput>事件可讓元件或應用程式以與裝置無關的方式接聽文字輸入。 鍵盤是主要的方法<xref:System.Windows.UIElement.TextInput>，但也可以將語音、 手寫和其他輸入的裝置<xref:System.Windows.UIElement.TextInput>。  
  
 因為索引鍵組合-在預設鍵盤或輸入的法編輯器-透過多個索引鍵的事件可能會引發一個文字輸入的事件。  
  
 此事件建立的別名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，此類別中，以便<xref:System.Windows.UIElement.TextInput>屬於類別的成員清單時<xref:System.Windows.UIElement>繼承為基底的項目。 附加至事件處理常式<xref:System.Windows.UIElement.TextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，並接收相同的事件資料執行個體。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TextInputEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewTextInput>。  
  
-   覆寫<xref:System.Windows.UIElement.OnTextInput%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，<xref:System.Windows.UIElement.PreviewTouchDown>和<xref:System.Windows.UIElement.TouchDown>手指觸控螢幕，並移動之前不會發生的事件。 手指在螢幕上按住卻不必移動它會使用按下並按住行為<xref:System.Windows.Input.Stylus>。 按住不放的行為相當於按一下滑鼠右鍵。  
  
 會造成<xref:System.Windows.UIElement.PreviewTouchDown>並<xref:System.Windows.UIElement.TouchDown>事件發生在手指觸控螢幕，如設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>; 附加屬性`false`此元素。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TouchDownEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewTouchDown>。  
  
-   覆寫<xref:System.Windows.UIElement.OnTouchDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控從這個項目的界限外部移至內部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一律引發這個事件，或有觸控式裝置擷取至這個項目。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TouchEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement.OnTouchEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TouchEnter" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已擷取至這個項目的所有觸控裝置。</summary>
        <value>已擷取至這個項目之 <see cref="T:System.Windows.Input.TouchDevice" /> 物件的列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已擷取至這個項目或其視覺化樹狀結構中之任何子項目的所有觸控裝置。</summary>
        <value>已擷取至這個項目或其視覺化樹狀結構中之任何子項目的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在這個項目上停留的所有觸控裝置。</summary>
        <value>在這個項目之上的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在這個項目或其視覺化樹狀結構中之任何子項目上停留的所有觸控裝置。</summary>
        <value>在這個項目或其視覺化樹狀結構中之任何子項目上停留的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控從這個項目的界限內部移至外部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一律引發這個事件，或有觸控式裝置擷取至這個項目。  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TouchLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement.OnTouchLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TouchLeave" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TouchMoveEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewTouchMove>。  
  
-   覆寫<xref:System.Windows.UIElement.OnTouchMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且離開螢幕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.TouchUpEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的通道事件是<xref:System.Windows.UIElement.PreviewTouchUp>。  
  
-   覆寫<xref:System.Windows.UIElement.OnTouchUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement.TouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatePoint">
      <MemberSignature Language="C#" Value="public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point TranslatePoint(valuetype System.Windows.Point point, class System.Windows.UIElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point TranslatePoint(System::Windows::Point point, System::Windows::UIElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="member this.TranslatePoint : System.Windows.Point * System.Windows.UIElement -&gt; System.Windows.Point" Usage="uIElement.TranslatePoint (point, relativeTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="relativeTo" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="point">相對於這個項目的點值。</param>
        <param name="relativeTo">指定的點要轉換成的項目。</param>
        <summary>將相對於這個項目的點轉換成相對於指定項目的座標。</summary>
        <returns>點值，現在會相對於目標項目，而不是這個來源項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳遞`null`針對`relativeTo`允許，而且表示座標應該相對於這個項目所屬的邏輯樹狀結構中的根項目。  
  
 這個方法用於將轉譯點擊測試點值。 如果您正在撰寫的控制項，而且需要處理較低層級的輸入，則呼叫這個方法就大致上是相關。 如果您使用現有的控制項，您通常可以假設已完成的控制項將報表正確轉譯的點擊的測試結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Uid">
      <MemberSignature Language="C#" Value="public string Uid { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Uid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Uid" />
      <MemberSignature Language="VB.NET" Value="Public Property Uid As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Uid { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Uid : string with get, set" Usage="System.Windows.UIElement.Uid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個項目的唯一識別項 (適用於當地語系化)。 這是相依性屬性。</summary>
        <value>這個項目之唯一識別項的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設計工具用來取得`x:Uid`值 (請參閱 < [WPF 全球化和當地語系化概觀](~/docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)如需詳細資訊)。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.UidProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/81defade-483b-4a89-b76d-9b25bba34010">X:uid 屬性</related>
      </Docs>
    </Member>
    <Member MemberName="UidProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UidProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UidProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.UidProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UidProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UidProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UidProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.UidProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Uid" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLayout">
      <MemberSignature Language="C#" Value="public void UpdateLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.UpdateLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateLayout();" />
      <MemberSignature Language="F#" Value="member this.UpdateLayout : unit -&gt; unit" Usage="uIElement.UpdateLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認這個項目的所有視覺化子項目都已正確為配置而更新。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫此方法中，使用的項目<xref:System.Windows.UIElement.IsMeasureValid%2A>`false`或是<xref:System.Windows.UIElement.IsArrangeValid%2A>`false`會呼叫項目專用<xref:System.Windows.UIElement.MeasureCore%2A>和<xref:System.Windows.UIElement.ArrangeCore%2A>方法，這會強制版面配置更新，且會驗證所有的計算的大小。  
  
 如果配置並未變更，或配置的排列或測量都不狀態無效，則呼叫這個方法沒有任何作用。 不過，如果在任一方面的配置無效<xref:System.Windows.UIElement.UpdateLayout%2A>呼叫將會取消復原整個版面配置。 因此，您應該避免呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>項目樹狀結構中的每個增量和次要變更後。 版面配置系統會執行項目配置，以延遲方式，使用的演算法來平衡效能與貨幣，並延後到根物件的變更，直到所有的子元素都是有效的加權策略。 您應該只呼叫<xref:System.Windows.UIElement.UpdateLayout%2A>如果一定需要更新的大小和位置，並只確定之後完成控制以及您可能會影響版面配置屬性的所有變更。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Visibility" />
      <MemberSignature Language="VB.NET" Value="Public Property Visibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility Visibility { System::Windows::Visibility get(); void set(System::Windows::Visibility value); };" />
      <MemberSignature Language="F#" Value="member this.Visibility : System.Windows.Visibility with get, set" Usage="System.Windows.UIElement.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個項目的 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 可見性。  這是相依性屬性。</summary>
        <value>列舉值。 預設值為 <see cref="F:System.Windows.Visibility.Visible" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性會影響的值影響<xref:System.Windows.UIElement.IsVisible%2A>，其接著可能會引發<xref:System.Windows.UIElement.IsVisibleChanged>事件。 不過，<xref:System.Windows.UIElement.IsVisible%2A>有影響其他因素，例如包含它的父代的可見性設定。  
  
 項目所在<xref:System.Windows.UIElement.Visibility%2A>不是<xref:System.Windows.Visibility.Visible>不會參與輸入事件 （或命令） 不會影響版面配置的測量或排列傳遞，是不 索引標籤順序，將不會報告在點擊測試。  
  
 當繼承<xref:System.Windows.Window>或其衍生的類別，<xref:System.Windows.Window>重新定義預設值，這個屬性是<xref:System.Windows.Visibility.Collapsed>。 這有不執行上一開始建立的 版面配置的測量傳遞的效果<xref:System.Windows.Window>，和<xref:System.Windows.UIElement.RenderSize%2A>傳回 (0，0)。 如需詳細資訊，請參閱 <xref:System.Windows.Window>。 <xref:System.Windows.Controls.Primitives.Popup> 也會重新定義預設值是<xref:System.Windows.Visibility.Collapsed>，具有類似的結果行為，如<xref:System.Windows.Controls.Primitives.Popup>和其衍生的類別。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement.VisibilityProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
   
  
## Examples  
 下列範例會實作參考兩個不同的具名的按鈕要會互斥的配對，使用者介面中的處理常式。 在執行之前與按鈕關聯的實際程式邏輯，在按鈕本身設定為<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>，而組配對中的 [其他] 按鈕會設定為<xref:System.Windows.Visibility.Visible?displayProperty=nameWithType>。  
  
 [!code-csharp[MediaElement_snip#UIElementVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/MediaElement_snip/CSharp/PlaybackExample.cs#uielementvisibility)]
 [!code-vb[MediaElement_snip#UIElementVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MediaElement_snip/VB/PlaybackExample.vb#uielementvisibility)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.VisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement.Visibility" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>