<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1d1529115d328a1d811aa8b586bd2a77931b537" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460237" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Defines an object that has a modifiable state and a read-only (frozen) state. Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>類別會提供特殊功能，可協助使用是相當費時的修改或複製的物件時，改善應用程式效能。 範例<xref:System.Windows.Freezable>物件包括下列：  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>衍生自可凍結  
 類別衍生自<xref:System.Windows.Freezable>獲得下列功能：  
  
-   特殊狀態： 唯讀 （凍結） 狀態和可寫入狀態。  
  
-   執行緒安全： 凍結<xref:System.Windows.Freezable>可以跨執行緒共用物件。  
  
-   詳細的變更通知： 不同於其他<xref:System.Windows.DependencyObject>物件<xref:System.Windows.Freezable>子屬性值變更時，物件會提供變更通知。  
  
-   容易複製： Freezable 的類別已實作數個方法可產生深層複製品。  
  
 如需有關使用，並建立您自己詳細<xref:System.Windows.Freezable>物件，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。  
  
 ]]></format>
    </remarks>
    <threadsafe>任何 public<see langword="static" />此類型的成員是安全執行緒。 不保證任何執行個體成員是安全執行緒。  當<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />物件可存取只會從其建立所在的執行緒。 嘗試存取另一個執行緒則會擲回從<see cref="T:System.InvalidOperationException" />。 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法提供支援封送處理至正確的執行緒。  當其<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />物件是無限制執行緒。  如需詳細資訊，請參閱 [Freezable 物件 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是抽象類別的受保護存取範圍建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object can be made unmodifiable.</summary>
        <value>如果可以將目前的物件設為不可修改，或是目前的物件已經不可修改，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>此方法實作會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法<paramref name="isChecking" />設<see langword="true" />來判斷是否<see cref="T:System.Windows.Freezable" />可以設為不可修改。若要修改此屬性在衍生類別中的行為的方式，覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試新增或移除事件處理常式，當目前的物件不是可修改時 (當<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`)，會擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values. When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|再製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性的運算式|運算式會被複製，但可能不能再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性，具有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持在否則可修改複製品中都已凍結。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>藉由呼叫無法修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>並進行本機<xref:System.Windows.Freezable.Clone%2A>能夠存取。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />產生複製品。若要修改的行為，這個方法在衍生類別中覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The object to clone.</param>
        <summary>Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.Clone%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.Clone%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。若要覆寫的原因包括下列:-您衍生的類別必須不會公開透過相依性屬性的資料。 -您在衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。它是不可或缺的所有實作都呼叫這個方法的基底實作。實作應該只會執行不會執行的預設實作的工作。預設實作會建立所有可寫入的本機設定屬性，包括內部的運算式的深層複本。如果物件具有資料繫結的相依性屬性，則運算式會複製，但是可能不能再解析。如需複製的資料繫結物件的詳細資訊，請參閱 [Freezable 物件 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。不會複製動畫。請注意，未設定的屬性不會複製，也不是唯讀屬性。如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持在否則可修改複製品中都已凍結。下列清單摘要說明此方法預期的行為:-產生的複本包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。 -不會複製未設定和唯讀屬性。 運算式會複製。 -無這些子物件已遭到凍結上建立。 -複製本身不會凍結。 -不會複製動畫。 -只屬性基底值是複製而非目前的動畫的值。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|再製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性的運算式|運算式會被複製，但可能不能再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性，具有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持在否則可修改複製品中都已凍結。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>使用無法修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>並讓它可以存取的本機複本。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法以產生複製;<see cref="T:System.Windows.Freezable" />實作者會覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必須確保複本上建立不已凍結。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to be cloned.</param>
        <summary>Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。若要覆寫的原因包括下列:-您衍生的類別必須不會公開透過相依性屬性的資料。 -您在衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。它是不可或缺的所有實作都呼叫這個方法的基底實作。實作應該只會執行不會執行的預設實作的工作。預設實作會建立所有可寫入的本機設定屬性的深層複本。如果物件包含相依性屬性的運算式 （例如資料繫結），而不是運算式本身複製運算式的目前值。如果物件具有動畫相依性屬性，複製目前的動畫的值，這些屬性時，但不是動畫。請注意，未設定的屬性不會複製，也不是唯讀屬性。如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持在否則可修改複製品中都已凍結。下列清單摘要說明此方法預期的行為。 產生-複製包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。 -不會複製未設定和唯讀屬性。 -如果屬性動畫效果，會複製其目前值，但本身不會。 -無這些子物件已遭到凍結上建立。 -複製本身不會凍結。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是受保護的方法，而且相依於覆寫實作實際特定物件的實作行為<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，這個方法會在內部呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法在內部呼叫<xref:System.Windows.Freezable.CreateInstance%2A>方法時的新執行個體<xref:System.Windows.Freezable>建立。  
  
   
  
## Examples  
 下列範例示範典型實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>。  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每個<see cref="T:System.Windows.Freezable" />衍生的類別必須實作這個方法。一般的實作會直接呼叫預設建構函式，並傳回結果。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免發生的可能性<xref:System.InvalidOperationException>呼叫此方法時，請檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性來判斷是否<xref:System.Windows.Freezable>可以為不可之前呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法以進行<see cref="T:System.Windows.Freezable" />為不可修改。若要修改凍結行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">The object to check or make unmodifiable. If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable. If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</param>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，除非衍生自<xref:System.Windows.Freezable>和覆寫<xref:System.Windows.Freezable.FreezeCore%2A>方法。  這個方法可用於<xref:System.Windows.Freezable.FreezeCore%2A>凍結其本身的類別資料成員的方法<xref:System.Windows.Freezable>物件。  
  
 它是保險起見上再次呼叫此方法<xref:System.Windows.Freezable>已遭凍結 （不可修改） 的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法以進行<see cref="T:System.Windows.Freezable" />為不可修改。若要修改凍結行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法在內部呼叫<xref:System.Windows.Freezable.CanFreeze%2A>屬性 (與`isChecking`等於`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (具有`isChecking`等於`false`)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> 類別包含不會儲存使用相依性屬性的資料時，實作者必須覆寫這個方法。一般的實作會呼叫基底，然後可以呼叫靜態<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />方法上所有<see cref="T:System.Windows.Freezable" />型別的屬性，其中包含類別，傳回<see langword="true" />只有當所有屬性凍結 （或可能有已凍結，在指定的情況下<see langword="true" />如<paramref name="isChecking" />)。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您應該檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性，才能呼叫這個方法可讓您確認<xref:System.Windows.Freezable>可以凍結。 使用這個方法是類似於建立複本，使用<xref:System.Windows.Freezable.Clone%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高複製的效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結; 它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性的運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是不被凍結，使用<xref:System.Windows.Freezable.Clone%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法以產生複製品。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The instance to copy.</param>
        <summary>Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />您可能需要覆寫這個方法。若要覆寫的原因包括下列:-您衍生的類別必須不會公開透過相依性屬性的資料。 -您在衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。它是不可或缺的所有實作都呼叫這個方法的基底實作。實作應該只會執行不會執行的預設實作的工作。預設實作會建立任何凍結的 freezable 和的所有其他可寫入的淺層複本、 在本機上設定屬性，它包含的深層複本。如果物件具有資料繫結的相依性屬性，運算式會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱 [Freezable 物件 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。不會複製動畫。請注意，未設定的屬性不會複製，也不是唯讀屬性。如果您不要覆寫這個方法，您必須呼叫基底實作。您不需要<see cref="M:System.Windows.Freezable.Freeze" />值的複製。結果由凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />在傳回之前。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法是類似於建立複本，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高複製的效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結; 它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性的運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是不被凍結，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法以產生複製品。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</param>
        <summary>Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />. If the object has animated dependency properties, their current animated values are copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。若要覆寫的原因包括下列:-您衍生的類別必須不會公開透過相依性屬性的資料。 -您在衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。它是不可或缺的所有實作都呼叫這個方法的基底實作。實作應該只會執行不會執行的預設實作的工作。預設實作會建立新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />方法，讓的凍結 freezable 的深層複本的所有其他可寫入的淺層複本在本機設定和它所包含的屬性。如果物件具有資料繫結的相依性屬性，資料繫結會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱 [Freezable 物件 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果物件具有動畫相依性屬性，複製目前的動畫的值，這些屬性時，但不是動畫。唯讀相依性屬性內<see cref="T:System.Windows.Freezable" />不會複製此預設實作。如果您不要覆寫這個方法，您必須呼叫基底實作。您不需要<see cref="M:System.Windows.Freezable.Freeze" />值的複製。結果由凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />在傳回之前。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object is currently modifiable.</summary>
        <value>
          <see langword="true" /> 如果物件已凍結，而且無法修改。，<see langword="false" />如果物件可以進行修改。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試修改的物件時其<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`會擲回<xref:System.InvalidOperationException>。  
  
 這個屬性是唯讀，從物件模型的觀點來看。 部分的相關文件<xref:System.Windows.Freezable>行為可能提及 」 設定<xref:System.Windows.Freezable.IsFrozen%2A>至`true`"或類似的語言，討論的其他方法的行為時<xref:System.Windows.Freezable>，但這種行為中發生的情況內部的類別執行個體，當執行個體方法操作存在於抽象類別的私用變數。 若要設定這個屬性的值，您應該呼叫<xref:System.Windows.Freezable.Freeze%2A>。 這實際上是一次性的操作，若要變更<xref:System.Windows.Freezable.IsFrozen%2A>屬性從初始預設`false`狀態`true`狀態。 沒有任何可用的方法，來將值設定回`false`。 相反地，您可以變更任何與原始版本進行的深層複本 (請參閱<xref:System.Windows.Freezable.Clone%2A>方法)。 這是根據設計，而且當套用至案例時，任何衍生的類別應該如何運作所在<xref:System.Windows.Freezable>模式就很有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫每當<xref:System.Windows.Freezable.Changed>就會發生事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您實作衍生自類別<see cref="T:System.Windows.Freezable" />，您可能會覆寫這個方法，以執行工作。</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <summary>Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該呼叫<xref:System.Windows.Freezable>繼承者每次<xref:System.Windows.DependencyObject>資料成員，不會儲存為<xref:System.Windows.DependencyProperty>設定。  
  
 這個方法不需要針對呼叫<xref:System.Windows.DependencyObject>則會使用儲存的資料成員<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <param name="property">The property that changed.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that contains information about which property changed, and its old and new values.</param>
        <summary>Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件資料的資訊關於僅包含<xref:System.Windows.Freezable>本身。 子屬性的任何資訊必須透過取得<xref:System.Windows.Freezable.Changed>處理常式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread. Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />它們嘗試存取不相依性屬性的任何成員之前的方法。<see cref="M:System.Windows.Freezable.WritePreamble" />寫入任何這類成員之前，應該呼叫方法。這個方法實際上不做任何動作多個呼叫<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method. Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫這個任何的方法 API 修改不會儲存為類別成員結尾<see cref="T:System.Windows.DependencyProperty" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context. <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>確認的執行緒內容可供存取，而且它會擲回例外狀況，如果<xref:System.Windows.Freezable>已凍結執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</exception>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />之前嘗試寫入不相依性屬性的任何成員。如果您呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />中 [！INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，您可以省略呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>