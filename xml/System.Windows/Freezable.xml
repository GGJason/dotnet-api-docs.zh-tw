<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="666b4c45528d1a4fc25516699cd25e3d50389a70" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064693" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定義具有可修改狀態和唯讀 (凍結) 狀態的物件。 衍生自 <see cref="T:System.Windows.Freezable" /> 的類別可以提供詳細變更告知、可以設為不變的，而且可以自我複製。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>類別會提供特殊功能，可協助改善應用程式效能，使用很難修改或複製的物件時。 範例<xref:System.Windows.Freezable>物件包括下列：  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>衍生自 Freezable  
 類別衍生自<xref:System.Windows.Freezable>獲得下列功能：  
  
-   特殊的狀態： 唯讀 （凍結） 狀態和可寫入狀態。  
  
-   執行緒安全： 凍結<xref:System.Windows.Freezable>可以跨執行緒共用物件。  
  
-   詳細的變更通知：不同於其他<xref:System.Windows.DependencyObject>物件，<xref:System.Windows.Freezable>子屬性值變更時，物件會提供變更通知。  
  
-   輕鬆複製： Freezable 的類別已實作數種方法，產生深層複製品。  
  
 如需有關使用和建立您自己<xref:System.Windows.Freezable>物件，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。  
  
 ]]></format>
    </remarks>
    <threadsafe>任何公用<see langword="static" />這個類型的成員都是安全執行緒。 不保證任何執行個體成員是安全執行緒。  
  
當<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />只能從其建立所在的執行緒可以存取物件。 嘗試從另一個執行緒則會擲回存取<see cref="T:System.InvalidOperationException" />。 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法提供支援封送處理至正確的執行緒。  
  
當他們<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />物件都是無限制執行緒。  如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化的新執行個體<see cref="T:System.Windows.Freezable" />衍生的類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是抽象類別的受保護的存取範圍建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可以將物件設為不可修改。</summary>
        <value>如果可以將目前的物件設為不可修改，或是目前的物件已經不可修改，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>這個方法實作會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法<paramref name="isChecking" />設為<see langword="true" />來判斷是否<see cref="T:System.Windows.Freezable" />可以設為不可修改。 若要修改此屬性在衍生類別中的行為的方式，覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生時<see cref="T:System.Windows.Freezable" />或它所包含的物件遭到修改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試新增或移除事件處理常式，當目前的物件是不可修改時 (當<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`)，會擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立這個 <see cref="T:System.Windows.Freezable" /> 的可修改複製，製作這個物件值的深層複製。 當複製這個物件的相依性屬性時，這個方法會複製運算式 (但可能已不再解析)，但不會複製動畫或其目前值。</summary>
        <returns>目前物件的可修改複本。 即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>並<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|複製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性具有運算式|運算式會被複製，但可能已不再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|目前的運算式值會複製，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持已凍結，否則為可修改複製品中。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動以 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>藉由呼叫設為不可修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>，並進行本機<xref:System.Windows.Freezable.Clone%2A>它可存取。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />產生的複製。 若要修改的行為，這個方法在衍生類別中覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的物件。</param>
        <summary>使用基底 (非動畫) 屬性值，將執行個體設為指定 <see cref="T:System.Windows.Freezable" /> 的複製品 (深層複製)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.Clone%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.Clone%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括以下各項： 
-您的衍生的類別具有不會公開透過相依性屬性的資料。  
  
-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。  
  
請務必讓所有實作會都呼叫這個方法的基底實作。 實作應該只會執行不會執行預設實作的工作。 預設實作會讓所有的可寫入的本機設定屬性，包括內部運算式的深層複本。  
  
如果物件具有資料繫結相依性屬性，運算式會複製，但可能已不再解析。 如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。 不會複製動畫。  
  
請注意，未設定的屬性不會複製，也不是唯讀的屬性。 如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持已凍結，否則為可修改複製品中。  
  
下列清單摘要說明此方法的預期的行為： 
產生-複製包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。  
  
-不會複製取消設定，且為唯讀狀態的屬性。  
  
運算式會被複製。  
  
-None 這些子物件的已凍結上建立。  
  
-複本本身不會凍結。  
  
-動畫不會複製。  
  
-只有屬性基底值是複製而非目前動畫的值。</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用 <see cref="T:System.Windows.Freezable" /> 的目前值，建立它的可修改複製品 (深層複本)。</summary>
        <returns>目前物件的可修改複本。 即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>並<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|複製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性具有運算式|運算式會被複製，但可能已不再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|目前的運算式值會複製，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持已凍結，否則為可修改複製品中。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動以 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>使用設為不可修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>並使它可以存取的本機副本。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法，以產生複製;<see cref="T:System.Windows.Freezable" />機制實作者會覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必須確保複本上建立不已凍結。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>使用目前的屬性值，讓執行個體成為指定之 <see cref="T:System.Windows.Freezable" /> 的可修改複本 (深層複本)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括以下各項： 
-您的衍生的類別具有不會公開透過相依性屬性的資料。  
  
-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。  
  
請務必讓所有實作會都呼叫這個方法的基底實作。 實作應該只會執行不會執行預設實作的工作。 預設實作會讓所有的可寫入的本機設定屬性的深層複本。 如果物件包含與運算式 （例如資料繫結） 的相依性屬性，而不是運算式本身複製運算式的目前值。  
  
如果物件具有動畫相依性屬性，會複製這些屬性的目前動畫的值，但動畫不是。  
  
請注意，未設定的屬性不會複製，也不是唯讀的屬性。 如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持已凍結，否則為可修改複製品中。  
  
下列清單摘要說明此方法的預期的行為。  
  
產生-複製包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。  
  
-不會複製取消設定，且為唯讀狀態的屬性。  
  
-如果以動畫顯示屬性，會複製其目前的值，但本身不會。  
  
-None 這些子物件的已凍結上建立。  
  
-複本本身不會凍結。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Freezable" /> 類別的新執行個體。</summary>
        <returns>新的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是受保護的方法，以及實際的特定物件的實作，行為會取決於覆寫實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，這個方法會在內部呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，會建立的新執行個體<see cref="T:System.Windows.Freezable" />衍生的類別。</summary>
        <returns>新的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法會在內部呼叫<xref:System.Windows.Freezable.CreateInstance%2A>方法時的新執行個體<xref:System.Windows.Freezable>建立。  
  
   
  
## Examples  
 下列範例示範的典型實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>。  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>每個<see cref="T:System.Windows.Freezable" />衍生的類別必須實作這個方法。 一般的實作會直接呼叫預設建構函式，並傳回結果。</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>可讓<see cref="T:System.Windows.Freezable" />設為不可修改的物件以及設定其<see cref="P:System.Windows.Freezable.IsFrozen" />屬性設<see langword="true" />，或測試是否<see cref="T:System.Windows.Freezable" />物件可以設為不可修改。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前的物件設為不可修改，並將其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性設定為 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免的可能性<xref:System.InvalidOperationException>呼叫這個方法時，檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性來判斷是否<xref:System.Windows.Freezable>可以成為不可修改時呼叫這個方法之前。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法將 <see cref="T:System.Windows.Freezable" /> 設為不可修改。</exception>
        <block subset="none" type="overrides"><para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，讓<see cref="T:System.Windows.Freezable" />設為不可修改。 若要修改凍結的行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">要檢查或設為不可修改的物件。 如果<paramref name="isChecking" />是<see langword="true" />，該物件會檢查以判斷它是否可以變成不可修改。 如果<paramref name="isChecking" />是<see langword="false" />，物件會設為不可的話。</param>
        <param name="isChecking"><see langword="true" /> 傳回表示是否可以凍結物件 （而不實際進行凍結）;<see langword="false" />表示實際凍結物件。</param>
        <summary>如果<paramref name="isChecking" />參數是<see langword="true" />，這個方法會指出是否指定<see cref="T:System.Windows.Freezable" />可以設為不可修改。 如果<paramref name="isChecking" />參數是<see langword="false" />，這個方法會嘗試將指定<see cref="T:System.Windows.Freezable" />設為不可修改，並指出作業是否成功。</summary>
        <returns>如果<paramref name="isChecking" />已<see langword="true" />，這個方法會傳回<see langword="true" />如果指定<see cref="T:System.Windows.Freezable" />可設為不可修改，或<see langword="false" />如果無法設為不可修改。 如果<paramref name="isChecking" />已<see langword="false" />，這個方法會傳回<see langword="true" />如果指定<see cref="T:System.Windows.Freezable" />已設為不可修改，或<see langword="false" />如果無法設為不可修改。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，除非您衍生自<xref:System.Windows.Freezable>，並覆寫<xref:System.Windows.Freezable.FreezeCore%2A>方法。  這個方法可用於<xref:System.Windows.Freezable.FreezeCore%2A>凍結本身的類別資料成員的方法<xref:System.Windows.Freezable>物件。  
  
 很好的上一次呼叫這個方法<xref:System.Windows.Freezable>已凍結 （設為不可修改） 的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">當<paramref name="isChecking" />已<see langword="false" />，嘗試以便讓<paramref name="freezable" />設為不可修改成功; 物件目前處於未知狀態 （它可能局部凍結）。</exception>
        <block subset="none" type="overrides"><para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，讓<see cref="T:System.Windows.Freezable" />設為不可修改。 若要修改凍結的行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" /> 傳回表示是否可以凍結物件 （而不實際進行凍結）;<see langword="false" />表示實際凍結物件。</param>
        <summary>可讓<see cref="T:System.Windows.Freezable" />物件設為不可修改，或測試是否可以將它設為不可修改。</summary>
        <returns>如果<paramref name="isChecking" />已<see langword="true" />，這個方法會傳回<see langword="true" />如果<see cref="T:System.Windows.Freezable" />可設為不可修改，或<see langword="false" />如果無法設為不可修改。 如果<paramref name="isChecking" />是<see langword="false" />，這個方法會傳回<see langword="true" />如果 if 指定<see cref="T:System.Windows.Freezable" />已設為不可修改，或<see langword="false" />如果無法設為不可修改。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 在內部呼叫這個方法<xref:System.Windows.Freezable.CanFreeze%2A>屬性 (與`isChecking`等於`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (具有`isChecking`等於`false`)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> 類別包含不會儲存使用相依性屬性的資料時，實作者必須覆寫這個方法。  
  
一般實作會呼叫基底，然後呼叫靜態<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />上所有的方法<see cref="T:System.Windows.Freezable" />類型的屬性，其中包含類別，傳回<see langword="true" />只有當所有屬性凍結 （或可能有已凍結，在指定的情況下<see langword="true" />針對<paramref name="isChecking" />)。</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立的凍結的複本<see cref="T:System.Windows.Freezable" />，使用基底 （非動畫） 屬性值。 因為複本已凍結，則會傳址方式複製任何凍結子物件。</summary>
        <returns>凍結的複本<see cref="T:System.Windows.Freezable" />。 複本<see cref="P:System.Windows.Freezable.IsFrozen" />屬性設定為<see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您應該檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性，才能呼叫這個方法，以確認<xref:System.Windows.Freezable>可以凍結。 使用此方法是建立複本，使用類似<xref:System.Windows.Freezable.Clone%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>並<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提升複製效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結，它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性具有運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|目前的運算式值會複製，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀的屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是未凍結，使用<xref:System.Windows.Freezable.Clone%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" />無法予以凍結，因為它包含運算式或動畫的屬性。</exception>
        <block subset="none" type="overrides"><para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法，以產生的複製。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的執行個體。</param>
        <summary>使用基底 (非動畫) 屬性值，將執行個體設為指定 <see cref="T:System.Windows.Freezable" /> 的凍結複本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您衍生自<see cref="T:System.Windows.Freezable" />您可能需要覆寫這個方法。 若要覆寫的原因包括以下各項： 
-您的衍生的類別具有不會公開透過相依性屬性的資料。  
  
-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。  
  
請務必讓所有實作會都呼叫這個方法的基底實作。 實作應該只會執行不會執行預設實作的工作。 預設實作可讓任何未凍結的 freezable 的所有其他可寫入的淺層複本，在本機設定屬性，它所包含深層的複本。 如果物件具有資料繫結相依性屬性，運算式會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。 不會複製動畫。  
  
請注意，未設定的屬性不會複製，也不是唯讀的屬性。  
  
如果您覆寫這個方法，您必須呼叫基底實作。  
  
您不需要<see cref="M:System.Windows.Freezable.Freeze" />將它們複製的值。  結果凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />再傳回。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立的凍結的複本<see cref="T:System.Windows.Freezable" />使用目前的屬性值。 因為複本已凍結，則會傳址方式複製任何凍結子物件。</summary>
        <returns>凍結的複本<see cref="T:System.Windows.Freezable" />。 複本<see cref="P:System.Windows.Freezable.IsFrozen" />屬性設定為<see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法是建立複本，使用類似<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>並<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提升複製效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結，它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性具有運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|目前的運算式值會複製，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀的屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是未凍結，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法，以產生的複製。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製和凍結的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>將目前執行個體設為所指定 <see cref="T:System.Windows.Freezable" /> 的凍結複本。 如果物件具有動畫相依性屬性，則會複製其目前的動畫值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括以下各項： 
-您的衍生的類別具有不會公開透過相依性屬性的資料。  
  
-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。  
  
請務必讓所有實作會都呼叫這個方法的基底實作。 實作應該只會執行不會執行預設實作的工作。 預設實作會建立新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />方法，並讓的未凍結的 freezable 的深層複本的所有其他可寫入的淺層複本在本機設定和它所包含的屬性。 如果物件具有資料繫結相依性屬性，複製的資料繫結，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，會複製這些屬性的目前動畫的值，但動畫不是。  
  
內的唯讀相依性屬性<see cref="T:System.Windows.Freezable" />不會複製此預設實作。  
  
如果您覆寫這個方法，您必須呼叫基底實作。  
  
您不需要<see cref="M:System.Windows.Freezable.Freeze" />將它們複製的值。  結果凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />再傳回。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值表示物件目前是否可修改。</summary>
        <value>如果物件已凍結，而且無法修改則為 <see langword="true" />，如果可以修改物件則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試修改物件時它<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`就會擲回<xref:System.InvalidOperationException>。  
  
 這個屬性是唯讀，從物件模型的觀點來看。 相關文件的一些<xref:System.Windows.Freezable>行為可能提及 」 設定<xref:System.Windows.Freezable.IsFrozen%2A>來`true`"或類似的語言，討論的其他方法的行為時<xref:System.Windows.Freezable>，但這種行為類別執行個體中的情況在內部當執行個體方法來處理存在於抽象類別的私用變數。 若要設定這個屬性的值，您應該呼叫<xref:System.Windows.Freezable.Freeze%2A>。 這實際上是一次性作業，來變更<xref:System.Windows.Freezable.IsFrozen%2A>屬性從初始的預設`false`狀態`true`狀態。 沒有任何可用的方法，來將值設定回`false`。 相反地，您可以變更任何從原始的深層複本 (請參閱<xref:System.Windows.Freezable.Clone%2A>方法)。 這是根據設計，而且當套用到案例中，任何衍生的類別應如何運作，<xref:System.Windows.Freezable>模式相當有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>目前的 <see cref="T:System.Windows.Freezable" /> 物件遭到修改時進行呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會呼叫這個方法時<xref:System.Windows.Freezable.Changed>就會發生事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當您實作的類別，衍生自<see cref="T:System.Windows.Freezable" />，您可能會覆寫這個方法，以執行工作。</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>可確保資料成員的型別，建立適當的內容指標<see cref="T:System.Windows.DependencyObject" />只是已修改。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">先前的資料成員值。</param>
        <param name="newValue">目前的資料成員值。</param>
        <summary>可確保，建立適當的內容指標<see cref="T:System.Windows.DependencyObjectType" />剛才設定的資料成員。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該由呼叫<xref:System.Windows.Freezable>繼承者每次<xref:System.Windows.DependencyObject>資料成員，不會儲存為<xref:System.Windows.DependencyProperty>設定。  
  
 這個方法不需要呼叫<xref:System.Windows.DependencyObject>都是使用儲存的資料成員<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">先前的資料成員值。</param>
        <param name="newValue">目前的資料成員值。</param>
        <param name="property">已變更的屬性。</param>
        <summary>這個成員支援 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構，但是您不可以從程式碼直接使用它。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件資料包含已變更哪個屬性的相關資訊，及舊值和新值。</param>
        <summary>覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 實作也可以叫用任何 <see cref="E:System.Windows.Freezable.Changed" /> 處理常式，以回應類型 <see cref="T:System.Windows.Freezable" /> 的變更相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件資料要包含關於資訊只<xref:System.Windows.Freezable>本身。 子屬性的任何資訊必須透過取得<xref:System.Windows.Freezable.Changed>處理常式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>可確保<see cref="T:System.Windows.Freezable" />從有效的執行緒進行存取。 繼承者<see cref="T:System.Windows.Freezable" />必須呼叫這個方法的任何開頭[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]讀取不相依性屬性的資料成員。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />方法之前使用者嘗試存取不相依性屬性的任何成員。 <see cref="M:System.Windows.Freezable.WritePreamble" />寫入任何這類成員之前，應該呼叫方法。  
  
這個方法實際上沒有多個呼叫<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引發 <see cref="T:System.Windows.Freezable" /> 的 <see cref="E:System.Windows.Freezable.Changed" /> 事件，並叫用其 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。 在任何 API 修改未以相依性屬性儲存的類別成員之後，衍生自 <see cref="T:System.Windows.Freezable" /> 的類別應該在 API 的結尾呼叫這個方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫這個方法結尾的修改不會儲存為類別成員的任何 API <see cref="T:System.Windows.DependencyProperty" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認<see cref="T:System.Windows.Freezable" />未凍結，從有效的執行緒內容進行存取。 <see cref="T:System.Windows.Freezable" /> 繼承者應該呼叫這個方法的任何開頭[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]寫入不是相依性屬性的資料成員。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>若要確認的執行緒內容可供存取，而且它會擲回例外狀況，如果<xref:System.Windows.Freezable>已凍結執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" />已凍結執行個體，而且不能有寫入它的成員。</exception>
        <block subset="none" type="overrides"><para>衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />之前嘗試寫入任何相依性屬性的成員。 如果您呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />中[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，您可以省略呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />。</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>