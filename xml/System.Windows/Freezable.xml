<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52214101" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="f9692-101">定義具有可修改狀態和唯讀 (凍結) 狀態的物件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="f9692-102">衍生自 <see cref="T:System.Windows.Freezable" /> 的類別可以提供詳細變更告知、可以設為不變的，而且可以自我複製。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-103"><xref:System.Windows.Freezable>類別會提供特殊功能，可協助改善應用程式效能，使用很難修改或複製的物件時。</span><span class="sxs-lookup"><span data-stu-id="f9692-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="f9692-104">範例<xref:System.Windows.Freezable>物件包括下列：</span><span class="sxs-lookup"><span data-stu-id="f9692-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="f9692-105">衍生自 Freezable</span><span class="sxs-lookup"><span data-stu-id="f9692-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="f9692-106">類別衍生自<xref:System.Windows.Freezable>獲得下列功能：</span><span class="sxs-lookup"><span data-stu-id="f9692-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="f9692-107">特殊的狀態： 唯讀 （凍結） 狀態和可寫入狀態。</span><span class="sxs-lookup"><span data-stu-id="f9692-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="f9692-108">執行緒安全： 凍結<xref:System.Windows.Freezable>可以跨執行緒共用物件。</span><span class="sxs-lookup"><span data-stu-id="f9692-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="f9692-109">詳細的變更通知： 不同於其他<xref:System.Windows.DependencyObject>物件，<xref:System.Windows.Freezable>子屬性值變更時，物件會提供變更通知。</span><span class="sxs-lookup"><span data-stu-id="f9692-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="f9692-110">輕鬆複製： Freezable 的類別已實作數種方法，產生深層複製品。</span><span class="sxs-lookup"><span data-stu-id="f9692-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="f9692-111">如需有關使用和建立您自己<xref:System.Windows.Freezable>物件，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f9692-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="f9692-112">任何公用<see langword="static" />這個類型的成員都是安全執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="f9692-113">不保證任何執行個體成員是安全執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="f9692-114">當<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />只能從其建立所在的執行緒可以存取物件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="f9692-115">嘗試從另一個執行緒則會擲回存取<see cref="T:System.InvalidOperationException" />。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="f9692-116">
        <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法提供支援封送處理至正確的執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="f9692-117">當他們<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />物件都是無限制執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="f9692-118">如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f9692-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-119">初始化 <see cref="T:System.Windows.Freezable" /> 衍生類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-120">這是抽象類別的受保護的存取範圍建構函式。</span><span class="sxs-lookup"><span data-stu-id="f9692-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9692-121">取得值，指出是否可以將物件設為不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9692-122">如果可以將目前的物件設為不可修改，或是目前的物件已經不可修改，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-123">這個方法實作會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法<paramref name="isChecking" />設為<see langword="true" />來判斷是否<see cref="T:System.Windows.Freezable" />可以設為不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-123">This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
            </span>
            <span data-ttu-id="f9692-124">若要修改此屬性在衍生類別中的行為的方式，覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-124">To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9692-125">發生於 <see cref="T:System.Windows.Freezable" /> 或所含的物件遭到修改時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-125">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-126">如果您嘗試新增或移除事件處理常式，當目前的物件是不可修改時 (當<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`)，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f9692-126">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-127">建立這個 <see cref="T:System.Windows.Freezable" /> 的可修改複製，製作這個物件值的深層複製。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-127">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="f9692-128">當複製這個物件的相依性屬性時，這個方法會複製運算式 (但可能已不再解析)，但不會複製動畫或其目前值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-128">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-129">目前物件的可修改複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-129">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="f9692-130">即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-130">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-131"><xref:System.Windows.Freezable.Clone%2A>並<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。</span><span class="sxs-lookup"><span data-stu-id="f9692-131">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="f9692-132">複製品實際上是目前物件的深層複本。</span><span class="sxs-lookup"><span data-stu-id="f9692-132">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="f9692-133">下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-133">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="f9692-134">動作</span><span class="sxs-lookup"><span data-stu-id="f9692-134">Action</span></span>|<span data-ttu-id="f9692-135">複製方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-135">Clone method behavior</span></span>|<span data-ttu-id="f9692-136">CloneCurrentValue 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-136">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="f9692-137">複製相依性屬性具有運算式</span><span class="sxs-lookup"><span data-stu-id="f9692-137">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="f9692-138">運算式會被複製，但可能已不再解析。</span><span class="sxs-lookup"><span data-stu-id="f9692-138">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="f9692-139">如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f9692-139">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="f9692-140">目前的運算式值會複製，而不是運算式本身。</span><span class="sxs-lookup"><span data-stu-id="f9692-140">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="f9692-141">複製動畫相依性屬性</span><span class="sxs-lookup"><span data-stu-id="f9692-141">Copying an animated dependency property</span></span>|<span data-ttu-id="f9692-142">屬性的基底 （非動畫） 值會複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-142">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="f9692-143">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-143">Animations are not copied.</span></span>|<span data-ttu-id="f9692-144">複製屬性的目前動畫的值。</span><span class="sxs-lookup"><span data-stu-id="f9692-144">The property's current animated value is copied.</span></span> <span data-ttu-id="f9692-145">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-145">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="f9692-146">請注意，不會複製未設定的屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-146">Note that unset properties are not copied.</span></span> <span data-ttu-id="f9692-147">如果未設定的屬性有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持已凍結，否則為可修改複製品中。</span><span class="sxs-lookup"><span data-stu-id="f9692-147">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="f9692-148">在執行緒之間移動以 Freezable</span><span class="sxs-lookup"><span data-stu-id="f9692-148">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="f9692-149">這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。</span><span class="sxs-lookup"><span data-stu-id="f9692-149">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="f9692-150">首先，請<xref:System.Windows.Freezable>藉由呼叫設為不可修改其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-150">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="f9692-151">現在可以存取另一個執行緒<xref:System.Windows.Freezable>，並進行本機<xref:System.Windows.Freezable.Clone%2A>它可存取。</span><span class="sxs-lookup"><span data-stu-id="f9692-151">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-152">這個方法會使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />產生的複製。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-152">This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone.</span>
            </span>
            <span data-ttu-id="f9692-153">若要修改的行為，這個方法在衍生類別中覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-153">To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="f9692-154">要複製的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-154">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-155">使用基底 (非動畫) 屬性值，將執行個體設為指定 <see cref="T:System.Windows.Freezable" /> 的複製品 (深層複製)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-155">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-156">這個方法會呼叫<xref:System.Windows.Freezable.Clone%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。</span><span class="sxs-lookup"><span data-stu-id="f9692-156">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="f9692-157">若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.Clone%2A>而不是直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-157">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-158">如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-158">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="f9692-159">若要覆寫的原因包括以下各項：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-159">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="f9692-160">-您的衍生的類別具有不會公開透過相依性屬性的資料。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-160">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-161">-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-161">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="f9692-162">比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-162">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="f9692-163">類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-163">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="f9692-164">請務必讓所有實作會都呼叫這個方法的基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-164">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="f9692-165">實作應該只會執行不會執行預設實作的工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-165">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="f9692-166">預設實作會讓所有的可寫入的本機設定屬性，包括內部運算式的深層複本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-166">The default implementation makes deep copies of all writable, locally set properties, including internal expressions.</span>
            </span>
            <span data-ttu-id="f9692-167">如果物件具有資料繫結相依性屬性，運算式會複製，但可能已不再解析。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-167">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve.</span>
            </span>
            <span data-ttu-id="f9692-168">如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-168">For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="f9692-169">如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-169">If the object has animated dependency properties, the base (non-animated) value of those properties is copied.</span>
            </span>
            <span data-ttu-id="f9692-170">不會複製動畫。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-170">Animations are not copied.</span>
            </span>
            <span data-ttu-id="f9692-171">請注意，未設定的屬性不會複製，也不是唯讀的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-171">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="f9692-172">如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持已凍結，否則為可修改複製品中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-172">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span>
            </span>
            <span data-ttu-id="f9692-173">下列清單摘要說明此方法的預期的行為：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-173">The following list summarizes the expected behavior for this method:</span>
            </span>
            <span data-ttu-id="f9692-174">產生-複製包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-174">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span>
            </span>
            <span data-ttu-id="f9692-175">-不會複製取消設定，且為唯讀狀態的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-175">-   Unset and read-only properties are not copied.</span>
            </span>
            <span data-ttu-id="f9692-176">運算式會被複製。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-176">-   Expressions are copied.</span>
            </span>
            <span data-ttu-id="f9692-177">-None 這些子物件的已凍結上建立。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-177">-   None of these sub-objects are frozen on creation.</span>
            </span>
            <span data-ttu-id="f9692-178">-複本本身不會凍結。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-178">-   The copy itself is not frozen.</span>
            </span>
            <span data-ttu-id="f9692-179">-動畫不會複製。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-179">-   Animations are not copied.</span>
            </span>
            <span data-ttu-id="f9692-180">-只有屬性基底值是複製而非目前動畫的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-180">-   Only property base values are copied, not current animated values.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-181">使用 <see cref="T:System.Windows.Freezable" /> 的目前值，建立它的可修改複製品 (深層複本)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-181">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-182">目前物件的可修改複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-182">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="f9692-183">即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-183">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-184"><xref:System.Windows.Freezable.Clone%2A>並<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。</span><span class="sxs-lookup"><span data-stu-id="f9692-184">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="f9692-185">複製品實際上是目前物件的深層複本。</span><span class="sxs-lookup"><span data-stu-id="f9692-185">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="f9692-186">下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-186">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="f9692-187">動作</span><span class="sxs-lookup"><span data-stu-id="f9692-187">Action</span></span>|<span data-ttu-id="f9692-188">複製方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-188">Clone method behavior</span></span>|<span data-ttu-id="f9692-189">CloneCurrentValue 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-189">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="f9692-190">複製相依性屬性具有運算式</span><span class="sxs-lookup"><span data-stu-id="f9692-190">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="f9692-191">運算式會被複製，但可能已不再解析。</span><span class="sxs-lookup"><span data-stu-id="f9692-191">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="f9692-192">如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f9692-192">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="f9692-193">目前的運算式值會複製，而不是運算式本身。</span><span class="sxs-lookup"><span data-stu-id="f9692-193">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="f9692-194">複製動畫相依性屬性</span><span class="sxs-lookup"><span data-stu-id="f9692-194">Copying an animated dependency property</span></span>|<span data-ttu-id="f9692-195">屬性的基底 （非動畫） 值會複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-195">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="f9692-196">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-196">Animations are not copied.</span></span>|<span data-ttu-id="f9692-197">複製屬性的目前動畫的值。</span><span class="sxs-lookup"><span data-stu-id="f9692-197">The property's current animated value is copied.</span></span> <span data-ttu-id="f9692-198">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-198">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="f9692-199">請注意，不會複製未設定的屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-199">Note that unset properties are not copied.</span></span> <span data-ttu-id="f9692-200">如果未設定的屬性有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持已凍結，否則為可修改複製品中。</span><span class="sxs-lookup"><span data-stu-id="f9692-200">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="f9692-201">在執行緒之間移動以 Freezable</span><span class="sxs-lookup"><span data-stu-id="f9692-201">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="f9692-202">這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。</span><span class="sxs-lookup"><span data-stu-id="f9692-202">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="f9692-203">首先，請<xref:System.Windows.Freezable>使用設為不可修改其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-203">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="f9692-204">現在可以存取另一個執行緒<xref:System.Windows.Freezable>並使它可以存取的本機副本。</span><span class="sxs-lookup"><span data-stu-id="f9692-204">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-205">這個方法會使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法，以產生複製;<see cref="T:System.Windows.Freezable" />機制實作者會覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必須確保複本上建立不已凍結。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-205">This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="f9692-206">要複製的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-206">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-207">使用目前的屬性值，讓執行個體成為指定之 <see cref="T:System.Windows.Freezable" /> 的可修改複本 (深層複本)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-207">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-208">這個方法會呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。</span><span class="sxs-lookup"><span data-stu-id="f9692-208">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="f9692-209">若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-209">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-210">如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-210">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="f9692-211">若要覆寫的原因包括以下各項：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-211">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="f9692-212">-您的衍生的類別具有不會公開透過相依性屬性的資料。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-212">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-213">-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-213">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="f9692-214">比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-214">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="f9692-215">類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-215">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="f9692-216">請務必讓所有實作會都呼叫這個方法的基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-216">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="f9692-217">實作應該只會執行不會執行預設實作的工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-217">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="f9692-218">預設實作會讓所有的可寫入的本機設定屬性的深層複本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-218">The default implementation makes deep copies of all writable, locally set properties.</span>
            </span>
            <span data-ttu-id="f9692-219">如果物件包含與運算式 （例如資料繫結） 的相依性屬性，而不是運算式本身複製運算式的目前值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-219">If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.</span>
            </span>
            <span data-ttu-id="f9692-220">如果物件具有動畫相依性屬性，會複製這些屬性的目前動畫的值，但動畫不是。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-220">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span>
            </span>
            <span data-ttu-id="f9692-221">請注意，未設定的屬性不會複製，也不是唯讀的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-221">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="f9692-222">如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持已凍結，否則為可修改複製品中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-222">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span>
            </span>
            <span data-ttu-id="f9692-223">下列清單摘要說明此方法的預期的行為。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-223">The following list summarizes the expected behavior for this method.</span>
            </span>
            <span data-ttu-id="f9692-224">產生-複製包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-224">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span>
            </span>
            <span data-ttu-id="f9692-225">-不會複製取消設定，且為唯讀狀態的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-225">-   Unset and read-only properties are not copied.</span>
            </span>
            <span data-ttu-id="f9692-226">-如果以動畫顯示屬性，會複製其目前的值，但本身不會。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-226">-   If a property is animated, its current value is copied, but the animation itself is not.</span>
            </span>
            <span data-ttu-id="f9692-227">-None 這些子物件的已凍結上建立。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-227">-   None of these sub-objects are frozen on creation.</span>
            </span>
            <span data-ttu-id="f9692-228">-複本本身不會凍結。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-228">-   The copy itself is not frozen.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-229">初始化 <see cref="T:System.Windows.Freezable" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-229">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-230">新的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-230">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-231">這是受保護的方法，以及實際的特定物件的實作，行為會取決於覆寫實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，這個方法會在內部呼叫。</span><span class="sxs-lookup"><span data-stu-id="f9692-231">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-232">在衍生類別中實作時，建立 <see cref="T:System.Windows.Freezable" /> 衍生類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-232">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-233">新的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-233">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-234">請勿呼叫這個方法，直接 （只是呼叫基底實作中）。</span><span class="sxs-lookup"><span data-stu-id="f9692-234">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="f9692-235">這個方法會在內部呼叫<xref:System.Windows.Freezable.CreateInstance%2A>方法時的新執行個體<xref:System.Windows.Freezable>建立。</span><span class="sxs-lookup"><span data-stu-id="f9692-235">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f9692-236">下列範例示範的典型實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>。</span><span class="sxs-lookup"><span data-stu-id="f9692-236">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-237">每個<see cref="T:System.Windows.Freezable" />衍生的類別必須實作這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-237">Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method.</span>
            </span>
            <span data-ttu-id="f9692-238">一般的實作會直接呼叫預設建構函式，並傳回結果。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-238">A typical implementation is to simply call the default constructor and return the result.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f9692-239">將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的再將它的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性設定為 <see langword="true" />，或者測試是否可以將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-239">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-240">將目前的物件設為不可修改，並將其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性設定為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-240">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-241">若要避免的可能性<xref:System.InvalidOperationException>呼叫這個方法時，檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性來判斷是否<xref:System.Windows.Freezable>可以成為不可修改時呼叫這個方法之前。</span><span class="sxs-lookup"><span data-stu-id="f9692-241">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f9692-242">無法將 <see cref="T:System.Windows.Freezable" /> 設為不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-242">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-243">這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，讓<see cref="T:System.Windows.Freezable" />設為不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-243">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span>
            </span>
            <span data-ttu-id="f9692-244">若要修改凍結的行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-244">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="f9692-245">要檢查或設為不可修改的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-245">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="f9692-246">如果 <paramref name="isChecking" /> 是 <see langword="true" />，則會檢查物件，判斷是否可以將它設為不可修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-246">If <paramref name="isChecking" /> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="f9692-247">如果 <paramref name="isChecking" /> 是 <see langword="false" />，則會適時將物件設為不可修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-247">If <paramref name="isChecking" /> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="f9692-248">
            <see langword="true" /> 表示傳回是否可以凍結物件 (而不是實際進行凍結)，<see langword="false" /> 則表示實際凍結物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-248">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-249">如果 <paramref name="isChecking" /> 參數是 <see langword="true" />，則這個方法表示是否可以將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-249">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="f9692-250">如果 <paramref name="isChecking" /> 參數是 <see langword="false" />，則這個方法會嘗試將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的，並表示作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-250">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-251">如果 <paramref name="isChecking" /> 是 <see langword="true" />，則這個方法會在可以將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-251">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="f9692-252">如果 <paramref name="isChecking" /> 是 <see langword="false" />，則這個方法會在指定的 <see cref="T:System.Windows.Freezable" /> 現在為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-252">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-253">請勿呼叫這個方法，除非您衍生自<xref:System.Windows.Freezable>，並覆寫<xref:System.Windows.Freezable.FreezeCore%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-253">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="f9692-254">這個方法可用於<xref:System.Windows.Freezable.FreezeCore%2A>凍結本身的類別資料成員的方法<xref:System.Windows.Freezable>物件。</span><span class="sxs-lookup"><span data-stu-id="f9692-254">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="f9692-255">很好的上一次呼叫這個方法<xref:System.Windows.Freezable>已凍結 （設為不可修改） 的物件。</span><span class="sxs-lookup"><span data-stu-id="f9692-255">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f9692-256">當 <paramref name="isChecking" /> 是 <see langword="false" /> 時，將 <paramref name="freezable" /> 設為不可修改的嘗試失敗了。這個物件現在是處於未知的狀態 (可能是局部凍結)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-256">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-257">這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，讓<see cref="T:System.Windows.Freezable" />設為不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-257">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span>
            </span>
            <span data-ttu-id="f9692-258">若要修改凍結的行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-258">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="f9692-259">
            <see langword="true" /> 表示傳回是否可以凍結物件 (而不是實際進行凍結)，<see langword="false" /> 則表示實際凍結物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-259">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-260">將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的，或測試是否可以將它設為不可修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-260">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-261">如果 <paramref name="isChecking" /> 是 <see langword="true" />，則這個方法會在可以將 <see cref="T:System.Windows.Freezable" /> 設為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-261">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="f9692-262">如果 <paramref name="isChecking" /> 是 <see langword="false" />，則這個方法會在指定的 <see cref="T:System.Windows.Freezable" /> 現在為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-262">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-263">請勿呼叫這個方法，直接 （只是呼叫基底實作中）。</span><span class="sxs-lookup"><span data-stu-id="f9692-263">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="f9692-264">在內部呼叫這個方法<xref:System.Windows.Freezable.CanFreeze%2A>屬性 (與`isChecking`等於`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (具有`isChecking`等於`false`)。</span><span class="sxs-lookup"><span data-stu-id="f9692-264">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-265">
              <see cref="T:System.Windows.Freezable" /> 類別包含不會儲存使用相依性屬性的資料時，實作者必須覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-265">
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-266">一般實作會呼叫基底，然後呼叫靜態<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />上所有的方法<see cref="T:System.Windows.Freezable" />類型的屬性，其中包含類別，傳回<see langword="true" />只有當所有屬性凍結 （或可能有已凍結，在指定的情況下<see langword="true" />針對<paramref name="isChecking" />)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-266">A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-267">使用基底 (非動畫) 屬性值，建立 <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-267">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="f9692-268">因為複本已凍結，所以會以傳址方式複製任何凍結子物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-268">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-269">
            <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-269">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="f9692-270">複本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性是設定為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-270">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-271">您應該檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性，才能呼叫這個方法，以確認<xref:System.Windows.Freezable>可以凍結。</span><span class="sxs-lookup"><span data-stu-id="f9692-271">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="f9692-272">使用此方法是建立複本，使用類似<xref:System.Windows.Freezable.Clone%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-272">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="f9692-273"><xref:System.Windows.Freezable.GetAsFrozen%2A>並<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提升複製效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結，它們只能參考所複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-273">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="f9692-274">下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-274">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="f9692-275">動作</span><span class="sxs-lookup"><span data-stu-id="f9692-275">Action</span></span>|<span data-ttu-id="f9692-276">GetAsFrozen 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-276">GetAsFrozen method behavior</span></span>|<span data-ttu-id="f9692-277">GetCurrentValueAsFrozen 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-277">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="f9692-278">複製相依性屬性具有運算式</span><span class="sxs-lookup"><span data-stu-id="f9692-278">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="f9692-279">方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-279">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="f9692-280">目前的運算式值會複製，而不是運算式本身。</span><span class="sxs-lookup"><span data-stu-id="f9692-280">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="f9692-281">複製動畫相依性屬性</span><span class="sxs-lookup"><span data-stu-id="f9692-281">Copying an animated dependency property</span></span>|<span data-ttu-id="f9692-282">屬性的基底 （非動畫） 值會複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-282">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="f9692-283">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-283">Animations are not copied.</span></span>|<span data-ttu-id="f9692-284">複製屬性的目前動畫的值。</span><span class="sxs-lookup"><span data-stu-id="f9692-284">The property's current animated value is copied.</span></span> <span data-ttu-id="f9692-285">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-285">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="f9692-286">請注意，未設定的屬性不會複製，也不是唯讀的屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-286">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="f9692-287">若要建立一份<xref:System.Windows.Freezable>也就是未凍結，使用<xref:System.Windows.Freezable.Clone%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-287">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f9692-288">
            <see cref="T:System.Windows.Freezable" /> 包含運算式或動畫屬性，因此無法予以凍結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-288">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-289">這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法，以產生的複製。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-289">This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="f9692-290">要複製的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-290">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-291">使用基底 (非動畫) 屬性值，將執行個體設為指定 <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-291">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-292">這個方法會呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。</span><span class="sxs-lookup"><span data-stu-id="f9692-292">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="f9692-293">若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-293">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-294">如果您衍生自<see cref="T:System.Windows.Freezable" />您可能需要覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-294">If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method.</span>
            </span>
            <span data-ttu-id="f9692-295">若要覆寫的原因包括以下各項：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-295">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="f9692-296">-您的衍生的類別具有不會公開透過相依性屬性的資料。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-296">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-297">-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-297">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="f9692-298">比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-298">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="f9692-299">類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-299">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="f9692-300">請務必讓所有實作會都呼叫這個方法的基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-300">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="f9692-301">實作應該只會執行不會執行預設實作的工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-301">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="f9692-302">預設實作可讓任何未凍結的 freezable 的所有其他可寫入的淺層複本，在本機設定屬性，它所包含深層的複本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-302">The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span>
            </span>
            <span data-ttu-id="f9692-303">如果物件具有資料繫結相依性屬性，運算式會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-303">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="f9692-304">如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-304">If the object has animated dependency properties, the base (non-animated) values of those properties are copied.</span>
            </span>
            <span data-ttu-id="f9692-305">不會複製動畫。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-305">Animations are not copied.</span>
            </span>
            <span data-ttu-id="f9692-306">請注意，未設定的屬性不會複製，也不是唯讀的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-306">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="f9692-307">如果您覆寫這個方法，您必須呼叫基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-307">If you do override this method, you must call the base implementation.</span>
            </span>
            <span data-ttu-id="f9692-308">您不需要<see cref="M:System.Windows.Freezable.Freeze" />將它們複製的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-308">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span>
            </span>
            <span data-ttu-id="f9692-309">結果凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />再傳回。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-309">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-310">使用目前屬性值，建立 <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-310">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="f9692-311">因為複本已凍結，所以會以傳址方式複製任何凍結子物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-311">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f9692-312">
            <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-312">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="f9692-313">複本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性是設定為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-313">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-314">使用此方法是建立複本，使用類似<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-314">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="f9692-315"><xref:System.Windows.Freezable.GetAsFrozen%2A>並<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提升複製效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結，它們只能參考所複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-315">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="f9692-316">下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-316">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="f9692-317">動作</span><span class="sxs-lookup"><span data-stu-id="f9692-317">Action</span></span>|<span data-ttu-id="f9692-318">GetAsFrozen 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-318">GetAsFrozen method behavior</span></span>|<span data-ttu-id="f9692-319">GetCurrentValueAsFrozen 方法行為</span><span class="sxs-lookup"><span data-stu-id="f9692-319">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="f9692-320">複製相依性屬性具有運算式</span><span class="sxs-lookup"><span data-stu-id="f9692-320">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="f9692-321">方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-321">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="f9692-322">目前的運算式值會複製，而不是運算式本身。</span><span class="sxs-lookup"><span data-stu-id="f9692-322">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="f9692-323">複製動畫相依性屬性</span><span class="sxs-lookup"><span data-stu-id="f9692-323">Copying an animated dependency property</span></span>|<span data-ttu-id="f9692-324">屬性的基底 （非動畫） 值會複製。</span><span class="sxs-lookup"><span data-stu-id="f9692-324">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="f9692-325">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-325">Animations are not copied.</span></span>|<span data-ttu-id="f9692-326">複製屬性的目前動畫的值。</span><span class="sxs-lookup"><span data-stu-id="f9692-326">The property's current animated value is copied.</span></span> <span data-ttu-id="f9692-327">不會複製動畫。</span><span class="sxs-lookup"><span data-stu-id="f9692-327">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="f9692-328">請注意，未設定的屬性不會複製，也不是唯讀的屬性。</span><span class="sxs-lookup"><span data-stu-id="f9692-328">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="f9692-329">若要建立一份<xref:System.Windows.Freezable>也就是未凍結，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-329">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-330">這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法，以產生的複製。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-330">This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="f9692-331">要複製和凍結的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-331">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-332">將目前執行個體設為所指定 <see cref="T:System.Windows.Freezable" /> 的凍結複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-332">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="f9692-333">如果物件具有動畫相依性屬性，則會複製其目前的動畫值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-333">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-334">這個方法會呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法並不會呼叫直接從程式碼中，除了呼叫基底實作，同時覆寫此方法時。</span><span class="sxs-lookup"><span data-stu-id="f9692-334">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="f9692-335">若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f9692-335">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-336">如果您衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-336">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="f9692-337">若要覆寫的原因包括以下各項：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-337">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="f9692-338">-您的衍生的類別具有不會公開透過相依性屬性的資料。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-338">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-339">-您的衍生的類別必須執行額外的初始設定工作無法完成的只覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-339">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="f9692-340">比方說，這適用於您的衍生的類別會實作<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-340">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="f9692-341">類別，將其所有資料都儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-341">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="f9692-342">請務必讓所有實作會都呼叫這個方法的基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-342">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="f9692-343">實作應該只會執行不會執行預設實作的工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-343">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="f9692-344">預設實作會建立新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />方法，並讓的未凍結的 freezable 的深層複本的所有其他可寫入的淺層複本在本機設定和它所包含的屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-344">The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span>
            </span>
            <span data-ttu-id="f9692-345">如果物件具有資料繫結相依性屬性，複製的資料繫結，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-345">If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="f9692-346">如果物件具有動畫相依性屬性，會複製這些屬性的目前動畫的值，但動畫不是。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-346">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span>
            </span>
            <span data-ttu-id="f9692-347">內的唯讀相依性屬性<see cref="T:System.Windows.Freezable" />不會複製此預設實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-347">Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.</span>
            </span>
            <span data-ttu-id="f9692-348">如果您覆寫這個方法，您必須呼叫基底實作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-348">If you do override this method, you must call the base implementation.</span>
            </span>
            <span data-ttu-id="f9692-349">您不需要<see cref="M:System.Windows.Freezable.Freeze" />將它們複製的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-349">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span>
            </span>
            <span data-ttu-id="f9692-350">結果凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />再傳回。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-350">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f9692-351">取得值，該值表示物件目前是否可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-351">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f9692-352">如果物件已凍結，而且無法修改則為 <see langword="true" />，如果可以修改物件則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-352">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-353">嘗試修改物件時它<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`就會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="f9692-353">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="f9692-354">這個屬性是唯讀，從物件模型的觀點來看。</span><span class="sxs-lookup"><span data-stu-id="f9692-354">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="f9692-355">相關文件的一些<xref:System.Windows.Freezable>行為可能提及 」 設定<xref:System.Windows.Freezable.IsFrozen%2A>來`true`"或類似的語言，討論的其他方法的行為時<xref:System.Windows.Freezable>，但這種行為類別執行個體中的情況在內部當執行個體方法來處理存在於抽象類別的私用變數。</span><span class="sxs-lookup"><span data-stu-id="f9692-355">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="f9692-356">若要設定這個屬性的值，您應該呼叫<xref:System.Windows.Freezable.Freeze%2A>。</span><span class="sxs-lookup"><span data-stu-id="f9692-356">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="f9692-357">這實際上是一次性作業，來變更<xref:System.Windows.Freezable.IsFrozen%2A>屬性從初始的預設`false`狀態`true`狀態。</span><span class="sxs-lookup"><span data-stu-id="f9692-357">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="f9692-358">沒有任何可用的方法，來將值設定回`false`。</span><span class="sxs-lookup"><span data-stu-id="f9692-358">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="f9692-359">相反地，您可以變更任何從原始的深層複本 (請參閱<xref:System.Windows.Freezable.Clone%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="f9692-359">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="f9692-360">這是根據設計，而且當套用到案例中，任何衍生的類別應如何運作，<xref:System.Windows.Freezable>模式相當有用。</span><span class="sxs-lookup"><span data-stu-id="f9692-360">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-361">目前的 <see cref="T:System.Windows.Freezable" /> 物件遭到修改時進行呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-361">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-362">會呼叫這個方法時<xref:System.Windows.Freezable.Changed>就會發生事件。</span><span class="sxs-lookup"><span data-stu-id="f9692-362">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-363">當您實作的類別，衍生自<see cref="T:System.Windows.Freezable" />，您可能會覆寫這個方法，以執行工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-363">When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f9692-364">確定已為型別為 <see cref="T:System.Windows.DependencyObject" /> 且剛剛修改過的資料成員，建立適當的內容指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-364">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="f9692-365">資料成員先前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-365">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="f9692-366">資料成員目前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-366">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-367">確定已為剛剛設定的 <see cref="T:System.Windows.DependencyObjectType" /> 資料成員，建立適當的內容指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-367">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-368">這個方法應該由呼叫<xref:System.Windows.Freezable>繼承者每次<xref:System.Windows.DependencyObject>資料成員，不會儲存為<xref:System.Windows.DependencyProperty>設定。</span><span class="sxs-lookup"><span data-stu-id="f9692-368">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="f9692-369">這個方法不需要呼叫<xref:System.Windows.DependencyObject>都是使用儲存的資料成員<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="f9692-369">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="f9692-370">資料成員先前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-370">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="f9692-371">資料成員目前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-371">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="f9692-372">已變更的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-372">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-373">這個成員支援 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構，但是您不可以從程式碼直接使用它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-373">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f9692-374">事件資料包含已變更哪個屬性的相關資訊，及舊值和新值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-374">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f9692-375">覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 實作也可以叫用任何 <see cref="E:System.Windows.Freezable.Changed" /> 處理常式，以回應類型 <see cref="T:System.Windows.Freezable" /> 的變更相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-375">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-376">事件資料要包含關於資訊只<xref:System.Windows.Freezable>本身。</span><span class="sxs-lookup"><span data-stu-id="f9692-376">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="f9692-377">子屬性的任何資訊必須透過取得<xref:System.Windows.Freezable.Changed>處理常式。</span><span class="sxs-lookup"><span data-stu-id="f9692-377">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-378">確定 <see cref="T:System.Windows.Freezable" /> 是從有效的執行緒進行存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-378">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="f9692-379">如果 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 會讀取非相依性屬性的資料成員，則 <see cref="T:System.Windows.Freezable" /> 的繼承者必須在該 API 的開頭呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-379">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-380">衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />方法之前使用者嘗試存取不相依性屬性的任何成員。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-380">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-381">
              <see cref="M:System.Windows.Freezable.WritePreamble" />寫入任何這類成員之前，應該呼叫方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-381">The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.</span>
            </span>
            <span data-ttu-id="f9692-382">這個方法實際上沒有多個呼叫<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-382">This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-383">引發 <see cref="T:System.Windows.Freezable" /> 的 <see cref="E:System.Windows.Freezable.Changed" /> 事件，並叫用其 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-383">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="f9692-384">在任何 API 修改未以相依性屬性儲存的類別成員之後，衍生自 <see cref="T:System.Windows.Freezable" /> 的類別應該在 API 的結尾呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-384">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-385">衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫這個方法結尾的修改不會儲存為類別成員的任何 API <see cref="T:System.Windows.DependencyProperty" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-385">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f9692-386">確認 <see cref="T:System.Windows.Freezable" /> 未凍結，而且是從有效的執行緒內容進行存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-386">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="f9692-387">在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 將資料寫入至非相依性屬性的資料成員之前，<see cref="T:System.Windows.Freezable" /> 繼承者應該在 API 的開頭呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-387">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f9692-388">這個方法會呼叫<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>若要確認的執行緒內容可供存取，而且它會擲回例外狀況，如果<xref:System.Windows.Freezable>已凍結執行個體。</span><span class="sxs-lookup"><span data-stu-id="f9692-388">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f9692-389">
            <see cref="T:System.Windows.Freezable" /> 執行個體已凍結，無法寫入它的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f9692-389">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f9692-390">衍生自類別<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />之前嘗試寫入任何相依性屬性的成員。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-390">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties.</span>
            </span>
            <span data-ttu-id="f9692-391">如果您呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />中[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，您可以省略呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f9692-391">If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>