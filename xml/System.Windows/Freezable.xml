<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c125d54ad21fa44be59bb03c1e4d67d257a48fed" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680382" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定義具有可修改狀態和唯讀 (凍結) 狀態的物件。 衍生自 <see cref="T:System.Windows.Freezable" /> 的類別可以提供詳細變更告知、可以設為不變的，而且可以自我複製。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>類別會提供特殊功能，可協助使用是相當費時的修改或複製的物件時，改善應用程式效能。 範例<xref:System.Windows.Freezable>物件包括下列：  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>衍生自可凍結  
 類別衍生自<xref:System.Windows.Freezable>獲得下列功能：  
  
-   特殊狀態： 唯讀 （凍結） 狀態和可寫入狀態。  
  
-   執行緒安全： 凍結<xref:System.Windows.Freezable>可以跨執行緒共用物件。  
  
-   詳細的變更通知： 不同於其他<xref:System.Windows.DependencyObject>物件<xref:System.Windows.Freezable>子屬性值變更時，物件會提供變更通知。  
  
-   容易複製： Freezable 的類別已實作數個方法可產生深層複製品。  
  
 如需有關使用，並建立您自己詳細<xref:System.Windows.Freezable>物件，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。  
  
 ]]></format>
    </remarks>
    <threadsafe>任何 public<see langword="static" />此類型的成員是安全執行緒。 不保證任何執行個體成員是安全執行緒。  
  
 當<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />物件可存取只會從其建立所在的執行緒。 嘗試存取另一個執行緒則會擲回從<see cref="T:System.InvalidOperationException" />。 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法提供支援封送處理至正確的執行緒。  
  
 當其<see cref="P:System.Windows.Freezable.IsFrozen" />屬性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />物件是無限制執行緒。  如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Freezable" /> 衍生類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是抽象類別的受保護存取範圍建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可以將物件設為不可修改。</summary>
        <value>
          如果可以將目前的物件設為不可修改，或是目前的物件已經不可修改，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>此方法實作會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法<paramref name="isChecking" />設<see langword="true" />來判斷是否<see cref="T:System.Windows.Freezable" />可以設為不可修改。 若要修改此屬性在衍生類別中的行為的方式，覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="T:System.Windows.Freezable" /> 或所含的物件遭到修改時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試新增或移除事件處理常式，當目前的物件不是可修改時 (當<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`)，會擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立這個 <see cref="T:System.Windows.Freezable" /> 的可修改複製，製作這個物件值的深層複製。 當複製這個物件的相依性屬性時，這個方法會複製運算式 (但可能已不再解析)，但不會複製動畫或其目前值。</summary>
        <returns>目前物件的可修改複本。 即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|再製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性的運算式|運算式會被複製，但可能不能再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性，具有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持在否則可修改複製品中都已凍結。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>藉由呼叫無法修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>並進行本機<xref:System.Windows.Freezable.Clone%2A>能夠存取。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />產生複製品。 若要修改的行為，這個方法在衍生類別中覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的物件。</param>
        <summary>使用基底 (非動畫) 屬性值，將執行個體設為指定 <see cref="T:System.Windows.Freezable" /> 的複製品 (深層複製)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.Clone%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.Clone%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括：  
  
-   您的衍生的類別會具有不會公開透過相依性屬性的資料。  
  
-   您的衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
 類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。  
  
 它是不可或缺的所有實作都呼叫這個方法的基底實作。 實作應該只會執行不會執行的預設實作的工作。 預設實作會建立所有可寫入的本機設定屬性，包括內部的運算式的深層複本。  
  
 如果物件具有資料繫結的相依性屬性，則運算式會複製，但是可能不能再解析。 如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。 不會複製動畫。  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。 如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持在否則可修改複製品中都已凍結。  
  
 下列清單摘要說明此方法預期的行為：  
  
-   所產生的複本包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。  
  
-   不會複製未設定和唯讀屬性。  
  
-   會複製運算式。  
  
-   任何這些子物件已遭到凍結上建立。  
  
-   複本本身不會凍結。  
  
-   不會複製動畫。  
  
-   屬性基底值是複製而非目前的動畫的值。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用 <see cref="T:System.Windows.Freezable" /> 的目前值，建立它的可修改複製品 (深層複本)。</summary>
        <returns>目前物件的可修改複本。 即使來源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性為 <see langword="true." />，複製物件的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性仍為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法會產生的可修改複製品凍結<xref:System.Windows.Freezable>物件 (方法也複製<xref:System.Windows.Freezable>未凍結的物件)。 複製品實際上是目前物件的深層複本。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|動作|再製方法行為|CloneCurrentValue 方法行為|  
|------------|---------------------------|---------------------------------------|  
|複製相依性屬性的運算式|運算式會被複製，但可能不能再解析。 如需詳細資訊，請參閱 [Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，不會複製未設定的屬性。 如果未設定的屬性，具有預設值是凍結<xref:System.Windows.Freezable>，屬性值會維持在否則可修改複製品中都已凍結。  
  
## <a name="move-a-freezable-between-threads"></a>在執行緒之間移動 Freezable  
 這個方法可用於移動<xref:System.Windows.Freezable>執行緒之間。 首先，請<xref:System.Windows.Freezable>使用無法修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 現在可以存取另一個執行緒<xref:System.Windows.Freezable>並讓它可以存取的本機複本。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法以產生複製;<see cref="T:System.Windows.Freezable" />實作者會覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必須確保複本上建立不已凍結。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>使用目前的屬性值，讓執行個體成為指定之 <see cref="T:System.Windows.Freezable" /> 的可修改複本 (深層複本)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的可修改複本，請呼叫<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括：  
  
-   您的衍生的類別會具有不會公開透過相依性屬性的資料。  
  
-   您的衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
 類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。  
  
 它是不可或缺的所有實作都呼叫這個方法的基底實作。 實作應該只會執行不會執行的預設實作的工作。 預設實作會建立所有可寫入的本機設定屬性的深層複本。 如果物件包含相依性屬性的運算式 （例如資料繫結），而不是運算式本身複製運算式的目前值。  
  
 如果物件具有動畫相依性屬性，複製目前的動畫的值，這些屬性時，但不是動畫。  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。 如果這類屬性具有預設值是凍結<see cref="T:System.Windows.Freezable" />，屬性值會維持在否則可修改複製品中都已凍結。  
  
 下列清單摘要說明此方法預期的行為。  
  
-   所產生的複本包含的所有複本<see cref="T:System.Windows.Freezable" />子物件。  
  
-   不會複製未設定和唯讀屬性。  
  
-   如果屬性動畫效果，會複製其目前值，但本身不會。  
  
-   任何這些子物件已遭到凍結上建立。  
  
-   複本本身不會凍結。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Freezable" /> 類別的新執行個體。</summary>
        <returns>新的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是受保護的方法，而且相依於覆寫實作實際特定物件的實作行為<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，這個方法會在內部呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，建立 <see cref="T:System.Windows.Freezable" /> 衍生類別的新執行個體。</summary>
        <returns>新的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法在內部呼叫<xref:System.Windows.Freezable.CreateInstance%2A>方法時的新執行個體<xref:System.Windows.Freezable>建立。  
  
   
  
## Examples  
 下列範例示範典型實作<xref:System.Windows.Freezable.CreateInstanceCore%2A>。  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每個<see cref="T:System.Windows.Freezable" />衍生的類別必須實作這個方法。 一般的實作會直接呼叫預設建構函式，並傳回結果。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的再將它的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性設定為 <see langword="true" />，或者測試是否可以將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前物件設為不可修改的，並將它的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性設定為 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免發生的可能性<xref:System.InvalidOperationException>呼叫此方法時，請檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性來判斷是否<xref:System.Windows.Freezable>可以為不可之前呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> 不可以設為不可修改的。</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法以進行<see cref="T:System.Windows.Freezable" />為不可修改。 若要修改凍結行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">要檢查或設為不可修改的物件。 如果 <c>isChecking</c> 為 <see langword="true" />，則會檢查物件，判斷是否可以將它設為不可修改的。 如果 <c>isChecking</c> 為 <see langword="false" />，則會盡可能將物件設為不可修改。</param>
        <param name="isChecking">
          <see langword="true" /> 表示傳回是否可以凍結物件 (而不是實際進行凍結)，<see langword="false" /> 則表示實際凍結物件。</param>
        <summary>如果 <paramref name="isChecking" /> 參數是 <see langword="true" />，則這個方法表示是否可以將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的。 如果 <paramref name="isChecking" /> 參數是 <see langword="false" />，則這個方法會嘗試將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的，並表示作業是否成功。</summary>
        <returns>如果 <paramref name="isChecking" /> 是 <see langword="true" />，則這個方法會在可以將指定的 <see cref="T:System.Windows.Freezable" /> 設為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。 如果 <paramref name="isChecking" /> 是 <see langword="false" />，則這個方法會在指定的 <see cref="T:System.Windows.Freezable" /> 現在為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，除非衍生自<xref:System.Windows.Freezable>和覆寫<xref:System.Windows.Freezable.FreezeCore%2A>方法。  這個方法可用於<xref:System.Windows.Freezable.FreezeCore%2A>凍結其本身的類別資料成員的方法<xref:System.Windows.Freezable>物件。  
  
 它是保險起見上再次呼叫此方法<xref:System.Windows.Freezable>已遭凍結 （不可修改） 的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">當 <paramref name="isChecking" /> 是 <see langword="false" /> 時，將 <paramref name="freezable" /> 設為不可修改的嘗試失敗了。這個物件現在是處於未知的狀態 (可能是局部凍結)。</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法以進行<see cref="T:System.Windows.Freezable" />為不可修改。 若要修改凍結行為，請覆寫<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> 表示傳回是否可以凍結物件 (而不是實際進行凍結)，<see langword="false" /> 則表示實際凍結物件。</param>
        <summary>將 <see cref="T:System.Windows.Freezable" /> 物件設為不可修改的，或測試是否可以將它設為不可修改的。</summary>
        <returns>如果 <paramref name="isChecking" /> 是 <see langword="true" />，則這個方法會在可以將 <see cref="T:System.Windows.Freezable" /> 設為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。 如果 <paramref name="isChecking" /> 是 <see langword="false" />，則這個方法會在指定的 <see cref="T:System.Windows.Freezable" /> 現在為不可修改的時傳回 <see langword="true" />，並在無法設為不可修改的時傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法在內部呼叫<xref:System.Windows.Freezable.CanFreeze%2A>屬性 (與`isChecking`等於`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (具有`isChecking`等於`false`)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> 類別包含不會儲存使用相依性屬性的資料時，實作者必須覆寫這個方法。  
  
 一般的實作會呼叫基底，然後可以呼叫靜態<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />方法上所有<see cref="T:System.Windows.Freezable" />型別的屬性，其中包含類別，傳回<see langword="true" />只有當所有屬性凍結 （或可能有已凍結，在指定的情況下<see langword="true" />如<paramref name="isChecking" />)。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用基底 (非動畫) 屬性值，建立 <see cref="T:System.Windows.Freezable" /> 的凍結複本。 因為複本已凍結，所以會以傳址方式複製任何凍結子物件。</summary>
        <returns>
          <see cref="T:System.Windows.Freezable" /> 的凍結複本。 複本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性是設定為 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您應該檢查<xref:System.Windows.Freezable.CanFreeze%2A>屬性，才能呼叫這個方法可讓您確認<xref:System.Windows.Freezable>可以凍結。 使用這個方法是類似於建立複本，使用<xref:System.Windows.Freezable.Clone%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高複製的效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結; 它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性的運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是不被凍結，使用<xref:System.Windows.Freezable.Clone%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> 包含運算式或動畫屬性，因此無法予以凍結。</exception>
        <block subset="none" type="overrides">
          <para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法以產生複製品。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製的執行個體。</param>
        <summary>使用基底 (非動畫) 屬性值，將執行個體設為所指定 <see cref="T:System.Windows.Freezable" /> 的凍結複製品。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />您可能需要覆寫這個方法。 若要覆寫的原因包括：  
  
-   您的衍生的類別會具有不會公開透過相依性屬性的資料。  
  
-   您的衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
 類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。  
  
 它是不可或缺的所有實作都呼叫這個方法的基底實作。 實作應該只會執行不會執行的預設實作的工作。 預設實作會建立任何凍結的 freezable 和的所有其他可寫入的淺層複本、 在本機上設定屬性，它包含的深層複本。 如果物件具有資料繫結的相依性屬性，運算式會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，則會複製這些屬性的基底 （非動畫） 值。 不會複製動畫。  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。  
  
 如果您不要覆寫這個方法，您必須呼叫基底實作。  
  
 您不需要<see cref="M:System.Windows.Freezable.Freeze" />值的複製。  結果由凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />在傳回之前。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用目前屬性值，建立 <see cref="T:System.Windows.Freezable" /> 的凍結複本。 因為複本已凍結，所以會以傳址方式複製任何凍結子物件。</summary>
        <returns>
          <see cref="T:System.Windows.Freezable" /> 的凍結複本。 複本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 屬性是設定為 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法是類似於建立複本，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然後將它與凍結<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高複製的效能，因為它們不會複製<xref:System.Windows.Freezable>子物件的已凍結; 它們只能參考所複製。  
  
 下表摘要說明之間的差異<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|動作|GetAsFrozen 方法行為|GetCurrentValueAsFrozen 方法行為|  
|------------|---------------------------------|---------------------------------------------|  
|複製相依性屬性的運算式|方法會擲回<xref:System.InvalidOperationException>因為它無法<xref:System.Windows.Freezable.Freeze%2A>屬性。|複製目前的運算式值，而不是運算式本身。|  
|複製動畫相依性屬性|屬性的基底 （非動畫） 值會複製。 不會複製動畫。|複製屬性的目前的動畫的值。 不會複製動畫。|  
  
 請注意，未設定的屬性不會複製，也不是唯讀屬性。  
  
 若要建立一份<xref:System.Windows.Freezable>也就是不被凍結，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法會使用虛擬<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法以產生複製品。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要複製和凍結的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>將目前執行個體設為所指定 <see cref="T:System.Windows.Freezable" /> 的凍結複製品。 如果物件具有動畫相依性屬性，則會複製其目前的動畫值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法並不應該呼叫直接從程式碼中，除了當呼叫時覆寫這個方法的基底實作。 若要建立目前物件的凍結的複本，請呼叫<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您是衍生自<see cref="T:System.Windows.Freezable" />，您可能需要覆寫這個方法。 若要覆寫的原因包括：  
  
-   您的衍生的類別會具有不會公開透過相依性屬性的資料。  
  
-   您的衍生的類別必須執行額外的初始設定工作無法完成的作業只是覆寫<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。 比方說，這適用於您的衍生的類別實作<see cref="T:System.ComponentModel.ISupportInitialize" />。  
  
 類別，將所有的資料儲存在相依性屬性和，不需要執行額外的初始設定工作不需要覆寫<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。  
  
 它是不可或缺的所有實作都呼叫這個方法的基底實作。 實作應該只會執行不會執行的預設實作的工作。 預設實作會建立新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />方法，讓的凍結 freezable 的深層複本的所有其他可寫入的淺層複本在本機設定和它所包含的屬性。 如果物件具有資料繫結的相依性屬性，資料繫結會複製，但可能不能再解析;如需複製的資料繫結物件的詳細資訊，請參閱[Freezable 物件概觀](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。 如果物件具有動畫相依性屬性，複製目前的動畫的值，這些屬性時，但不是動畫。  
  
 唯讀相依性屬性內<see cref="T:System.Windows.Freezable" />不會複製此預設實作。  
  
 如果您不要覆寫這個方法，您必須呼叫基底實作。  
  
 您不需要<see cref="M:System.Windows.Freezable.Freeze" />值的複製。  結果由凍結<see cref="M:System.Windows.Freezable.GetAsFrozen" />在傳回之前。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值表示物件目前是否可修改。</summary>
        <value>
          如果物件凍結而且無法修改則為 <see langword="true" />，如果物件是可以修改的則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試修改的物件時其<xref:System.Windows.Freezable.IsFrozen%2A>屬性是`true`會擲回<xref:System.InvalidOperationException>。  
  
 這個屬性是唯讀，從物件模型的觀點來看。 部分的相關文件<xref:System.Windows.Freezable>行為可能提及 」 設定<xref:System.Windows.Freezable.IsFrozen%2A>至`true`"或類似的語言，討論的其他方法的行為時<xref:System.Windows.Freezable>，但這種行為中發生的情況內部的類別執行個體，當執行個體方法操作存在於抽象類別的私用變數。 若要設定這個屬性的值，您應該呼叫<xref:System.Windows.Freezable.Freeze%2A>。 這實際上是一次性的操作，若要變更<xref:System.Windows.Freezable.IsFrozen%2A>屬性從初始預設`false`狀態`true`狀態。 沒有任何可用的方法，來將值設定回`false`。 相反地，您可以變更任何與原始版本進行的深層複本 (請參閱<xref:System.Windows.Freezable.Clone%2A>方法)。 這是根據設計，而且當套用至案例時，任何衍生的類別應該如何運作所在<xref:System.Windows.Freezable>模式就很有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>修改目前 <see cref="T:System.Windows.Freezable" /> 物件時進行呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫每當<xref:System.Windows.Freezable.Changed>就會發生事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您實作衍生自類別<see cref="T:System.Windows.Freezable" />，您可能會覆寫這個方法，以執行工作。</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>確定已為型別為 <see cref="T:System.Windows.DependencyObject" /> 且剛剛修改過的資料成員，建立適當的內容指標。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">資料成員先前的值。</param>
        <param name="newValue">資料成員目前的值。</param>
        <summary>確定已為剛剛設定的 <see cref="T:System.Windows.DependencyObjectType" /> 資料成員，建立適當的內容指標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該呼叫<xref:System.Windows.Freezable>繼承者每次<xref:System.Windows.DependencyObject>資料成員，不會儲存為<xref:System.Windows.DependencyProperty>設定。  
  
 這個方法不需要針對呼叫<xref:System.Windows.DependencyObject>則會使用儲存的資料成員<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">資料成員先前的值。</param>
        <param name="newValue">資料成員目前的值。</param>
        <param name="property">已變更的屬性。</param>
        <summary>這個成員支援 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構，但是您不可以從程式碼直接使用它。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件資料包含已變更哪個屬性的相關資訊，及舊值和新值。</param>
        <summary>覆寫 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 實作也可以叫用任何 <see cref="E:System.Windows.Freezable.Changed" /> 處理常式，以回應類型 <see cref="T:System.Windows.Freezable" /> 的變更相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件資料的資訊關於僅包含<xref:System.Windows.Freezable>本身。 子屬性的任何資訊必須透過取得<xref:System.Windows.Freezable.Changed>處理常式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確定 <see cref="T:System.Windows.Freezable" /> 是從有效的執行緒進行存取。 如果 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 會讀取非相依性屬性的資料成員，則 <see cref="T:System.Windows.Freezable" /> 的繼承者必須在該 API 的開頭呼叫這個方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />它們嘗試存取不相依性屬性的任何成員之前的方法。 <see cref="M:System.Windows.Freezable.WritePreamble" />寫入任何這類成員之前，應該呼叫方法。  
  
 這個方法實際上不做任何動作多個呼叫<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引發 <see cref="E:System.Windows.Freezable.Changed" /> 的 <see cref="T:System.Windows.Freezable" /> 事件，並叫用它的 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。 在任何 API 修改未以相依性屬性儲存的類別成員之後，衍生自 <see cref="T:System.Windows.Freezable" /> 的類別應該在 API 的結尾呼叫這個方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫這個任何的方法 API 修改不會儲存為類別成員結尾<see cref="T:System.Windows.DependencyProperty" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認 <see cref="T:System.Windows.Freezable" /> 未凍結，而且是從有效的執行緒內容進行存取。 在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 將資料寫入至非相依性屬性的資料成員之前，<see cref="T:System.Windows.Freezable" /> 繼承者應該在 API 的開頭呼叫這個方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>確認的執行緒內容可供存取，而且它會擲回例外狀況，如果<xref:System.Windows.Freezable>已凍結執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> 執行個體已凍結，無法寫入它的成員。</exception>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Freezable" />應該呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />之前嘗試寫入不相依性屬性的任何成員。 如果您呼叫<see cref="M:System.Windows.Freezable.WritePreamble" />中[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，您可以省略呼叫<see cref="M:System.Windows.Freezable.ReadPreamble" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>