<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bab463ec19438453c1818b250c1ed9bf8e3cb1f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490968" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="68804-101">在特定行為方面定義相依性屬性，因為它會套用到特定的類型，包括註冊時所用的條件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="68804-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-102">屬性中繼資料可以定義和呼叫時，相依性屬性註冊期間使用<xref:System.Windows.DependencyProperty.Register%2A>方法 （或附加的屬性或唯讀相依性屬性的變化），或之後呼叫時的原始擁有者註冊<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="68804-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="68804-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> 也會考慮屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="68804-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="68804-104">這個類別是可用於每個這些呼叫的具象基底類別。</span><span class="sxs-lookup"><span data-stu-id="68804-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="68804-105">不過，是很常見，指定中繼資料使用的其中一個衍生的類別例如<xref:System.Windows.FrameworkPropertyMetadata>。</span><span class="sxs-lookup"><span data-stu-id="68804-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="68804-106">這些衍生的類別支援更詳細的中繼資料當做布林值屬性值，可用來偵測，或啟用只會在實作某些屬性系統和版面配置行為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]架構層級。</span><span class="sxs-lookup"><span data-stu-id="68804-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="68804-107">這個類別的數個屬性是讀寫物件模型中，但只能在例如使用中的屬性系統作業的執行個體之前寫入<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="68804-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="68804-108">每個屬性可能也已設定的建構函式，但會公開讓<xref:System.Windows.PropertyMetadata.Merge%2A>方法實作可以設定它們。</span><span class="sxs-lookup"><span data-stu-id="68804-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="68804-109">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="68804-109">XAML Text Usage</span></span>  
 <span data-ttu-id="68804-110">此型別和成員，這種不通常會以[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="68804-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="68804-111">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68804-112">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="68804-113">指定相依性屬性的預設值，通常做為某些特定型別的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-114">使用要套用這個中繼資料之相依性屬性的指定預設值，初始化 <see cref="T:System.Windows.PropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-115">提供值的型別`defaultValue`必須相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="68804-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="68804-116">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為 （不符會引發執行階段例外狀況） 的編譯期間無法偵測不相符。</span><span class="sxs-lookup"><span data-stu-id="68804-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="68804-117">預設的每一個無參數建構函式中，雖然`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="68804-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="68804-118">嘗試執行此作業將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="68804-119">
            <paramref name="defaultValue" /> 無法設定為值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-119">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="68804-120">處理常式實作的參考，當屬性的有效值變更時會由屬性系統呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-121">使用指定的 <see cref="T:System.Windows.PropertyMetadata" /> 實作參考，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="68804-122">相依性屬性的預設值，通常是做為某些特定型別的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-122">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="68804-123">處理常式實作的參考，當屬性的有效值變更時會由屬性系統呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-124">使用指定的預設值和 <see cref="T:System.Windows.PropertyMetadata" /> 實作參考，初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-125">提供值的型別`defaultValue`必須相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="68804-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="68804-126">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為 （不符會引發執行階段例外狀況） 的編譯期間無法偵測不相符。</span><span class="sxs-lookup"><span data-stu-id="68804-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="68804-127">預設的每一個無參數建構函式中，雖然`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="68804-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="68804-128">嘗試執行此作業將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="68804-129">
            <paramref name="defaultValue" /> 無法設定為值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-129">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="68804-130">相依性屬性的預設值，通常是做為某些特定型別的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-130">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="68804-131">處理常式實作的參考，當屬性的有效值變更時會由屬性系統呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="68804-132">處理常式實作的參考，當屬性系統針對這個屬性呼叫 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 時便會呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-133">使用指定的預設值和回呼，初始化 <see cref="T:System.Windows.PropertyMetadata" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-134">如果您想要指定<xref:System.Windows.CoerceValueCallback>而非<xref:System.Windows.PropertyChangedCallback>，您可以傳遞`null`如`propertyChangedCallback`參數。</span><span class="sxs-lookup"><span data-stu-id="68804-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="68804-135">提供值的型別`defaultValue`必須相符或相關相依性屬性，此中繼資料將會套用到原始的註冊中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="68804-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="68804-136">很難偵錯時，中繼資料預設值的類型與套用至相依性屬性的型別之間的不符，因為 （不符會引發執行階段例外狀況） 的編譯期間無法偵測不相符。</span><span class="sxs-lookup"><span data-stu-id="68804-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="68804-137">預設的每一個無參數建構函式中，雖然`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="68804-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="68804-138">嘗試執行此作業將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="68804-139">
            <paramref name="defaultValue" /> 無法設定為值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-139">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68804-140">取得或設定在這個中繼資料中指定之 <see cref="T:System.Windows.CoerceValueCallback" /> 實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68804-141">
            <see cref="T:System.Windows.CoerceValueCallback" /> 實作參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-142">屬性中繼資料中的回呼不包含的類型，通常是公用成員，因此這個屬性的值不是很重要，大部分的情況下，只要使用現有的相依性屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="68804-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="68804-143">這個屬性會公開的其中一個原因是，讓中繼資料的子類別可以執行其所需的合併邏輯，如果基底中繼資料和覆寫/新增的中繼資料指定<xref:System.Windows.CoerceValueCallback>。</span><span class="sxs-lookup"><span data-stu-id="68804-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="68804-144">不過，預設值合併邏輯<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>是要取代舊的金鑰。</span><span class="sxs-lookup"><span data-stu-id="68804-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="68804-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 是物件模型中定義為讀寫。</span><span class="sxs-lookup"><span data-stu-id="68804-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="68804-146">這種情形<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>可以初始化之後調整<xref:System.Windows.PropertyMetadata>物件本身。</span><span class="sxs-lookup"><span data-stu-id="68804-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="68804-147">不過，一旦中繼資料的一部分的呼叫消耗<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 屬性系統會將密封該中繼資料執行個體和屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="68804-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="68804-148">嘗試設定<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68804-149">一旦套用至相依性屬性作業，便無法設定中繼資料屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-149">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68804-150">取得或設定相依性屬性的預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-150">Gets or sets the default value of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68804-151">屬性的預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-151">The default value of the property.</span>
          </span>
          <span data-ttu-id="68804-152">上的預設值<see cref="T:System.Windows.PropertyMetadata" />建立具有無參數建構函式的執行個體將會<see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 是物件模型中定義為讀寫。</span><span class="sxs-lookup"><span data-stu-id="68804-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="68804-154">這種情形<xref:System.Windows.PropertyMetadata.DefaultValue%2A>可以初始化之後調整<xref:System.Windows.PropertyMetadata>物件本身。</span><span class="sxs-lookup"><span data-stu-id="68804-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="68804-155">不過，一旦中繼資料的一部分的呼叫消耗<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 屬性系統會將密封該中繼資料執行個體和屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="68804-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="68804-156">嘗試設定<xref:System.Windows.PropertyMetadata.DefaultValue%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="68804-157">預設的每一個無參數建構函式中，雖然`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>無法使用其中一個設定<xref:System.Windows.PropertyMetadata.DefaultValue%2A>或建構函式。</span><span class="sxs-lookup"><span data-stu-id="68804-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="68804-158">嘗試執行此作業將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="68804-159">XAML 文字使用方式</span><span class="sxs-lookup"><span data-stu-id="68804-159">XAML Text Usage</span></span>  
 <span data-ttu-id="68804-160">這個類型的成員不會通常用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="68804-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="68804-161">一旦建立，便無法設定為值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68804-162">一旦套用至相依性屬性作業，便無法設定中繼資料屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-162">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68804-163">取得值，這個值判斷中繼資料是否已經以某種方式套用至屬性，導致中繼資料執行個體的不可變狀態。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68804-164">如果中繼資料執行個體是不可變的則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-164">
              <see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-165">各種屬性<xref:System.Windows.PropertyMetadata>，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，為讀寫物件模型中定義。</span><span class="sxs-lookup"><span data-stu-id="68804-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="68804-166">這是讓這些屬性可以初始化之後調整<xref:System.Windows.PropertyMetadata>物件本身。</span><span class="sxs-lookup"><span data-stu-id="68804-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="68804-167">不過，一旦中繼資料套用至相依性屬性呼叫的一部分<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 屬性系統會將密封該中繼資料執行個體和屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="68804-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="68804-168">其中一個呼叫，當時<xref:System.Windows.PropertyMetadata.OnApply%2A>呼叫時，且這個屬性的值設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="68804-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68804-169">下列範例會檢查<xref:System.Windows.PropertyMetadata.IsSealed%2A>之前設定作業中的自訂中繼資料屬性。</span><span class="sxs-lookup"><span data-stu-id="68804-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="68804-170">要與這個執行個體值合併的基底中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-170">The base metadata to merge with this instance's values.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="68804-171">要套用這個中繼資料的相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-171">The dependency property to which this metadata is being applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-172">合併這個中繼資料和基底中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-172">Merges this metadata with the base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-173">正在覆寫中繼資料時在內部使用這個方法 (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="68804-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68804-174">下列範例會將一個額外的屬性加入至屬性中繼資料的自訂中繼資料類型的合併。</span><span class="sxs-lookup"><span data-stu-id="68804-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68804-175">
            <para>類別衍生自的實作<see cref="T:System.Windows.PropertyMetadata" />應該覆寫這個方法，以負責他們已在其實作任何中繼資料屬性。比方說，您的實作可能已經加入新的旗標型列舉值，而<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />實作應該可以正確結合這些旗標。請務必呼叫基底實作之前您實作程式碼，因為基底實作會負責合併上已定義的所有屬性<see cref="T:System.Windows.PropertyMetadata" />型別。合併的確切行為是由您決定。您可以選擇有合併的值，請還原成基底值，如果衍生的中繼資料已保留預設值或根據您已將其加入您特定的中繼資料類別和其意義的屬性類型的其他行為。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-175">
              <para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="68804-176">已套用這個中繼資料的相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-176">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="68804-177">如果這是型別特定的中繼資料，則為與這個中繼資料相關聯的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-177">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="68804-178">如果這是預設中繼資料，則該值是 null 參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-178">If this is default metadata, this value is a null reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68804-179">在這個中繼資料已套用至屬性時呼叫，表示要密封中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-180">子類別應該確保任何可變動性的資料結構<xref:System.Windows.PropertyMetadata>子類別應該標示為不可變一次<xref:System.Windows.PropertyMetadata.OnApply%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="68804-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="68804-181">這會呼叫後之中繼資料套用至屬性系統作業 （註冊、 將擁有者新增、 覆寫中繼資料）。</span><span class="sxs-lookup"><span data-stu-id="68804-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68804-182">取得或設定在這個中繼資料中指定之 <see cref="T:System.Windows.PropertyChangedCallback" /> 實作的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68804-183">
            <see cref="T:System.Windows.PropertyChangedCallback" /> 實作參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68804-184">屬性中繼資料中的回呼不在定義的型別，通常是公用成員，因此這個屬性的值不是很重要，大部分的情況下，只要使用現有的相依性屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="68804-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="68804-185">這個屬性會公開的其中一個原因是，讓中繼資料類別可以執行其所需的合併邏輯，如果基底中繼資料和覆寫/新增的中繼資料指定<xref:System.Windows.PropertyChangedCallback>。</span><span class="sxs-lookup"><span data-stu-id="68804-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="68804-186">預設合併邏輯會維護所有<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>實作中的資料表和呼叫每一個人，在執行第一個階層架構中最深的類別所建立的回呼。</span><span class="sxs-lookup"><span data-stu-id="68804-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="68804-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 是物件模型中定義為讀寫。</span><span class="sxs-lookup"><span data-stu-id="68804-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="68804-188">這種情形<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>可以初始化之後調整<xref:System.Windows.PropertyMetadata>物件本身。</span><span class="sxs-lookup"><span data-stu-id="68804-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="68804-189">不過，一旦中繼資料的一部分的呼叫消耗<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 屬性系統會將密封該中繼資料執行個體和屬性現在會被視為不變。</span><span class="sxs-lookup"><span data-stu-id="68804-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="68804-190">嘗試設定<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="68804-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68804-191">一旦套用至相依性屬性作業，便無法設定中繼資料屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="68804-191">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>