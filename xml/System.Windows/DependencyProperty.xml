<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cd5b6a2bc5d76e65fbad41cf01060484fb71b52e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="956a3-101">代表可以透過方法設定的屬性，例如樣式、資料繫結、動畫和繼承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="956a3-101">Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-102">A<xref:System.Windows.DependencyProperty>支援中的下列功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="956a3-102">A <xref:System.Windows.DependencyProperty> supports the following capabilities in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span></span>  
  
-   <span data-ttu-id="956a3-103">這個屬性可以設定樣式。</span><span class="sxs-lookup"><span data-stu-id="956a3-103">The property can be set in a style.</span></span> <span data-ttu-id="956a3-104">如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-104">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
-   <span data-ttu-id="956a3-105">這個屬性可以透過資料繫結設定。</span><span class="sxs-lookup"><span data-stu-id="956a3-105">The property can be set through data binding.</span></span> <span data-ttu-id="956a3-106">如需資料繫結相依性屬性的詳細資訊，請參閱[How to： 將控制項繫結屬性的兩個](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-106">For more information about data binding dependency properties, see [How to: Bind the Properties of Two Controls](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span></span>  
  
-   <span data-ttu-id="956a3-107">這個屬性可以設定的動態資源參考。</span><span class="sxs-lookup"><span data-stu-id="956a3-107">The property can be set with a dynamic resource reference.</span></span> <span data-ttu-id="956a3-108">如需詳細資訊，請參閱 [XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-108">For more information, see [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
-   <span data-ttu-id="956a3-109">屬性可以在自動繼承其值從父元素中的項目樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="956a3-109">The property can inherit its value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="956a3-110">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-110">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
-   <span data-ttu-id="956a3-111">屬性可以動畫顯示。</span><span class="sxs-lookup"><span data-stu-id="956a3-111">The property can be animated.</span></span> <span data-ttu-id="956a3-112">如需詳細資訊，請參閱 [動畫概觀](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-112">For more information, see [Animation Overview](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
-   <span data-ttu-id="956a3-113">已變更之屬性的舊值和屬性值可以強制轉型時，可報告屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-113">The property can report when the previous value of the property has been changed and the property value can be coerced.</span></span> <span data-ttu-id="956a3-114">如需詳細資訊，請參閱[相依性屬性回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-114">For more information, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="956a3-115">屬性會報告資訊[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如變更屬性值是否需要重新撰寫的項目視覺效果的版面配置系統。</span><span class="sxs-lookup"><span data-stu-id="956a3-115">The property reports information to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], such as whether changing a property value should require the layout system to recompose the visuals for an element.</span></span>  
  
-   <span data-ttu-id="956a3-116">屬性會獲得中的支援[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-116">The property receives support in the [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].</span></span>  <span data-ttu-id="956a3-117">例如，在編輯內容**屬性**視窗。</span><span class="sxs-lookup"><span data-stu-id="956a3-117">For example, the property can be edited in the **Properties** window.</span></span>  
  
 <span data-ttu-id="956a3-118">若要了解有關相依性屬性的詳細資訊，請參閱[相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-118">To learn more about dependency properties, see [Dependency Properties Overview](~/docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="956a3-119">如果您想屬性上您在上述清單中支援的功能的自訂類型時，您應該建立相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-119">If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</span></span>  <span data-ttu-id="956a3-120">若要深入了解如何建立自訂的相依性屬性，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-120">To learn how to create custom dependency properties, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="956a3-121">附加的屬性是屬性，可讓任何要報告其資訊所定義之附加的屬性的型別物件。</span><span class="sxs-lookup"><span data-stu-id="956a3-121">An attached property is a property that enables any object to report information to the type that defines the attached property.</span></span> <span data-ttu-id="956a3-122">在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，繼承自任何型別<xref:System.Windows.DependencyObject>可以使用附加的屬性，不論是否類型繼承自定義屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-122">In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], any type that inherits from <xref:System.Windows.DependencyObject> can use an attached property regardless of whether the type inherits from the type that defines the property.</span></span> <span data-ttu-id="956a3-123">附加的屬性是一項功能[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語言。</span><span class="sxs-lookup"><span data-stu-id="956a3-123">An attached property is a feature of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.</span></span>  <span data-ttu-id="956a3-124">若要設定附加的屬性在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*ownerType*。*propertyName*語法。</span><span class="sxs-lookup"><span data-stu-id="956a3-124">To set an attached property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], use the *ownerType*.*propertyName* syntax.</span></span> <span data-ttu-id="956a3-125">附加屬性的範例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-125">An example of an attached property is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="956a3-126">如果您想要建立此屬性，可以用在所有<xref:System.Windows.DependencyObject>類型，則您應該建立附加的屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-126">If you want to create a property that can be used on all <xref:System.Windows.DependencyObject> types, then you should create an attached property.</span></span> <span data-ttu-id="956a3-127">若要深入了解附加的屬性，包括如何建立它們，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-127">To learn more about attached properties, including how to create them, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="956a3-128">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="956a3-128">XAML Attribute Usage</span></span>  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a><span data-ttu-id="956a3-129">XAML 值</span><span class="sxs-lookup"><span data-stu-id="956a3-129">XAML Values</span></span>  
 `dependencyPropertyName`  
 <span data-ttu-id="956a3-130">字串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>所需的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-130">A string that specifies the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> of the desired dependency property.</span></span> <span data-ttu-id="956a3-131">這可以前面加上 XML 命名空間前置詞如果屬性不是預設 XML 命名空間 (如需詳細資訊，請參閱[XAML 命名空間和 WPF XAML 命名空間對應](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)</span><span class="sxs-lookup"><span data-stu-id="956a3-131">This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span></span>  
  
 <span data-ttu-id="956a3-132">`ownerType`.`dependencyPropertyName`</span><span class="sxs-lookup"><span data-stu-id="956a3-132">`ownerType`.`dependencyPropertyName`</span></span>  
 <span data-ttu-id="956a3-133">字串，指定擁有者類型的相依性屬性，點 （.），然後在<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="956a3-133">A string that specifies an owner type of a dependency property, a dot (.), then the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="956a3-134">`ownerType` 前面可以也有 XML 命名空間前置詞。</span><span class="sxs-lookup"><span data-stu-id="956a3-134">`ownerType` can also be preceded by an XML namespace prefix.</span></span> <span data-ttu-id="956a3-135">這種用法是晚期繫結樣式和範本，因為剖析內容必須指定相依性屬性的擁有者的特殊`TargetType`尚不知道。</span><span class="sxs-lookup"><span data-stu-id="956a3-135">This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the `TargetType` is not yet known.</span></span> <span data-ttu-id="956a3-136">如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-136">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="956a3-137">`attachedPropertyOwnerType` *.*</span><span class="sxs-lookup"><span data-stu-id="956a3-137">`attachedPropertyOwnerType` *.*</span></span> `attachedPropertyName`  
 <span data-ttu-id="956a3-138">字串，指定附加的屬性，點 （.），然後附加的屬性名稱的擁有者。</span><span class="sxs-lookup"><span data-stu-id="956a3-138">A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</span></span> <span data-ttu-id="956a3-139">`attachedPropertyOwnerType` 前面可以也有 XML 命名空間前置詞。</span><span class="sxs-lookup"><span data-stu-id="956a3-139">`attachedPropertyOwnerType` can also be preceded by an XML namespace prefix.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-140">加入其他類型，以作為已註冊至某個類型之相依性屬性的擁有者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-140">Adds another type as an owner of a dependency property that has already been registered to a type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="956a3-141">要加入為此相依性屬性之擁有者的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-141">The type to add as an owner of this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-142">加入其他類型，作為已註冊之相依性屬性的擁有者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-142">Adds another type as an owner of a dependency property that has already been registered.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-143">原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-143">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="956a3-144">應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-144">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-145">這個方法可讓您對屬性系統，以識別一開始未登錄特定相依性屬性的型別上的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-145">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="956a3-146">一般而言，<xref:System.Windows.DependencyProperty.AddOwner%2A>用來將相依性屬性加入至已經不會公開透過 managed 的類別繼承該相依性屬性的類別 (類別繼承會導致在衍生類別繼承的包裝函式屬性，因此會提供一般成員資料表的相依性屬性的存取已經）。</span><span class="sxs-lookup"><span data-stu-id="956a3-146">Typically, <xref:System.Windows.DependencyProperty.AddOwner%2A> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</span></span> <span data-ttu-id="956a3-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> 可讓屬性系統，以識別一開始未登錄該相依性屬性的型別上的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</span></span>  
  
 <span data-ttu-id="956a3-148">此簽章不允許指定中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-148">This signature does not allow for specifying metadata.</span></span>  <span data-ttu-id="956a3-149">當您使用這個方法時，中繼資料會自動產生新的<xref:System.Windows.DependencyProperty>和擁有者型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-149">When you use this method, the metadata is automatically generated for the new <xref:System.Windows.DependencyProperty> and its owner type.</span></span> <span data-ttu-id="956a3-150">自動產生中繼資料是從所有已定義這個屬性的基底類型的合併中繼資料的結果。</span><span class="sxs-lookup"><span data-stu-id="956a3-150">The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</span></span> <span data-ttu-id="956a3-151">如果沒有合併中繼資料可用，則會使用屬性的預設中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-151">If no merged metadata is available, then the default metadata for the property is used.</span></span> <span data-ttu-id="956a3-152">如果屬性已註冊使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，則預設中繼資料是時建立的中繼資料相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="956a3-152">If the property is registered by using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, then the default metadata is the same as the metadata that is created when <xref:System.Windows.DependencyProperty.RegisterAttached%2A> was called.</span></span> <span data-ttu-id="956a3-153">否則，<xref:System.Windows.PropertyMetadata>物件會透過<xref:System.Windows.PropertyMetadata.DefaultValue%2A>屬性設定為屬性類型的預設和所有其他屬性<xref:System.Windows.PropertyMetadata>設`null`。</span><span class="sxs-lookup"><span data-stu-id="956a3-153">Otherwise, the <xref:System.Windows.PropertyMetadata> object is created with the <xref:System.Windows.PropertyMetadata.DefaultValue%2A> property set to the property type's default and all other properties of the <xref:System.Windows.PropertyMetadata> is set to `null`.</span></span> <span data-ttu-id="956a3-154">使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>簽章，如果您想要加入至提供的類型，提供中繼資料版本的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-154">Use the <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</span></span>  
  
 <span data-ttu-id="956a3-155">這個方法的傳回值通常用來宣告及公開之相依性屬性所儲存的相依性屬性的識別項。</span><span class="sxs-lookup"><span data-stu-id="956a3-155">The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</span></span> <span data-ttu-id="956a3-156">識別項提供的相依性屬性的存取，如果您想要呼叫屬性系統[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]針對相依性屬性，特別是因為它存在於加入的擁有者類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-156">The identifier provides access to the dependency property if you want to call property system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] against the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="956a3-157">原始的擁有者和加入的擁有者相同的屬性名稱應該用來表示類似的功能。</span><span class="sxs-lookup"><span data-stu-id="956a3-157">The same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="956a3-158">您應該使用<xref:System.Windows.DependencyProperty>的傳回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法定義相依性屬性的識別項，並宣告[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-158">You should use the <xref:System.Windows.DependencyProperty> return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> method to define the dependency property identifier, and also to declare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="956a3-159"><xref:System.Windows.DependencyProperty.AddOwner%2A>建立宣告內的相依性屬性時，上述建議的方法使用[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-159">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating the dependency properties that are declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="956a3-160">比方說，兩者<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-160">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="956a3-161"><xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性至屬性系統，藉由呼叫<xref:System.Windows.DependencyProperty.AddOwner%2A>根據原始的擁有者<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性的識別項。</span><span class="sxs-lookup"><span data-stu-id="956a3-161"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> based on the original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="956a3-162"><xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立新的靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上加入的擁有者，該屬性和`BorderBrush`也已經宣告屬性的包裝函式。</span><span class="sxs-lookup"><span data-stu-id="956a3-162">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a new static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="956a3-163">要加入為此相依性屬性之擁有者的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-163">The type to add as owner of this dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-164">限定存在於所提供類型之相依性屬性的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-164">The metadata that qualifies the dependency property as it exists on the provided type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-165">加入另一個類型作為已註冊的相依性屬性的擁有者，並提供在所提供擁有者類型上存在之相依性屬性的相依性屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-165">Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-166">原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-166">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="956a3-167">應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-167">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-168">這個方法可讓您對屬性系統，以識別一開始未登錄特定相依性屬性的型別上的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-168">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="956a3-169">這個方法的傳回值用於宣告，並公開 （expose） 的相依性屬性，特別是存在於加入的擁有者類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-169">The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="956a3-170">一般而言，原始的擁有者和加入的擁有者相同的屬性名稱應該用來表示類似的功能。</span><span class="sxs-lookup"><span data-stu-id="956a3-170">Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="956a3-171">若要公開 （expose） 的識別碼，以及當新的最佳作法是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-171">It is good practice to expose the identifiers, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="956a3-172"><xref:System.Windows.DependencyProperty.AddOwner%2A>上述建議的方法在建立時使用[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]內宣告[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-172">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="956a3-173">比方說，兩者<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-173">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="956a3-174"><xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性至屬性系統，藉由呼叫<xref:System.Windows.DependencyProperty.AddOwner%2A>原始的擁有者上<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性的識別項。</span><span class="sxs-lookup"><span data-stu-id="956a3-174"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> on original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="956a3-175"><xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上加入的擁有者，該屬性和`BorderBrush`也已經宣告屬性的包裝函式。</span><span class="sxs-lookup"><span data-stu-id="956a3-175">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>)for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 <span data-ttu-id="956a3-176">加入的擁有者相依性屬性的識別項應該使用作業例如<xref:System.Windows.DependencyObject.GetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-176">The added owner's dependency property identifier should be used for operations such as <xref:System.Windows.DependencyObject.GetValue%2A>.</span></span> <span data-ttu-id="956a3-177">不過，與類型或已加入為具有不同的中繼資料擁有者仍類別的執行個體相關的特定類型的作業會傳回預期的結果，即使原始 （未加入擁有者） 中所指定相依性屬性的識別項這類方法呼叫<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-177">However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</span></span> <span data-ttu-id="956a3-178">加入的擁有者的中繼資料由址<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫本身，不一定是以獨佔方式所加入的擁有者類別識別項欄位參考。</span><span class="sxs-lookup"><span data-stu-id="956a3-178">The metadata for the added owner is perpetuated by the <xref:System.Windows.DependencyProperty.AddOwner%2A> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</span></span> <span data-ttu-id="956a3-179">不過，公開的識別項，以及當新的最佳作法是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>，因為這麼建立之間的差異[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]屬性的表示法。</span><span class="sxs-lookup"><span data-stu-id="956a3-179">Nevertheless, it is good practice to expose the  identifier, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>, because failing to do so creates disparity between the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representations of your properties.</span></span>  
  
 <span data-ttu-id="956a3-180">為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-180">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="956a3-181">將會保存任何原始基底中繼資料中所指定的特性。</span><span class="sxs-lookup"><span data-stu-id="956a3-181">Any characteristics that were specified in the original base metadata will persist.</span></span> <span data-ttu-id="956a3-182">只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。</span><span class="sxs-lookup"><span data-stu-id="956a3-182">Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="956a3-183">某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果有指定新的中繼資料中會被取代。</span><span class="sxs-lookup"><span data-stu-id="956a3-183">Some characteristics, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are replaced if they are specified in the new metadata.</span></span> <span data-ttu-id="956a3-184">其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。</span><span class="sxs-lookup"><span data-stu-id="956a3-184">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="956a3-185">最後，合併行為取決於用來覆寫時，因此這裡描述的行為是所使用的現有屬性中繼資料類別的屬性中繼資料型別[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-185">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="956a3-186">如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-186">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-187">取得相依性屬性的預設中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-187">Gets the default metadata of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-188">相依性屬性的預設中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-188">The default metadata of the dependency property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-189">預設中繼資料不是可用於該特定物件或衍生型別的物件沒有替代的中繼資料，提供明確的屬性中繼資料<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="956a3-189">The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call.</span></span>  
  
 <span data-ttu-id="956a3-190">如果原始的擁有者中繼資料用於第一個<xref:System.Windows.DependencyProperty.Register%2A>建立相依性屬性，則該中繼資料會做為傳回的呼叫<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-190">If the original owner applied metadata to the first <xref:System.Windows.DependencyProperty.Register%2A> call that established the dependency property, then that metadata is returned as <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="956a3-191">如果沒有中繼資料已套用至原始<xref:System.Windows.DependencyProperty.Register%2A>呼叫，則預設中繼資料會產生從<xref:System.Windows.DependencyProperty.Register%2A>呼叫，這個值會當成<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-191">If no metadata was applied in the original <xref:System.Windows.DependencyProperty.Register%2A> call, then default metadata is generated from within the <xref:System.Windows.DependencyProperty.Register%2A> call and this value is returned as the <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="956a3-192">具有相關聯的預設中繼資料的主要目的<xref:System.Windows.DependencyProperty>提供任何上這個屬性的預設值是<xref:System.Windows.DependencyObject>或衍生型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-192">The main purpose of having default metadata associated with a <xref:System.Windows.DependencyProperty> is to supply a default value for this property on any <xref:System.Windows.DependencyObject> or a derived type.</span></span>  
  
 <span data-ttu-id="956a3-193">對於未附加的屬性，這個屬性所傳回的中繼資料類型無法轉換成衍生類型的<xref:System.Windows.PropertyMetadata>類型，即使屬性最初註冊與衍生的中繼資料型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-193">For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <xref:System.Windows.PropertyMetadata> type, even if the property was originally registered with a derived metadata type.</span></span> <span data-ttu-id="956a3-194">如果您想原先已註冊的中繼資料，包括其原始的中繼資料可能是衍生型別時，呼叫<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>相反地，傳遞原始註冊型別做為參數。</span><span class="sxs-lookup"><span data-stu-id="956a3-194">If you want the originally registered metadata including its original possibly derived metadata type, call <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> instead, passing the original registering type as a parameter.</span></span>  
  
 <span data-ttu-id="956a3-195">為附加屬性，這個屬性所傳回的中繼資料的類型會比對中原始提供的類型<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊方法。</span><span class="sxs-lookup"><span data-stu-id="956a3-195">For attached properties, the type of the metadata returned by this property will match the type given in the original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> registration method.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="956a3-196">傳回這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-196">Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-197">這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-197">The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-198">對屬性系統會使用它自己的唯一識別碼<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，且該屬性的值傳回的<xref:System.Windows.DependencyProperty.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-198">The property system uses its own unique identifier <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, and the value of that property is returned by <xref:System.Windows.DependencyProperty.GetHashCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-199">傳回與特定類型的此相依性屬性相關聯的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-199">Returns the metadata associated with this dependency property as it exists for a particular type.</span>
          </span>
          <span data-ttu-id="956a3-200">這可以是第一次註冊相依性屬性的類型 (之後會加一)，或透過繼承取得相依性屬性但特別覆寫中繼資料的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-200">This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="956a3-201">要從中擷取相依性屬性中繼資料的特定類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-201">The specific type from which to retrieve the dependency property metadata.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-202">傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的現有類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-202">Returns the metadata for this dependency property as it exists on a specified existing type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-203">屬性中繼資料物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-203">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-204">指定的類型或物件參考做為型別是必要的因為中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>alter 相依性屬性的中繼資料存在於型別上的呼叫。</span><span class="sxs-lookup"><span data-stu-id="956a3-204">Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that alter the metadata of the dependency property as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-205">下列範例會取得其類型為基礎的相依性屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-205">The following example gets metadata for a dependency property based on its type.</span></span> <span data-ttu-id="956a3-206">型別透過使用`typeof`運算子。</span><span class="sxs-lookup"><span data-stu-id="956a3-206">The type is obtained by using a `typeof` operator.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">
          <span data-ttu-id="956a3-207">檢查了相依性物件的類型，以判斷中繼資料應該來自於相依性屬性的哪一個特定類型版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-207">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-208">傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的物件執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-208">Returns the metadata for this dependency property as it exists on the specified object instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-209">屬性中繼資料物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-209">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-210">指定的類型或物件參考，所以必須任何指定的相依性屬性的中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以修正屬性中繼資料的呼叫型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-210">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
 <span data-ttu-id="956a3-211">當您要求執行個體為基礎的屬性中繼資料時，您實際上只傳遞執行個體，以便可以在內部評估它的型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-211">When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</span></span> <span data-ttu-id="956a3-212">相依性屬性中繼資料不會變化每個執行個體。它永遠是一致的任何指定的型別屬性組合。</span><span class="sxs-lookup"><span data-stu-id="956a3-212">Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-213">下列範例會取得根據特定的相依性屬性的中繼資料<xref:System.Windows.DependencyObject>執行個體。</span><span class="sxs-lookup"><span data-stu-id="956a3-213">The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">
          <span data-ttu-id="956a3-214">記錄需要相依性屬性中繼資料之相依性物件類型的特定物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-214">A specific object that records the dependency object type from which the dependency property metadata is desired.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-215">傳回存在於所指定類型之這個相依性屬性的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-215">Returns the metadata for this dependency property as it exists on a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-216">屬性中繼資料物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-216">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-217">指定的類型或物件參考，所以必須任何指定的相依性屬性的中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以修正屬性中繼資料的呼叫型別。</span><span class="sxs-lookup"><span data-stu-id="956a3-217">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-218">下列範例會取得中繼資料相依性屬性，根據其<xref:System.Windows.DependencyObjectType>。</span><span class="sxs-lookup"><span data-stu-id="956a3-218">The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-219">取得可唯一識別相依性屬性的內部產生值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-219">Gets an internally generated value that uniquely identifies the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-220">唯一數值識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-220">A unique numeric identifier.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-221">這個值不是整數， [!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-221">This value is an integer, not a [!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)].</span></span> <span data-ttu-id="956a3-222">一般而言，並不需要，使用此索引值，而且沒有任何索引資料表的存取權的所有相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-222">Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</span></span> <span data-ttu-id="956a3-223">依其識別項欄位時，應該改為參考相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-223">Dependency properties should instead be referenced by their identifier fields.</span></span>  
  
 <span data-ttu-id="956a3-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> 在內部用來更快速存取使用的資料結構<xref:System.Windows.DependencyProperty.GlobalIndex%2A>為以零為起始的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="956a3-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> is used internally for faster access to data structures that use the <xref:System.Windows.DependencyProperty.GlobalIndex%2A> as a zero-based array index.</span></span> <span data-ttu-id="956a3-225">類似的使用方式可能會有應用程式的設計工具或工具。</span><span class="sxs-lookup"><span data-stu-id="956a3-225">A similar usage might have applications for designers or tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="956a3-226">要檢查的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-226">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-227">根據原始相依性屬性註冊所提供的屬性型別檢查這個相依性屬性的型別，判斷此型別是否接受指定的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-227">Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-228">如果指定的值為註冊的屬性型別或可接受的衍生型別則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-228">
              <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-229">值為`null`是有效的類型為參考類型的相依性屬性，或<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。</span><span class="sxs-lookup"><span data-stu-id="956a3-229">A value of `null` is a valid type for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="956a3-230">相依性屬性的未參考情況下也未<xref:System.Nullable%601>型別，<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="956a3-230">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-231">下列範例會使用<xref:System.Windows.DependencyProperty.IsValidType%2A>之前先呼叫檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-231">The following example uses <xref:System.Windows.DependencyProperty.IsValidType%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="956a3-232">要檢查的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-232">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-233">透過基本型別檢查，判斷屬性型別是否接受所提供的值，並在必要時判斷此值是否位於該型別的允許值範圍內。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-233">Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-234">如果此值可被接受且屬於正確型別或衍生型別，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-234">
              <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-235">相依性屬性，允許的範圍，該類型的值可以透過指定<xref:System.Windows.ValidateValueCallback>提供相依性屬性註冊中。</span><span class="sxs-lookup"><span data-stu-id="956a3-235">For a dependency property, an allowed range of values for that type can be specified through a <xref:System.Windows.ValidateValueCallback> that is provided in the dependency property registration.</span></span>  
  
 <span data-ttu-id="956a3-236">這個方法會呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>內部。</span><span class="sxs-lookup"><span data-stu-id="956a3-236">This method calls <xref:System.Windows.DependencyProperty.IsValidType%2A> internally.</span></span> <span data-ttu-id="956a3-237">如果有問題的相依性屬性沒有<xref:System.Windows.ValidateValueCallback>，則呼叫這個方法會有效等同於呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-237">If the dependency property in question has no <xref:System.Windows.ValidateValueCallback>,then calling this method is effectively equivalent to calling <xref:System.Windows.DependencyProperty.IsValidType%2A>.</span></span> <span data-ttu-id="956a3-238">如果沒有相依性屬性<xref:System.Windows.ValidateValueCallback>，而且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`true`，然後在回呼中實作時，會傳回的值。</span><span class="sxs-lookup"><span data-stu-id="956a3-238">If the dependency property does have a <xref:System.Windows.ValidateValueCallback>, and if <xref:System.Windows.DependencyProperty.IsValidType%2A> would have returned `true`, then the value returned will be as implemented in the callback.</span></span>  
  
 <span data-ttu-id="956a3-239">Null 值是有效的值為參考類型的相依性屬性，或<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。</span><span class="sxs-lookup"><span data-stu-id="956a3-239">A null value is a valid value for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="956a3-240">相依性屬性的未參考情況下也未<xref:System.Nullable%601>型別，<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="956a3-240">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-241">下列範例會使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>之前先呼叫檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-241">The following example uses <xref:System.Windows.DependencyProperty.IsValidValue%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-242">取得相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-242">Gets the name of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-243">屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-243">The name of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-244">這個屬性會取得名稱做為提供`name`期間註冊相依性屬性的參數。</span><span class="sxs-lookup"><span data-stu-id="956a3-244">This property gets the name provided as the `name` parameter during dependency property registration.</span></span> <span data-ttu-id="956a3-245">這個名稱是不可變的且無法`null`或空字串。</span><span class="sxs-lookup"><span data-stu-id="956a3-245">This name is immutable, and cannot be `null` or an empty string.</span></span> <span data-ttu-id="956a3-246">重複名稱註冊相同的擁有者類型上不允許，並將會擲回例外狀況，當您嘗試註冊重複。</span><span class="sxs-lookup"><span data-stu-id="956a3-246">Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="956a3-247"><xref:System.Windows.DependencyProperty.Name%2A>相依性的屬性必須遵循的慣例後置詞"Property"減去其相依性屬性的識別項的名稱相符。</span><span class="sxs-lookup"><span data-stu-id="956a3-247">The <xref:System.Windows.DependencyProperty.Name%2A> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</span></span> <span data-ttu-id="956a3-248">如需詳細資訊，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-248">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-249">下列範例會查詢各種特性的相依性屬性的識別項，包括<xref:System.Windows.DependencyProperty.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-249">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.Name%2A>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-250">提供這個相依性屬性出現在所指定類型的執行個體時所要使用的替代中繼資料，相較於初始相依性屬性註冊中所提供的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-250">Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="956a3-251">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-251">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-252">要套用至覆寫類型上相依性屬性的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-252">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-253">當這個相依性屬性出現在所指定類型的執行個體中時，指定其替代中繼資料，並覆寫從基底類型繼承時存在的相依性屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-253">Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-254">應該覆寫相依性屬性中繼資料，再對屬性系統使用的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-254">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="956a3-255">這等同於使用登錄相依性屬性的類別建立特定的執行個體的時間。</span><span class="sxs-lookup"><span data-stu-id="956a3-255">This equates to the time that specific instances are created using the class that registers the dependency property.</span></span> <span data-ttu-id="956a3-256">呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>執行應該只能在靜態建構函式的類型，提供本身為`forType`參數，這個方法，或透過類似的具現化。</span><span class="sxs-lookup"><span data-stu-id="956a3-256">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="956a3-257">嘗試變更中繼資料之後有擁有者類型的執行個體, 將不會引發例外狀況，但將會導致屬性系統中的行為不一致。</span><span class="sxs-lookup"><span data-stu-id="956a3-257">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="956a3-258">使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別中的中繼資料將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="956a3-258">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="956a3-259">為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-259">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="956a3-260">會保存任何原始基底中繼資料中所指定的特性。只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。</span><span class="sxs-lookup"><span data-stu-id="956a3-260">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="956a3-261">某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的中繼資料中指定，會被取代。</span><span class="sxs-lookup"><span data-stu-id="956a3-261">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="956a3-262">其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。</span><span class="sxs-lookup"><span data-stu-id="956a3-262">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="956a3-263">最後，合併行為取決於用來覆寫時，因此這裡描述的行為是所使用的現有屬性中繼資料類別的屬性中繼資料型別[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-263">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="956a3-264">如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-264">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="956a3-265">嘗試覆寫唯讀相依性屬性的中繼資料 (無法使用此簽章完成作業)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-265">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="956a3-266">已經建立相依性屬性的中繼資料，因為它存在於所提供的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-266">Metadata was already established for the dependency property as it exists on the provided type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="956a3-267">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-267">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-268">要套用至覆寫類型上相依性屬性的中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-268">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <param name="key">
          <span data-ttu-id="956a3-269">唯讀相依性屬性的存取索引鍵。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-269">The access key for a read-only dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-270">當它出現在所指定類型的執行個體，覆寫在初始相依性屬性登錄中所提供的中繼資料時，提供唯讀相依性屬性的替代中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-270">Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</span>
          </span>
          <span data-ttu-id="956a3-271">您必須傳遞唯讀相依性屬性的 <see cref="T:System.Windows.DependencyPropertyKey" />，以免引發例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-271">You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-272">此簽章提供基礎實作唯讀相依性屬性的識別項 (<xref:System.Windows.DependencyPropertyKey>) 方法。</span><span class="sxs-lookup"><span data-stu-id="956a3-272">This signature provides underlying implementation for a read-only dependency property identifier (<xref:System.Windows.DependencyPropertyKey>) method.</span></span> <span data-ttu-id="956a3-273">如果覆寫讀寫相依性屬性的中繼資料，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。</span><span class="sxs-lookup"><span data-stu-id="956a3-273">If overriding metadata for a read-write dependency property, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="956a3-274">應該覆寫相依性屬性中繼資料，再對屬性系統使用的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-274">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="956a3-275">這等同於登錄相依性屬性的類別會建立特定物件的時間。</span><span class="sxs-lookup"><span data-stu-id="956a3-275">This equates to the time that specific objects are created for the class that registers the dependency property.</span></span> <span data-ttu-id="956a3-276">呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>執行應該只能在靜態建構函式的類型，提供本身為`forType`參數，這個方法，或透過類似的具現化。</span><span class="sxs-lookup"><span data-stu-id="956a3-276">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="956a3-277">嘗試變更中繼資料之後有擁有者類型的執行個體, 將不會引發例外狀況，但將會導致屬性系統中的行為不一致。</span><span class="sxs-lookup"><span data-stu-id="956a3-277">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="956a3-278">使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別中的中繼資料將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="956a3-278">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="956a3-279">為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-279">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="956a3-280">會保存任何原始基底中繼資料中所指定的特性。只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。</span><span class="sxs-lookup"><span data-stu-id="956a3-280">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="956a3-281">某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的中繼資料中指定，會被取代。</span><span class="sxs-lookup"><span data-stu-id="956a3-281">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="956a3-282">其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。</span><span class="sxs-lookup"><span data-stu-id="956a3-282">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="956a3-283">合併行為取決於用來覆寫的屬性中繼資料類型。</span><span class="sxs-lookup"><span data-stu-id="956a3-283">The merge behavior depends on the property metadata type being used for the override.</span></span> <span data-ttu-id="956a3-284">如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-284">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-285">取得對屬性系統註冊相依性屬性之物件，或將本身作為屬性擁有者加入之物件的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-285">Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-286">註冊屬性或將本身作為屬性擁有者加入的物件類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-286">The type of the object that registered the property or added itself as owner of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-287">在屬性註冊期間提供的這個值。</span><span class="sxs-lookup"><span data-stu-id="956a3-287">This value was provided during property registration.</span></span> <span data-ttu-id="956a3-288">擁有者將會是原始註冊型別是<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.Register%2A>呼叫時或將本身作為擁有者中的案例中加入型別<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="956a3-288">The owner will be either the original registering type in the case of a <xref:System.Windows.DependencyProperty> identifier generated from a <xref:System.Windows.DependencyProperty.Register%2A> call, or the type that added itself as owner in the case of a <xref:System.Windows.DependencyProperty> identifier generated from an <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span>  
  
 <span data-ttu-id="956a3-289"><xref:System.Windows.DependencyProperty.OwnerType%2A>在任何給定<xref:System.Windows.DependencyProperty>是不可變的且無法`null`中有效<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-289">The <xref:System.Windows.DependencyProperty.OwnerType%2A> on any given <xref:System.Windows.DependencyProperty> is immutable, and cannot be `null` in a valid <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-290">下列範例會取得相依性屬性的識別項所根據的擁有者類型`dp`，然後在該相同的識別項的擁有者類型上取得中繼資料。</span><span class="sxs-lookup"><span data-stu-id="956a3-290">The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier.</span></span> <span data-ttu-id="956a3-291">這項作業會實際相當於取得<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。</span><span class="sxs-lookup"><span data-stu-id="956a3-291">This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-292">取得相依性屬性用於其值的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-292">Gets the type that the dependency property uses for its value.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-293">屬性值的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-293">The <see cref="T:System.Type" /> of the property value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-294">這個屬性會報告透過宣告的原始屬性註冊中，屬性值的型別`propertyType`參數。</span><span class="sxs-lookup"><span data-stu-id="956a3-294">This property reports the type of the property's value as declared by the original property registration, through the `propertyType` parameter.</span></span> <span data-ttu-id="956a3-295">類似於<xref:System.Windows.DependencyProperty.Name%2A>之後註冊, 相依性屬性的屬性類型是不變。</span><span class="sxs-lookup"><span data-stu-id="956a3-295">Similar to the <xref:System.Windows.DependencyProperty.Name%2A>, the property type of a dependency property is immutable after registration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-296">下列範例會查詢各種特性的相依性屬性的識別項，包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-296">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.PropertyType%2A>.</span></span> <span data-ttu-id="956a3-297">類型名稱字串<xref:System.Windows.DependencyProperty.PropertyType%2A>取得從傳回<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="956a3-297">The type name string of the <xref:System.Windows.DependencyProperty.PropertyType%2A> is obtained from the returned <xref:System.Type>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-298">取得值，這個值表示此 <see cref="T:System.Windows.DependencyProperty" /> 執行個體所識別的相依性屬性是否為唯讀相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-298">Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-299">如果相依性屬性為唯讀則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-299">
              <see langword="true" /> if the dependency property is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-300">唯讀相依性屬性時，會註冊內對屬性系統上，藉由呼叫<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法與<xref:System.Windows.DependencyProperty.Register%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="956a3-300">Read-only dependency properties are registered within the property system by calling the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method as opposed to the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="956a3-301">附加的屬性也可以註冊為唯讀。請參閱<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-301">Attached properties can also be registered as read-only; see <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="956a3-302">唯讀相依性屬性需要<xref:System.Windows.DependencyPropertyKey>識別碼而非<xref:System.Windows.DependencyProperty>執行中繼資料作業，例如覆寫中繼資料或設定值的識別項。</span><span class="sxs-lookup"><span data-stu-id="956a3-302">Read-only dependency properties require a <xref:System.Windows.DependencyPropertyKey> identifier rather than a <xref:System.Windows.DependencyProperty> identifier to perform metadata operations such as overriding the metadata or setting the value.</span></span> <span data-ttu-id="956a3-303">如果您取得的集合<xref:System.Windows.DependencyProperty>透過呼叫的識別項<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一個[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公開識別項，核取<xref:System.Windows.DependencyProperty.ReadOnly%2A>值，然後再嘗試將呼叫<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用，相依性屬性的識別項做為輸入參數，以確認相依性屬性的識別項表示不是唯讀狀態。</span><span class="sxs-lookup"><span data-stu-id="956a3-303">If you obtained a collection of <xref:System.Windows.DependencyProperty> identifiers through a call to <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> or another [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] that exposes identifiers, check the <xref:System.Windows.DependencyProperty.ReadOnly%2A> value before attempting to call <xref:System.Windows.DependencyObject.SetValue%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</span></span> <span data-ttu-id="956a3-304">如果值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`相依性屬性，沒有任何程式設計的方式，來取得指向參考<xref:System.Windows.DependencyPropertyKey>從中繼資料，或從該相依性屬性的識別項<xref:System.Windows.DependencyProperty>識別碼; 識別項若要呼叫必須為靜態欄位有<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>針對唯讀相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-304">If the value of <xref:System.Windows.DependencyProperty.ReadOnly%2A> is `true` on a dependency property, there is no programmatic way to obtain a reference to the <xref:System.Windows.DependencyPropertyKey> identifier of that dependency property, from the metadata or from the <xref:System.Windows.DependencyProperty> identifier; the identifier must be available as a static field in order to call <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> against a read-only dependency property.</span></span>  
  
 <span data-ttu-id="956a3-305">當您建立自訂的相依性屬性，並註冊以唯讀狀態時，您應該定義只能用於 get[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包裝函式屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-305">When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper property.</span></span> <span data-ttu-id="956a3-306">否則，您的類別必須令人混淆的物件模型的內容包裝函式相較於備份相依性屬性的存取。</span><span class="sxs-lookup"><span data-stu-id="956a3-306">Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</span></span> <span data-ttu-id="956a3-307">如需詳細資訊，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[唯讀相依性屬性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-307">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md) or [Read-Only Dependency Properties](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-308">下列範例從各種不同的相依性屬性欄位中取得的預設中繼資料和相依性屬性的識別項屬性，並使用此資訊來擴展資料表，以實作 「 中繼資料瀏覽器 」。</span><span class="sxs-lookup"><span data-stu-id="956a3-308">The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-309">登錄相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-309">Registers a dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-310">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-310">The name of the dependency property to register.</span>
          </span>
          <span data-ttu-id="956a3-311">名稱在擁有者類型的註冊命名空間內必須是唯一的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-311">The name must be unique within the registration namespace of the owner type.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-312">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-312">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-313">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-313">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-314">使用指定的屬性名稱、屬性類型和擁有者類型以註冊相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-314">Registers a dependency property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-315">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-315">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-316">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-316">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-317">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-317">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-318">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-318">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-319">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-319">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-320">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-320">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-321">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-321">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-322">請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-322">Registers a dependency property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-323">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-323">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-324">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-324">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-325">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-325">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-326">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-326">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-327">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-327">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-328">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-328">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-329">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-329">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="956a3-330">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-330">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-331">使用指定的屬性名稱、屬性類型、擁有者類型、屬性中繼資料和屬性的值驗證回呼，註冊相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-331">Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-332">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-332">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-333">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-333">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-334">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-334">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-335">下列範例會註冊相依性屬性，包括驗證回呼 (回呼定義不會顯示; 如需回呼定義的詳細資訊，請參閱<xref:System.Windows.ValidateValueCallback>)。</span><span class="sxs-lookup"><span data-stu-id="956a3-335">The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-336">向屬性系統註冊附加的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-336">Registers an attached property with the property system.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-337">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-337">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-338">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-338">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-339">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-339">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-340">使用指定的屬性名稱、屬性類型和擁有者類型以註冊附加屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-340">Registers an attached property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-341">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-341">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-342">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-342">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-343">附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-343">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="956a3-344"> 實作相依性屬性為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-344"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="956a3-345">因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。</span><span class="sxs-lookup"><span data-stu-id="956a3-345">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="956a3-346">如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-346">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="956a3-347">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-347">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-348">下列範例會註冊附加的屬性上使用這項功能的抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。</span><span class="sxs-lookup"><span data-stu-id="956a3-348">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-349">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-349">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-350">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-350">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-351">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-351">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="956a3-352">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-352">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="956a3-353">這可以包含預設值及其他特性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-353">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-354">請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄附加的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-354">Registers an attached property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-355">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-355">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-356">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-356">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-357">附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-357">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="956a3-358"> 實作相依性屬性為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-358"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="956a3-359">因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。</span><span class="sxs-lookup"><span data-stu-id="956a3-359">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="956a3-360">如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-360">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="956a3-361">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-361">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="956a3-362">使用 RegisterAttached 值繼承相依性屬性</span><span class="sxs-lookup"><span data-stu-id="956a3-362">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="956a3-363">註冊具有的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。</span><span class="sxs-lookup"><span data-stu-id="956a3-363">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="956a3-364">您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。</span><span class="sxs-lookup"><span data-stu-id="956a3-364">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="956a3-365">雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。</span><span class="sxs-lookup"><span data-stu-id="956a3-365">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="956a3-366">註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。</span><span class="sxs-lookup"><span data-stu-id="956a3-366">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="956a3-367">一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="956a3-367">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="956a3-368">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-368">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-369">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-369">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-370">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-370">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-371">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-371">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="956a3-372">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-372">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="956a3-373">這可以包含預設值及其他特性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-373">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="956a3-374">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-374">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-375">使用指定的屬性類型、擁有者類型、屬性中繼資料以及屬性的值驗證回呼，註冊附加屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-375">Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-376">相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-376">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="956a3-377">若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-377">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-378">附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-378">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="956a3-379"> 實作相依性屬性為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-379"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="956a3-380">因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。</span><span class="sxs-lookup"><span data-stu-id="956a3-380">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="956a3-381">如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-381">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="956a3-382">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-382">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="956a3-383">使用 RegisterAttached 值繼承相依性屬性</span><span class="sxs-lookup"><span data-stu-id="956a3-383">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="956a3-384">註冊具有的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。</span><span class="sxs-lookup"><span data-stu-id="956a3-384">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="956a3-385">您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。</span><span class="sxs-lookup"><span data-stu-id="956a3-385">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="956a3-386">雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。</span><span class="sxs-lookup"><span data-stu-id="956a3-386">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="956a3-387">註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。</span><span class="sxs-lookup"><span data-stu-id="956a3-387">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="956a3-388">一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="956a3-388">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="956a3-389">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-389">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-390">下列範例會註冊附加的屬性上使用這項功能的抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。</span><span class="sxs-lookup"><span data-stu-id="956a3-390">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span> <span data-ttu-id="956a3-391">這個連接的屬性是列舉型別屬性，並註冊會加入驗證回呼，以確認提供的值是列舉值。</span><span class="sxs-lookup"><span data-stu-id="956a3-391">This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-392">註冊唯讀的附加屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-392">Registers a read-only attached property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-393">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-393">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-394">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-394">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-395">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-395">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="956a3-396">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-396">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-397">註冊具有指定屬性類型、擁有者類型和屬性中繼資料的唯讀附加屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-397">Registers a read-only attached property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-398">應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-398">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-399">這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-399">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="956a3-400">一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="956a3-400">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="956a3-401">類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。</span><span class="sxs-lookup"><span data-stu-id="956a3-401">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="956a3-402">也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-402">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="956a3-403">唯讀附加的屬性會是罕見的情況下，因為附加屬性的主要案例是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-403">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="956a3-404">沒有公用 setter，附加的屬性無法設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。</span><span class="sxs-lookup"><span data-stu-id="956a3-404">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="956a3-405">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-405">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="956a3-406">使用 RegisterAttached 值繼承相依性屬性</span><span class="sxs-lookup"><span data-stu-id="956a3-406">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="956a3-407">註冊為相依性屬性的其中一個特定案例附加為支援繼承屬性值。</span><span class="sxs-lookup"><span data-stu-id="956a3-407">One particular scenario for registering a dependency property as attached is to support property value inheritance.</span></span> <span data-ttu-id="956a3-408">您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。</span><span class="sxs-lookup"><span data-stu-id="956a3-408">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="956a3-409">雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。</span><span class="sxs-lookup"><span data-stu-id="956a3-409">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="956a3-410">註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。</span><span class="sxs-lookup"><span data-stu-id="956a3-410">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="956a3-411">一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="956a3-411">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="956a3-412">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-412">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-413">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-413">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-414">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-414">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-415">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-415">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="956a3-416">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-416">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="956a3-417">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-417">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-418">使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼，註冊一個唯讀附加屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-418">Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-419">相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-419">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-420">這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-420">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="956a3-421">一般而言，代表類型的索引鍵<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-421">Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="956a3-422">一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="956a3-422">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="956a3-423">類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。</span><span class="sxs-lookup"><span data-stu-id="956a3-423">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="956a3-424">也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-424">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="956a3-425">唯讀附加的屬性會是罕見的情況下，因為附加屬性的主要案例是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="956a3-425">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="956a3-426">沒有公用 setter，附加的屬性無法設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。</span><span class="sxs-lookup"><span data-stu-id="956a3-426">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="956a3-427">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-427">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="956a3-428">使用 RegisterAttached 值繼承相依性屬性</span><span class="sxs-lookup"><span data-stu-id="956a3-428">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="956a3-429">註冊為而不是附加的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。</span><span class="sxs-lookup"><span data-stu-id="956a3-429">One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="956a3-430">您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。</span><span class="sxs-lookup"><span data-stu-id="956a3-430">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="956a3-431">雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。</span><span class="sxs-lookup"><span data-stu-id="956a3-431">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="956a3-432">註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。</span><span class="sxs-lookup"><span data-stu-id="956a3-432">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="956a3-433">一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="956a3-433">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="956a3-434">如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-434">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-435">註冊相依性屬性為唯讀相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-435">Registers a dependency property as a read-only dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-436">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-436">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-437">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-437">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-438">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-438">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-439">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-439">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-440">使用指定的屬性類型、擁有者類型和屬性中繼資料登錄唯讀相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-440">Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-441">相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-441">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-442">這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-442">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="956a3-443">一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="956a3-443">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="956a3-444">類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。</span><span class="sxs-lookup"><span data-stu-id="956a3-444">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="956a3-445">也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-445">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="956a3-446">唯讀相依性屬性是相當一般的案例中這兩個現有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]及自訂案例，因為其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要相依性屬性，即使該屬性不是要由可設定呼叫端。</span><span class="sxs-lookup"><span data-stu-id="956a3-446">Read-only dependency properties are a fairly typical scenario both in the existing [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] and for customization scenarios, because other [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features might require a dependency property even if that property is not intended to be settable by callers.</span></span> <span data-ttu-id="956a3-447">您可以使用唯讀相依性屬性的值做為基礎的相依性屬性，例如為基礎之其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-447">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="956a3-448">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-448">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="956a3-449">下列範例會註冊`AquariumSize`以唯讀狀態的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-449">The following example registers an `AquariumSize` dependency property as read-only.</span></span> <span data-ttu-id="956a3-450">此範例會定義`AquariumSizeKey`內部索引鍵 （組件中的，讓其他類別可以覆寫中繼資料） 以及與該索引鍵為基礎的相依性屬性的識別項會公開`AquariumSizeProperty`。</span><span class="sxs-lookup"><span data-stu-id="956a3-450">The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`.</span></span> <span data-ttu-id="956a3-451">此外，包裝函式建立`AquariumSize`，僅有 get 存取子。</span><span class="sxs-lookup"><span data-stu-id="956a3-451">Also, a wrapper is created for `AquariumSize`, with only a get accessor.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="956a3-452">要註冊之相依性屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-452">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="956a3-453">屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-453">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="956a3-454">正在註冊相依性屬性的擁有者類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-454">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="956a3-455">相依性屬性的屬性中繼資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-455">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="956a3-456">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-456">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="956a3-457">使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼登錄唯讀相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-457">Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-458">應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-458">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-459">這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-459">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="956a3-460">一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="956a3-460">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="956a3-461">類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。</span><span class="sxs-lookup"><span data-stu-id="956a3-461">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="956a3-462">也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。</span><span class="sxs-lookup"><span data-stu-id="956a3-462">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="956a3-463">唯讀相依性屬性是相當一般的案例。</span><span class="sxs-lookup"><span data-stu-id="956a3-463">Read-only dependency properties are a fairly typical scenario.</span></span> <span data-ttu-id="956a3-464">您可以使用唯讀相依性屬性的值做為基礎的相依性屬性，例如為基礎之其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-464">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="956a3-465">如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="956a3-465">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 <span data-ttu-id="956a3-466">唯讀相依性屬性的驗證可能是較不重要。</span><span class="sxs-lookup"><span data-stu-id="956a3-466">Validation on a read-only dependency property might be less important.</span></span> <span data-ttu-id="956a3-467">您指定的索引鍵的非公用存取層級可降低對任意無效的輸入。</span><span class="sxs-lookup"><span data-stu-id="956a3-467">The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="956a3-468">傳回相依性屬性的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-468">Returns the string representation of the dependency property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="956a3-469">相依性屬性的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-469">The string representation of the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-470">這個實作會傳回<xref:System.Windows.DependencyProperty.Name%2A>屬性值。</span><span class="sxs-lookup"><span data-stu-id="956a3-470">This implementation returns the <xref:System.Windows.DependencyProperty.Name%2A> property value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-471">指定 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 屬性系統所使用的靜態值，而非指定 <see langword="null" />，以表示屬性已存在，但屬性系統尚未設定其值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-471">Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-472"><xref:System.Windows.DependencyProperty.UnsetValue> 是用於案例之 sentinel 值其中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統是無法判斷要求<xref:System.Windows.DependencyProperty>值。</span><span class="sxs-lookup"><span data-stu-id="956a3-472"><xref:System.Windows.DependencyProperty.UnsetValue> is a sentinel value that is used for scenarios where the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system is unable to determine a requested <xref:System.Windows.DependencyProperty> value.</span></span> <span data-ttu-id="956a3-473"><xref:System.Windows.DependencyProperty.UnsetValue> 會使用而非`null`，因為`null`可能是有效的屬性值，以及有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-473"><xref:System.Windows.DependencyProperty.UnsetValue> is used rather than `null`, because `null` could be a valid property value, as well as a valid (and frequently used) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</span></span>  
  
 <span data-ttu-id="956a3-474"><xref:System.Windows.DependencyProperty.UnsetValue> 絕對不會傳回出<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="956a3-474"><xref:System.Windows.DependencyProperty.UnsetValue> is never returned out of <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="956a3-475">當您呼叫<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>相依性屬性上<xref:System.Windows.DependencyObject>下列其中一種適用於執行個體：</span><span class="sxs-lookup"><span data-stu-id="956a3-475">When you call <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> on a dependency property on a <xref:System.Windows.DependencyObject> instance, one of the following applies:</span></span>  
  
-   <span data-ttu-id="956a3-476">相依性屬性中繼資料中所建立的預設值，而且在傳回的值。</span><span class="sxs-lookup"><span data-stu-id="956a3-476">A dependency property has a default value established in metadata and that value is returned.</span></span> <span data-ttu-id="956a3-477">這個值可能來自於<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="956a3-477">This value might come from <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
-   <span data-ttu-id="956a3-478">其他值對屬性系統，所建立，不再相關的預設值。</span><span class="sxs-lookup"><span data-stu-id="956a3-478">Some other value was established by the property system, and the default value is no longer relevant.</span></span> <span data-ttu-id="956a3-479">如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-479">For details, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 <span data-ttu-id="956a3-480">設定<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>特別不允許。</span><span class="sxs-lookup"><span data-stu-id="956a3-480">Setting a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> of <xref:System.Windows.DependencyProperty.UnsetValue> is specifically disallowed.</span></span>  
  
 <span data-ttu-id="956a3-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 傳回<xref:System.Windows.DependencyProperty.UnsetValue>當要求的屬性尚未在本機設定。</span><span class="sxs-lookup"><span data-stu-id="956a3-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> returns <xref:System.Windows.DependencyProperty.UnsetValue> when the requested property has not been locally set.</span></span>  
  
 <span data-ttu-id="956a3-482"><xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊意義時做為傳回值<xref:System.Windows.CoerceValueCallback>。</span><span class="sxs-lookup"><span data-stu-id="956a3-482"><xref:System.Windows.DependencyProperty.UnsetValue> has a special meaning when used as the return value of a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="956a3-483">如需詳細資訊，請參閱[相依性屬性的回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-483">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 <span data-ttu-id="956a3-484">如果您要繫結至資料庫，請注意，<xref:System.Windows.DependencyProperty.UnsetValue>不等同於<xref:System.DBNull.Value>，方式類似的方式<xref:System.DBNull.Value>不等於 null，則為 true。</span><span class="sxs-lookup"><span data-stu-id="956a3-484">If you are binding to a database, note that <xref:System.Windows.DependencyProperty.UnsetValue> is not equivalent to <xref:System.DBNull.Value>, in a similar way to how <xref:System.DBNull.Value> is not equivalent to a true null.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="956a3-485">取得相依性屬性的值驗證回呼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-485">Gets the value validation callback for the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="956a3-486">這個相依性屬性的值驗證回呼，如同在原始相依性屬性註冊中為 <paramref name="validateValueCallback" /> 參數所提供的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="956a3-486">The value validation callback for this dependency property, as provided for the <paramref name="validateValueCallback" /> parameter in the original dependency property registration.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="956a3-487">這個屬性會包含`null`與任何已註冊的驗證回呼的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="956a3-487">This property will contain `null` for any dependency property with no registered validation callback.</span></span>  
  
 <span data-ttu-id="956a3-488">驗證回呼必須扮演靜態的有意義的值： 透過套用驗證<xref:System.Windows.ValidateValueCallback>無法判斷提供的值是否為有效的任何特定執行個體。</span><span class="sxs-lookup"><span data-stu-id="956a3-488">Validate value callbacks must act in a static sense: validation applied through the <xref:System.Windows.ValidateValueCallback> cannot determine whether the provided value is valid for any particular instance.</span></span> <span data-ttu-id="956a3-489">回呼只會得出擁有相依性屬性的所有物件是否不應該接受所提供的值為有效。</span><span class="sxs-lookup"><span data-stu-id="956a3-489">The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</span></span> <span data-ttu-id="956a3-490">如果您要執行驗證所使用的了解在特定的執行個體，使用其他相依性屬性的值<xref:System.Windows.CoerceValueCallback>改為。</span><span class="sxs-lookup"><span data-stu-id="956a3-490">If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <xref:System.Windows.CoerceValueCallback> instead.</span></span> <span data-ttu-id="956a3-491"><xref:System.Windows.CoerceValueCallback>註冊為組件的相依性屬性中繼資料，而不是直接相依性屬性的識別項。</span><span class="sxs-lookup"><span data-stu-id="956a3-491">The <xref:System.Windows.CoerceValueCallback> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</span></span> <span data-ttu-id="956a3-492">如需詳細資訊，請參閱[相依性屬性的回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="956a3-492">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>