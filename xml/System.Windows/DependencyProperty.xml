<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48e189814c9d38e818a9d416a18db9a92e096f66" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48623033" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表可以透過方法設定的屬性，例如樣式、資料繫結、動畫和繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.DependencyProperty>支援中的下列功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   屬性可以設定樣式中。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
-   屬性可以透過資料繫結進行設定。 如需有關資料繫結相依性屬性的詳細資訊，請參閱 <<c0> [ 如何： 將控制項繫結屬性的兩個](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。  
  
-   屬性可以設定的動態資源參考。 如需詳細資訊，請參閱 [XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   屬性可以自動繼承它的值，從項目樹狀結構中父項目。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
-   屬性可以動畫顯示。 如需詳細資訊，請參閱 [動畫概觀](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。  
  
-   已變更之屬性的先前值和屬性值可以強制轉型時，可以報告的屬性。 如需詳細資訊，請參閱[相依性屬性回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
-   屬性資訊回報給[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如變更屬性值是否是否需要重新撰寫項目的視覺效果的版面配置系統。  
  
-   屬性會獲得中的支援[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。  例如，屬性可以在中編輯**屬性**視窗。  
  
 若要深入了解相依性屬性，請參閱[相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。 如果您想在您要支援的功能，在上述清單中的自訂類型的屬性，您應該建立相依性屬性。  若要了解如何建立自訂的相依性屬性，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
 附加的屬性是可讓報表的資訊，可定義附加的屬性的類型至任何物件的屬性。 在  [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，繼承自任何型別<xref:System.Windows.DependencyObject>可以使用附加的屬性，不論類型是否定義屬性的型別會繼承。 附加的屬性是一項功能[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語言。  若要設定附加的屬性在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*ownerType*。*propertyName*語法。 附加屬性的範例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性。 如果您想要建立此屬性，可以用在所有<xref:System.Windows.DependencyObject>型別，則您應建立附加的屬性。 若要深入了解附加屬性，包括如何建立這些項目，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 值  
 `dependencyPropertyName`  
 字串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>所需的相依性屬性。 這可以前面加上的 XML 命名空間前置詞如果屬性不是預設 XML 命名空間 (如需詳細資訊，請參閱 < [XAML 命名空間和命名空間對應 WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)  
  
 `ownerType`.`dependencyPropertyName`  
 字串，指定擁有者類型的相依性屬性，句點 （.），則<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。 `ownerType` 也可以前面的 XML 命名空間前置詞。 這種用法是晚期繫結樣式和範本，以剖析內容，因為必須指定相依性屬性的擁有者的特殊`TargetType`還不知道。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 字串，指定附加的屬性、 句點 （.），然後附加的屬性名稱的擁有者。 `attachedPropertyOwnerType` 也可以前面的 XML 命名空間前置詞。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加入其他類型，以作為已註冊至某個類型之相依性屬性的擁有者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">要加入為此相依性屬性之擁有者的類型。</param>
        <summary>加入其他類型，作為已註冊之相依性屬性的擁有者。</summary>
        <returns>原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。 應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓屬性系統能夠辨識一開始並未註冊該特定的相依性屬性的型別上的相依性屬性。  
  
 一般而言，<xref:System.Windows.DependencyProperty.AddOwner%2A>用來將相依性屬性新增至已經不會公開透過 managed 的類別繼承該相依性屬性的類別 (類別繼承會造成可繼承衍生類別中的包裝函式屬性，因此會提供一般的成員資料表存取權的相依性屬性已經）。 <xref:System.Windows.DependencyProperty.AddOwner%2A> 可讓屬性系統能夠辨識一開始並未註冊該相依性屬性的型別上的相依性屬性。  
  
 此簽章不允許指定的中繼資料。  當您使用這個方法時，中繼資料會自動產生新<xref:System.Windows.DependencyProperty>和其擁有者類型。 自動產生的中繼資料是從所有已定義這個屬性的基底類型的合併中繼資料的結果。 如果沒有合併中繼資料可用，則會使用預設的中繼資料屬性。 如果使用已註冊的屬性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，則預設的中繼資料是時，會建立的中繼資料與相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>呼叫。 否則<xref:System.Windows.PropertyMetadata>物件會透過<xref:System.Windows.PropertyMetadata.DefaultValue%2A>屬性設定為屬性類型的預設值和所有其他屬性<xref:System.Windows.PropertyMetadata>設定為`null`。 使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>簽章，如果您想要加入至提供的型別，提供中繼資料版本的相依性屬性。  
  
 這個方法的傳回值是通常用來宣告和公開的相依性屬性儲存相依性屬性識別項。 識別項提供相依性屬性的存取，如果您想要呼叫屬性系統[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]針對相依性屬性，特別是因為它存在於上新增的擁有者類別。 原始擁有者和擁有者新增相同的屬性名稱應該用來表示類似的功能。 您應該使用<xref:System.Windows.DependencyProperty>的傳回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法，定義相依性屬性識別項，並宣告[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>建立宣告內的相依性屬性時，上述建議的方法使用[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 比方說，同時<xref:System.Windows.Controls.Border>並<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。 <xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性，以藉由呼叫屬性系統<xref:System.Windows.DependencyProperty.AddOwner%2A>根據原始的擁有者<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性識別項。 <xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立新的靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上所新增的擁有者，該屬性和`BorderBrush`屬性包裝函式也會宣告。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">要加入為此相依性屬性之擁有者的類型。</param>
        <param name="typeMetadata">限定存在於所提供類型之相依性屬性的中繼資料。</param>
        <summary>加入另一個類型作為已註冊的相依性屬性的擁有者，並提供在所提供擁有者類型上存在之相依性屬性的相依性屬性中繼資料。</summary>
        <returns>原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。 應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓屬性系統能夠辨識一開始並未註冊該特定的相依性屬性的型別上的相依性屬性。  
  
 這個方法的傳回值用來宣告，並公開 （expose） 相依性屬性中，特別是存在於新增的擁有者類別。 一般而言，原始擁有者和擁有者新增相同的屬性名稱應該用來表示類似的功能。 公開 （expose） 的識別碼，以及當新的好習慣[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>建立時，會使用上述建議的方法[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]內宣告[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 比方說，同時<xref:System.Windows.Controls.Border>並<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。 <xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性，以藉由呼叫屬性系統<xref:System.Windows.DependencyProperty.AddOwner%2A>在原始的擁有者<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性識別項。 <xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上所新增的擁有者，該屬性和`BorderBrush`屬性包裝函式也會宣告。  
  
 加入的擁有者相依性屬性識別項應該使用作業例如<xref:System.Windows.DependencyObject.GetValue%2A>。 不過，類型或已加入為具有不同的中繼資料擁有者仍類別的執行個體相關的特定類型的作業會傳回預期的結果，即使原始 （未新增擁有者） 中所指定相依性屬性識別項呼叫方法這類<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。 加入的擁有者的中繼資料會永久存在於由<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫本身，不一定是以獨佔方式所新增的擁有者類別識別項欄位參考。 不過，公開 （expose） 的識別碼，以及當新的最佳作法是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>，因為這麼建立之間的差異[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]並[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]表示您的屬性。  
  
 存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 會保留原始的基底中繼資料中所指定的任何特性。 只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果有指定新的中繼資料中就會被取代。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 合併行為取決於用於覆寫，因此此處所述的行為是針對所使用的現有屬性中繼資料類別的屬性中繼資料類型的最後，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。 如需詳細資訊，請參閱 <<c0> [ 相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)並[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的預設中繼資料。</summary>
        <value>相依性屬性的預設中繼資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設中繼資料是屬性的中繼資料可供使用該特定物件或衍生型別的物件沒有替代的中繼資料，提供明確<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼叫。  
  
 如果原始的擁有者套用中繼資料的第一個<xref:System.Windows.DependencyProperty.Register%2A>呼叫，建立相依性屬性，則該中繼資料會傳回為<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 如果沒有中繼資料所套用的原始<xref:System.Windows.DependencyProperty.Register%2A>呼叫，則預設的中繼資料會產生內在<xref:System.Windows.DependencyProperty.Register%2A>呼叫，且此值會傳回為<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 具有相關聯的預設中繼資料的主要目的<xref:System.Windows.DependencyProperty>提供任何上這個屬性的預設值是<xref:System.Windows.DependencyObject>或衍生型別。  
  
 若為非附加屬性，這個屬性所傳回的中繼資料類型無法轉換成衍生類型的<xref:System.Windows.PropertyMetadata>類型，即使衍生的中繼資料型別使用原本註冊屬性。 如果您想原先已註冊的中繼資料，包括其原始的可能衍生的中繼資料型別時，呼叫<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>相反地，傳遞原來的註冊類型做為參數。  
  
 為附加屬性，這個屬性所傳回的中繼資料的型別會比對中原始提供的型別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊方法。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊程式碼。</summary>
        <returns>這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊程式碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性系統會使用它自己的唯一識別碼<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，以及該屬性的值由<xref:System.Windows.DependencyProperty.GetHashCode%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回與特定類型的此相依性屬性相關聯的中繼資料。 這可以是第一次註冊相依性屬性的類型 (之後會加一)，或透過繼承取得相依性屬性但特別覆寫中繼資料的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">要從中擷取相依性屬性中繼資料的特定類型。</param>
        <summary>傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的現有類型。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考型別是必要的因為中繼資料有可能從原始註冊到期，到使用<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>更改的相依性屬性中繼資料存在於類型的呼叫。  
  
   
  
## Examples  
 下列範例會取得其類型為基礎的相依性屬性的中繼資料。 使用取得型別`typeof`運算子。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">檢查了相依性物件的類型，以判斷中繼資料應該來自於相依性屬性的哪一個特定類型版本。</param>
        <summary>傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的物件執行個體。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考需要因為任何指定的相依性屬性的中繼資料有可能從到期到原始的註冊<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以精簡屬性中繼資料的呼叫型別。  
  
 當您要求的執行個體為基礎的屬性中繼資料時，您其實只傳遞執行個體，以便可以在內部評估它的型別。 相依性屬性中繼資料不會每個執行個體;它永遠是一致的任何指定的型別屬性組合。  
  
   
  
## Examples  
 下列範例會取得根據特定的相依性屬性的中繼資料<xref:System.Windows.DependencyObject>執行個體。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">記錄需要相依性屬性中繼資料之相依性物件類型的特定物件。</param>
        <summary>傳回存在於所指定類型之這個相依性屬性的中繼資料。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考需要因為任何指定的相依性屬性的中繼資料有可能從到期到原始的註冊<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以精簡屬性中繼資料的呼叫型別。  
  
   
  
## Examples  
 下列範例會取得根據相依性屬性的中繼資料及其<xref:System.Windows.DependencyObjectType>。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可唯一識別相依性屬性的內部產生值。</summary>
        <value>唯一數值識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個值是整數，不全域唯一識別碼 (GUID)。 一般而言，使用這個索引的值不是必要項，而沒有任何索引資料表的存取權的所有相依性屬性。 依其識別項欄位時，應該改為參考相依性屬性。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 在內部用來更快速地存取所使用的資料結構<xref:System.Windows.DependencyProperty.GlobalIndex%2A>為以零為起始的陣列索引。 類似的使用量可能會有設計工具或工具的應用程式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要檢查的值。</param>
        <summary>根據原始相依性屬性註冊所提供的屬性型別檢查這個相依性屬性的型別，判斷此型別是否接受指定的值。</summary>
        <returns>如果指定的值為註冊的屬性型別或可接受的衍生型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值為`null`有效的類型或參考類型的相依性屬性，如<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。 在相依性屬性所在的未參考的情況下也不是<xref:System.Nullable%601>型別<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.DependencyProperty.IsValidType%2A>呼叫之前，先檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要檢查的值。</param>
        <summary>透過基本型別檢查，判斷屬性型別是否接受所提供的值，並在必要時判斷此值是否位於該型別的允許值範圍內。</summary>
        <returns>如果此值可被接受且屬於正確型別或衍生型別，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性屬性，允許該類型的值範圍可以透過指定<xref:System.Windows.ValidateValueCallback>相依性屬性註冊中所提供。  
  
 這個方法會呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>內部。 如果有問題的相依性屬性不含任何<xref:System.Windows.ValidateValueCallback>，然後呼叫這個方法會有效等同於呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>。 如果沒有相依性屬性<xref:System.Windows.ValidateValueCallback>，而且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`true`，然後在回呼中實作時，會傳回的值。  
  
 Null 值是有效的值或參考類型的相依性屬性，如<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。 在相依性屬性所在的未參考的情況下也不是<xref:System.Nullable%601>型別<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>呼叫之前，先檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的名稱。</summary>
        <value>屬性的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會取得與所提供的名稱`name`相依性屬性註冊期間的參數。 這個名稱是不可變的且無法`null`或空字串。 在相同的擁有者型別上的重複名稱註冊不允許，並將會擲回例外狀況，當您嘗試註冊重複。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>的相依性屬性都必須遵循的比對的名稱減去"Property"字尾其相依性屬性識別碼的慣例。 如需詳細資訊，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
   
  
## Examples  
 下列範例會查詢相依性屬性識別項的各種特性包括<xref:System.Windows.DependencyProperty.Name%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供這個相依性屬性出現在所指定類型的執行個體時所要使用的替代中繼資料，相較於初始相依性屬性註冊中所提供的中繼資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</param>
        <param name="typeMetadata">要套用至覆寫類型上相依性屬性的中繼資料。</param>
        <summary>當這個相依性屬性出現在所指定類型的執行個體中時，指定其替代中繼資料，並覆寫從基底類型繼承時存在的相依性屬性中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性系統會使用相依性屬性之前，應該覆寫相依性屬性中繼資料。 這相當於使用的類別，登錄相依性屬性建立特定的執行個體的時間。 若要呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>本身提供為類型的靜態建構函式內，才可以執行`forType`這種方法，或透過類似的具現化的參數。 嘗試將擁有者類型的執行個體存在之後，變更中繼資料將不會引發例外狀況，但將會導致屬性系統中的不一致的行為。  
  
 使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別上的中繼資料將會引發例外狀況。  
  
 存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 會保留原始的基底中繼資料中所指定的任何特性;只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>會被取代，如果在新的中繼資料中指定。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 合併行為取決於用於覆寫，因此此處所述的行為是針對所使用的現有屬性中繼資料類別的屬性中繼資料類型的最後，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。 如需詳細資訊，請參閱 <<c0> [ 相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)並[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">嘗試覆寫唯讀相依性屬性的中繼資料 (無法使用此簽章完成作業)。</exception>
        <exception cref="T:System.ArgumentException">已經建立相依性屬性的中繼資料，因為它存在於所提供的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</param>
        <param name="typeMetadata">要套用至覆寫類型上相依性屬性的中繼資料。</param>
        <param name="key">唯讀相依性屬性的存取索引鍵。</param>
        <summary>當它出現在所指定類型的執行個體，覆寫在初始相依性屬性登錄中所提供的中繼資料時，提供唯讀相依性屬性的替代中繼資料。 您必須傳遞唯讀相依性屬性的 <see cref="T:System.Windows.DependencyPropertyKey" />，以免引發例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此簽章提供基礎實作的唯讀相依性屬性識別項 (<xref:System.Windows.DependencyPropertyKey>) 方法。 如果覆寫讀寫相依性屬性的中繼資料，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。  
  
 屬性系統會使用相依性屬性之前，應該覆寫相依性屬性中繼資料。 這相當於登錄相依性屬性的類別會建立特定物件的時間。 若要呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>本身提供為類型的靜態建構函式內，才可以執行`forType`這種方法，或透過類似的具現化的參數。 嘗試將擁有者類型的執行個體存在之後，變更中繼資料將不會引發例外狀況，但將會導致屬性系統中的不一致的行為。  
  
 使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別上的中繼資料將會引發例外狀況。  
  
 存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 會保留原始的基底中繼資料中所指定的任何特性;只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>會被取代，如果在新的中繼資料中指定。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 合併行為取決於用於覆寫屬性中繼資料類型。 如需詳細資訊，請參閱 <<c0> [ 相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)並[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對屬性系統註冊相依性屬性之物件，或將本身作為屬性擁有者加入之物件的類型。</summary>
        <value>註冊屬性或將本身作為屬性擁有者加入的物件類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在屬性註冊期間提供此值。 擁有者便是其中一個原始註冊類型的情況<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.Register%2A>呼叫，或是類型本身新增為擁有者的情況<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫。  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A>在任何給定<xref:System.Windows.DependencyProperty>是不可變的且無法`null`有效<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會取得根據相依性屬性識別項的擁有者類型`dp`，然後在該相同的識別項的擁有者型別上取得中繼資料。 這項作業是實際上相當於取得<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性用於其值的型別。</summary>
        <value>屬性值的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會報告屬性的值透過原始屬性登錄中，所宣告的型別`propertyType`參數。 類似於<xref:System.Windows.DependencyProperty.Name%2A>，註冊後，相依性屬性的屬性類型是不變。  
  
   
  
## Examples  
 下列範例會查詢相依性屬性識別項的各種特性包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。 型別名稱字串<xref:System.Windows.DependencyProperty.PropertyType%2A>會取得從傳回<xref:System.Type>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Windows.DependencyProperty" /> 執行個體所識別的相依性屬性是否為唯讀相依性屬性。</summary>
        <value>如果相依性屬性為唯讀則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 唯讀相依性屬性時，會註冊內屬性系統上，藉由呼叫<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法，而不是<xref:System.Windows.DependencyProperty.Register%2A>方法。 附加的屬性也可以註冊為唯讀的;請參閱<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。  
  
 唯讀相依性屬性需要<xref:System.Windows.DependencyPropertyKey>識別項而非<xref:System.Windows.DependencyProperty>執行中繼資料作業，例如覆寫中繼資料，或將其值的識別項。 如果您取得的集合<xref:System.Windows.DependencyProperty>識別碼，透過呼叫<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一個[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公開識別項，核取<xref:System.Windows.DependencyProperty.ReadOnly%2A>值之前嘗試呼叫<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用，做為輸入參數，以確認相依性屬性識別項表示不是唯讀的相依性屬性識別碼。 如果值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`相依性屬性，沒有任何程式設計的方式，來取得參考<xref:System.Windows.DependencyPropertyKey>從中繼資料，或從該相依性屬性識別項<xref:System.Windows.DependencyProperty>識別項，識別項若要呼叫必須可以當做靜態欄位<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>對唯讀的相依性屬性。  
  
 當您建立自訂的相依性屬性，並註冊以唯讀模式時，您應該定義只有 get 存取子的[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包裝函式屬性。 否則，您的類別必須令人混淆的物件模型，相較於存取支援相依性屬性的屬性包裝函式。 如需詳細資訊，請參閱 <<c0> [ 自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或是[唯讀相依性屬性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
   
  
## Examples  
 下列範例會從多個相依性屬性欄位，會取得預設的中繼資料和相依性屬性識別項屬性，並使用的資訊來填入資料表，以實作 「 中繼資料瀏覽器 」。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>登錄相依性屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。 名稱在擁有者類型的註冊命名空間內必須是唯一的。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <summary>使用指定的屬性名稱、屬性類型和擁有者類型以註冊相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</param>
        <summary>使用指定的屬性名稱、屬性類型、擁有者類型、屬性中繼資料和屬性的值驗證回呼，註冊相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊相依性屬性，包括驗證回呼 (回呼定義不會顯示; 如需回呼定義的詳細資訊，請參閱<xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向屬性系統註冊附加的屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <summary>使用指定的屬性名稱、屬性類型和擁有者類型以註冊附加屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是由定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料，可以用一般屬性系統，例如報告配置特性的作業。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊附加的屬性上使用此抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。 這可以包含預設值及其他特性。</param>
        <summary>請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄附加的屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是由定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料，可以用一般屬性系統，例如報告配置特性的作業。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承的相依性屬性  
 註冊的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援屬性值繼承。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義公開 （expose） 相依性屬性的屬性包裝函式存取子，而且即使您不想要公開 Get * 和 Set * 的靜態方法，以提供為 true，則連接屬性支援存取子。   雖然屬性值繼承似乎適用於非附加相依性屬性，但透過執行階段樹狀結構中特定元素界限的非附加屬性繼承行為是未定義。 註冊為附加有效的屬性會附加的屬性的全域屬性對屬性系統，並可確保屬性值繼承，適用於跨所有項目樹狀結構中的界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。 這可以包含預設值及其他特性。</param>
        <param name="validateValueCallback">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料以及屬性的值驗證回呼，註冊附加屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是由定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料，可以用一般屬性系統，例如報告配置特性的作業。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承的相依性屬性  
 註冊的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援屬性值繼承。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義公開 （expose） 相依性屬性的屬性包裝函式存取子，而且即使您不想要公開 Get * 和 Set * 的靜態方法，以提供為 true，則連接屬性支援存取子。   雖然屬性值繼承似乎適用於非附加相依性屬性，但透過執行階段樹狀結構中特定元素界限的非附加屬性繼承行為是未定義。 註冊為附加有效的屬性會附加的屬性的全域屬性對屬性系統，並可確保屬性值繼承，適用於跨所有項目樹狀結構中的界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
   
  
## Examples  
 下列範例會註冊附加的屬性上使用此抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。 此附加的屬性是列舉型別屬性，並註冊將驗證回呼，以確認提供的值是列舉型別的值。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊唯讀的附加屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>註冊具有指定屬性類型、擁有者類型和屬性中繼資料的唯讀附加屬性。</summary>
        <returns>應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回的型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為索引鍵可用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別的設計會影響您的需求，但通常最好是限制的存取權和可見性的任何<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的類別或應用程式邏輯中設定該相依性屬性。 也建議您公開唯讀相依性屬性的相依性屬性識別項，方法是公開的值<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>做為`public static readonly`類別上的欄位。  
  
 唯讀附加的屬性會是罕見的案例，因為附加屬性的主要用途是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 無法在中設定沒有公用 setter，附加的屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承的相依性屬性  
 註冊為相依性屬性的其中一個特定案例連接是支援的屬性值繼承。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義公開 （expose） 相依性屬性的屬性包裝函式存取子，而且即使您不想要公開 Get * 和 Set * 的靜態方法，以提供為 true，則連接屬性支援存取子。   雖然屬性值繼承似乎適用於非附加相依性屬性，但透過執行階段樹狀結構中特定元素界限的非附加屬性繼承行為是未定義。 註冊為附加有效的屬性會附加的屬性的全域屬性對屬性系統，並可確保屬性值繼承，適用於跨所有項目樹狀結構中的界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼，註冊一個唯讀附加屬性。</summary>
        <returns>相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回的型別<xref:System.Windows.DependencyProperty>。 一般而言，代表類型的索引鍵<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為索引鍵可用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別的設計會影響您的需求，但通常最好是限制的存取權和可見性的任何<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的類別或應用程式邏輯中設定該相依性屬性。 也建議您公開唯讀相依性屬性的相依性屬性識別項，方法是公開的值<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>做為`public static readonly`類別上的欄位。  
  
 唯讀附加的屬性會是罕見的案例，因為附加屬性的主要用途是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 無法在中設定沒有公用 setter，附加的屬性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承的相依性屬性  
 註冊相依性屬性，而不是連接的其中一個特定案例<xref:System.Windows.DependencyProperty.Register%2A>是為了支援屬性值繼承。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義公開 （expose） 相依性屬性的屬性包裝函式存取子，而且即使您不想要公開 Get * 和 Set * 的靜態方法，以提供為 true，則連接屬性支援存取子。   雖然屬性值繼承似乎適用於非附加相依性屬性，但透過執行階段樹狀結構中特定元素界限的非附加屬性繼承行為是未定義。 註冊為附加有效的屬性會附加的屬性的全域屬性對屬性系統，並可確保屬性值繼承，適用於跨所有項目樹狀結構中的界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登錄，您指定的屬性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊相依性屬性為唯讀相依性屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>使用指定的屬性類型、擁有者類型和屬性中繼資料登錄唯讀相依性屬性。</summary>
        <returns>相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回的型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為索引鍵可用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別的設計會影響您的需求，但通常最好是限制的存取權和可見性的任何<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的類別或應用程式邏輯中設定該相依性屬性。 也建議您公開唯讀相依性屬性的相依性屬性識別項，方法是公開的值<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>做為`public static readonly`類別上的欄位。  
  
 唯讀相依性屬性是相當典型的案例這兩個現有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]和自訂的情況下，因為其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要的相依性屬性，即使該屬性不是要設定呼叫端。 您可以使用唯讀相依性屬性的值做為基礎採取相依性屬性，例如做為其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊`AquariumSize`相依性屬性為唯讀。 此範例會定義`AquariumSizeKey`（組件中的，讓其他類別可以覆寫中繼資料） 的內部索引鍵以及與該索引鍵為基礎的相依性屬性識別項會公開`AquariumSizeProperty`。 此外，包裝函式會為`AquariumSize`，只有 get 存取子。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼登錄唯讀相依性屬性。</summary>
        <returns>應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回的型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為索引鍵可用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別的設計會影響您的需求，但通常最好是限制的存取權和可見性的任何<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的類別或應用程式邏輯中設定該相依性屬性。 也建議您公開唯讀相依性屬性的相依性屬性識別項，方法是公開的值<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>做為`public static readonly`類別上的欄位。  
  
 唯讀相依性屬性都是相當常見的案例。 您可以使用唯讀相依性屬性的值做為基礎採取相依性屬性，例如做為其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。  
  
 如需有關相依性屬性註冊的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
 唯讀相依性屬性上的驗證可能較不重要。 您指定的索引鍵的非公用存取層級降低對任意無效的輸入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回相依性屬性的字串表示。</summary>
        <returns>相依性屬性的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作會傳回<xref:System.Windows.DependencyProperty.Name%2A>屬性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 屬性系統所使用的靜態值，而非指定 <see langword="null" />，以表示屬性已存在，但屬性系統尚未設定其值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> 是用於案例之 sentinel 值所在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統，才能夠判斷要求<xref:System.Windows.DependencyProperty>值。 <xref:System.Windows.DependencyProperty.UnsetValue> 會使用而非`null`，因為`null`可能是有效的屬性值，以及有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 永遠不會傳回共<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。 當您呼叫<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>上的相依性屬性上<xref:System.Windows.DependencyObject>執行個體，下列其中一種適用於：  
  
-   相依性屬性中繼資料中所建立的預設值，而且在傳回的值。 此值可能來自<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
-   屬性系統中，已建立一些其他的值，預設值不再相關。 如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 設定<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>特別不允許。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 傳回<xref:System.Windows.DependencyProperty.UnsetValue>當要求的內容尚未在本機設定。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊意義的傳回值使用時<xref:System.Windows.CoerceValueCallback>。 如需詳細資訊，請參閱 <<c0> [ 相依性屬性回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 如果您要繫結至資料庫，請注意<xref:System.Windows.DependencyProperty.UnsetValue>不等於<xref:System.DBNull.Value>，類似的方式，如何<xref:System.DBNull.Value>並不相同，則為 true 的 null。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的值驗證回呼。</summary>
        <value>這個相依性屬性的值驗證回呼，如同在原始相依性屬性註冊中為 <paramref name="validateValueCallback" /> 參數所提供的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會包含`null`與任何已註冊的驗證回呼的任何相依性屬性。  
  
 驗證回呼必須處理靜態意義的值： 透過套用驗證<xref:System.Windows.ValidateValueCallback>無法判斷提供的值是否為有效的任何特定執行個體。 擁有相依性屬性的所有物件是否不應該接受提供的值為有效，只會得出回呼。 如果您要執行相依於了解在特定的執行個體，使用其他相依性屬性的值驗證<xref:System.Windows.CoerceValueCallback>改。 <xref:System.Windows.CoerceValueCallback>註冊為組件的相依性屬性中繼資料，而不是直接相依性屬性識別項。 如需詳細資訊，請參閱 <<c0> [ 相依性屬性回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>