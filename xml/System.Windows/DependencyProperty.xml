<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e36dd257b906b7c94742536f4e333ac2cac8cd0" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660016" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表可以透過方法設定的屬性，例如樣式、資料繫結、動畫和繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.DependencyProperty>支援中的下列功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   這個屬性可以設定樣式。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
-   這個屬性可以透過資料繫結設定。 如需資料繫結相依性屬性的詳細資訊，請參閱[How to： 將控制項繫結屬性的兩個](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。  
  
-   這個屬性可以設定的動態資源參考。 如需詳細資訊，請參閱 [XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   屬性可以在自動繼承其值從父元素中的項目樹狀結構。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
-   屬性可以動畫顯示。 如需詳細資訊，請參閱 [動畫概觀](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。  
  
-   已變更之屬性的舊值和屬性值可以強制轉型時，可報告屬性。 如需詳細資訊，請參閱[相依性屬性回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
-   屬性會報告資訊[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如變更屬性值是否需要重新撰寫的項目視覺效果的版面配置系統。  
  
-   屬性會獲得中的支援[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。  例如，在編輯內容**屬性**視窗。  
  
 若要了解有關相依性屬性的詳細資訊，請參閱[相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。 如果您想屬性上您在上述清單中支援的功能的自訂類型時，您應該建立相依性屬性。  若要深入了解如何建立自訂的相依性屬性，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
 附加的屬性是屬性，可讓任何要報告其資訊所定義之附加的屬性的型別物件。 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，繼承自任何型別<xref:System.Windows.DependencyObject>可以使用附加的屬性，不論是否類型繼承自定義屬性的型別。 附加的屬性是一項功能[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語言。  若要設定附加的屬性在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*ownerType*。*propertyName*語法。 附加屬性的範例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性。 如果您想要建立此屬性，可以用在所有<xref:System.Windows.DependencyObject>類型，則您應該建立附加的屬性。 若要深入了解附加的屬性，包括如何建立它們，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 值  
 `dependencyPropertyName`  
 字串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>所需的相依性屬性。 這可以前面加上 XML 命名空間前置詞如果屬性不是預設 XML 命名空間 (如需詳細資訊，請參閱[XAML 命名空間和 WPF XAML 命名空間對應](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)  
  
 `ownerType`.`dependencyPropertyName`  
 字串，指定擁有者類型的相依性屬性，點 （.），然後在<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。 `ownerType` 前面可以也有 XML 命名空間前置詞。 這種用法是晚期繫結樣式和範本，因為剖析內容必須指定相依性屬性的擁有者的特殊`TargetType`尚不知道。 如需詳細資訊，請參閱 [設定樣式和範本](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 字串，指定附加的屬性，點 （.），然後附加的屬性名稱的擁有者。 `attachedPropertyOwnerType` 前面可以也有 XML 命名空間前置詞。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加入其他類型，以作為已註冊至某個類型之相依性屬性的擁有者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">要加入為此相依性屬性之擁有者的類型。</param>
        <summary>加入其他類型，作為已註冊之相依性屬性的擁有者。</summary>
        <returns>原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。 應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您對屬性系統，以識別一開始未登錄特定相依性屬性的型別上的相依性屬性。  
  
 一般而言，<xref:System.Windows.DependencyProperty.AddOwner%2A>用來將相依性屬性加入至已經不會公開透過 managed 的類別繼承該相依性屬性的類別 (類別繼承會導致在衍生類別繼承的包裝函式屬性，因此會提供一般成員資料表的相依性屬性的存取已經）。 <xref:System.Windows.DependencyProperty.AddOwner%2A> 可讓屬性系統，以識別一開始未登錄該相依性屬性的型別上的相依性屬性。  
  
 此簽章不允許指定中繼資料。  當您使用這個方法時，中繼資料會自動產生新的<xref:System.Windows.DependencyProperty>和擁有者型別。 自動產生中繼資料是從所有已定義這個屬性的基底類型的合併中繼資料的結果。 如果沒有合併中繼資料可用，則會使用屬性的預設中繼資料。 如果屬性已註冊使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，則預設中繼資料是時建立的中繼資料相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>呼叫。 否則，<xref:System.Windows.PropertyMetadata>物件會透過<xref:System.Windows.PropertyMetadata.DefaultValue%2A>屬性設定為屬性類型的預設和所有其他屬性<xref:System.Windows.PropertyMetadata>設`null`。 使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>簽章，如果您想要加入至提供的類型，提供中繼資料版本的相依性屬性。  
  
 這個方法的傳回值通常用來宣告及公開之相依性屬性所儲存的相依性屬性的識別項。 識別項提供的相依性屬性的存取，如果您想要呼叫屬性系統[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]針對相依性屬性，特別是因為它存在於加入的擁有者類別。 原始的擁有者和加入的擁有者相同的屬性名稱應該用來表示類似的功能。 您應該使用<xref:System.Windows.DependencyProperty>的傳回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法定義相依性屬性的識別項，並宣告[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>建立宣告內的相依性屬性時，上述建議的方法使用[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 比方說，兩者<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。 <xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性至屬性系統，藉由呼叫<xref:System.Windows.DependencyProperty.AddOwner%2A>根據原始的擁有者<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性的識別項。 <xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立新的靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上加入的擁有者，該屬性和`BorderBrush`也已經宣告屬性的包裝函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">要加入為此相依性屬性之擁有者的類型。</param>
        <param name="typeMetadata">限定存在於所提供類型之相依性屬性的中繼資料。</param>
        <summary>加入另一個類型作為已註冊的相依性屬性的擁有者，並提供在所提供擁有者類型上存在之相依性屬性的相依性屬性中繼資料。</summary>
        <returns>原始 <see cref="T:System.Windows.DependencyProperty" /> 識別項的參考，它識別相依性屬性。 應該藉由加入類別作為 <see langword="public static readonly" /> 欄位來公開此識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您對屬性系統，以識別一開始未登錄特定相依性屬性的型別上的相依性屬性。  
  
 這個方法的傳回值用於宣告，並公開 （expose） 的相依性屬性，特別是存在於加入的擁有者類別。 一般而言，原始的擁有者和加入的擁有者相同的屬性名稱應該用來表示類似的功能。 若要公開 （expose） 的識別碼，以及當新的最佳作法是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>上述建議的方法在建立時使用[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]內宣告[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 比方說，兩者<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定義`BorderBrush`具有類似功能的相依性屬性。 <xref:System.Windows.Controls.Control> 定義其`BorderBrush`屬性至屬性系統，藉由呼叫<xref:System.Windows.DependencyProperty.AddOwner%2A>原始的擁有者上<xref:System.Windows.Controls.Border>且其已註冊<xref:System.Windows.Controls.Border.BorderBrushProperty>相依性屬性的識別項。 <xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值，然後用來建立靜態<xref:System.Windows.DependencyProperty>欄位 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上加入的擁有者，該屬性和`BorderBrush`也已經宣告屬性的包裝函式。  
  
 加入的擁有者相依性屬性的識別項應該使用作業例如<xref:System.Windows.DependencyObject.GetValue%2A>。 不過，與類型或已加入為具有不同的中繼資料擁有者仍類別的執行個體相關的特定類型的作業會傳回預期的結果，即使原始 （未加入擁有者） 中所指定相依性屬性的識別項這類方法呼叫<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。 加入的擁有者的中繼資料由址<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫本身，不一定是以獨佔方式所加入的擁有者類別識別項欄位參考。 不過，公開的識別項，以及當新的最佳作法是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性的包裝函式，會加入至類型使用的相依性屬性<xref:System.Windows.DependencyProperty.AddOwner%2A>，因為這麼建立之間的差異[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]屬性的表示法。  
  
 為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 將會保存任何原始基底中繼資料中所指定的特性。 只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果有指定新的中繼資料中會被取代。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 最後，合併行為取決於用來覆寫時，因此這裡描述的行為是所使用的現有屬性中繼資料類別的屬性中繼資料型別[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。 如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的預設中繼資料。</summary>
        <value>相依性屬性的預設中繼資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設中繼資料不是可用於該特定物件或衍生型別的物件沒有替代的中繼資料，提供明確的屬性中繼資料<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼叫。  
  
 如果原始的擁有者中繼資料用於第一個<xref:System.Windows.DependencyProperty.Register%2A>建立相依性屬性，則該中繼資料會做為傳回的呼叫<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 如果沒有中繼資料已套用至原始<xref:System.Windows.DependencyProperty.Register%2A>呼叫，則預設中繼資料會產生從<xref:System.Windows.DependencyProperty.Register%2A>呼叫，這個值會當成<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 具有相關聯的預設中繼資料的主要目的<xref:System.Windows.DependencyProperty>提供任何上這個屬性的預設值是<xref:System.Windows.DependencyObject>或衍生型別。  
  
 對於未附加的屬性，這個屬性所傳回的中繼資料類型無法轉換成衍生類型的<xref:System.Windows.PropertyMetadata>類型，即使屬性最初註冊與衍生的中繼資料型別。 如果您想原先已註冊的中繼資料，包括其原始的中繼資料可能是衍生型別時，呼叫<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>相反地，傳遞原始註冊型別做為參數。  
  
 為附加屬性，這個屬性所傳回的中繼資料的類型會比對中原始提供的類型<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊方法。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊程式碼。</summary>
        <returns>這個 <see cref="T:System.Windows.DependencyProperty" /> 的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 對屬性系統會使用它自己的唯一識別碼<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，且該屬性的值傳回的<xref:System.Windows.DependencyProperty.GetHashCode%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回與特定類型的此相依性屬性相關聯的中繼資料。 這可以是第一次註冊相依性屬性的類型 (之後會加一)，或透過繼承取得相依性屬性但特別覆寫中繼資料的類型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">要從中擷取相依性屬性中繼資料的特定類型。</param>
        <summary>傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的現有類型。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考做為型別是必要的因為中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>alter 相依性屬性的中繼資料存在於型別上的呼叫。  
  
   
  
## Examples  
 下列範例會取得其類型為基礎的相依性屬性的中繼資料。 型別透過使用`typeof`運算子。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">檢查了相依性物件的類型，以判斷中繼資料應該來自於相依性屬性的哪一個特定類型版本。</param>
        <summary>傳回這個相依性屬性的中繼資料，因為這個屬性位於指定的物件執行個體。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考，所以必須任何指定的相依性屬性的中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以修正屬性中繼資料的呼叫型別。  
  
 當您要求執行個體為基礎的屬性中繼資料時，您實際上只傳遞執行個體，以便可以在內部評估它的型別。 相依性屬性中繼資料不會變化每個執行個體。它永遠是一致的任何指定的型別屬性組合。  
  
   
  
## Examples  
 下列範例會取得根據特定的相依性屬性的中繼資料<xref:System.Windows.DependencyObject>執行個體。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">記錄需要相依性屬性中繼資料之相依性物件類型的特定物件。</param>
        <summary>傳回存在於所指定類型之這個相依性屬性的中繼資料。</summary>
        <returns>屬性中繼資料物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的類型或物件參考，所以必須任何指定的相依性屬性的中繼資料可能與原始的註冊，因為<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>存在於可以修正屬性中繼資料的呼叫型別。  
  
   
  
## Examples  
 下列範例會取得中繼資料相依性屬性，根據其<xref:System.Windows.DependencyObjectType>。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可唯一識別相依性屬性的內部產生值。</summary>
        <value>唯一數值識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個值是整數，不全域唯一識別碼 (GUID)。 一般而言，並不需要，使用此索引值，而且沒有任何索引資料表的存取權的所有相依性屬性。 依其識別項欄位時，應該改為參考相依性屬性。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 在內部用來更快速存取使用的資料結構<xref:System.Windows.DependencyProperty.GlobalIndex%2A>為以零為起始的陣列索引。 類似的使用方式可能會有應用程式的設計工具或工具。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要檢查的值。</param>
        <summary>根據原始相依性屬性註冊所提供的屬性型別檢查這個相依性屬性的型別，判斷此型別是否接受指定的值。</summary>
        <returns>
          如果指定的值為註冊的屬性型別或可接受的衍生型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值為`null`是有效的類型為參考類型的相依性屬性，或<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。 相依性屬性的未參考情況下也未<xref:System.Nullable%601>型別，<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.DependencyProperty.IsValidType%2A>之前先呼叫檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要檢查的值。</param>
        <summary>透過基本型別檢查，判斷屬性型別是否接受所提供的值，並在必要時判斷此值是否位於該型別的允許值範圍內。</summary>
        <returns>
          如果此值可被接受且屬於正確型別或衍生型別，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性屬性，允許的範圍，該類型的值可以透過指定<xref:System.Windows.ValidateValueCallback>提供相依性屬性註冊中。  
  
 這個方法會呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>內部。 如果有問題的相依性屬性沒有<xref:System.Windows.ValidateValueCallback>，則呼叫這個方法會有效等同於呼叫<xref:System.Windows.DependencyProperty.IsValidType%2A>。 如果沒有相依性屬性<xref:System.Windows.ValidateValueCallback>，而且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`true`，然後在回呼中實作時，會傳回的值。  
  
 Null 值是有效的值為參考類型的相依性屬性，或<xref:System.Nullable%601>相依性屬性，而會傳回`true`在這些情況下。 相依性屬性的未參考情況下也未<xref:System.Nullable%601>型別，<xref:System.Windows.DependencyProperty.IsValidType%2A>會傳回`false`null 值，而不是引發例外狀況。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>之前先呼叫檢查<xref:System.Windows.DependencyObject.SetValue%2A>的相依性屬性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的名稱。</summary>
        <value>屬性的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會取得名稱做為提供`name`期間註冊相依性屬性的參數。 這個名稱是不可變的且無法`null`或空字串。 重複名稱註冊相同的擁有者類型上不允許，並將會擲回例外狀況，當您嘗試註冊重複。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>相依性的屬性必須遵循的慣例後置詞"Property"減去其相依性屬性的識別項的名稱相符。 如需詳細資訊，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
   
  
## Examples  
 下列範例會查詢各種特性的相依性屬性的識別項，包括<xref:System.Windows.DependencyProperty.Name%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供這個相依性屬性出現在所指定類型的執行個體時所要使用的替代中繼資料，相較於初始相依性屬性註冊中所提供的中繼資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</param>
        <param name="typeMetadata">要套用至覆寫類型上相依性屬性的中繼資料。</param>
        <summary>當這個相依性屬性出現在所指定類型的執行個體中時，指定其替代中繼資料，並覆寫從基底類型繼承時存在的相依性屬性中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應該覆寫相依性屬性中繼資料，再對屬性系統使用的相依性屬性。 這等同於使用登錄相依性屬性的類別建立特定的執行個體的時間。 呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>執行應該只能在靜態建構函式的類型，提供本身為`forType`參數，這個方法，或透過類似的具現化。 嘗試變更中繼資料之後有擁有者類型的執行個體, 將不會引發例外狀況，但將會導致屬性系統中的行為不一致。  
  
 使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別中的中繼資料將會引發例外狀況。  
  
 為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 會保存任何原始基底中繼資料中所指定的特性。只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的中繼資料中指定，會被取代。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 最後，合併行為取決於用來覆寫時，因此這裡描述的行為是所使用的現有屬性中繼資料類別的屬性中繼資料型別[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]相依性屬性。 如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">嘗試覆寫唯讀相依性屬性的中繼資料 (無法使用此簽章完成作業)。</exception>
        <exception cref="T:System.ArgumentException">已經建立相依性屬性的中繼資料，因為它存在於所提供的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">繼承這個相依性屬性，且將套用所提供替代中繼資料的類型。</param>
        <param name="typeMetadata">要套用至覆寫類型上相依性屬性的中繼資料。</param>
        <param name="key">唯讀相依性屬性的存取索引鍵。</param>
        <summary>當它出現在所指定類型的執行個體，覆寫在初始相依性屬性登錄中所提供的中繼資料時，提供唯讀相依性屬性的替代中繼資料。 您必須傳遞唯讀相依性屬性的 <see cref="T:System.Windows.DependencyPropertyKey" />，以免引發例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此簽章提供基礎實作唯讀相依性屬性的識別項 (<xref:System.Windows.DependencyPropertyKey>) 方法。 如果覆寫讀寫相依性屬性的中繼資料，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。  
  
 應該覆寫相依性屬性中繼資料，再對屬性系統使用的相依性屬性。 這等同於登錄相依性屬性的類別會建立特定物件的時間。 呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>執行應該只能在靜態建構函式的類型，提供本身為`forType`參數，這個方法，或透過類似的具現化。 嘗試變更中繼資料之後有擁有者類型的執行個體, 將不會引發例外狀況，但將會導致屬性系統中的行為不一致。  
  
 使用此方法建立的特定衍生的類別覆寫中繼資料之後，後續嘗試覆寫這個相同的衍生類別中的中繼資料將會引發例外狀況。  
  
 為存在於基底的擁有者相依性屬性的屬性中繼資料會合併提供的中繼資料。 會保存任何原始基底中繼資料中所指定的特性。只有在特別以新的中繼資料變更的特性，將會覆寫基底中繼資料的特性。 某些特性，例如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的中繼資料中指定，會被取代。 其他項目，例如<xref:System.Windows.PropertyChangedCallback>，結合。 合併行為取決於用來覆寫的屬性中繼資料類型。 如需詳細資訊，請參閱[相依性屬性中繼資料](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[架構屬性中繼資料](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對屬性系統註冊相依性屬性之物件，或將本身作為屬性擁有者加入之物件的類型。</summary>
        <value>註冊屬性或將本身作為屬性擁有者加入的物件類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在屬性註冊期間提供的這個值。 擁有者將會是原始註冊型別是<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.Register%2A>呼叫時或將本身作為擁有者中的案例中加入型別<xref:System.Windows.DependencyProperty>從產生的識別項<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫。  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A>在任何給定<xref:System.Windows.DependencyProperty>是不可變的且無法`null`中有效<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會取得相依性屬性的識別項所根據的擁有者類型`dp`，然後在該相同的識別項的擁有者類型上取得中繼資料。 這項作業會實際相當於取得<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性用於其值的型別。</summary>
        <value>屬性值的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會報告透過宣告的原始屬性註冊中，屬性值的型別`propertyType`參數。 類似於<xref:System.Windows.DependencyProperty.Name%2A>之後註冊, 相依性屬性的屬性類型是不變。  
  
   
  
## Examples  
 下列範例會查詢各種特性的相依性屬性的識別項，包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。 類型名稱字串<xref:System.Windows.DependencyProperty.PropertyType%2A>取得從傳回<xref:System.Type>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Windows.DependencyProperty" /> 執行個體所識別的相依性屬性是否為唯讀相依性屬性。</summary>
        <value>
          如果相依性屬性為唯讀則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 唯讀相依性屬性時，會註冊內對屬性系統上，藉由呼叫<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法與<xref:System.Windows.DependencyProperty.Register%2A>方法。 附加的屬性也可以註冊為唯讀。請參閱<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。  
  
 唯讀相依性屬性需要<xref:System.Windows.DependencyPropertyKey>識別碼而非<xref:System.Windows.DependencyProperty>執行中繼資料作業，例如覆寫中繼資料或設定值的識別項。 如果您取得的集合<xref:System.Windows.DependencyProperty>透過呼叫的識別項<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一個[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公開識別項，核取<xref:System.Windows.DependencyProperty.ReadOnly%2A>值，然後再嘗試將呼叫<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用，相依性屬性的識別項做為輸入參數，以確認相依性屬性的識別項表示不是唯讀狀態。 如果值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`相依性屬性，沒有任何程式設計的方式，來取得指向參考<xref:System.Windows.DependencyPropertyKey>從中繼資料，或從該相依性屬性的識別項<xref:System.Windows.DependencyProperty>識別碼; 識別項若要呼叫必須為靜態欄位有<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>針對唯讀相依性屬性。  
  
 當您建立自訂的相依性屬性，並註冊以唯讀狀態時，您應該定義只能用於 get[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包裝函式屬性。 否則，您的類別必須令人混淆的物件模型的內容包裝函式相較於備份相依性屬性的存取。 如需詳細資訊，請參閱[自訂相依性屬性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[唯讀相依性屬性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
   
  
## Examples  
 下列範例從各種不同的相依性屬性欄位中取得的預設中繼資料和相依性屬性的識別項屬性，並使用此資訊來擴展資料表，以實作 「 中繼資料瀏覽器 」。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>登錄相依性屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。 名稱在擁有者類型的註冊命名空間內必須是唯一的。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <summary>使用指定的屬性名稱、屬性類型和擁有者類型以註冊相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</param>
        <summary>使用指定的屬性名稱、屬性類型、擁有者類型、屬性中繼資料和屬性的值驗證回呼，註冊相依性屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊相依性屬性，包括驗證回呼 (回呼定義不會顯示; 如需回呼定義的詳細資訊，請參閱<xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向屬性系統註冊附加的屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <summary>使用指定的屬性名稱、屬性類型和擁有者類型以註冊附加屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊附加的屬性上使用這項功能的抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。 這可以包含預設值及其他特性。</param>
        <summary>請使用指定的屬性名稱、屬性類型、擁有者類型和屬性中繼資料登錄附加的屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承相依性屬性  
 註冊具有的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。   雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。 註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。 這可以包含預設值及其他特性。</param>
        <param name="validateValueCallback">回呼的參考，應該執行對相依性屬性值之一般類型驗證以外的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料以及屬性的值驗證回呼，註冊附加屬性。</summary>
        <returns>相依性屬性識別項應該用於設定類別中的 <see langword="public static readonly" /> 欄位。 若為以程式設計方式設定其值或取得中繼資料等的作業，之後就會用識別項參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的屬性是所定義的屬性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 實作相依性屬性為附加屬性。 因為[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的屬性是相依性屬性，它們可以有套用中繼資料可供一般屬性系統的作業，例如報表版面配置特性的。 如需詳細資訊，請參閱[附加屬性概觀](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承相依性屬性  
 註冊具有的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。   雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。 註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
   
  
## Examples  
 下列範例會註冊附加的屬性上使用這項功能的抽象類別<xref:System.Windows.DependencyProperty.RegisterAttached%2A>簽章。 這個連接的屬性是列舉型別屬性，並註冊會加入驗證回呼，以確認提供的值是列舉值。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊唯讀的附加屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>註冊具有指定屬性類型、擁有者類型和屬性中繼資料的唯讀附加屬性。</summary>
        <returns>應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。 也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。  
  
 唯讀附加的屬性會是罕見的情況下，因為附加屬性的主要案例是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 沒有公用 setter，附加的屬性無法設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承相依性屬性  
 註冊為相依性屬性的其中一個特定案例附加為支援繼承屬性值。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。   雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。 註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="defaultMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼，註冊一個唯讀附加屬性。</summary>
        <returns>相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。 一般而言，代表類型的索引鍵<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。 也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。  
  
 唯讀附加的屬性會是罕見的情況下，因為附加屬性的主要案例是用於[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 沒有公用 setter，附加的屬性無法設定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]語法。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值繼承相依性屬性  
 註冊為而不是附加的相依性屬性的其中一個特定案例<xref:System.Windows.DependencyProperty.Register%2A>是為了支援繼承屬性值。 您應該註冊將相依性屬性值繼承與<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使類別會定義屬性的包裝函式存取子中公開 （expose） 的相依性屬性，而且即使您不想要取得 * 和集 * 的靜態方法，以提供公開 （expose） 為 true，則附加屬性支援存取子。   雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀結構中特定項目界限的附加屬性的繼承行為是未定義。 註冊為附加有效的屬性附加的屬性的全域屬性至屬性系統，並確保屬性值繼承跨項目樹狀結構中的所有界限。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊屬性，指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>中繼資料中。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊相依性屬性為唯讀相依性屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <summary>使用指定的屬性類型、擁有者類型和屬性中繼資料登錄唯讀相依性屬性。</summary>
        <returns>相依性屬性索引鍵，應該用來在您的類別中設定靜態唯獨欄位值，然後用來參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。 也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。  
  
 唯讀相依性屬性是相當一般的案例中這兩個現有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]及自訂案例，因為其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要相依性屬性，即使該屬性不是要由可設定呼叫端。 您可以使用唯讀相依性屬性的值做為基礎的相依性屬性，例如為基礎之其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下列範例會註冊`AquariumSize`以唯讀狀態的相依性屬性。 此範例會定義`AquariumSizeKey`內部索引鍵 （組件中的，讓其他類別可以覆寫中繼資料） 以及與該索引鍵為基礎的相依性屬性的識別項會公開`AquariumSizeProperty`。 此外，包裝函式建立`AquariumSize`，僅有 get 存取子。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要註冊之相依性屬性的名稱。</param>
        <param name="propertyType">屬性的類型。</param>
        <param name="ownerType">正在註冊相依性屬性的擁有者類型。</param>
        <param name="typeMetadata">相依性屬性的屬性中繼資料。</param>
        <param name="validateValueCallback">使用者建立回呼的參考，除了一般類型驗證以外，還應執行相依性屬性值的任何自訂驗證。</param>
        <summary>使用指定的屬性類型、擁有者類型、屬性中繼資料和驗證回呼登錄唯讀相依性屬性。</summary>
        <returns>應該用來設定類別中靜態唯讀欄位值的相依性屬性索引鍵，其將在稍後用於參考相依性屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回型別<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>傳回型別<xref:System.Windows.DependencyProperty>。 一般而言，代表唯讀屬性的索引鍵不會公開，因為這些金鑰可以用來設定相依性屬性值，藉由呼叫<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 類別設計會影響您的需求，但通常最好是限制的存取和任何的可見性<xref:System.Windows.DependencyPropertyKey>只有部分的程式碼所需的相依性屬性設定為類別或應用程式邏輯的一部分。 也建議您藉由公開的值公開唯讀相依性屬性的相依性屬性的識別項<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>為`public static readonly`欄位上您的類別。  
  
 唯讀相依性屬性是相當一般的案例。 您可以使用唯讀相依性屬性的值做為基礎的相依性屬性，例如為基礎之其他屬性系統作業<xref:System.Windows.Trigger>樣式中的相依性屬性。  
  
 如需有關註冊相依性屬性的詳細資訊，請參閱<xref:System.Windows.DependencyProperty>。  
  
 唯讀相依性屬性的驗證可能是較不重要。 您指定的索引鍵的非公用存取層級可降低對任意無效的輸入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回相依性屬性的字串表示。</summary>
        <returns>相依性屬性的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作會傳回<xref:System.Windows.DependencyProperty.Name%2A>屬性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 屬性系統所使用的靜態值，而非指定 <see langword="null" />，以表示屬性已存在，但屬性系統尚未設定其值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> 是用於案例之 sentinel 值其中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]屬性系統是無法判斷要求<xref:System.Windows.DependencyProperty>值。 <xref:System.Windows.DependencyProperty.UnsetValue> 會使用而非`null`，因為`null`可能是有效的屬性值，以及有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 絕對不會傳回出<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。 當您呼叫<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>相依性屬性上<xref:System.Windows.DependencyObject>下列其中一種適用於執行個體：  
  
-   相依性屬性中繼資料中所建立的預設值，而且在傳回的值。 這個值可能來自於<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
-   其他值對屬性系統，所建立，不再相關的預設值。 如需詳細資訊，請參閱[相依性屬性值優先順序](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 設定<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>特別不允許。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 傳回<xref:System.Windows.DependencyProperty.UnsetValue>當要求的屬性尚未在本機設定。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊意義時做為傳回值<xref:System.Windows.CoerceValueCallback>。 如需詳細資訊，請參閱[相依性屬性的回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 如果您要繫結至資料庫，請注意，<xref:System.Windows.DependencyProperty.UnsetValue>不等同於<xref:System.DBNull.Value>，方式類似的方式<xref:System.DBNull.Value>不等於 null，則為 true。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的值驗證回呼。</summary>
        <value>這個相依性屬性的值驗證回呼，如同在原始相依性屬性註冊中為 <paramref name="validateValueCallback" /> 參數所提供的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會包含`null`與任何已註冊的驗證回呼的相依性屬性。  
  
 驗證回呼必須扮演靜態的有意義的值： 透過套用驗證<xref:System.Windows.ValidateValueCallback>無法判斷提供的值是否為有效的任何特定執行個體。 回呼只會得出擁有相依性屬性的所有物件是否不應該接受所提供的值為有效。 如果您要執行驗證所使用的了解在特定的執行個體，使用其他相依性屬性的值<xref:System.Windows.CoerceValueCallback>改為。 <xref:System.Windows.CoerceValueCallback>註冊為組件的相依性屬性中繼資料，而不是直接相依性屬性的識別項。 如需詳細資訊，請參閱[相依性屬性的回呼和驗證](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>