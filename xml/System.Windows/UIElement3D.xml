<Type Name="UIElement3D" FullName="System.Windows.UIElement3D">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1b4fe164e5086607128f1b7486da3fa6192ba9e" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32039964" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class UIElement3D : System.Windows.Media.Media3D.Visual3D, System.Windows.IInputElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract UIElement3D extends System.Windows.Media.Media3D.Visual3D implements class System.Windows.IInputElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement3D" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class UIElement3D&#xA;Inherits Visual3D&#xA;Implements IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class UIElement3D abstract : System::Windows::Media::Media3D::Visual3D, System::Windows::IInputElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Media3D.Visual3D</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <see cref="T:System.Windows.UIElement3D" /> 是以 Windows Presentation Foundation (WPF) 項目和基本呈現方式特性為建置基礎之 WPF 核心層級實作的基底類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D> 是抽象的基底類別，您可以從中衍生類別來代表特定的 3D 項目。  
  
 3D 項目的輸入、 焦點，以及事件處理行為的許多一般定義於<xref:System.Windows.UIElement3D>類別。 這包括鍵盤、 滑鼠及手寫筆輸入及相關的狀態屬性的事件。 其中許多事件會路由的事件，以及許多輸入相關的事件都有兩個反昇路由版本，以及通道事件的版本。 這些配對的事件通常是最大控制項作者感興趣的事件。  
  
 <xref:System.Windows.UIElement3D> 也包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]相關的[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]事件模型，包括可以引發的方法所指定路由傳送來自於項目執行個體的事件。  
  
 A<xref:System.Windows.UIElement3D>具有下列功能，特別由定義<xref:System.Windows.UIElement3D>類別：  
  
-   可以回應使用者輸入 (包括控制項的輸入透過事件處理的傳送位置路由或路由的命令)。  
  
-   可以引發邏輯項目樹狀透過路由的路由的事件。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement3D.Visibility%2A> 狀態會影響所有的項目所處理的輸入。 不會顯示的項目不會參與點擊測試，而不會收到輸入的事件，即使透過範圍將項目，則滑鼠如果可以看見。  
  
 不同於<xref:System.Windows.UIElement>類別<xref:System.Windows.UIElement3D>類別不包含配置。 因此，<xref:System.Windows.UIElement3D>類別不包含**量值**或**排列**方法。  
  
 類別衍生自<xref:System.Windows.UIElement3D>並維護它自己的集合<xref:System.Windows.Media.Media3D.Visual3D>藉由覆寫物件<xref:System.Windows.Media.Media3D.Visual3D.GetVisual3DChild%2A>和<xref:System.Windows.Media.Media3D.Visual3D.Visual3DChildrenCount%2A>仍然必須傳遞新<xref:System.Windows.Media.Media3D.Visual3D>物件加入至<xref:System.Windows.Media.Media3D.Visual3D.AddVisual3DChild%2A>。  
  
 <xref:System.Windows.UIElement3D> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例示範如何從衍生<xref:System.Windows.UIElement3D>類別來建立`Sphere`類別：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 如需完整範例，請參閱[UIElement3D 球體範例](http://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIElement3D ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UIElement3D();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.UIElement3D" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.%23ctor%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要處理的路由事件識別項。</param>
        <param name="handler">處理常式實作的參考。</param>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以加入相同的處理常式事件多次，而不會引發例外狀況。 不過，此處理常式實際叫用時處理事件的多次。 因此，請考慮如何這種行為可能會有副作用，都應該在處理常式實作。  
  
 您通常使用這個方法來提供的 「 加入 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要處理的路由事件識別項。</param>
        <param name="handler">處理常式實作的參考。</param>
        <param name="handledEventsToo">
          <see langword="true" /> 表示註冊處理常式，以便即使路由事件在其事件資料中標記為已處理，仍會叫用該處理常式。<see langword="false" /> 表示以預設條件註冊處理常式，也就是如果路由事件已經標記為已處理，則不會叫用該處理常式。  
  
 預設值為 <see langword="false" />。  
  
 請勿定期要求重新處理路由事件。</param>
        <summary>加入所指定路由事件的路由事件處理常式，會將此處理常式加入目前項目的處理常式集合中。 將 <paramref name="handledEventsToo" /> 指定為 <see langword="true" />，以針對已經由事件路由上另一個項目標記為已處理的路由事件，叫用提供的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在可行的方式處理低階輸入是一個複雜的工作。 許多控制項實作特定事件標示為已處理，而取代為另一個更具直覺性事件的行為。 一般而言，控制項只會將平台輸入的事件，為已處理，如果沒有這麼做一些設計用意。 在某些情況下，這些設計目的不可能的輸入事件的特定處理的需要。 這些案例是該註冊處理常式取代`handledEventsToo`為`true`適合。 但您不應該這麼例行性。 叫用處理常式以回應所有事件，即使處理將會使得您自己的應用程式事件處理邏輯。 如果處理常式邏輯的很大，可能會看到效能降低。 您應該保留附加尚未處理的情況下，您已經發現特定控制項所處理的事件，您仍然想要處理的應用程式邏輯在開發程序的事件處理常式的使用。  
  
 避免處理行為的某些事件控制組合類別的另一個技術是使用該事件預覽替代方案。 例如，如果<xref:System.Windows.UIElement3D.MouseLeftButtonDown>標示為已處理的類別處理，您可以加入處理常式<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>改為。  
  
 您可以加入相同的處理常式事件多次，而不會引發例外狀況。 不過，此處理常式實際叫用時處理事件的多次。 因此，請考慮如何這種行為可能會有副作用，都應該在處理常式實作。  
  
 您通常使用這個方法來提供的 「 加入 」 存取子的實作[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自訂路由事件的存取模式。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">加入處理常式的事件路由。</param>
        <param name="e">用於加入處理常式的事件資料。 這個方法會使用事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性來建立處理常式。</param>
        <summary>針對目前的 <see cref="T:System.Windows.EventRoute" /> 事件處理常式集合，將處理常式加入至指定的 <see cref="T:System.Windows.UIElement3D" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 內容主機項目可以使用這個方法 (可能是指實作<xref:System.Windows.IContentHost>或未) 若要加入的子項目，來處理常式<xref:System.Windows.EventRoute>。  
  
 <xref:System.Windows.UIElement3D.AddToEventRoute%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定此元素是否可以當做拖放操作目標的值。</summary>
        <value>
          如果這個項目可以用來做為拖放作業的目標則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 拖放作業依預設，未啟用，且必須藉由設定刻意啟用<xref:System.Windows.UIElement3D.AllowDrop%2A>至`true`。 超出此基本設定，拖放行為完全實作特定，不由定義<xref:System.Windows.UIElement3D>或其他類型的基底項目類別。 某些控制項，例如<xref:System.Windows.Controls.RichTextBox>，沒有預設行為。 如需拖放的詳細資訊，請參閱[拖曳和卸除概觀](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。  
  
 <xref:System.Windows.UIElement3D.AllowDrop%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.AllowDropProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.AllowDrop" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.AllowDropProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控擷取至這個項目。</summary>
        <value>
          如果至少有一個觸控擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目。</summary>
        <value>
          如果至少有一個觸控擷取至這個項目或其視覺化樹狀結構中的任何子項目，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控在這個項目上按下。</summary>
        <value>
          如果至少有一個觸控在這個項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示是否至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下。</summary>
        <value>
          如果至少有一個觸控在這個項目或其視覺化樹狀結構中的任何子項目上按下，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesOver" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試強制將滑鼠的捕捉給這個項目。</summary>
        <returns>
          如果成功捕捉到滑鼠則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要擷取項目都必須啟用。 檢查是否<xref:System.Windows.UIElement3D.IsEnabled%2A>是`true`之前先呼叫<xref:System.Windows.UIElement3D.CaptureMouse%2A>。  
  
 如果呼叫<xref:System.Windows.UIElement3D.CaptureMouse%2A>傳回`true`，然後<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>也`true`。  
  
 如果呼叫<xref:System.Windows.UIElement3D.CaptureMouse%2A>傳回`true`，然後在<xref:System.Windows.UIElement3D.GotMouseCapture>和<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>引發事件，與<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>事件中的項目報告資料其中<xref:System.Windows.UIElement3D.CaptureMouse%2A>方法呼叫。 如果您強制擷取時，您可能會干擾現有的擷取 — 尤其是使用與拖放滑鼠相關聯的擷取。  
  
 若要清除所有項目從滑鼠擷取，請呼叫<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>與`element`提供做為參數`null`。  
  
 <xref:System.Windows.UIElement3D.CaptureMouse%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試強制將手寫筆的捕捉給這個項目。</summary>
        <returns>
          如果成功捕捉到手寫筆則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 永遠根據基礎的預設手寫筆裝置的預設實作會傳回`true`。 不過，如果可延伸提供輸入系統的裝置實作的輸入的裝置，則可以替代手寫筆裝置的實作可能會傳回不同的結果，以建立系統。  
  
 當項目擷取手寫筆時，即使手寫筆在其範圍外接收手寫筆輸入。 通常只會在拖放作業期間擷取手寫筆。  
  
 呼叫這個方法會呼叫基礎靜態<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。 實際擷取行為的實作方法的使用中的手寫筆裝置的實作。  
  
 若要擷取項目都必須啟用。 檢查是否<xref:System.Windows.UIElement3D.IsEnabled%2A>是`true`傳回才能呼叫<xref:System.Windows.UIElement3D.CaptureStylus%2A>。  
  
 如果呼叫<xref:System.Windows.UIElement3D.CaptureStylus%2A>傳回`true`，<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>也`true`。  
  
 <xref:System.Windows.UIElement3D.CaptureStylus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要擷取的裝置。</param>
        <summary>嘗試強制將觸控擷取至這個項目。</summary>
        <returns>
          如果指定的觸控已擷取至這個項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.CaptureTouch%2A> 會傳回`false`如果<xref:System.Windows.Input.TouchDevice>目前擷取另一個項目。  
  
 如果<xref:System.Windows.UIElement3D.CaptureTouch%2A>傳回`true`，然後在<xref:System.Windows.UIElement3D.GotTouchCapture>就會引發事件。  
  
 若要釋放擷取的單一觸控從這個項目，使用<xref:System.Windows.UIElement3D.ReleaseTouchCapture%2A>方法並指定要發行的觸控式裝置。 若要釋放所有的工作，從這個項目，使用<xref:System.Windows.UIElement3D.ReleaseAllTouchCaptures%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個項目關聯的 <see cref="T:System.Windows.Input.CommandBinding" /> 物件集合。</summary>
        <value>所有 <see cref="T:System.Windows.Input.CommandBinding" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Input.CommandBinding>啟用這個項目的特定命令的命令處理，並宣告命令、 其事件，以及由這個項目附加的處理常式之間的連結。  
  
 典型的另一種方式填入<xref:System.Windows.UIElement3D.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以程式設計的方式。  
  
 <xref:System.Windows.UIElement3D.CommandBindings%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreCommandBindings*  
 一或多個<xref:System.Windows.Input.CommandBinding>項目。 每一個都應該有<xref:System.Windows.Input.CommandBinding.Command%2A>屬性設定為已知的命令，而且屬性設定為<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>處理常式實作。 如需詳細資訊，請參閱<xref:System.Windows.Input.CommandBinding>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.DragEnter?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.DragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.DragEnter> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.DragEnterEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewDragEnter>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnDragEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.DragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragEnterEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.DragLeave?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.DragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.DragLeave> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.DragLeaveEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewDragLeave>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnDragLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.DragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragLeaveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使拖曳來自項目範圍中，就會發生此事件。 如果拖曳啟動界限之外，然後移動到內部，也會引發這個事件，以及<xref:System.Windows.UIElement3D.DragEnter>和相關的預覽事件。  
  
 此事件會建立一個別名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.DragOver?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.DragOver>事件會附加至基礎<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.DragOver> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.DragOverEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewDragOver>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnDragOver%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.DragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragOverEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.Drop?displayProperty=nameWithType>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.Drop>事件會附加至基礎<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.Drop> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.DropEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewDrop>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnDrop%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.Drop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DropEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試在項目上設定邏輯焦點。</summary>
        <returns>
          如果邏輯與鍵盤焦點皆設定至此項目則為 <see langword="true" />，如果只有設定邏輯焦點則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要可設定焦點，<xref:System.Windows.UIElement3D.Focusable%2A>和<xref:System.Windows.UIElement3D.IsEnabled%2A>兩者都必須是`true`。  
  
 即使項目是在特定的樹狀結構中的可設定焦點且已啟用，事件處理，（例如，針對複合控制項） 可能會回應預覽焦點事件藉由禁止焦點，因此這個方法會傳回`false`。  
  
 如果呼叫<xref:System.Windows.UIElement3D.Focus%2A>傳回`true`，<xref:System.Windows.UIElement3D.IsKeyboardFocused%2A>和<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>也`true`。  
  
 如果相關的屬性尚未`true`，當您呼叫<xref:System.Windows.UIElement3D.Focus%2A>，一或多個下列事件會依照下列順序引發： <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>， <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> （來源為新的焦點目標） <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>， <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>，<xref:System.Windows.UIElement3D.LostKeyboardFocus>， <xref:System.Windows.UIElement3D.GotKeyboardFocus> （來源為新的焦點目標）。  
  
 為了讓這個呼叫才會成功，應用程式中的某個其他項目需要先前有焦點。  
  
 焦點通常由兩個不同的概念： 鍵盤焦點和邏輯焦點，並不一定相同。 此方法會設定邏輯焦點，而且嘗試設定鍵盤焦點。 沒有任何程式設計的方法，來設定鍵盤焦點具體來說，這是由使用者輸入。 如需詳細資訊，請參閱[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.Focus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定元素是否能夠接收焦點的值。</summary>
        <value>
          如果項目可設定焦點則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有已取得焦點的項目收到鍵盤輸入。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]實際上會相依性屬性的屬性存取子。 這個特定的相依性屬性相當常有衍生的項目類別中以不同的方式設定其明顯"default"值。 這通常會發生在兩種方式之一：  
  
-   相依性屬性繼承自特定的衍生類別，但是，衍生類別覆寫之相依性屬性的中繼資料，並變更屬性的預設值。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.FocusableProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.UIElement3D.Focusable" /> 屬性的值變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.FocusableChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.Focusable" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.FocusableProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>當在衍生類別中覆寫時，如果沒有視覺化父項目存在，則會為這個項目傳回替代的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父項目。</summary>
        <returns>一個物件，如果衍生類別的實作有替代父代連接要報告。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設的虛擬實作這個方法會傳回`null`。 <xref:System.Windows.FrameworkElement> 提供實際的實作。  
  
 替代的父代是用於事件的路由，在其中項目會建立替代父結構，讓它的事件會路由傳送偏離標準模式的視覺化樹狀目錄以標準的父代，路由的方式的情況下或在中向下預覽路由策略。  
  
 <xref:System.Windows.UIElement3D.GetUIParentCore%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下牽涉此元素的拖放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.GiveFeedback>事件允許拖曳事件修改滑鼠指標外觀，以便將使用者視覺化回應提供拖放作業期間的來源。 視覺回應強調拖放作業正在進行。  
  
 此事件會建立一個別名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.GiveFeedback>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.GiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.GiveFeedback> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GiveFeedbackEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewGiveFeedback>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GiveFeedbackEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素取得邏輯焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同的範圍與鍵盤焦點不同邏輯焦點。 在此案例中，鍵盤焦點會維持其所在和項目位置<xref:System.Windows.UIElement3D.Focus%2A>方法呼叫仍取得邏輯焦點。  
  
 這個事件的更精確的解釋是它時引發的值<xref:System.Windows.UIElement3D.IsFocused%2A>屬性路由的項目已從`false`至`true`。  
  
 由於這個事件會使用反昇路由，接收焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。  
  
 <xref:System.Windows.UIElement3D.GotFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GotFocusEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
-   沒有任何對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGotFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> 是類似的事件可追蹤之屬性維護的項目; 焦點狀態中的狀態變更<xref:System.Windows.UIElement3D.GotKeyboardFocus>的許多相同的情況下，就會引發事件。  
  
 這個事件會使用反昇路由，因為具有焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際具有焦點的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.GotKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.GotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GotKeyboardFocusEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素擷取滑鼠時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目捕捉到滑鼠時，它收到滑鼠輸入，即使將滑鼠指標位於其範圍外。 滑鼠通常只會在拖放作業期間擷取並且擷取之前拖放作業的拖放動作發生。  
  
 這個事件會使用反昇路由，因為已擷取的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>資料，以判斷實際項目具有滑鼠擷取的事件。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.GotMouseCapture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.GotMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.GotMouseCapture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GotMouseCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   沒有定義對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGotMouseCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GotMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotMouseCaptureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素擷取手寫筆時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目擷取手寫筆時，即使指標位於其範圍外接收手寫筆輸入。 手寫筆通常只會在拖放作業期間擷取，並保留擷取，直到拖放作業的拖放動作發生。  
  
 這個事件會使用反昇路由，因為已擷取的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷已擷取的實際項目中。  
  
 此事件會建立這個類別的附加事件的別名，讓<xref:System.Windows.UIElement3D.GotStylusCapture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.GotStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.GotStylusCapture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GotStylusCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   沒有定義對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGotStylusCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GotStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotStylusCaptureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控擷取至這個項目時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.GotTouchCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與此元素關聯的輸入繫結集合。</summary>
        <value>輸入繫結的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入繫結支援命令與輸入裝置繫的結。 例如，<xref:System.Windows.Input.MouseBinding>實作輸入包含的滑鼠裝置特定內容的繫結。  
  
 輸入繫結的集合會包含屬於此類型的輸入繫結以及宣告執行個體的輸入繫結。  
  
 相關的屬性， <xref:System.Windows.UIElement3D.CommandBindings%2A>，維持命令繫結的集合。 這些不同從輸入繫結，因為它們代表的下一個層級的動作會繫結至已知命令的命令處理。  
  
 <xref:System.Windows.UIElement3D.InputBindings%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreInputBindings*  
 一或多個<xref:System.Windows.Input.InputBinding>項目 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>衍生類別)。 每一個都應該要有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>屬性設定。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateModel">
      <MemberSignature Language="C#" Value="public void InvalidateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.InvalidateModel" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateModel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateModel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓代表項目的模型失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您衍生自<xref:System.Windows.UIElement3D>類別，您可以使用這個方法並搭配<xref:System.Windows.UIElement3D.OnUpdateModel%2A>方法，以重新整理模型的項目。  
  
 您只需要在進階案例中呼叫這個方法。 這類進階的案例之一就是在衍生的類別有多個屬性會影響外觀，並且您想要一次更新基礎的模型。  
  
 <xref:System.Windows.UIElement3D.InvalidateModel%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例示範如何從衍生<xref:System.Windows.UIElement3D>類別來建立`Sphere`類別：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 如需完整範例，請參閱[UIElement3D 球體範例](http://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示此項目是否在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中啟用。</summary>
        <value>
          如果已啟用該項目則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意這個屬性會受到特定類別的實作<xref:System.Windows.UIElement3D.IsEnabledCore%2A>特定項目，通常在執行階段。 因此，此處所列的預設值有時不是有效。 嘗試設定此值將也可能會覆寫所傳回的值<xref:System.Windows.UIElement3D.IsEnabledCore%2A>。  
  
 未啟用的項目不會參與點擊測試或焦點，而且不會因此輸入事件的來源。  
  
 <xref:System.Windows.UIElement3D.IsEnabled%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsEnabledProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsEnabledChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會成為衍生類別中 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 的傳回值。</summary>
        <value>
          如果已啟用該項目則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsEnabledCore%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個屬性的預設實作快取的值，而且也會計算這個項目之父項目是否已啟用。 (如果未啟用父代，無法在實際有效地啟用的子項目[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果您選擇覆寫這個實作，請確定呼叫基底實作以保留此行為。</para>
        </block>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement3D.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsEnabledProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，決定這個項目是否具有邏輯焦點。</summary>
        <value>
          如果這個項目擁有邏輯焦點則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某個應用程式多個焦點分區，例如功能表內容和應用程式的其餘部分之間，可能會與鍵盤焦點不同邏輯焦點。 在此案例中，應用程式 UI 的一個項目上只能是鍵盤焦點，不過，其他焦點分割中的特定項目可能仍會保留邏輯焦點。 如需有關邏輯焦點的詳細資訊，請參閱[焦點概觀](~/docs/framework/wpf/advanced/focus-overview.md)。  
  
 您未設定此屬性 （它是唯讀） 設定焦點。 這個屬性的典型用法就是使用它作為相依性屬性的<xref:System.Windows.Setter>或<xref:System.Windows.EventTrigger>。 若要以程式設計方式設定焦點，呼叫<xref:System.Windows.UIElement3D.Focus%2A>。 藉由使用者動作或控制項實作，其中可能包括滑鼠捕捉行為，也可以設定焦點。  
  
 <xref:System.Windows.UIElement3D.IsFocused%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsFocusedProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsFocused" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsFocusedProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsHitTestVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHitTestVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHitTestVisible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定宣告此元素是否可以從其呈現內容的某些部分傳回，作為點擊測試結果的值。</summary>
        <value>
          如果這個項目可從至少一個點當做點擊測試結果傳回則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的有效值會受到點擊測試的項目邏輯樹狀中的相對位置。 比方說，如果某個元素的子元素的項目，不會叫用測試顯示，將會繼續的子系上屬性的有效值`false`，即使嘗試在本機設定該值。 基於這個理由，請務必確認您未設定<xref:System.Windows.UIElement3D.IsHitTestVisible%2A>至`false`複合控制項上，除非您不想要的任何輸入或的點擊測試該控制項。 如需點擊測試的詳細資訊，請參閱[視覺分層中的點擊測試](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisible%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsHitTestVisibleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsHitTestVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsHitTestVisibleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> 相依性屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsHitTestVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHitTestVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHitTestVisibleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值指出是否已啟用輸入方法系統，例如[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]，以處理此項目的輸入。</summary>
        <value>
          如果輸入方法作用中則為 <see langword="true" />，否則為 <see langword="false" />。 基礎附加屬性的預設值是<see langword="true;" />不過，這會受到輸入法在執行階段的實際狀態。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回附加的屬性所傳回的值<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>針對目前啟用輸入法 （keyboard、 語音、 其他輸入的裝置）。  
  
 <xref:System.Windows.UIElement3D.IsInputMethodEnabled%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個項目是否具有鍵盤焦點。</summary>
        <value>
          如果這個項目具有鍵盤焦點則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 決定的值，這個屬性的變更可能會伴隨焦點相關事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>常用類別事件處理常式中的其他輸入相關的事件，例如來決定項目已經有鍵盤焦點，或進行決定當滑鼠事件和鍵盤事件一起出現。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示鍵盤焦點是否在項目或其視覺化樹狀子項目內的任何位置。</summary>
        <value>
          如果鍵盤焦點在項目或其子項目上則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 對這個屬性的值的變更通常引發<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>事件，除非在衍生的類別已覆寫<xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A>来隱藏的事件。  
  
 您未設定這個屬性，但您也可以呼叫的項目設定焦點<xref:System.Windows.UIElement3D.Focus%2A>，或藉由<xref:System.Windows.UIElement3D.MoveFocus%2A>要求。 這些方法會呼叫其中一項可能會變更這個屬性值。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>通常用於類別的事件處理常式中其他輸入相關的事件，例如來決定項目已經有鍵盤焦點，或進行決定當滑鼠事件和鍵盤事件一起出現。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否將滑鼠擷取至這個項目。</summary>
        <value>
          如果項目已具有滑鼠捕捉則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 與處理序中的拖放作業相關的滑鼠捕捉的狀態。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsMouseCapturedProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCapturedProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值決定滑鼠擷取是由這個項目持有，還是由其視覺化樹狀結構中的子項目持有。</summary>
        <value>
          如果這個項目或包含的項目具有滑鼠捕捉則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithin%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出滑鼠指標位置是否與點擊測試結果對應，該結果會將複合項目納入考量。</summary>
        <value>
          <see langword="true" /> 如果滑鼠指標位於相同的項目結果與點擊測試。否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Windows.UIElement3D.IsMouseOver%2A>，這個屬性才`true`如果滑鼠指標常值的項目，因為其適用於點擊測試。 如果滑鼠指標改為子項目，這個屬性會是`false`。 大部分的情況下都不製作控制項，使用<xref:System.Windows.UIElement3D.IsMouseOver%2A>改為。  
  
 如果將滑鼠擷取由這個項目，而且這個屬性為`true`在擷取時，這個屬性會繼續傳回`true`直到失去滑鼠捕捉但其範圍不是指標。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出滑鼠指標是否在這個項目上方 (包括視覺化樹狀中的子項目)。</summary>
        <value>
          如果滑鼠指標位於項目或其子項目上方則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，控制項是複合的控制項 （視覺化樹狀結構） 內的各種項目都會報告包含控制項的滑鼠狀態。 例如，<xref:System.Windows.Controls.ListBox>樣式控制項將會報告<xref:System.Windows.UIElement3D.IsMouseOver%2A>為`true`如果滑鼠任意處是它的幾何，包括任何<xref:System.Windows.Controls.ListBoxItem>。  
  
 雖然類似"IsMouseOverChanged 」 事件不存在，便會執行數個類似的事件。 例如，您可以處理<xref:System.Windows.UIElement3D.MouseEnter>， <xref:System.Windows.UIElement3D.MouseMove>，和<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>。  
  
 如果此元素擷取滑鼠，這個屬性會保留`true`直到已失去滑鼠捕捉滑鼠指標離開項目範圍。  
  
 有些控制項刻意捕捉滑鼠上似乎沒有直接牽涉到滑鼠特定動作。 這可能會導致<xref:System.Windows.UIElement3D.IsMouseOver%2A>正在`true`即使看似沒有移動滑鼠。  
  
 <xref:System.Windows.UIElement3D.IsMouseOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsMouseOverProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsMouseOver" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseOverProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個項目是否擷取手寫筆。</summary>
        <value>
          如果項目已具有手寫筆捕捉則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptured%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsStylusCapturedProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusCapturedChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusCapturedProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值決定手寫筆擷取是由這個項目持有，還是由項目範圍及其視覺化樹狀中的項目持有。</summary>
        <value>
          如果這個項目或包含的項目具有手寫筆捕捉則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement3D.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出手寫筆位置是否與點擊測試結果相對應，該結果會將複合項目納入考量。</summary>
        <value>
          如果手寫筆位於與點擊測試相同的項目結果上方則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Windows.UIElement3D.IsStylusOver%2A>，這個屬性才`true`如果手寫筆在元素上方。 如果手寫筆改為透過子元素或元素的更深入的複合 （視覺化樹狀結構） 的一部分的項目，這個屬性會是`false`。  
  
 除非您知道控制項的複合 （例如，您使用這個屬性的自訂控制項範本中的控制項，您定義），這個屬性可能會傳回非預期的結果。 大部分的情況下都不製作控制項，使用<xref:System.Windows.UIElement3D.IsStylusOver%2A>改為。  
  
 如果這個項目具有手寫筆擷取，而且這個屬性是`true`在擷取時，這個屬性會保持`true`直到手寫筆擷取遺失，且其範圍不是手寫筆。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出手寫筆游標是否位在這個項目上方 (包括視覺子項目)。</summary>
        <value>
          如果手寫筆游標位於項目或其子項目上方則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目具有手寫筆擷取，這個屬性會繼續傳回`true`直到手寫筆擷取是遺失而且已超出其範圍的指標。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsStylusOverProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsStylusOver" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusOverProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此項目在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中是否為可見的。</summary>
        <value>
          如果事件為可見的則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 判斷<xref:System.Windows.UIElement3D.IsVisible%2A>值會考量許多因素而定。 相反地， <xref:System.Windows.UIElement3D.Visibility%2A>，這是可設定的屬性，只表示要以程式設計的方式讓項目，可見或不可見。  
  
 這個屬性的值的變更通常會引發<xref:System.Windows.UIElement3D.IsVisibleChanged>事件。 沒有相符[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]」 上 * 」 類別處理覆寫方法，讓某些衍生類別覆寫該行為，以及處理事件，但仍無法直接使用附加的類別處理常式<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 項目位置<xref:System.Windows.UIElement3D.IsVisible%2A>是`false`參與輸入的事件 （或命令），請執行不影響量值或排列傳遞的版面配置，不是可設定焦點、 索引標籤順序而且不會報告在點擊測試。 相較之下，項目位置<xref:System.Windows.UIElement3D.IsEnabled%2A>是`false`仍會參與事件和命令，以及點擊測試，但是也不是可設定焦點。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> 不是要做為樣式的觸發程序。 使用<xref:System.Windows.UIElement3D.IsVisible%2A>為樣式觸發程序可能會有無法預期的結果。 <xref:System.Windows.UIElement3D.IsVisible%2A> 適用於較低層級的輸入實作所檢查的狀態。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.IsVisibleProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsVisibleChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目的 <see cref="P:System.Windows.UIElement3D.IsVisible" /> 屬性值變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件，則不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsVisibleChanged> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsVisibleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.IsVisible" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsVisibleProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點且按下按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.KeyDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.KeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.KeyDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.KeyDownEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewKeyDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnKeyDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.KeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.KeyDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點且放開按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加這個類別的事件，讓<xref:System.Windows.UIElement3D.KeyUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.KeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.KeyUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.KeyUpEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewKeyUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnKeyUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.KeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.KeyUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去邏輯焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用方法呼叫刻意強制焦點，但上一個鍵盤焦點存在於不同範圍中，則邏輯焦點會與鍵盤焦點不同。 在此案例中、 鍵盤焦點會維持為，其所在和項目位置<xref:System.Windows.UIElement3D.Focus%2A>方法呼叫仍取得邏輯焦點。  
  
 這個事件的更精確的解釋是它時引發的值<xref:System.Windows.UIElement3D.IsFocused%2A>屬性路由的項目從變更`true`至`false`。  
  
 由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際取得焦點的項目中。  
  
 <xref:System.Windows.UIElement3D.LostFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.LostFocusEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.RoutedEventHandler>|  
  
-   沒有任何對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnLostFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤不再以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.LostKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.LostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.LostKeyboardFocusEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.LostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去滑鼠擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目捕捉到滑鼠時，它收到滑鼠輸入，即使指標位於其範圍外。 滑鼠通常只會在拖放作業期間擷取。  
  
 由於這個事件會使用反昇路由，失去擷取項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際遺失擷取的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.LostMouseCapture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.LostMouseCapture>事件會附加至基礎<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.LostMouseCapture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.LostMouseCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   沒有定義對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnLostMouseCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.LostMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostMouseCaptureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素失去手寫筆擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目擷取手寫筆時，即使指標位於其範圍外接收手寫筆輸入。 通常只會在拖放作業期間擷取手寫筆。  
  
 由於這個事件會使用反昇路由，失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.LostStylusCapture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.LostStylusCapture>事件會附加至基礎<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.LostStylusCapture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.LostStylusCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   沒有定義對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnLostStylusCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.LostStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostStylusCaptureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個項目失去觸控擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.LostTouchCaptureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指標在此元素上方且按下任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseDown>通常就會引發事件一起可能<xref:System.Windows.UIElement3D.MouseLeftButtonDown>或<xref:System.Windows.UIElement3D.MouseRightButtonDown>，這對應到其中的兩個標準滑鼠按鈕的按下。 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> 和<xref:System.Windows.UIElement3D.MouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。 請參閱備註<xref:System.Windows.UIElement3D.MouseLeftButtonDown>或<xref:System.Windows.UIElement3D.MouseRightButtonDown>。  
  
> [!IMPORTANT]
>  某些控制項可能會繼承的類別處理滑鼠按鈕的事件。 滑鼠左鍵按下事件是最有可能有控制項中的類別處理事件。 處理通常類別標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。 一旦處理標記事件，通常無法引發另一個執行個體處理常式附加至該元素。 不通常也會引發任何其他類別或執行個體的處理常式附加到反昇方向朝向 UI 樹狀目錄中的根項目。  
  
 您可以解決問題，會在前面的重要概述，仍然會接收<xref:System.Windows.UIElement3D.MouseDown>滑鼠左鍵，往下處理使用其中一個這些方案的類別衍生類別上的事件的事件：  
  
-   附加的處理常式<xref:System.Windows.UIElement3D.PreviewMouseDown>未標示為已由控制項所處理的事件。 請注意，因為這是預覽事件時，路由從根目錄開始，並透過通道傳送到控制項。  
  
-   藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.UIElement3D.AddHandler%2A>，然後選擇讓接聽事件，即使它們已標示為已處理路由的事件資料中的處理常式的簽章選項。  
  
 <xref:System.Windows.UIElement3D.MouseDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseDownEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewMouseDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標進入此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseEnter> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。 直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。  
  
 雖然<xref:System.Windows.UIElement3D.MouseEnter>時滑鼠指標進入項目的邊界時發生，此事件的詳細追蹤逐字報告<xref:System.Windows.UIElement3D.IsMouseOver%2A>屬性值已經從`false`至`true`這個項目上。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseEnter>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseEnter>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseEnter> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseEnterEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標離開此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeave> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。 直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。  
  
 雖然<xref:System.Windows.UIElement3D.MouseLeave>曲目，當滑鼠離開項目時，此事件多逐字報告<xref:System.Windows.UIElement3D.IsMouseOver%2A>屬性值已經從`true`至`false`這個項目上。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseLeave>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseLeave>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseLeave> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeaveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.MouseLeftButtonDown>處理，您要基本上標記<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。 這可能是包含類別處理常式產生事件如<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
> [!IMPORTANT]
>  處理通常類別標示基礎<xref:System.Windows.Input.Mouse>為已處理的類別事件。 一旦處理標記事件，通常無法引發另一個執行個體處理常式附加至該元素。 不通常也會引發任何其他類別或執行個體的處理常式附加到反昇方向朝向 UI 樹狀目錄中的根項目。  
  
 您可以解決問題，會在前面的重要概述，仍然會接收<xref:System.Windows.UIElement3D.MouseLeftButtonDown>滑鼠左鍵，往下處理使用其中一個這些方案的類別衍生類別上的事件的事件：  
  
-   附加的處理常式<xref:System.Windows.UIElement3D.PreviewMouseDown>未標示為已由控制項所處理的事件。 請注意，因為這是預覽事件時，路由從根目錄開始，並透過通道傳送到控制項。  
  
-   藉由呼叫可循序註冊控制項上的處理常式<xref:System.Windows.UIElement3D.AddHandler%2A>，然後選擇讓接聽事件，即使它們已標示為已處理路由的事件資料中的處理常式的簽章選項。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.MouseLeftButtonUp>處理，您要基本上標記<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseMoveEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewMouseMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.MouseRightButtonDown>處理，您要基本上標記<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。 這可能是包含類別處理常式產生事件如<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 滑鼠右鍵事件中通常會有原生處理應用程式案例。 比方說，向下的滑鼠右按鈕可能會顯示內容功能表。 請參閱[ContextMenu 概觀](~/docs/framework/wpf/controls/contextmenu-overview.md)。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseRightButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循反昇路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.MouseRightButtonUp>處理，您要基本上標記<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseRightButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素上方放開任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseUp>通常就會引發事件一起可能<xref:System.Windows.UIElement3D.MouseLeftButtonUp>或<xref:System.Windows.UIElement3D.MouseRightButtonUp>，這對應至其中的兩個標準滑鼠按鈕的版本。 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> 和<xref:System.Windows.UIElement3D.MouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。 請參閱備註<xref:System.Windows.UIElement3D.MouseLeftButtonUp>或<xref:System.Windows.UIElement3D.MouseRightButtonUp>。  
  
 <xref:System.Windows.UIElement3D.MouseUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseUpEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewMouseUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦點或滑鼠捕捉優先於滑鼠指標所在位置。因此，如果您收到<xref:System.Windows.UIElement3D.MouseWheel>事件從取得焦點或擷取的項目，將滑鼠指標可能實際上是透過另一個項目。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.MouseWheel>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.MouseWheel>事件會附加至基礎<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.MouseWheel> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.MouseWheelEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewMouseWheel>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnMouseWheel%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.MouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseWheelEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">包含屬性的周遊要求，該屬性指出在現有定位順序中周遊的模式，或以視覺化方式移動的方向。</param>
        <summary>嘗試將焦點從這個項目移至另一個項目。 移動焦點的方向是由指引方向所指定，該指引方向是在這個項目之視覺化父代的組織內解譯。</summary>
        <returns>
          如果已執行要求的周遊則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請確定您檢查此方法的傳回值。 傳回值為`false`如果周遊時碰到的定位點由控制項的組合所定義，並周遊要求未包裝要求可能會傳回。  
  
 <xref:System.Windows.UIElement3D.MoveFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">便捷鍵事件的事件資料。 該事件資料會報告叫用哪個便捷鍵，並指出控制這些事件之傳送的 <see cref="T:System.Windows.Input.AccessKeyManager" /> 物件，是否也會將這個便捷鍵引動過程傳送至其他項目。</param>
        <summary>當叫用對這個項目有意義的便捷鍵 (Access Key) 時，為其提供類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在任何實際 AccessKey 事件<xref:System.Windows.UIElement3D>類別，或其他位置，您可以引發或附加的處理常式。 相反地，透過專用的管理員類別，產生事件<xref:System.Windows.Input.AccessKeyManager>，其中進行後置處理所有輸入来搜尋適用於整個輸入模型的存取金鑰。  
  
 <xref:System.Windows.UIElement3D.OnAccessKey%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法中的預設實作<see cref="T:System.Windows.UIElement3D" />設定鍵盤焦點移到這個項目 (藉由呼叫<see cref="M:System.Windows.UIElement3D.Focus" />)。 如果它們是可設定焦點，因為它是協助工具案例中的預期的行為的實作應該延續此行為。 請注意，基底實作不做任何動作與傳遞的事件資料，而且會引發任何進一步的事件。它只會將焦點。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基礎結構傳回類別特定的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</summary>
        <returns>因型別而異的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnCreateAutomationPeer%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法的實作會在呼叫的特定建構函式通常是<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作中，並將其傳回做為傳回值。  
  
 所有<see cref="T:System.Windows.UIElement3D" />衍生的類別應該實作這個方法以提供它們自己的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />實作[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基礎結構。 如需實作此模式的詳細資訊，請參閱<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnDragEnter%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnDragLeave%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnDragOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.Drop" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnDrop%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnGiveFeedback%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料。 此事件資料必須包含 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 事件的識別項。</param>
        <summary>使用所提供的事件資料引發 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法中，雖然是虛擬的沒有預設實作會引發事件。  
  
 這在 * 方法實作用來引發事件，這個相同的方法實作會在內部叫用來引發事件時<xref:System.Windows.UIElement3D.IsFocused%2A>屬性值變更。 <xref:System.Windows.UIElement3D.OnGotFocus%2A>實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 只提供便利的方式來加入類別處理事件的實作。  
  
 <xref:System.Windows.UIElement3D.OnGotFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>除非您有故意和不尋常的需要，將不會引發焦點事件，請確定您的實作呼叫基底實作。 否則，<see cref="E:System.Windows.UIElement3D.GotFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。 如果您不想要您可設定焦點的項目，您可以防止項目可設定焦點設定<see cref="P:System.Windows.UIElement3D.Focusable" />至<see langword="false" />。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnGotMouseCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnGotStylusCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> 路由事件的類別處理，而這個事件會在擷取到對此項目的觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>處理衍生類別中<xref:System.Windows.UIElement3D.GotTouchCapture>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsKeyboardFocused%2A>相依性屬性變更。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>會在 <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" /> 事件正要由這個項目引發前被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsMouseCapturedChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseCapturedChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虛擬方法時，會呼叫的值<see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" />相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />與該相同的事件資料執行個體就會引發事件。 請注意，此事件不是路由的事件。因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。 請注意，<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsStylusCapturedChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsStylusCapturedChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCapturedChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此，您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>會在對這個項目引發未處理的 <see cref="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" /> 事件時被叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虛擬方法時，會呼叫的值<xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A>相依性屬性變更其值。 會先呼叫虛擬方法，並可以操作需要的事件資料。 然後在<xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged>與該相同的事件資料執行個體就會引發事件。 請注意，事件就不會路由的事件。 因此您無法將它標示為已處理的類別處理常式中。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按鍵動作是由專用的輸入管理員處理。 依賴按鍵，例如，輸入和命令繫結的其他程式設計功能可能會處理按鍵之前它會公開為一般的按鍵。 如果這些輸入系統功能將事件標記為已處理，然後<xref:System.Windows.UIElement3D.OnKeyDown%2A>不會叫用。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnKeyDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按鍵動作是由專用的輸入管理員處理。 依賴按鍵，例如，輸入和命令繫結的其他程式設計功能可能會處理按鍵之前它會公開為一般的按鍵。 如果這些輸入系統功能將事件標記為已處理，然後<xref:System.Windows.UIElement3D.OnKeyUp%2A>不會叫用。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnKeyUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" />，包含事件資料。 此事件資料必須包含 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 事件的識別項。</param>
        <summary>使用所提供的事件資料引發 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法中，雖然是虛擬的沒有預設實作會引發事件。  
  
 這在 * 方法實作用來引發事件，這個相同的方法實作會在內部叫用來引發事件時<xref:System.Windows.UIElement3D.IsFocused%2A>屬性值變更。 這項實作不同於其他[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 只提供便利的方式來加入類別處理事件的實作。  
  
 <xref:System.Windows.UIElement3D.OnLostFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>除非您有故意和不尋常的需要，將不會引發焦點事件，請確定您的實作呼叫基底實作。 否則，<see cref="E:System.Windows.UIElement3D.LostFocus" />通常將焦點設定至這個項目的一般使用者作業期間將不會引發事件。 如果您不想要您可設定焦點的項目，您可以防止項目可設定焦點設定<see cref="P:System.Windows.UIElement3D.Focusable" />至<see langword="false" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnLostMouseCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnLostStylusCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> 路由事件的類別處理，而這個事件會在此項目失去觸控擷取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>處理衍生類別中<xref:System.Windows.UIElement3D.LostTouchCapture>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 此事件資料會報告有關按下的滑鼠按鈕以及已處理狀態的詳細資訊。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕動作也是由專用的輸入管理員處理。 依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。 如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.UIElement3D.OnMouseDown%2A>不會叫用。  
  
 如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.UIElement3D.MouseLeftButtonDown>和<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。  
  
 如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。 如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement3D.OnMouseDown%2A>，您會隱含的類別處理負責執行下的所有可能的滑鼠按鈕。 此行為可能會不必要的。 當您使用此虛擬方法標記為已處理的事件，因此，使用警告。  
  
 每個按鈕特定直接事件也有虛擬機器 * 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是具有直接路由策略的路由的事件。 將事件標示為已處理仍很有用防止一般的執行個體的處理常式 (這些不指定`handledEventsToo`) 叫用。  
  
 <xref:System.Windows.UIElement3D.OnMouseEnter%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是具有直接路由策略的路由的事件。 將事件標示為已處理仍很有用防止一般的執行個體的處理常式 (這些不指定`handledEventsToo`) 叫用。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeave%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠左鍵已按下。</param>
        <summary>當這個項目上引發未處理的 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> 路由事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown>事件反昇路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.MouseLeftButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement3D.MouseLeftButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 您是否願意呼叫基底實作，取決於您的案例。 無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Button>並覆寫<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>在您衍生的類別，而不需要呼叫基底實作; 不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠左鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp>事件反昇路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.MouseLeftButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement3D.MouseLeftButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠右鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseRightButtonDown>事件反昇路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement3D.MouseRightButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 您是否願意呼叫基底實作，取決於您的案例。 無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Control>並覆寫<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>中您的衍生類別，而不呼叫基底; 不過，此覆寫停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠右鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp>事件反昇路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 為路由傳送，泡泡圖的基礎事件和每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.MouseRightButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement3D.MouseRightButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠按鈕已釋放。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕動作也是由專用的輸入管理員處理。 依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。 如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.UIElement3D.OnMouseUp%2A>不會叫用。  
  
 如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.UIElement3D.MouseLeftButtonUp>和<xref:System.Windows.UIElement3D.MouseRightButtonUp>。 其中一個這些事件可能會接收項目上引發時<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。  
  
 如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。 如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement3D.OnMouseUp%2A>，您會隱含的類別處理計算在內的所有可能滑鼠動作。 此行為可能會不必要的。 當您使用此虛擬方法標記為已處理的事件，因此，使用警告。  
  
 每個按鈕特定直接事件也有虛擬機器 * 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseWheel%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragOver%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDrop%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告一個或多個滑鼠按鈕已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕動作也是由專用的輸入管理員處理。 依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。 如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>不會叫用。  
  
 如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>。 其中一個這些事件可能會接收的項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。  
  
 如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。 如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>，您會隱含的類別處理負責執行下的所有可能的滑鼠按鈕。 此行為可能會不必要的。 當您使用此虛擬方法標記為已處理的事件，因此，使用警告。  
  
 每個按鈕特定直接事件也有虛擬機器 * 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠左鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>事件傳輸通道的路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 您是否願意呼叫基底實作，取決於您的案例。 無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Button>並覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>在您衍生的類別，而不需要呼叫基底實作; 不過，這會覆寫停用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠左鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>事件傳輸通道的路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告滑鼠右鍵已按下。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>事件傳輸通道的路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 雖然您可以將標記<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>。  
  
 或者，您可以覆寫這個方法以變更處理特定的滑鼠狀態的事件。 您是否願意呼叫基底實作，取決於您的案例。 無法呼叫基底會停用該也預期會叫用的上階類別上的滑鼠事件的預設輸入的處理<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>。 例如，您可以從衍生<xref:System.Windows.Controls.Control>並覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>中您的衍生類別，而不呼叫基底; 不過，此覆寫停用內容功能表上的服務您的控制項，也就是組件的<xref:System.Windows.Controls.Control>預設行為。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告已放開滑鼠右鍵。</param>
        <summary>當未處理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> 路由事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>事件傳輸通道的路由會出現但實際上是以間接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 為基礎的事件通道路由傳送，且每個<xref:System.Windows.UIElement3D>沿著事件路由會使用相同的處理來直接路由的事件的引發<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。 雖然您可以將標記<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>為基於的這個項目已處理的事件，處理的狀態不保存事件路由上的其他項目。 不過，您可能想要將事件標記為已處理，以避免一般的執行個體處理常式 (即未指定`handledEventsToo`) 叫用。  
  
 一般的滑鼠事件處理中的預設實作<xref:System.Windows.UIElement3D>接聽<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>並將它轉換成適當的本機事件。 如果您想要覆寫這個邏輯，您必須建立衍生的類別。 在衍生類別的靜態建構函式中註冊替代的類別處理常式<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 您無法變更處理行為的滑鼠<xref:System.Windows.UIElement3D>藉由覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件資料會報告一個或多個滑鼠按鈕已釋放。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 滑鼠按鈕動作也是由專用的輸入管理員處理。 依賴滑鼠按鈕的動作，例如輸入和命令繫結之前它會公開為一般的滑鼠按鈕動作, 可能會叫用動作的處理常式的其他程式設計功能。 如果這些輸入系統功能標記<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件為已處理，<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>不會叫用。  
  
 如果您使用這個類別處理常式來標示為已處理的事件時，可能會影響下列事件：<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。 其中一個這些事件可能會接收項目上引發時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。  
  
 如果您要標示為已處理的類別中處理此事件，仍然會引發子;不過，它們將傳遞事件資料中處理的狀態。 如果在處理中的類別處理事件，副的執行個體處理常式不會叫用除非您明確地使用<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>與`handledEventsToo``true`才能附加處理常式。 類別處理常式也不會叫用這些類別處理常式已向除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章與`handledEventsToo` `true`。 藉由處理<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>，您會隱含的類別處理計算在內的所有可能滑鼠動作。 此行為可能會不必要的。 當您使用此虛擬方法標記為已處理的事件，因此，使用警告。  
  
 每個按鈕特定直接事件也有虛擬機器 * 方法。請考慮是否覆寫這些按鈕特定的類別處理常式可能更合適。  
  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。 是特別針對預覽事件的另一種情形是將它們加以處理，因此相符的反昇類別處理常式不會叫用標記。  
  
 <xref:System.Windows.UIElement3D.OnPreviewTextInput%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement3D.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>處理衍生類別中<xref:System.Windows.UIElement3D.PreviewTouchDown>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>處理衍生類別中<xref:System.Windows.UIElement3D.PreviewTouchMove>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>處理衍生類別中<xref:System.Windows.UIElement3D.PreviewTouchUp>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnQueryCursor%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusDown%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 將事件標示為已處理仍很有用防止一般的執行個體處理常式 (這些不指定`handledEventsToo`) 叫用。  
  
 <xref:System.Windows.UIElement3D.OnStylusEnter%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusInAirMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusInRange%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當這個項目引發未處理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。 您可能會呼叫基底之前或之後特殊處理，根據您的需求。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 將事件標示為已處理仍很有用防止一般的執行個體處理常式 (這些不指定`handledEventsToo`) 叫用。  
  
 <xref:System.Windows.UIElement3D.OnStylusLeave%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusMove%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnStylusUp%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>當未處理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件到達其路由中衍生自此類別的項目時叫用。 實作這個方法可為此事件加入類別處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會具有預設的實作。 因為中繼類別繼承中的可能會實作這個方法，我們建議您在自己的實作呼叫基底實作。  
  
 這個方法的目的是類似於[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 * 方法： 這個方法會提供要藉由建立類別處理常式，而不是執行個體處理常式處理衍生類別的比對事件的方法。 在此情況下，符合的事件是路由的事件。 由於路由的事件就會引發子元素，不一定會叫用處理常式的項目，On * 方法的實作模式是不同的路由事件。 因此，您的實作必須檢查的事件資料來源屬性。 它不應嘗試重新引發此事件在大部分情況下。  
  
 覆寫這個方法，或登錄類別處理常式取代<xref:System.Windows.EventManager.RegisterClassHandler%2A>，衍生的類別<xref:System.Windows.UIElement3D>事件路由上收到事件時，可以呼叫私用類別處理常式方法。 其中類別處理是適當的其中一個案例是操作事件資料，並標示為已處理的路由的事件。  
  
 <xref:System.Windows.UIElement3D.OnTextInput%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.TouchDown" /> 路由事件的類別處理，而這個事件會在觸控按下此項目內部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchDown%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnTouchDown%2A>處理衍生類別中<xref:System.Windows.UIElement3D.TouchDown>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnTouchDown%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.TouchEnter" /> 路由事件的類別處理，而這個事件會在觸控從外面移至此項目範圍內時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchEnter%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnTouchEnter%2A>處理衍生類別中<xref:System.Windows.UIElement3D.TouchEnter>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnTouchEnter%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.TouchLeave" /> 路由事件的類別處理，而這個事件會在觸控從此項目內部移至其範圍外時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchLeave%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnTouchLeave%2A>處理衍生類別中<xref:System.Windows.UIElement3D.TouchLeave>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnTouchLeave%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.TouchMove" /> 路由事件的類別處理，而這個事件會在觸控尚處於此項目內並有所移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchMove%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnTouchMove%2A>處理衍生類別中<xref:System.Windows.UIElement3D.TouchMove>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnTouchMove%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.TouchEventArgs" />，其中包含事件資料。</param>
        <summary>提供 <see cref="E:System.Windows.UIElement3D.TouchUp" /> 路由事件的類別處理，而這個事件會在觸控於此項目內放開時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchUp%2A>方法有預設的實作。 覆寫<xref:System.Windows.UIElement3D.OnTouchUp%2A>處理衍生類別中<xref:System.Windows.UIElement3D.TouchUp>事件。 確定呼叫基底類別的<xref:System.Windows.UIElement3D.OnTouchUp%2A>方法的基底類別，接收到事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUpdateModel">
      <MemberSignature Language="C#" Value="protected virtual void OnUpdateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUpdateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnUpdateModel" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUpdateModel ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUpdateModel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，參與的呈現作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您衍生自<xref:System.Windows.UIElement3D>類別，您可以使用這個方法並搭配<xref:System.Windows.UIElement3D.InvalidateModel%2A>方法，以重新整理模型的項目。  
  
 您只需要在進階案例中呼叫這個方法。 這類進階的案例之一就是在衍生的類別有多個屬性會影響外觀，並且您想要一次更新基礎的模型。 內<xref:System.Windows.UIElement3D.OnUpdateModel%2A>方法無法更新<xref:System.Windows.Media.Media3D.Visual3D.Visual3DModel%2A>屬性<xref:System.Windows.Media.Media3D.Visual3D>類別。  
  
 這個方法有預設的實作<xref:System.Windows.UIElement3D>類別。  
  
 <xref:System.Windows.UIElement3D.OnUpdateModel%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例示範如何從衍生<xref:System.Windows.UIElement3D>類別來建立`Sphere`類別：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 如需完整範例，請參閱[UIElement3D 球體範例](http://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父代。 如果 <see cref="T:System.Windows.DependencyObject" /> 先前沒有父項目，這可提供為 <see langword="null" />。</param>
        <summary>當這個 <see cref="T:System.Windows.UIElement3D" /> 的父項目報告其基礎視覺化父項目的變更時叫用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnVisualParentChanged%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，請務必呼叫基底實作。 預設基底實作會執行某些內部維護的反向繼承的屬性狀態。 無法呼叫基底實作，會使此狀態。  
  
 這個方法覆寫 <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />。 <see cref="T:System.Windows.FrameworkElement" /> 和<see cref="T:System.Windows.Window" />兩者也覆寫<see cref="T:System.Windows.UIElement3D" />實作<see cref="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />，和<see cref="T:System.Windows.Window" />密封它。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求的焦點周遊方向。</param>
        <summary>在衍生類別中覆寫時，傳回會針對指定之焦點周遊方向接收焦點的項目，而不用實際將焦點移至該項目。</summary>
        <returns>如果實際上有叫用 <see cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />，就會取得焦點的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別中，這個方法的預設實作不完整，且一律會傳回`null`。  
  
 <xref:System.Windows.UIElement3D.PredictFocus%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳目標的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewDragEnter>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewDragEnter>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnter> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewDragEnterEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.DragEnter>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewDragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnterEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以此項目作為拖曳來源的拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewDragLeave>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewDragLeave>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeave> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewDragLeaveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.DragLeave>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewDragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeaveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在輸入系統回報以此項目作為可能置放目標的基礎拖曳事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewDragOver>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewDragOver>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOver> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewDragOverEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.DragOver>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewDragOver%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewDragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOverEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>輸入系統報告其下以這個項目作為置放目標的置放事件時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewDrop>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewDrop>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewDrop> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewDropEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.DragEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.Drop>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewDrop%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewDrop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDropEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作開始時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback>事件可讓修改滑鼠指標的外觀，以便將使用者視覺化回應提供拖放作業期間的拖曳事件來源。  
  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewGiveFeedback>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewGiveFeedback>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.GiveFeedback>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件使用通道路由，因為具有焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際具有焦點的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.GotKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點且按下按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewKeyDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewKeyDown>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewKeyDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.KeyDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewKeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤以此元素為焦點且放開按鍵時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵處理互動與其他的平台功能，例如命令和撰寫文字。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewKeyUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewKeyUp>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewKeyUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.KeyUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewKeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>鍵盤不再以此元素為焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件使用通道路由，因為失去焦點的項目可能是子元素，而非項目實際附加事件處理常式。 請檢查<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料來判斷實際失去焦點的項目中。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>事件會附加至基礎<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.LostKeyboardFocus>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指標在此元素上方且按下任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewMouseDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewMouseDown>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown>通常就會引發事件一起可能<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>，這對應到其中的兩個標準滑鼠按鈕的按下。 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> 和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到達事件路由上的這個項目。 請參閱備註<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.MouseDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>處理，您要基本上標記<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。 這可能是包含類別處理常式產生事件如<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠左按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>處理，您要基本上標記<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且移動滑鼠指標時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 都會發生這個事件項目界限，第一次進入滑鼠指標時，也會在滑鼠指標移時仍保持項目範圍內。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewMouseMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.MouseMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且按下滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>處理，您要基本上標記<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。 這可能是包含類別處理常式產生事件如<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開滑鼠右按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然這[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循通道路由項目樹狀目錄中，透過它實際上是直接的路由的事件引發且由每個項目樹狀結構沿著 reraised <xref:System.Windows.UIElement3D>。  
  
 此事件會報告滑鼠按鈕細節的基礎的多個相關事件的其中一個<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，這是附加的事件處理的事件路由上的每個項目。  
  
 這個事件的事件資料會公開事件資料的基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果該事件標示為已處理此事件路由上，仍然會引發滑鼠按鈕的特定事件。不過，必須加入的滑鼠按鈕的特定事件的處理常式藉由明確地呼叫<xref:System.Windows.UIElement3D.AddHandler%2A>，選項來處理已標記為已處理的事件、 事件接聽程式，才能使用。 如果您將標示<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>處理，您要基本上標記<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>路由中的所有其他接聽程式處理，而且所有相關事件。  
  
 在概念上，將這個事件 (和其他滑鼠按鈕的事件上<xref:System.Windows.UIElement3D>) 是滑鼠 「 服務 」 (所提供的服務定義<xref:System.Windows.Input.Mouse>類別)。 這個事件加入不需檢查原始的滑鼠事件的事件資料中的滑鼠按鈕狀態 （左右，上下按鈕控制項） 的便利性。 更進階的情況下，例如檢查狀態的非標準按鈕，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>類別而不是那些在<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且放開任何滑鼠按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewMouseUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewMouseUp>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp>通常就會引發事件一起可能<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>，這對應到其中的兩個標準滑鼠按鈕的按下。 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> 和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>也是路由的事件，但它們是直接路由的事件，就會引發適當的按鈕特定事件時<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到達事件路由上的這個項目。 請參閱備註<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.MouseUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>滑鼠指標在此元素上方且使用者滾動滑鼠滾輪時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦點或滑鼠捕捉優先於滑鼠指標所在位置。因此，如果您收到這個事件與已取得焦點或擷取的項目時，滑鼠指標實際上可能是透過另一個項目。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewMouseMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewMouseMove>事件會附加至基礎<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheel> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewMouseWheelEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.MouseWheel>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewMouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheelEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>事件可讓拖曳來源能夠宣告是否應取消拖放作業。  
  
 此事件會建立一個別名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.QueryContinueDrag>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusButtonDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusButtonUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方且碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusInAirMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusInRange>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRange> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusInRange>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當手寫筆位在項目上方並移動時發生。 手寫筆必須在受到數位板偵測時移動才能引發此事件，否則會改為引發 <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆遠離數位板而無法被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusOutOfRange>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者執行其中一種手寫筆筆勢時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 手寫筆筆勢的相關資訊，請參閱<xref:System.Windows.Input.SystemGesture>。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusSystemGesture>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewStylusDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewStylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewStylusUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.StylusUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewStylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素以一種與裝置無關的方式取得文字時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewTextInput>事件可讓元件或應用程式與裝置無關的方式接聽文字輸入。 鍵盤是的主要方式<xref:System.Windows.UIElement3D.PreviewTextInput>; 但也可以產生語音、 手寫，以及其他輸入的裝置<xref:System.Windows.UIElement3D.PreviewTextInput>。  
  
 因為組合 — 在預設鍵盤或輸入的法編輯器透過 — 多個按鍵事件可能會引發一個文字輸入的事件。  
  
 此事件會建立一個別名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.PreviewTextInput>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.PreviewTextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInput> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewTextInputEvent>|  
|路由策略|通道|  
|Delegate - 委派|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.TextInput>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewTextInput%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewTextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInputEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指接觸到螢幕，並移動之前不會發生事件。 手指在螢幕上按住不移動的方式會使按下並按住行為<xref:System.Windows.Input.Stylus>。 按住行為相當於按一下滑鼠右鍵。  
  
 若要讓<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指接觸到螢幕，因為發生事件設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加屬性`false`這個項目的。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewTouchDownEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.TouchDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewTouchMoveEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.TouchMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且離開螢幕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.PreviewTouchUpEvent>|  
|路由策略|通道|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應的反昇事件<xref:System.Windows.UIElement3D.TouchUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>拖放操作期間，鍵盤或滑鼠按鈕狀態變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.QueryContinueDrag>事件可讓拖曳來源能夠決定是否應取消拖放作業。  
  
 此事件會建立一個別名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.QueryContinueDrag>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.QueryContinueDrag>事件會附加至基礎<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDrag> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.QueryContinueDragEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.QueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDragEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求顯示游標時發生。 每當滑鼠指標移動至新位置時，都會引發此事件，這意謂游標物件可能會根據其新位置而變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.QueryCursor>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.QueryCursor>事件會附加至基礎<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 這個事件名稱所參考的資料指標不一定是文字游標 （有時稱為插入點）。 相反地，此內容中的資料指標是宣告畫面的圖形化顯示數個可能的輸入相關裝置或在 Windows 程式設計概念相關的物件。 該物件由<xref:System.Windows.Input.Cursor>WPF 中的類別。 WPF 輸入的系統可讓您變更這個資料指標，它代表在螢幕上的滑鼠指標位置時。 您可以使用預先定義的值從<xref:System.Windows.Input.Cursors>列舉型別，或者您可以宣告為影像檔的自訂資料指標。  
  
 接聽<xref:System.Windows.UIElement3D.QueryCursor>事件就不會針對資料指標管理而有效率的技術。 相反地，每個項目應該定義自己的資料指標行為<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。 您只應依賴<xref:System.Windows.UIElement3D.QueryCursor>如果您不想要使用的 WPF 架構層級基底項目，或在異常的情況下，其中定義以每個項目為基礎的資料指標的行為不符合您的需求。 如需有關在回應中實作資料指標行為<xref:System.Windows.UIElement3D.QueryCursor>，請參閱<xref:System.Windows.Input.QueryCursorEventHandler>。  
  
 <xref:System.Windows.UIElement3D.QueryCursor> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.QueryCursorEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   沒有定義對應通道的事件。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnQueryCursor%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.QueryCursor" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.QueryCursorEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.RoutedEventArgs" />，其包含事件資料，也會識別要引發的事件。</param>
        <summary>引發特定路由事件。 要引發的 <see cref="T:System.Windows.RoutedEvent" /> 是在所提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 執行個體內被識別 (該執行個體是提供做為該事件資料的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 屬性)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`參數的型別做為路由的事件的所有資料的通用基底類型; 不過，應該指定事件資料為最特定的事件資料類型是適用於所引發的事件，因為<xref:System.Windows.RoutedEventArgs>衍生的類別包含實際的特定資料是針對特定事件時引發此事件的屬性。  
  
 <xref:System.Windows.RoutedEventArgs> 沒有狀態內容事件。它也會識別要引發哪個路由的事件。 此事件引發模式且同時與不同的路由的事件資料[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和資料類別，通常只包含與事件相關的屬性。  
  
 <xref:System.Windows.UIElement3D.RaiseEvent%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從這個項目釋放所有擷取到的觸控裝置。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果這個項目保有滑鼠捕捉，則釋放捕捉。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目按擷取不放，呼叫這個方法沒有任何作用。 請考慮檢查值<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>之前先呼叫這個方法。  
  
 <xref:System.Windows.UIElement3D.ReleaseMouseCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果這個項目保有手寫筆裝置捕捉，則釋放捕捉。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個項目按擷取不放，呼叫這個方法沒有任何作用。 請考慮檢查值<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>之前先呼叫這個方法。  
  
 <xref:System.Windows.UIElement3D.ReleaseStylusCapture%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要釋放的裝置。</param>
        <summary>嘗試從這個項目中釋放指定的觸控裝置。</summary>
        <returns>
          如果已釋放觸控裝置則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要附加處理常式之路由事件的識別項。</param>
        <param name="handler">要從這個項目上的事件處理常式集合中移除的特定處理常式實作。</param>
        <summary>從這個項目中移除指定的路由事件處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的案例使用這[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是當您實作[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自訂路由事件，特別是當您實作在處理常式的 「 移除 」 邏輯時相關聯的 「 包裝函式 」 事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]層級。  
  
 如果沒有任何處理常式註冊以比對方法呼叫的輸入的參數的準則，則呼叫這個方法任何作用。  
  
 如果一個以上的處理常式附加事件處理常式存放區會移除比對準則，第一個處理常式。 這個行為會與一致[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]行為`-=`運算子。  
  
 既不`routedEvent`也`handler`可能`null`。 嘗試在提供做為任一個值`null`會引發例外狀況。  
  
 這個方法會忽略`handledEventsToo`加上參數資訊，如果第一個處理常式提供<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>簽章，可讓已處理事件的處理。 會移除任一類型的處理常式。  
  
 <xref:System.Windows.UIElement3D.RemoveHandler%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.UIElement3D.CommandBindings" /> 屬性的內容序列化。</summary>
        <returns>
          如果應序列化 <see cref="P:System.Windows.UIElement3D.CommandBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.UIElement3D.CommandBindings%2A>本機設定。  
  
 這`ShouldSerialize`方法提供，因為<xref:System.Windows.UIElement3D.CommandBindings%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果在開發設計師或開發您自己的控制項加入<xref:System.Windows.UIElement3D>。  
  
 如需詳細資訊，請參閱[定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeCommandBindings%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回序列化 (Serialization) 處理序是否應該在這個類別的執行個體上，將 <see cref="P:System.Windows.UIElement3D.InputBindings" /> 屬性的內容序列化。</summary>
        <returns>
          如果應序列化 <see cref="P:System.Windows.UIElement3D.InputBindings" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這會傳回`true`如果<xref:System.Windows.UIElement3D.InputBindings%2A>本機設定。  
  
 這`ShouldSerialize`方法提供，因為<xref:System.Windows.UIElement3D.InputBindings%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果在開發設計師或開發您自己的控制項加入<xref:System.Windows.UIElement3D>。  
  
 如需詳細資訊，請參閱[定義預設值使用 ShouldSerialize 和重設方法](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeInputBindings%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且按下手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusButtonDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusButtonDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusButtonDownEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusButtonDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆指標在此元素上方且放開手寫筆按鈕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusButtonUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusButtonUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusButtonUpEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusButtonUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方且碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusDown>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusDown>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusDown> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusDownEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusDownEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆進入此元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.StylusEnter> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。 直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。 不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。  
  
 雖然<xref:System.Windows.UIElement3D.StylusEnter>當手寫筆進入範圍的項目，這個多個事件的追蹤依其字面報告<xref:System.Windows.UIElement3D.IsStylusOver%2A>屬性值已經從`false`至`true`這個項目上。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusEnter>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusEnter>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusEnter> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusEnterEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在項目上方移動，但沒有真正碰觸數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusInAirMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusInAirMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusInAirMoveEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusInAirMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且夠靠近數位板而被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusInRange>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusInRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusInRange> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusInRangeEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusInRange>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusInRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusInRangeEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆離開元素的邊界時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.StylusLeave> 是[路由傳送事件概觀](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件處理路由策略。 直接路由的事件不會引發的路由。相反地，它們會在處理相同的項目所引發的位置。 不過，它們會啟用路由的事件的行為，例如事件觸發程序在樣式中的其他層面。  
  
 雖然<xref:System.Windows.UIElement3D.StylusLeave>時手寫筆離開範圍的項目，此事件的多個追蹤逐字報告<xref:System.Windows.UIElement3D.IsStylusOver%2A>屬性值已經從`true`至`false`這個項目上。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusLeave>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusLeave>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusLeave> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusLeaveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當手寫筆移至此項目上方時發生。 手寫筆在數位板上必須移動才會引發這個事件。 否則會改為引發 <see cref="E:System.Windows.UIElement3D.StylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusMove>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusMove>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusMove> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusMoveEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusMoveEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且遠離數位板而無法被偵測到時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusOutOfRange>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusOutOfRange>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRange> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusOutOfRangeEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRangeEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者執行其中一種手寫筆筆勢時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 手寫筆筆勢的相關資訊的詳細資訊，請參閱<xref:System.Windows.Input.SystemGesture>。  
  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusSystemGesture>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusSystemGesture>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGesture> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusSystemGestureEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGestureEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手寫筆在此項目上方，且使用者將手寫筆舉起離開數位板時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會建立一個別名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.StylusUp>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.StylusUp>事件會附加至基礎<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 觸控、 滑鼠及手寫筆輸入存在於特定的關聯性。 如需詳細資訊，請參閱[觸控輸入支援在 Windows Vista](http://go.microsoft.com/fwlink/?LinkId=160818)和[輸入概觀](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusUp> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.StylusUpEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewStylusUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnStylusUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.StylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusUpEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此元素以一種與裝置無關的方式取得文字時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.TextInput>事件可讓元件或應用程式與裝置無關的方式接聽文字輸入。 鍵盤是的主要方式<xref:System.Windows.UIElement3D.TextInput>，但也可以引發語音、 手寫，以及其他輸入的裝置<xref:System.Windows.UIElement3D.TextInput>。  
  
 因為組合 — 在預設鍵盤或輸入的法編輯器透過 — 多個按鍵事件可能會引發一個文字輸入的事件。  
  
 此事件會建立一個別名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，這個類別，以便<xref:System.Windows.UIElement3D.TextInput>屬於類別的成員 清單時<xref:System.Windows.UIElement3D>繼承基底的項目。 事件處理常式附加至<xref:System.Windows.UIElement3D.TextInput>事件會附加至基礎<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件和接收相同的事件資料執行個體。  
  
 <xref:System.Windows.UIElement3D.TextInput> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TextInputEvent>|  
|路由策略|反昇|  
|Delegate - 委派|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewTextInput>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTextInput%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊路由事件時，會建立路由事件識別項。 這些識別項包含用於加入事件擁有者的識別名稱、擁有者類型、處理常式類型、路由策略和公用程式方法。 您可以使用這些識別項來加入類別處理常式。  
  
 如需註冊路由事件的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 如需使用路由事件識別項來加入類別處理常式的詳細資訊，請參閱 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.TextInputEvent> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上觸控時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指接觸到螢幕，並移動之前不會發生事件。 手指在螢幕上按住不移動的方式會使按下並按住行為<xref:System.Windows.Input.Stylus>。 按住行為相當於按一下滑鼠右鍵。  
  
 若要讓<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指接觸到螢幕，因為發生事件設定<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加屬性`false`這個項目的。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TouchDownEvent>|  
|路由策略|反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewTouchDown>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTouchDown%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控從這個項目的界限外部移至內部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一律引發這個事件，或有觸控式裝置擷取至這個項目。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TouchEnterEvent>|  
|路由策略|直接|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTouchEnter%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TouchEnter" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已擷取至這個項目的所有觸控裝置。</summary>
        <value>已擷取至這個項目之 <see cref="T:System.Windows.Input.TouchDevice" /> 物件的列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已擷取至這個項目或其視覺化樹狀結構中之任何子項目的所有觸控裝置。</summary>
        <value>已擷取至這個項目或其視覺化樹狀結構中之任何子項目的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在這個項目上停留的所有觸控裝置。</summary>
        <value>在這個項目之上的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在這個項目或其視覺化樹狀結構中之任何子項目上停留的所有觸控裝置。</summary>
        <value>在這個項目或其視覺化樹狀結構中之任何子項目上停留的 <see cref="T:System.Windows.Input.TouchDevice" /> 物件列舉。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當觸控從這個項目的界限內部移至外部時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TouchLeaveEvent>|  
|路由策略|直接|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTouchLeave%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TouchLeave" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且在螢幕上移動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TouchMoveEvent>|  
|路由策略|反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewTouchMove>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTouchMove%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>手指在這個項目上方且離開螢幕時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.TouchUpEvent>|  
|路由策略|反昇|  
|Delegate - 委派|型別 <xref:System.EventHandler%601> 的 <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   對應通道的事件<xref:System.Windows.UIElement3D.PreviewTouchUp>。  
  
-   覆寫<xref:System.Windows.UIElement3D.OnTouchUp%2A>實作在衍生類別中這個事件的類別處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.UIElement3D.TouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Visibility" />
      <MemberSignature Language="VB.NET" Value="Public Property Visibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility Visibility { System::Windows::Visibility get(); void set(System::Windows::Visibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個項目的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 可視性。</summary>
        <value>列舉值。 預設值是 <see cref="F:System.Windows.Visibility.Visible" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性會影響值<xref:System.Windows.UIElement3D.IsVisible%2A>，其接著可能會引發<xref:System.Windows.UIElement3D.IsVisibleChanged>事件。 不過，<xref:System.Windows.UIElement3D.IsVisible%2A>有其他因素影響，例如包含它的父代的可見性設定。  
  
 項目位置<xref:System.Windows.UIElement3D.Visibility%2A>不<xref:System.Windows.Visibility.Visible>不會參與輸入的事件 （或命令），並不會報告在點擊測試。  
  
 <xref:System.Windows.UIElement3D.Visibility%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.UIElement3D.VisibilityProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.VisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.UIElement3D.Visibility" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.VisibilityProperty> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>