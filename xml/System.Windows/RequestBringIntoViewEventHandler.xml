<Type Name="RequestBringIntoViewEventHandler" FullName="System.Windows.RequestBringIntoViewEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1fabd3e8ca79d0ed50a5a9c8a6f00299e7b8f9dd" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37491190" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void RequestBringIntoViewEventHandler(object sender, RequestBringIntoViewEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RequestBringIntoViewEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RequestBringIntoViewEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub RequestBringIntoViewEventHandler(sender As Object, e As RequestBringIntoViewEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void RequestBringIntoViewEventHandler(System::Object ^ sender, RequestBringIntoViewEventArgs ^ e);" />
  <TypeSignature Language="F#" Value="type RequestBringIntoViewEventHandler = delegate of obj * RequestBringIntoViewEventArgs -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.RequestBringIntoViewEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">
      <span data-ttu-id="15602-101">附加事件處理常式的物件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="15602-101">The object where the event handler is attached.</span>
      </span>
    </param>
    <param name="e">
      <span data-ttu-id="15602-102">事件資料。</span>
      <span class="sxs-lookup">
        <span data-stu-id="15602-102">The event data.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="15602-103">表示將處理 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 路由事件的方法。</span>
      <span class="sxs-lookup">
        <span data-stu-id="15602-103">Represents the method that will handle the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> routed event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15602-104">處理這個事件通常僅完成支援可捲動區域，或否則刻意設定其呈現大小小於合併的項目內所需大小及其子系項目內容中，並只是藉由刻意處理一旦它具有路由項目樹狀結構中向上傳送，而且已達到支援捲動區域的第一個父代的事件。</span><span class="sxs-lookup"><span data-stu-id="15602-104">Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</span></span> <span data-ttu-id="15602-105">現有的實作，可處理的方式，通常需要使用者控制項的捲動區域是<xref:System.Windows.Controls.ScrollViewer>。</span><span class="sxs-lookup"><span data-stu-id="15602-105">An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <xref:System.Windows.Controls.ScrollViewer>.</span></span> <span data-ttu-id="15602-106">如果您衍生自<xref:System.Windows.Controls.ScrollViewer>，您可以註冊的類別處理常式<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>並補充基底類別處理的事件。</span><span class="sxs-lookup"><span data-stu-id="15602-106">If you derive from <xref:System.Windows.Controls.ScrollViewer>, you can register a class handler for <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> and supplement the base class handling of the event.</span></span> <span data-ttu-id="15602-107">您也應該考慮使用或類別定義的類別處理<xref:System.Windows.Controls.ScrollViewer.ScrollChanged>事件而非<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="15602-107">You should also consider using or class-handling the class-defined <xref:System.Windows.Controls.ScrollViewer.ScrollChanged> event instead of <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>.</span></span> <span data-ttu-id="15602-108">或者，如果您建立完全自訂的類別，不是衍生自<xref:System.Windows.Controls.ScrollViewer>，您仍然可以新增類別處理，藉由呼叫<xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType>您類別具現化。</span><span class="sxs-lookup"><span data-stu-id="15602-108">Alternatively, if you create an entirely custom class that does not derive from <xref:System.Windows.Controls.ScrollViewer>, you can still add class handling by calling <xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType> in your class instantiation.</span></span>  <span data-ttu-id="15602-109">如需類別處理的詳細資訊，請參閱[路由事件標記為已處理以及類別處理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="15602-109">For details on class handling, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="15602-110">內容項目可能會導致其內容的主機引發事件 (透過呼叫<xref:System.Windows.FrameworkContentElement.BringIntoView%2A>以及引發<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>內容主機)。</span><span class="sxs-lookup"><span data-stu-id="15602-110">Content elements can cause the event to be raised by their content hosts (through calling <xref:System.Windows.FrameworkContentElement.BringIntoView%2A> and raising <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> from the content host).</span></span> <span data-ttu-id="15602-111">同樣地，您可以要求使用協助程式方法帶入檢視的邏輯樹狀結構項目<xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="15602-111">Similarly, you can request logical tree elements to be brought into view with the helper method <xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="15602-112">A<xref:System.Windows.Controls.ListBox>實作相關但不同的方法<xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>。</span><span class="sxs-lookup"><span data-stu-id="15602-112">A <xref:System.Windows.Controls.ListBox> implements a related but different method <xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.RequestBringIntoViewEventArgs" />
    <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
    <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
    <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
    <altmember cref="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
  </Docs>
</Type>